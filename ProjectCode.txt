Project Code Export
Date: Thu Jan 08 2026 16:49:55 GMT+0100 (MitteleuropÃ¤ische Normalzeit)
Exported Folder: Drumcomputer

Project Structure:
ğŸ“ Drumcomputer/
  ğŸ“„ .DS_Store
  ğŸ“„ .editorconfig
  ğŸ“„ .eslintrc.cjs
  ğŸ“ .git/ (14 items)
    ğŸ“„ ...
  ğŸ“„ .gitattributes
  ğŸ“ .github/
    ğŸ“„ copilot-instructions.md
  ğŸ“„ .gitignore
  ğŸ“„ .gitignore 2
  ğŸ“„ .mocharc.json
  ğŸ“ .nuxt/ (18 items)
    ğŸ“„ ...
  ğŸ“ .vscode/ (1 items)
    ğŸ“„ ...
  ğŸ“„ Components.md
  ğŸ“„ Composables.md
  ğŸ“„ Domain.md
  ğŸ“ Flashpost-tests/
    ğŸ“„ flashpost.db
    ğŸ“„ flashpostCollections.db
    ğŸ“„ flashpostCookies.db
    ğŸ“„ flashpostHistory.db
    ğŸ“„ flashpostUserPreference.db
    ğŸ“„ flashpostVariable.db
  ğŸ“„ LICENSE
  ğŸ“„ ProjectCode.txt
  ğŸ“„ README 2.md
  ğŸ“„ README.md
  ğŸ“„ StepCell.md
  ğŸ“„ StepGrid.md
  ğŸ“ _archive/
    ğŸ“ composables_dupes/
      ğŸ“„ useAudioEngine.client 2.ts
      ğŸ“„ useImportExport.client 2.ts
      ğŸ“„ useMidi.client 2.ts
      ğŸ“„ useSequencer 2.ts
      ğŸ“„ useSync.client 2.ts
    ğŸ“ patches/
      ğŸ“„ useAudioEngine.patch
      ğŸ“„ useImportExport.patch
      ğŸ“„ useMidi.patch
      ğŸ“„ useSequencer.patch
      ğŸ“„ useSync.patch
  ğŸ“„ alleDateien.md
  ğŸ“„ app.vue
  ğŸ“ assets/ (5 items)
    ğŸ“„ ...
  ğŸ“ audio/
    ğŸ“ engine/
      ğŸ“ play/
        ğŸ“„ playStep.ts
      ğŸ“„ stepResolver.ts
      ğŸ“„ transportAudioHooks.ts
    ğŸ“„ fxGraph.ts
  ğŸ“ components/
    ğŸ“„ .DS_Store
    ğŸ“„ DrumMachine.vue
    ğŸ“„ FxPopup.vue
    ğŸ“„ KnobControl.vue
    ğŸ“„ MidiPanel.vue
    ğŸ“„ PadCell.vue
    ğŸ“„ PadGrid.vue
    ğŸ“„ PlayheadOverlay.vue
    ğŸ“„ SampleBrowser.vue
    ğŸ“„ SoundbankManager.vue
    ğŸ“„ StepCell.vue
    ğŸ“„ StepGrid.vue
    ğŸ“„ SyncPanel.vue
    ğŸ“„ TabPanel.vue
    ğŸ“„ TransportBar.vue
    ğŸ“ control/
      ğŸ“„ DualDisplay.vue
      ğŸ“„ FourDEncoder.vue
      ğŸ“„ SoftButtonStrip.vue
    ğŸ“ panels/
      ğŸ“„ ChannelPanel.vue
      ğŸ“„ ExportPanel.vue
      ğŸ“„ FxPanel.vue
      ğŸ“„ PatternsPanel.vue
      ğŸ“„ SoundPanel.vue
    ğŸ“ placeholders/
      ğŸ“„ DualDisplayPlaceholder.vue
      ğŸ“„ FourDEncoderPlaceholder.vue
      ğŸ“„ ModeColumnPlaceholder.vue
      ğŸ“„ ScreenKnobRingPlaceholder.vue
      ğŸ“„ SoftButtonStripPlaceholder.vue
      ğŸ“„ TouchStripPlaceholder.vue
  ğŸ“ composables/
    ğŸ“„ shortcutCommands.ts
    ğŸ“„ use4DEncoder.ts
    ğŸ“„ useAudioEngine.client.ts
    ğŸ“„ useAudioInput.client.ts
    ğŸ“„ useCapabilities.client.ts
    ğŸ“„ useImportExport.client.ts
    ğŸ“„ useMidi.client.ts
    ğŸ“„ useMidiLearn.ts
    ğŸ“„ usePatternStorage.client.ts
    ğŸ“„ useQuickBrowse.ts
    ğŸ“„ useRecentFiles.ts
    ğŸ“„ useSamplePreview.client.ts
    ğŸ“„ useScheduler.ts
    ğŸ“„ useSequencer.ts
    ğŸ“„ useShortcuts.ts
    ğŸ“„ useSoundbankStorage.client.ts
    ğŸ“„ useSync.client.ts
  ğŸ“ config/
    ğŸ“„ pwa.ts
  ğŸ“„ control-review.md
  ğŸ“ diagrams/
    ğŸ“„ browser-file-system-access.md
    ğŸ“„ browser-performance.md
    ğŸ“„ browser-sorting.md
    ğŸ“„ class-diagram.md
    ğŸ“„ control-4d-encoder-browser.md
    ğŸ“„ control-area-mapping.md
    ğŸ“„ favorites-flow.md
    ğŸ“„ library-hierarchy.md
    ğŸ“„ library-import-progress.md
    ğŸ“„ padgrid-modus-layout.md
    ğŸ“„ persistence-and-audio.md
    ğŸ“„ quick-browse.md
    ğŸ“„ recent-files.md
    ğŸ“„ sample-preview.md
    ğŸ“„ tag-dialog.md
    ğŸ“„ transport-engine.md
    ğŸ“„ ui-sequencer.md
    ğŸ“„ use-cases.md
  ğŸ“ dist/ (0 items)
    ğŸ“„ ...
  ğŸ“ dist-test/
    ğŸ“ audio/
      ğŸ“„ fxGraph.js
      ğŸ“„ fxGraph.js.map
    ğŸ“ composables/
      ğŸ“„ use4DEncoder.js
      ğŸ“„ use4DEncoder.js.map
      ğŸ“„ useAudioEngine.client.js
      ğŸ“„ useAudioEngine.client.js.map
      ğŸ“„ useAudioInput.client.js
      ğŸ“„ useAudioInput.client.js.map
      ğŸ“„ useCapabilities.client.js
      ğŸ“„ useCapabilities.client.js.map
      ğŸ“„ useImportExport.client.js
      ğŸ“„ useImportExport.client.js.map
      ğŸ“„ useMidi.client.js
      ğŸ“„ useMidi.client.js.map
      ğŸ“„ useMidiLearn.js
      ğŸ“„ useMidiLearn.js.map
      ğŸ“„ usePatternStorage.client.js
      ğŸ“„ usePatternStorage.client.js.map
      ğŸ“„ useQuickBrowse.js
      ğŸ“„ useQuickBrowse.js.map
      ğŸ“„ useRecentFiles.js
      ğŸ“„ useRecentFiles.js.map
      ğŸ“„ useSamplePreview.client.js
      ğŸ“„ useSamplePreview.client.js.map
      ğŸ“„ useScheduler.js
      ğŸ“„ useScheduler.js.map
      ğŸ“„ useSequencer.js
      ğŸ“„ useSequencer.js.map
      ğŸ“„ useSoundbankStorage.client.js
      ğŸ“„ useSoundbankStorage.client.js.map
      ğŸ“„ useSync.client.js
      ğŸ“„ useSync.client.js.map
    ğŸ“ domain/
      ğŸ“ clock/
        ğŸ“„ renderClock.js
        ğŸ“„ renderClock.js.map
        ğŸ“„ scheduler.js
        ğŸ“„ scheduler.js.map
      ğŸ“„ midiMapping.js
      ğŸ“„ midiMapping.js.map
      ğŸ“„ quantize.js
      ğŸ“„ quantize.js.map
      ğŸ“„ timing.js
      ğŸ“„ timing.js.map
      ğŸ“ transport/
        ğŸ“„ audioHooks.js
        ğŸ“„ audioHooks.js.map
        ğŸ“„ transportEngine.js
        ğŸ“„ transportEngine.js.map
        ğŸ“„ types.js
        ğŸ“„ types.js.map
      ğŸ“„ velocity.js
      ğŸ“„ velocity.js.map
    ğŸ“ services/
      ğŸ“„ fileSystemRepository.js
      ğŸ“„ fileSystemRepository.js.map
      ğŸ“„ libraryRepository.js
      ğŸ“„ libraryRepository.js.map
    ğŸ“ stores/
      ğŸ“„ browser.js
      ğŸ“„ browser.js.map
      ğŸ“„ control.js
      ğŸ“„ control.js.map
      ğŸ“„ patterns.js
      ğŸ“„ patterns.js.map
      ğŸ“„ session.js
      ğŸ“„ session.js.map
      ğŸ“„ soundbanks.js
      ğŸ“„ soundbanks.js.map
      ğŸ“„ transport.js
      ğŸ“„ transport.js.map
    ğŸ“ tests/
      ğŸ“ componentTests/
        ğŸ“„ PadCell.component.spec.js
        ğŸ“„ PadCell.component.spec.js.map
        ğŸ“„ PadGrid.component.spec.js
        ğŸ“„ PadGrid.component.spec.js.map
      ğŸ“ unitTests/
        ğŸ“„ browserPerformance.spec.js
        ğŸ“„ browserPerformance.spec.js.map
        ğŸ“„ browserSort.spec.js
        ğŸ“„ browserSort.spec.js.map
        ğŸ“„ browserStore.spec.js
        ğŸ“„ browserStore.spec.js.map
        ğŸ“„ controlBrowserIntegration.spec.js
        ğŸ“„ controlBrowserIntegration.spec.js.map
        ğŸ“„ favorites.spec.js
        ğŸ“„ favorites.spec.js.map
        ğŸ“„ fileSystemRepository.spec.js
        ğŸ“„ fileSystemRepository.spec.js.map
        ğŸ“„ libraryHierarchy.spec.js
        ğŸ“„ libraryHierarchy.spec.js.map
        ğŸ“„ libraryImport.spec.js
        ğŸ“„ libraryImport.spec.js.map
        ğŸ“„ quickBrowse.spec.js
        ğŸ“„ quickBrowse.spec.js.map
        ğŸ“„ recentFiles.spec.js
        ğŸ“„ recentFiles.spec.js.map
        ğŸ“„ samplePreview.spec.js
        ğŸ“„ samplePreview.spec.js.map
        ğŸ“„ tagManagement.spec.js
        ğŸ“„ tagManagement.spec.js.map
        ğŸ“„ transportEngine.spec.js
        ğŸ“„ transportEngine.spec.js.map
        ğŸ“„ use4DEncoder.spec.js
        ğŸ“„ use4DEncoder.spec.js.map
    ğŸ“ types/
      ğŸ“„ audio.js
      ğŸ“„ audio.js.map
      ğŸ“„ drums.js
      ğŸ“„ drums.js.map
      ğŸ“„ library.js
      ğŸ“„ library.js.map
      ğŸ“„ midi.js
      ğŸ“„ midi.js.map
      ğŸ“„ persistence.js
      ğŸ“„ persistence.js.map
      ğŸ“„ render.js
      ğŸ“„ render.js.map
      ğŸ“„ sync.js
      ğŸ“„ sync.js.map
      ğŸ“„ time.js
      ğŸ“„ time.js.map
    ğŸ“ utils/
      ğŸ“„ seededRandom.js
      ğŸ“„ seededRandom.js.map
      ğŸ“„ zip.js
      ğŸ“„ zip.js.map
  ğŸ“ domain/
    ğŸ“„ .DS_Store
    ğŸ“ clock/
      ğŸ“„ renderClock.ts
      ğŸ“„ scheduler.ts
    ğŸ“„ midiMapping.ts
    ğŸ“„ quantize.ts
    ğŸ“„ timing.ts
    ğŸ“ transport/
      ğŸ“„ audioHooks.ts
      ğŸ“„ transportEngine.ts
      ğŸ“„ types.ts
    ğŸ“„ validators.ts
    ğŸ“ velocity/
      ğŸ“„ velocityToGain.ts
    ğŸ“„ velocity.ts
  ğŸ“„ eslint.config.cjs
  ğŸ“„ eslint.config.js
  ğŸ“ iMac/
    ğŸ“ Repositories/
      ğŸ“ FullStackDeveloperCourse/
        ğŸ“ JavaScriptAdvanced/
          ğŸ“ CertificationProjects/
            ğŸ“ Drumcomputer/
              ğŸ“ node_modules/ (1 items)
                ğŸ“„ ...
  ğŸ“„ implementationPlan.json
  ğŸ“ layouts/
    ğŸ“„ default.vue
  ğŸ“ node_modules/ (773 items)
    ğŸ“„ ...
  ğŸ“„ nuxt.config.ts
  ğŸ“„ package-lock.json
  ğŸ“„ package.json
  ğŸ“ pages/
    ğŸ“„ index.vue
  ğŸ“ plugins/
    ğŸ“„ vuetify.client.ts
    ğŸ“„ vuetify.ts
  ğŸ“„ promptingAgentInstructions.json
  ğŸ“ public/
    ğŸ“„ .DS_Store
    ğŸ“ samples/
      ğŸ“„ clap.wav
      ğŸ“„ hihat.wav
      ğŸ“„ kick.wav
      ğŸ“„ snare.wav
  ğŸ“ scripts/
    ğŸ“„ dev.mjs
  ğŸ“ services/
    ğŸ“„ fileSystemRepository.ts
    ğŸ“„ libraryRepository.ts
    ğŸ“„ sampleDb.ts
  ğŸ“ stores/
    ğŸ“„ browser.ts
    ğŸ“„ control.ts
    ğŸ“„ patterns.ts
    ğŸ“„ session.ts
    ğŸ“„ soundbanks.ts
    ğŸ“„ transport.ts
  ğŸ“ styles/
    ğŸ“„ drum-machine.less
    ğŸ“„ globals.less
    ğŸ“„ variables.less
    ğŸ“„ vuetify-overrides.less
  ğŸ“ tests/
    ğŸ“ componentTests/
      ğŸ“„ DualDisplay.component.spec.ts
      ğŸ“„ FourDEncoder.component.spec.ts
      ğŸ“„ KnobControl.component.spec.ts
      ğŸ“„ PadCell.component.spec.ts
      ğŸ“„ PadGrid.component.spec.ts
    ğŸ“ setup/
      ğŸ“„ atobShim.ts
      ğŸ“„ indexedDBShim.ts
    ğŸ“ unitTests/
      ğŸ“„ browserPerformance.spec.ts
      ğŸ“„ browserSort.spec.ts
      ğŸ“„ browserStore.spec.ts
      ğŸ“„ controlBrowserIntegration.spec.ts
      ğŸ“„ favorites.spec.ts
      ğŸ“„ fileSystemRepository.spec.ts
      ğŸ“„ libraryHierarchy.spec.ts
      ğŸ“„ libraryImport.spec.ts
      ğŸ“„ quickBrowse.spec.ts
      ğŸ“„ recentFiles.spec.ts
      ğŸ“„ sampleDb.spec.ts
      ğŸ“„ sampleImportToPad.spec.ts
      ğŸ“„ samplePreview.spec.ts
      ğŸ“„ tagManagement.spec.ts
      ğŸ“„ transportEngine.spec.ts
      ğŸ“„ use4DEncoder.spec.ts
      ğŸ“„ useShortcuts.spec.ts
  ğŸ“„ tsconfig.json
  ğŸ“„ tsconfig.test.json
  ğŸ“ types/
    ğŸ“„ audio.ts
    ğŸ“„ drums.ts
    ğŸ“„ file-saver.d.ts
    ğŸ“„ import-meta.d.ts
    ğŸ“„ library.ts
    ğŸ“„ midi.ts
    ğŸ“„ persistence.ts
    ğŸ“„ process.d.ts
    ğŸ“„ render.ts
    ğŸ“„ shims-vue.d.ts
    ğŸ“„ sync.ts
    ğŸ“„ time.ts
    ğŸ“„ window.d.ts
  ğŸ“ utils/
    ğŸ“„ seededRandom.ts
    ğŸ“„ zip.ts
  ğŸ“„ vitest.config.ts


=========================================
File: .editorconfig
=========================================

# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = false
insert_final_newline = false


=========================================
File: .eslintrc.cjs
=========================================

module.exports = {
  root: true,
  env: {
    browser: true,
    es2021: true
  },
  extends: ['eslint:recommended', 'plugin:vue/vue3-recommended', 'plugin:@typescript-eslint/recommended'],
  parser: 'vue-eslint-parser',
  parserOptions: {
    parser: '@typescript-eslint/parser',
    ecmaVersion: 'latest',
    sourceType: 'module'
  },
  rules: {
    '@typescript-eslint/no-explicit-any': 'error'
  }
}



=========================================
File: .gitattributes
=========================================

*.wav filter=lfs diff=lfs merge=lfs -text
*.mp4 filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text
*.pdf filter=lfs diff=lfs merge=lfs -text



=========================================
File: .github/copilot-instructions.md
=========================================

## Role

- Software engineering copilot for a Nuxt 4 + Vue 3 (Options API) + TypeScript (strict) + Vuetify 3 project using Pug templates and Less.
- Web Audio / Web MIDI drum machine with IndexedDB + LocalStorage persistence.
- `DrumMachine.vue` stays the central UI component and primary integration point; do not move core orchestration away from it.

## Non-negotiable Global Rules

- Options API only; do not convert to Composition API. Use data/computed/methods/watch and lifecycle hooks.
- UI stability: no redesign/rearrange/restyle unless explicitly requested. Only minimal markup changes to wire functionality.
- Clean code: small focused functions, predictable state flow via stores/composables, avoid ad-hoc state and side-effects. Prefer domain helpers and scheduler utilities for timing/quantization.
- Stack compliance: Nuxt 4 conventions, Vuetify 3 components, Pug templates, Less styles. No new external UI libraries.
- English-only for comments/docs/diagrams.
- Clock authority: `AudioContext` is the single time source; route BPM/division changes through shared scheduler helpers.
- Deterministic export: preserve FX snapshot + seeded RNG reproducibility for render/export.
- Persistence discipline: IndexedDB for large/structured assets (soundbanks/samples); LocalStorage v2 for patterns/scenes/undo. Revoke old blob URLs when replacing samples; persist manifest + blob; avoid storing large blobs unnecessarily.

## Scope Governor (for any request)

- Produce a Scope Contract: bullet list of what will change (files/modules) and what will **not** change.
- If unclear, ask up to 3 targeted questions; otherwise proceed with best effort and document assumptions in English.
- Do not implement nice-to-have refactors/renames/formatting-only/architectural migrations unless explicitly requested.

## Project Map (authoritative)

- Stores: `stores/` (transport, patterns/scenes, session caps, soundbanks, control, browser).
- Composables: `composables/` (audio engine, scheduler, sequencer, MIDI/sync, import/export, audio input, storage).
- Domain: `domain/` (timing/quantize/velocity).
- UI shell: `pages/index.vue` + `components/DrumMachine.vue`.
- Diagrams as truth: `diagrams/*.md` (consult before altering flows).
- Mount reality rule: verify components are actually mounted before wiring logic.

## Quality Gates (always)

- Run `npm run lint`.
- Run `npm run typecheck`.
- Run tests: `npm test` (or repo test command). No acceptance if any gate fails.

## Testing Policy (hard gate)

- For every implemented function or user-facing behavior, add at least one test under `./tests/<appropriate-subfolder>/...`.
- Component behavior â†’ `tests/componentTests/...`.
- Pure logic/store/composable â†’ `tests/unitTests/...`.
- Tests must validate observable outcomes, not just â€œmethod was calledâ€ (unless that is the only stable observable).
- If tests fail, fix implementation/tests until all pass. No partial acceptance.

## Tooltip + Shortcut Policy (global)

- If a control is keyboard-triggerable, assign a shortcut via the global shortcut registry.
- Show the shortcut on hover via title or minimal Vuetify tooltip. Do not add new UI chrome/help panels unless requested.

## Definition of Done (required for every change set)

- **Functional**: requested behaviors implemented and verifiable; no unrelated features; UI behavior matches existing interaction patterns (SHIFT modifiers, soft button conventions, control store routing).
- **UI & UX Safety**: no unintended layout/style changes; display stays within 100vh; no new page scroll unless explicitly requested.
- **Code Quality**: Options API maintained; no Composition API; TypeScript strict passes; clean minimal diff; no formatting-only changes.
- **Performance & Stability**: no scheduler timing regressions; browser/file lists use scroll containers properly; persistence uses IndexedDB appropriately; avoid heavy sync loops on UI thread.
- **Documentation**: new comments/docs in English; update diagrams/docs when flows change materially.
- **Tests**: each implemented function/behavior has a test in `./tests/...`; all tests pass locally; lint + typecheck pass.
- **Deliverables**: list of changed files; short English changelog; exact commands to run lint/typecheck/tests; brief verification notes (what to click/press to confirm).

## Current Active Change Request (example template)

When a user provides a change request, respond with:

- Scope Contract (will change / wonâ€™t change)
- Implementation Plan (ordered, minimal)
- Test Plan (which tests, expected outcomes)
- DoD checklist mapping (how each DoD item will be satisfied)


=========================================
File: .gitignore
=========================================

node_modules
.nitro
.nuxt
.env
.DS_Store
npm-debug.log*
pnpm-lock.yaml
yarn.lock
Components.md
Composables.md
Domain.md
alleDateien.md
StepCell.md
StepGrid.md
dist
ROADMAP.md
nimamk3.json
uiList.json
functionsList.json
maschinemk3.jpg


=========================================
File: .gitignore 2
=========================================

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.*
!.env.example

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Sveltekit cache directory
.svelte-kit/

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Firebase cache directory
.firebase/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v3
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Vite logs files
vite.config.js.timestamp-*
vite.config.ts.timestamp-*



=========================================
File: .mocharc.json
=========================================

{
  "timeout": 5000,
  "color": true,
  "extension": [
    "js"
  ]
}


=========================================
File: Components.md
=========================================

## SoundPanel.vue
```vue
<template>
  <div class="sound-panel">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'SoundPanel'
})
</script>

<style scoped>
.sound-panel {
  background: #222;
  padding: 16px;
  border-radius: 8px;
  min-height: 100px;
}
</style>
```
## PatternsPanel.vue
```vue
<template>
  <div class="patterns-panel">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'PatternsPanel'
})
</script>

<style scoped>
.patterns-panel {
  background: #222;
  padding: 16px;
  border-radius: 8px;
  min-height: 100px;
}
</style>
```
## FxPanel.vue
```vue
<template>
  <div class="fx-panel">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'FxPanel'
})
</script>

<style scoped>
.fx-panel {
  background: #222;
  padding: 16px;
  border-radius: 8px;
  min-height: 100px;
}
</style>
```
## ExportPanel.vue
```vue
<template>
  <div class="export-panel">
    <button @click="$emit('export')">Exportieren</button>
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'ExportPanel',
  emits: ['export']
})
</script>

<style scoped>
.export-panel {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 8px;
  background: #222;
  padding: 16px;
  border-radius: 8px;
}
.export-panel button {
  background: #444;
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 1em;
  transition: background 0.1s;
}
.export-panel button:hover {
  background: #ff9800;
}
</style>
```
## TransportBar.vue
```vue
<template>
  <div class="transport-bar">
    <button @click="$emit('play')">Play</button>
    <button @click="$emit('stop')">Stop</button>
    <button @click="$emit('record')">Record</button>
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'TransportBar',
  emits: ['play', 'stop', 'record']
})
</script>

<style scoped>
.transport-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #222;
  padding: 8px 16px;
  border-radius: 8px;
}
.transport-bar button {
  background: #444;
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 1em;
  transition: background 0.1s;
}
.transport-bar button:hover {
  background: #ff9800;
}
</style>
```
## TabPanel.vue
```vue
<template>
  <div class="tab-panel">
    <div class="tab-bar">
      <button
        v-for="(tab, idx) in tabs"
        :key="tab.key"
        :class="{ active: tab.key === activeTab }"
        @click="$emit('update:activeTab', tab.key)"
      >
        {{ tab.label }}
      </button>
    </div>
    <div class="tab-content">
      <slot :name="activeTab" />
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'TabPanel',
  props: {
    tabs: {
      type: Array,
      required: true
    },
    activeTab: {
      type: String,
      required: true
    }
  },
  emits: ['update:activeTab']
})
</script>

<style scoped>
.tab-panel {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
}
.tab-bar {
  display: flex;
  border-bottom: 1px solid #444;
}
.tab-bar button {
  background: none;
  border: none;
  color: #fff;
  padding: 8px 16px;
  cursor: pointer;
  font-size: 1em;
  outline: none;
  transition: background 0.1s;
}
.tab-bar button.active {
  background: #222;
  border-bottom: 2px solid #ff9800;
}
.tab-content {
  flex: 1;
  padding: 16px;
  background: #222;
}
</style>
```
## StepGrid.vue
```vue
<template>
  <div class="step-grid">
    <StepCell
      v-for="(step, idx) in steps"
      :key="idx"
      :active="step.active"
      :selected="step.selected"
      :playing="step.playing"
      :label="step.label"
      @click="$emit('stepClick', idx)"
      @mousedown="$emit('stepMousedown', idx)"
      @mouseup="$emit('stepMouseup', idx)"
      @mouseenter="$emit('stepMouseenter', idx)"
      @mouseleave="$emit('stepMouseleave', idx)"
    >
      {{ step.label }}
    </StepCell>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import StepCell from './StepCell.vue'

export default defineComponent({
  name: 'StepGrid',
  components: { StepCell },
  props: {
    steps: {
      type: Array,
      required: true
    }
  },
  emits: [
    'stepClick',
    'stepMousedown',
    'stepMouseup',
    'stepMouseenter',
    'stepMouseleave'
  ]
})
</script>

<style scoped>
.step-grid {
  display: grid;
  grid-template-columns: repeat(16, 1fr);
  gap: 2px;
  width: 100%;
  height: 100%;
}
</style>
```
## StepCell.vue
```vue
<template>
  <div
    class="step-cell"
    :class="{ active, selected, playing }"
    @click="$emit('click')"
    @mousedown="$emit('mousedown')"
    @mouseup="$emit('mouseup')"
    @mouseenter="$emit('mouseenter')"
    @mouseleave="$emit('mouseleave')"
    tabindex="0"
    :aria-label="label"
  >
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'StepCell',
  props: {
    active: Boolean,
    selected: Boolean,
    playing: Boolean,
    label: String
  },
  emits: ['click', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave']
})
</script>

<style scoped>
.step-cell {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  background: #333;
  color: #fff;
  cursor: pointer;
  user-select: none;
  outline: none;
  transition: background 0.1s;
}
.step-cell.active {
  background: #ff9800;
}
.step-cell.selected {
  border: 2px solid #fff;
}
.step-cell.playing {
  background: #4caf50;
}
</style>
```
## PlayheadOverlay.vue
```vue
<template>
  <div class="playhead-overlay" :style="overlayStyle">
    <div class="playhead" :style="playheadStyle"></div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'PlayheadOverlay',
  props: {
    position: {
      type: Number,
      required: true
    },
    total: {
      type: Number,
      required: true
    }
  },
  computed: {
    overlayStyle(): Record<string, string> {
      return {
        position: 'absolute',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        pointerEvents: 'none'
      }
    },
    playheadStyle(): Record<string, string> {
      const percent = (this.position / this.total) * 100
      return {
        position: 'absolute',
        top: '0',
        left: percent + '%',
        width: '2px',
        height: '100%',
        background: '#ff9800',
        zIndex: '2'
      }
    }
  }
})
</script>

<style scoped>
.playhead-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}
.playhead {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: #ff9800;
  z-index: 2;
}
</style>
```
## PadGrid.vue
```vue
<template>
  <div class="pad-grid">
    <PadCell
      v-for="(pad, idx) in pads"
      :key="pad.id"
      :active="pad.active"
      :triggered="pad.triggered"
      :playing="pad.playing"
      :label="pad.label"
      @padDown="$emit('padDown', pad.id)"
      @padUp="$emit('padUp', pad.id)"
    >
      {{ pad.label }}
    </PadCell>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import PadCell from './PadCell.vue'

export default defineComponent({
  name: 'PadGrid',
  components: { PadCell },
  props: {
    pads: {
      type: Array,
      required: true
    }
  },
  emits: ['padDown', 'padUp']
})
</script>

<style scoped>
.pad-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 8px;
  width: 100%;
  height: 100%;
}
</style>
```
## PadCell.vue
```vue
<template>
  <div
    class="pad-cell"
    :class="{ active, triggered, playing }"
    @mousedown="onPadDown"
    @mouseup="onPadUp"
    @mouseleave="onPadUp"
    @touchstart.prevent="onPadDown"
    @touchend.prevent="onPadUp"
    @keydown.space.prevent="onPadDown"
    @keyup.space.prevent="onPadUp"
    tabindex="0"
    :aria-label="label"
  >
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'PadCell',
  props: {
    active: Boolean,
    triggered: Boolean,
    playing: Boolean,
    label: String
  },
  emits: ['padDown', 'padUp'],
  methods: {
    onPadDown() {
      this.$emit('padDown')
    },
    onPadUp() {
      this.$emit('padUp')
    }
  }
})
</script>

<style scoped>
.pad-cell {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  background: #222;
  color: #fff;
  cursor: pointer;
  user-select: none;
  outline: none;
  transition: background 0.1s;
}
.pad-cell.active {
  background: #444;
}
.pad-cell.triggered {
  background: #ff9800;
}
.pad-cell.playing {
  background: #4caf50;
}
</style>
```
## FxPopup.vue
```vue
<template>
  <div class="fx-popup" v-if="visible">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'FxPopup',
  props: {
    visible: {
      type: Boolean,
      required: true
    }
  }
})
</script>

<style scoped>
.fx-popup {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
</style>
```
# Komponenten

## DrumMachine.vue
```vue
<template>
  <slot
    name="main"
    :props="mainSlotProps"
  />
  <slot
    name="transport"
    :props="transportSlotProps"
  />
  <slot
    name="pads"
    :props="padsSlotProps"
  />
  <slot
    name="drawer"
    :props="drawerSlotProps"
  />
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import { saveAs } from 'file-saver'
import { DEFAULT_GRID_SPEC, GRID_DIVISIONS, normalizeGridSpec } from '@/domain/timing'
import { useTransportStore } from '@/stores/transport'
import { usePatternsStore } from '@/stores/patterns'
import { useSoundbanksStore } from '@/stores/soundbanks'
import { useSessionStore } from '@/stores/session'
import { useSequencer } from '@/composables/useSequencer'
import { useSync } from '@/composables/useSync.client'
import { useMidi } from '@/composables/useMidi.client'
import { usePatternStorage } from '@/composables/usePatternStorage.client'
import { useSoundbankStorage } from '@/composables/useSoundbankStorage.client'
import { useImportExport } from '@/composables/useImportExport.client'
import { useCapabilities } from '@/composables/useCapabilities.client'
import { useMidiLearn } from '@/composables/useMidiLearn'
import TransportBar from './TransportBar.vue'
import PadGrid from './PadGrid.vue'
import StepGridComponent from './StepGrid.vue'
import TabPanel from './TabPanel.vue'
import SoundPanel from './panels/SoundPanel.vue'
import FxPanel from './panels/FxPanel.vue'
import PatternsPanel from './panels/PatternsPanel.vue'
import ExportPanel from './panels/ExportPanel.vue'
import { createZip, type ZipEntry } from '@/utils/zip'
import type { DrumPadId, Scene } from '@/types/drums'
import type { TimeDivision, GridSpec } from '@/types/time'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import type { RenderEvent, RenderMetadata } from '@/types/render'
import type { StepGrid } from '@/types/drums'

const slugify = (value: string): string => {
  const cleaned = value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
  return cleaned || 'drum-session'
}

type StemFiles = Partial<
  Record<
    DrumPadId,
    {
      fileName: string
      blob: Blob
    }
  >
>

type StemEntry = {
  padId: DrumPadId
  label: string
  fileName: string
}

type PadState = {
  label: string
  isTriggered: boolean
  isPlaying: boolean
}

const VISIBLE_DIVISIONS: TimeDivision[] = GRID_DIVISIONS.filter((value) => value <= 16)

const collectPlayingPads = (steps: StepGrid): Set<DrumPadId> => {
  const set = new Set<DrumPadId>()

  Object.values(steps).forEach((bar) => {
    Object.values(bar).forEach((step) => {
      Object.keys(step).forEach((padId) => {
        set.add(padId as DrumPadId)
      })
    })
  })

  return set
}

export default defineComponent({
  name: 'DrumMachine',
  components: {
    TransportBar,
    PadGrid,
    StepGrid: StepGridComponent,
    TabPanel,
    SoundPanel,
    FxPanel,
    PatternsPanel,
    ExportPanel
  },
  data() {
    const transport = useTransportStore()
    const patterns = usePatternsStore()
    const soundbanks = useSoundbanksStore()
    const session = useSessionStore()
    const capabilitiesProbe = useCapabilities()
    session.setCapabilities(capabilitiesProbe.capabilities.value)

    const importExport = useImportExport()
    const midi = useMidi()
    const midiLearn = useMidiLearn(midi)
    const sequencer = useSequencer({
      getPattern: () => patterns.currentPattern,
      onPatternBoundary: () => patterns.advanceScenePlayback()
    })
    const handleExternalStart = () => {
      if (!transport.isPlaying) {
        patterns.prepareScenePlayback()
        void sequencer.start().catch((error) => {
          console.error('Failed to start sequencer from external sync', error)
        })
      }
    }
    const handleExternalStop = () => {
      if (transport.isPlaying) {
        sequencer.stop()
      }
    }
    const sync = useSync('internal', {
      midi,
      getAudioTime: () => sequencer.getAudioTime(),
      onExternalStart: handleExternalStart,
      onExternalStop: handleExternalStop
    })
    const patternStorage = usePatternStorage()
    const soundbankStorage = useSoundbankStorage()

    const pads: DrumPadId[] = [
      'pad1',
      'pad2',
      'pad3',
      'pad4',
      'pad5',
      'pad6',
      'pad7',
      'pad8',
      'pad9',
      'pad10',
      'pad11',
      'pad12',
      'pad13',
      'pad14',
      'pad15',
      'pad16'
    ]
    const divisions: TimeDivision[] = [...VISIBLE_DIVISIONS]
    const defaultBank: Soundbank = {
      id: 'default-kit',
      name: 'Default Kit',
      createdAt: Date.now(),
      updatedAt: Date.now(),
      pads: {
        pad1: { id: 'kick', name: 'Kick', url: '/samples/kick.wav', format: 'wav' },
        pad5: { id: 'kick-2', name: 'Kick 2', url: '/samples/kick.wav', format: 'wav' },
        pad9: { id: 'kick-3', name: 'Kick 3', url: '/samples/kick.wav', format: 'wav' },
        pad13: { id: 'kick-4', name: 'Kick 4', url: '/samples/kick.wav', format: 'wav' },
        pad2: { id: 'snare', name: 'Snare', url: '/samples/snare.wav', format: 'wav' },
        pad6: { id: 'snare-2', name: 'Snare 2', url: '/samples/snare.wav', format: 'wav' },
        pad10: { id: 'snare-3', name: 'Snare 3', url: '/samples/snare.wav', format: 'wav' },
        pad14: { id: 'snare-4', name: 'Snare 4', url: '/samples/snare.wav', format: 'wav' },
        pad3: { id: 'hihat', name: 'Hi-Hat', url: '/samples/hihat.wav', format: 'wav' },
        pad7: { id: 'hihat-2', name: 'Hi-Hat 2', url: '/samples/hihat.wav', format: 'wav' },
        pad11: { id: 'hihat-3', name: 'Hi-Hat 3', url: '/samples/hihat.wav', format: 'wav' },
        pad15: { id: 'hihat-4', name: 'Hi-Hat 4', url: '/samples/hihat.wav', format: 'wav' },
        pad4: { id: 'clap', name: 'Clap', url: '/samples/clap.wav', format: 'wav' },
        pad8: { id: 'clap-2', name: 'Clap 2', url: '/samples/clap.wav', format: 'wav' },
        pad12: { id: 'clap-3', name: 'Clap 3', url: '/samples/clap.wav', format: 'wav' },
        pad16: { id: 'clap-4', name: 'Clap 4', url: '/samples/clap.wav', format: 'wav' }
      }
    }

    if (soundbanks.banks.length === 0) {
      soundbanks.setBanks([defaultBank])
    }

    return {
      transport,
      patterns,
      soundbanks,
      session,
      sequencer,
      sync,
      midi,
      midiLearn,
      patternStorage,
      soundbankStorage,
      pads,
      divisions,
      defaultBank,
      unwatchers: [] as Array<() => void>,
      stepGridRef: null as (InstanceType<typeof StepGridComponent> & { focusGrid?: () => void }) | null,
      exportMetadata: null as RenderMetadata | null,
      exportAudioBlob: null as Blob | null,
      exportTimeline: undefined as RenderEvent[] | undefined,
      exportStems: null as StemFiles | null,
      isExporting: false,
      exportError: null as string | null,
      exportAudioFn: importExport.exportAudio,
      selectedPadId: 'pad1' as DrumPadId,
      drawerTab: 'sound'
    }
  },
  // ...restlicher Code siehe Datei DrumMachine.vue ...
</script>
```

## DrumMachineSlots.vue
```vue
<template>
  <div class="drum-machine-slots">
    <slot name="transport" />
    <slot name="pads" />
    <slot name="drawer" />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'DrumMachineSlots'
})
</script>

<style scoped>
.drum-machine-slots {
  display: flex;
  flex-direction: column;
  height: 100%;
}
</style>
```



=========================================
File: Composables.md
=========================================

# Composables

## useAudioEngine.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'
import type { DrumPadId } from '@/types/drums'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import { createSeededRandom, type RandomSource } from '@/utils/seededRandom'
import { createFxGraph, connectFxGraph, updateFxGraph, type FxGraphNodes } from '@/audio/fxGraph'

interface TriggerRequest {
	padId: DrumPadId
	when: number
	velocity?: number
}

const cloneFxSettings = (settings: FxSettings): FxSettings => ({
	filter: { ...settings.filter },
	drive: { ...settings.drive },
	reverb: { ...settings.reverb }
})

const createAudioEngineInstance = () => {
	const audioContext = ref<AudioContext | null>(null)
	const masterGain = ref<GainNode | null>(null)
	const sampleCache = ref<Map<DrumPadId, AudioBuffer>>(new Map())
	const fxSettings = ref<FxSettings>({
		filter: { enabled: true, frequency: 12000, q: 0.7 },
		drive: { enabled: false, amount: 0.25 },
		reverb: { enabled: false, mix: 0.15 }
	})
	const fxSnapshot = ref<FxSettings>(cloneFxSettings(fxSettings.value))
	const fxGraph = ref<FxGraphNodes | null>(null)
	let randomSource: RandomSource = createSeededRandom(0)
	let wasRunningOnHide = false
	let handlePageHide: (() => void) | null = null
	let handlePageShow: (() => void) | null = null

	const syncFxSnapshot = () => {
		fxSnapshot.value = cloneFxSettings(fxSettings.value)
		return fxSnapshot.value
	}

	const ensureFxGraph = (ctx: BaseAudioContext, snapshot: FxSettings) => {
		if (!masterGain.value) {
			return
		}
		if (!fxGraph.value) {
			fxGraph.value = createFxGraph(ctx)
			connectFxGraph(fxGraph.value, masterGain.value)
		}
		updateFxGraph(ctx, fxGraph.value, snapshot, randomSource)
	}

	const ensureContext = () => {
		if (!audioContext.value) {
			const context = new AudioContext()
			const gain = context.createGain()
			gain.gain.value = 0.8
			gain.connect(context.destination)
			audioContext.value = context
			masterGain.value = gain
		}
		ensureFxGraph(audioContext.value as BaseAudioContext, fxSnapshot.value)
		return audioContext.value as AudioContext
	}

	const resumeContext = async () => {
		const ctx = ensureContext()
		if (ctx.state === 'suspended') {
			await ctx.resume()
		}
		return ctx
	}

	const getFxSnapshot = () => cloneFxSettings(fxSnapshot.value)

	const setFxRandomSource = (source: RandomSource) => {
		randomSource = source
		if (fxGraph.value?.reverbNode) {
			fxGraph.value.reverbNode.buffer = null
		}
		if (audioContext.value) {
			ensureFxGraph(audioContext.value, fxSnapshot.value)
		}
	}

	const decodeSample = async (sample: SampleRef): Promise<AudioBuffer | null> => {
		const ctx = ensureContext()
		if (sample.buffer) {
			return sample.buffer
		}
		if (sample.blob) {
			const arrayBuffer = await sample.blob.arrayBuffer()
			return ctx.decodeAudioData(arrayBuffer.slice(0))
		}
		if (sample.url) {
			const response = await fetch(sample.url)
			const arrayBuffer = await response.arrayBuffer()
			return ctx.decodeAudioData(arrayBuffer)
		}
		return null
	}

	const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
		const buffer = sample.buffer ?? (await decodeSample(sample))
		if (buffer) {
			sampleCache.value.set(padId, buffer)
		}
	}

	const applySoundbank = async (bank: Soundbank) => {
		const entries = Object.entries(bank.pads)
		await Promise.all(
			entries.map(async ([padId, sample]) => {
				if (sample) {
					await setSampleForPad(padId as DrumPadId, sample)
				}
			})
		)
	}

	const setFx = (partial: Partial<FxSettings>) => {
		fxSettings.value = {
			filter: { ...fxSettings.value.filter, ...(partial.filter ?? {}) },
			drive: { ...fxSettings.value.drive, ...(partial.drive ?? {}) },
			reverb: { ...fxSettings.value.reverb, ...(partial.reverb ?? {}) }
		}
		const snapshot = syncFxSnapshot()
		const ctx = ensureContext()
		ensureFxGraph(ctx, snapshot)
	}

	const trigger = async ({ padId, when, velocity = 1 }: TriggerRequest) => {
		const ctx = ensureContext()
		const buffer = sampleCache.value.get(padId) ?? null
		if (!buffer) {
			return
		}
		const source = ctx.createBufferSource()
		source.buffer = buffer
		const gain = ctx.createGain()
		gain.gain.value = velocity
		source.connect(gain)
		if (fxGraph.value) {
			gain.connect(fxGraph.value.fxInput)
		} else {
			gain.connect(masterGain.value ?? ctx.destination)
		}
		source.start(when)
	}

	if (typeof window !== 'undefined') {
		handlePageHide = () => {
			if (audioContext.value) {
				wasRunningOnHide = audioContext.value.state === 'running'
				void audioContext.value.suspend().catch(() => undefined)
			}
		}

		handlePageShow = () => {
			if (wasRunningOnHide && audioContext.value) {
				void audioContext.value.resume().catch(() => undefined)
			}
			wasRunningOnHide = false
		}

		window.addEventListener('pagehide', handlePageHide)
		window.addEventListener('pageshow', handlePageShow)
	}

	onBeforeUnmount(() => {
		if (handlePageHide) {
			window.removeEventListener('pagehide', handlePageHide)
		}
		if (handlePageShow) {
			window.removeEventListener('pageshow', handlePageShow)
		}
		audioContext.value?.close()
		sampleCache.value.clear()
	})

	return {
		audioContext,
		masterGain,
		sampleCache,
		fxSettings,
		ensureContext,
		resumeContext,
		decodeSample,
		applySoundbank,
		setFx,
		setSampleForPad,
		trigger,
		getFxSnapshot,
		setFxRandomSource
	}
}

let audioEngineInstance: ReturnType<typeof createAudioEngineInstance> | null = null

export function useAudioEngine() {
	if (!audioEngineInstance) {
		audioEngineInstance = createAudioEngineInstance()
	}
	return audioEngineInstance
}

```

## useAudioInput.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'

export interface AudioInputState {
	stream?: MediaStream
	error?: string
}

export function useAudioInput() {
	const state = ref<AudioInputState>({})
	const sourceNode = ref<MediaStreamAudioSourceNode | null>(null)
	const audioContext = ref<AudioContext | null>(null)
	let handlePageHide: (() => void) | null = null

	const requestMic = async () => {
		try {
			const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
			const context = new AudioContext()
			sourceNode.value = context.createMediaStreamSource(stream)
			audioContext.value = context
			state.value = { stream }
		} catch (error) {
			const message = error instanceof Error ? error.message : 'microphone request failed'
			state.value = { error: message }
		}
	}

	const stop = () => {
		state.value.stream?.getTracks().forEach((track) => track.stop())
		void audioContext.value?.close()
		audioContext.value = null
		state.value = {}
	}

	if (typeof window !== 'undefined') {
		handlePageHide = () => {
			stop()
			sourceNode.value = null
		}
		window.addEventListener('pagehide', handlePageHide)
	}

	onBeforeUnmount(() => {
		if (handlePageHide) {
			window.removeEventListener('pagehide', handlePageHide)
		}
		stop()
		sourceNode.value = null
	})

	return {
		state,
		sourceNode,
		requestMic,
		stop
	}
}
```

## useCapabilities.client.ts
```typescript
import { ref } from 'vue'

export interface Capabilities {
	supportsWebMIDI: boolean
	supportsAudioInput: boolean
}

export function useCapabilities() {
	const capabilities = ref<Capabilities>({ supportsWebMIDI: false, supportsAudioInput: false })

	const evaluate = () => {
		capabilities.value = {
			supportsWebMIDI: typeof navigator !== 'undefined' && 'requestMIDIAccess' in navigator,
			supportsAudioInput: typeof navigator !== 'undefined' && Boolean(navigator.mediaDevices?.getUserMedia)
		}
	}

	evaluate()

	return {
		capabilities,
		evaluate
	}
}
```

## useImportExport.client.ts
```typescript
import { ref } from 'vue'
import { saveAs } from 'file-saver'
import { Midi as MidiType } from '@tonejs/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import { clampVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock } from '@/domain/clock/renderClock'
import { createFxGraph, connectFxGraph, updateFxGraph } from '@/audio/fxGraph'
import { useAudioEngine } from './useAudioEngine.client'
import { usePatternsStore } from '@/stores/patterns'
import { useTransportStore } from '@/stores/transport'
import { createSeededRandom } from '@/utils/seededRandom'
import type { ScheduledTask } from './useScheduler'
import { scheduleStep } from './useSequencer'
import type { ScheduleStepOptions, ScheduledStep } from './useSequencer'
import type { GridSpec } from '@/types/time'
import type { MidiFileData, MidiMapping } from '@/types/midi'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { RenderMetadata, RenderEvent } from '@/types/render'
import type { DrumPadId, Pattern } from '@/types/drums'

// ...existing code...
```

## useMidi.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'
import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '@/types/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'

// ...existing code...
```

## useMidiLearn.ts
```typescript
import { computed, onBeforeUnmount, ref } from 'vue'
import { defaultMidiMapping } from '@/domain/midiMapping'
import type { MidiMessage, MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

// ...existing code...
```

## usePatternStorage.client.ts
```typescript
import { ref } from 'vue'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import type { Pattern, Scene } from '@/types/drums'

// ...existing code...
```

## useScheduler.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'

// ...existing code...
```

## useSequencer.ts
```typescript
import { ref, type Ref } from 'vue'
import { quantizeToStep } from '@/domain/quantize'
import { normalizeGridSpec, secondsPerStep } from '@/domain/timing'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { GridSpec, StepAddress } from '@/types/time'
import { useTransportStore } from '@/stores/transport'
import { useScheduler, type ScheduledTask } from './useScheduler'
import { useAudioEngine } from './useAudioEngine.client'
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock, type RenderClock } from '@/domain/clock/renderClock'

// ...existing code...
```

## useSoundbankStorage.client.ts
```typescript
import { ref } from 'vue'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { Soundbank, SampleRef } from '@/types/audio'

// ...existing code...
```

## useSync.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'
import { useScheduler } from './useScheduler'
import type { ClockAuthority, SyncMode, SyncRole, SyncState } from '@/types/sync'
import type { MidiMessage } from '@/types/midi'

// ...existing code...
```



=========================================
File: Domain.md
=========================================

# Domain

## midiMapping.ts
```typescript
import type { MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

const defaultPads: DrumPadId[] = [
	'pad1',
	'pad2',
	'pad3',
	'pad4',
	'pad5',
	'pad6',
	'pad7',
	'pad8',
	'pad9',
	'pad10',
	'pad11',
	'pad12',
	'pad13',
	'pad14',
	'pad15',
	'pad16'
]

export function defaultMidiMapping(): MidiMapping {
	const noteMap: Partial<Record<number, DrumPadId>> = {}
	const noteMapInverse: Partial<Record<DrumPadId, number>> = {}
	defaultPads.forEach((padId, index) => {
		const note = 36 + index
		noteMap[note] = padId
		noteMapInverse[padId] = note
	})
	return { noteMap, noteMapInverse, transportMap: {} }
}

```

## quantize.ts
```typescript
import type { StepAddress } from '@/types/time'

export function quantizeToStep(time: number, secondsPerStep: number, bars: number, division: number): StepAddress {
	const totalSteps = bars * division
	const stepIndex = Math.max(0, Math.min(totalSteps - 1, Math.round(time / secondsPerStep)))
	return {
		barIndex: Math.floor(stepIndex / division),
		stepInBar: stepIndex % division
	}
}

```

## timing.ts
```typescript
import type { GridSpec, TimeDivision } from '@/types/time'

export const GRID_DIVISIONS: readonly TimeDivision[] = [1, 2, 4, 8, 16, 32, 64] as const
export const DEFAULT_GRID_SPEC: GridSpec = { bars: 1, division: 16 }

export function secondsPerStep(bpm: number, division: number): number {
	return (60 / bpm) * (4 / division)
}

export function stepsPerBar(gridSpec: GridSpec): number {
	return gridSpec.division
}

export function normalizeGridSpec(gridSpec?: Partial<GridSpec>): GridSpec {
	const division = GRID_DIVISIONS.includes((gridSpec?.division ?? DEFAULT_GRID_SPEC.division) as TimeDivision)
		? (gridSpec?.division as TimeDivision)
		: DEFAULT_GRID_SPEC.division
	const bars: GridSpec['bars'] =
		gridSpec?.bars === 1 || gridSpec?.bars === 2 || gridSpec?.bars === 4 || gridSpec?.bars === 8
			? gridSpec.bars
			: DEFAULT_GRID_SPEC.bars

	return { bars, division }
}

```

## validators.ts
```typescript
import { GRID_DIVISIONS } from './timing'
import type { GridSpec } from '../types/time'

export function isValidGridSpec(gridSpec: GridSpec): boolean {
	return gridSpec.bars >= 1 && gridSpec.bars <= 8 && GRID_DIVISIONS.includes(gridSpec.division)
}

```

## velocity.ts
```typescript
export const STEP_VELOCITY_LEVELS = [0.7, 1, 1.25] as const
export const DEFAULT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[0]
export const ACCENT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[STEP_VELOCITY_LEVELS.length - 1]!

const EPSILON = 0.001

const matchesLevel = (value: number, level: number) => Math.abs(value - level) < EPSILON

export function clampVelocity(value?: number): number {
	const resolved = typeof value === 'number' ? value : DEFAULT_STEP_VELOCITY
	const clamped = Math.max(STEP_VELOCITY_LEVELS[0], Math.min(ACCENT_STEP_VELOCITY, resolved))
	const closest = STEP_VELOCITY_LEVELS.find((level) => matchesLevel(clamped, level))
	return closest ?? clamped
}

export function cycleVelocity(current?: number): number | null {
	if (typeof current !== 'number') {
		return DEFAULT_STEP_VELOCITY
	}
	const index = STEP_VELOCITY_LEVELS.findIndex((level) => matchesLevel(current, level))
	if (index === -1) {
		return DEFAULT_STEP_VELOCITY
	}
	const nextIndex = index + 1
	if (nextIndex >= STEP_VELOCITY_LEVELS.length) {
		return null
	}
	const nextValue = STEP_VELOCITY_LEVELS[nextIndex]
	if (typeof nextValue !== 'number') {
		return null
	}
	return nextValue
}

export function velocityToIntensity(value?: number): number {
	if (!value) return 0
	return Math.min(1, value / ACCENT_STEP_VELOCITY)
}

```

### clock/renderClock.ts
```typescript
export interface RenderClock {
	readonly ctx: BaseAudioContext

	/**
	 * Indicates whether the clock is used for offline rendering.
	 * Offline clocks must not rely on real-time scheduling.
	 */
	readonly isOffline: boolean

	/**
	 * Current audio time in seconds.
	 * This is always based on the underlying AudioContext.
	 */
	audioTime(): number

	/**
	 * Alias for audioTime(), for compatibility.
	 */
	now(): number
}

export function createRenderClock(


	ctx: BaseAudioContext,
	isOffline = false
): RenderClock {
	return {
		ctx,
		isOffline,
		audioTime: () => ctx.currentTime,
		now: () => ctx.currentTime
	}
}

```

### clock/scheduler.ts
```typescript
import type { RenderClock } from './renderClock'

export type ScheduledFn = (audioTime: number) => void

export interface SchedulerOptions {
	readonly lookaheadSec: number
	readonly intervalMs: number
}

export interface Scheduler {
	start(): void
	stop(): void
	schedule(atTimeSec: number, fn: ScheduledFn): void
	clear(): void
}

interface ScheduledItem {
	at: number
	fn: ScheduledFn
}

const DEFAULT_OPTIONS: SchedulerOptions = {
	lookaheadSec: 0.1,
	intervalMs: 25
}

export function createScheduler(clock: RenderClock, options: Partial<SchedulerOptions> = {}): Scheduler {
	const cfg: SchedulerOptions = { ...DEFAULT_OPTIONS, ...options }

	let timerId: ReturnType<typeof setInterval> | null = null
	let wasRunningOnHide = false
	let queue: ScheduledItem[] = []

	const flush = (): void => {
		const now = clock.audioTime()
		const horizon = now + cfg.lookaheadSec

		// Keep queue sorted to guarantee deterministic execution order
		queue.sort((a, b) => a.at - b.at)

		const due: ScheduledItem[] = []
		const pending: ScheduledItem[] = []

		for (const item of queue) {
			if (item.at <= horizon) {
				due.push(item)
			} else {
				pending.push(item)
			}
		}

		queue = pending

		// Execute all due items in order
		for (const item of due) {
			item.fn(item.at)
		}
	}

	const startTimer = (): void => {
		if (clock.isOffline) {
			// Offline rendering should call flush manually from the renderer/engine
			return
		}
		if (timerId) {
			return
		}
		timerId = setInterval(flush, cfg.intervalMs)
	}

	const stopTimer = (): void => {
		if (!timerId) {
			return
		}
		clearInterval(timerId)
		timerId = null
	}

	if (typeof window !== 'undefined') {
		const handlePageHide = () => {
			if (timerId) {
				wasRunningOnHide = true
				stopTimer()
			} else {
				wasRunningOnHide = false
			}
		}

		const handlePageShow = () => {
			if (wasRunningOnHide) {
				startTimer()
				flush()
			}
		}

		window.addEventListener('pagehide', handlePageHide)
		window.addEventListener('pageshow', handlePageShow)
	}

	return {
		start(): void {
			startTimer()
		},

		stop(): void {
			stopTimer()
		},

		schedule(atTimeSec: number, fn: ScheduledFn): void {
			queue.push({ at: atTimeSec, fn })
		},

		clear(): void {
			queue = []
		}
	}
}

```

### transport/audioHooks.ts
```typescript
export interface TransportAudioHooks {
	onStep(stepIndex: number, audioTime: number): void
}

```

### transport/transportEngine.ts
```typescript
import type { RenderClock } from '../clock/renderClock'
import type { Scheduler } from '../clock/scheduler'
import type { TransportConfig, TransportState } from './types'
import type { TransportAudioHooks } from './audioHooks'
export type TransportListener = (state: TransportState) => void

export interface TransportEngine {
	start(): void
	stop(): void
	setConfig(next: TransportConfig): void
	subscribe(listener: TransportListener): () => void
	tick(): void
}

const clampInt = (value: number): number => {
	if (!Number.isFinite(value)) {
		return 0
	}
	return Math.floor(value)
}



export function createTransportEngine(
	clock: RenderClock,
	scheduler: Scheduler,
	initial: TransportConfig,
	audioHooks?: TransportAudioHooks
	): TransportEngine {
		let cfg: TransportConfig = initial

		let isPlaying = false
		let startTimeSec = 0
		let lastStep = -1
		let lastAbsoluteStep = -1

		const listeners = new Set<TransportListener>()
		const stepDurationSec = (): number => {
		const stepsPerBar = Math.max(1, cfg.gridSpec.division)
		const beatsPerBar = 4
		const beatsPerStep = beatsPerBar / stepsPerBar
		const secPerBeat = 60 / Math.max(1, cfg.bpm)
		return beatsPerStep * secPerBeat
		}
  
		const totalSteps = (): number => {
			const steps = cfg.gridSpec.bars * cfg.gridSpec.division
			return Math.max(0, clampInt(steps))
		}

		const normalizeStep = (step: number): number => {
			const steps = Math.max(totalSteps(), 1)
			return ((step % steps) + steps) % steps
		}

		const swingOffsetSec = (stepIndex: number): number => {
		const swing = cfg.swing ?? 0
		if (swing <= 0) {
			return 0
		}

		// apply swing to off-beats only
		const isOffBeat = stepIndex % 2 === 1
		if (!isOffBeat) {
			return 0
		}

		return stepDurationSec() * swing * 0.5
	}

	const emit = (): void => {
		const steps = Math.max(totalSteps(), 1)
		const normalized = ((lastStep % steps) + steps) % steps

		const state: TransportState = {
			isPlaying,
			currentStep: normalized
		}

		for (const listener of listeners) {
			listener(state)
			}
		}
    
		const computeAbsoluteStepAt = (timeSec: number): number => {
			const dur = stepDurationSec()
			const raw = (timeSec - startTimeSec) / dur
			return clampInt(raw)
		}

		let lastScheduledStep = -1

		const scheduleStepBoundary = (stepIndexAbsolute: number): void => {
			if (stepIndexAbsolute === lastScheduledStep) {
				return
			}

			const normalizedStep = normalizeStep(stepIndexAbsolute)
			lastScheduledStep = stepIndexAbsolute

			const stepTimeSec =
				startTimeSec +
				stepIndexAbsolute * stepDurationSec() +
				swingOffsetSec(normalizedStep)

			scheduler.schedule(stepTimeSec, (audioTime) => {
				audioHooks?.onStep(normalizedStep, audioTime)
			})
		}


		const advance = (): void => {
			const now = clock.audioTime()
			const currentAbsolute = computeAbsoluteStepAt(now)
			const current = normalizeStep(currentAbsolute)

			if (current !== lastStep) {
				lastStep = current
				lastAbsoluteStep = currentAbsolute
				scheduleStepBoundary(lastAbsoluteStep + 1)
				emit()
			}
		}

	return {
		start(): void {
			if (isPlaying) {
				return
			}
			isPlaying = true
			startTimeSec = clock.audioTime()
			lastStep = -1
			lastAbsoluteStep = -1
			lastScheduledStep = -1
			scheduler.clear()
			scheduler.start()
			lastAbsoluteStep = computeAbsoluteStepAt(startTimeSec)
			lastStep = normalizeStep(lastAbsoluteStep)
			emit()
			scheduleStepBoundary(lastAbsoluteStep + 1)
		},

		stop(): void {
			if (!isPlaying) {
				return
			}
			isPlaying = false
			scheduler.stop()
			scheduler.clear()
			lastStep = -1
			lastScheduledStep = -1
			emit()
		},

		setConfig(next: TransportConfig): void {
			cfg = next
			// Re-normalize immediately
			if (isPlaying) {
				// Keep phase consistent by resetting start time to "now - currentStep * dur"
				const now = clock.audioTime()
				const dur = stepDurationSec()
				const steps = Math.max(totalSteps(), 1)
				const current = ((lastStep % steps) + steps) % steps
				startTimeSec = now - lastAbsoluteStep * dur - swingOffsetSec(current)
				scheduler.clear()
				lastScheduledStep = -1
				lastAbsoluteStep = computeAbsoluteStepAt(now)
				lastStep = normalizeStep(lastAbsoluteStep)
				scheduleStepBoundary(lastAbsoluteStep + 1)
			} else {
				lastScheduledStep = -1
			}
			emit()
		},

		subscribe(listener: TransportListener): () => void {
			listeners.add(listener)
			// emit current snapshot immediately
			listener({
				isPlaying,
				currentStep: Math.max(0, lastStep)
			})
			return (): void => {
				listeners.delete(listener)
			}
		},

		tick(): void {
			if (!isPlaying) {
				return
			}
			advance()
		}
	}
}

```

### transport/types.ts
```typescript
import type { DrumPadId } from '@/types/drums'
// Update the import path below to the correct relative path where GridSpec is defined
import type { GridSpec } from '@/types/time'
// Or adjust the path as needed based on your project structure

export interface TransportState {
	readonly isPlaying: boolean
	readonly currentStep: number
}

export type StepTogglePayload = {
	barIndex: number
	stepInBar: number
	padId: DrumPadId
}

export interface TransportConfig {
	readonly bpm: number
	readonly gridSpec: GridSpec
	swing?: number
}

```

### velocity/velocityToGain.ts
```typescript
export function velocityToGain(
	velocity: number,
	minGain = 0.15
): number {
	// velocity expected in [0, 1]
	const v = Math.max(0, Math.min(1, velocity))

	// psychoacoustic-friendly curve
	const curved = v * v

	return minGain + (1 - minGain) * curved
}

```



=========================================
File: LICENSE
=========================================

MIT License

Copyright (c) 2025 Markus Tratschitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



=========================================
File: README 2.md
=========================================

# Drumcomputer


=========================================
File: README.md
=========================================

# Drumcomputer

Nuxt 4 drum machine using Vue 3 Options API + TypeScript strict, Vuetify 3 (Pug + Less), Web Audio lookahead scheduling, Web MIDI capability checks, and IndexedDB stubs for soundbanks.

![UI screenshot](assets/screenshots/screenshot.png)

## Maschine MK3 UI Parity Plan (2026-01-04)

- **No-scroll full-screen shell**: Lock the hardware wrapper to `100vh` with inner flex grids only; push any overflow (sound/FX/pattern drawers) into internal scroll areas and clamp paddings/margins so a 1080p viewport fits without page scroll.
- **Layout map (placeholders first)**: Dual displays with 8 soft buttons on top, 8 screen knobs below, 4D encoder + master/volume knob cluster and nav buttons between displays, transport cluster bottom-left, left column for mode buttons (Scene/Pattern/Events/Variation/Duplicate/Select/Mute/Solo) plus Shift, right column for touch strip + pad mode buttons (Keyboard/Chord/Step/Note Repeat), 4Ã—4 pads on the right, performance LEDs, and a small meter/pad bank indicator row.
- **Button symbols + hover hints**: Use consistent symbols and `title`/tooltip hints on every control. Proposed symbols: Play â–¶, Stop â– , Rec â—, Restart â†», Loop âŸ³, Count-In â™©, Tap Tempo â˜¼, Metronome â™¬, Follow â‡¥, Pad Bank â—ª, Duplicate â§‰, Select â˜, Mute ğŸ”‡, Solo âš¡, Scene â–¤, Pattern â–¦, Events âœ±, Variation â‰ˆ, Keyboard âŒ¨, Chords â™«, Step â—«, Note Repeat âœº, Shift â‡§, 4D encoder arrows â†•â†”, Touch Strip â‰¡.
- **Placeholder components to scaffold**: `DualDisplayPlaceholder` (dual LCD mock with soft-label text), `SoftButtonStripPlaceholder`, `ScreenKnobRingPlaceholder` (shows detents + hover hint), `FourDEncoderPlaceholder`, `TransportClusterPlaceholder`, `ModeColumnPlaceholder`, `TouchStripPlaceholder`, `PadBankIndicator`, `PerformanceMeterPlaceholder`, `OverlayHint` (hover helper for any element), and `DrawerPanelFrame` with fixed height for scroll containment.
- **Interaction & hover behavior**: Every element should expose a hover hint describing primary + shift-layer functions; knobs/buttons trigger placeholder overlays that can later be wired to real handlers. Touching/hovering a screen knob opens a selector overlay mock; encoder hover shows navigation arrows + confirm hint; transport buttons expose play/stop/reset semantics.
- **Sizing refactor plan**: Reduce outer gutters, use CSS `clamp()` for hardware widths/heights, pin pad square to max 640px with responsive shrink, align display + knob rows to match MK3 proportions, and keep drawers at a fixed height (e.g., 360px) with internal scroll so the main stage never scrolls.

## Setup

```bash
npm install
npm run dev
# QA
npm run lint
npm run typecheck
```

To override the dev or HMR port, prefix the command with the env vars you need:
```bash
PORT=3001 HMR_PORT=24679 npm run dev
```

## Use Cases

- Build and rehearse drum patterns live: tap pads, quantized record hits, and loop transport with velocity cycling and pad focus for performance.
- Arrange song ideas with scenes and pattern chains: switch patterns at bar boundaries and normalize grid specs when divisions change.
- Customize soundbanks: swap pad samples from local files, persist banks/patterns in IndexedDB/LocalStorage, and rehydrate blobs on load.
- Connect hardware: map pads and transport to MIDI notes, follow or drive MIDI clock, and probe WebMIDI/Audio input capabilities in the UI.
- Export mixes or stems: bounce the current scene chain to WAV/ZIP with deterministic FX seeds and optional per-pad stems for downstream DAWs.
- Normalize/import assets: round-trip patterns via JSON/MIDI, import/export soundbank manifests + blobs, and clamp malformed payloads.

## Features

- Lookahead Web Audio scheduler with AudioContext time, quantized live recording, and 16-pad grid sequencing.
- Default kit served from `public/samples` and auto-loaded into the audio engine; patterns persist via LocalStorage (v1 schema with normalization).
- Pinia stores for transport, patterns/scenes, session caps, and soundbanks; composables for audio, scheduler, sequencer, MIDI, sync, import/export, audio input, and IndexedDB soundbank storage (banks, samples, patterns).
- Client-only MIDI hooks with device selection, pad mapping, and MIDI clock support (master/slave) plus Ableton Link stub exposure via sync panel.
- Soundbank manager can select banks and replace pad samples (stored as blobs in IndexedDB) with lazy decoding; patterns also persisted per-bank in IDB.
- Configurable step grid divisions (1/2/4/8/16/32/64) with responsive layout for larger sequences and stable transport start/stop handling.
- Import/Export helpers for patterns, MIDI (@tonejs/midi), soundbank manifests + sample blobs, and WAV bounce via OfflineAudioContext.
- Scene chains with bar-boundary pattern switching, per-step velocity/accent cycling, and an FX chain (filter/drive/reverb) routed through the WebAudio graph.

## Integrated Browser

- Local file access via the File System Access API (with a safe memory fallback when unsupported or denied).
- Hierarchical filters (Category â†’ Product â†’ Bank â†’ SubBank), favorites, recents, and quick-browse restore.
- 4D encoder integration for field navigation, filter edits, and tag management without new UI controls.
- Preview (prehear) playback for selected items using the shared AudioContext.
- Sort modes, import progress tracking, and list virtualization for large libraries.

## Control Area (MK3)

- Pinia store `stores/control.ts` owns modes, per-mode pages, soft buttons, encoder parameters, and display models; DrumMachine wires it without changing layout.
- Mode buttons fire primary and SHIFT secondary actions (e.g., CHANNELâ†’MIDI, PLUGINâ†’Instance, BROWSERâ†’Plug-in menu, FILEâ†’Save As, MACROâ†’Set). Page â—€/â–¶ steps through pages within the active mode.
- SoftButtonStrip renders 8 dynamic labels/tooltips per page and emits press events; display soft labels mirror the current soft buttons.
- DualDisplay renders contextual panels for Browser, File, Settings, Sampling, Mixer, Arranger, and info views; header shows mode + page.
- Encoders react to mousewheel on hover and arrow keys; SHIFT enables fine step. SHIFT hold is de-latched via global pointer/key listeners; knobs expose tabindex + aria-label.

## Analysis & Plan

- **Current gaps**: Pattern/scene editing UIs are not mounted on `pages/index.vue`; transport lacks full MK3 semantics; placeholder overlays for soft buttons/encoders/4D are not wired; accessibility coverage is partial.
- **To close parity**: Restore sequencer UI (StepGrid/StepCell) and mount Patterns/Export/TabPanel; bring transport to MK3 semantics (play/stop toggle, stop-reset, restart, count-in, tap tempo, follow/metronome controls, loop range adjust); add grid/loop UX and erase panels; surface channel/plug-in/macro/midi control modes with soft labels; wire selector overlays to 4D/soft buttons; ensure a11y labels and focus flows.

## Timing & Sync

- AudioContext is the sole clock authority; the lookahead scheduler, sequencer, and MIDI clock master all derive their timings from `AudioContext.currentTime`.
- A small `RenderClock` wrapper now feeds every scheduler/step planner from the shared `scheduleStep` helper so live playback and future offline renders can work off the same time basis.
- MIDI clock output follows the audio clock (scheduled via the lookahead worker); incoming MIDI clock only drives phase counters/start-stop follow and never retimes audio events.
- BPM updates are clamped and restored on sync mode/role changes to prevent drift when switching between internal and MIDI clock roles; transport BPM remains the master source.

## Workflow & UX

- Undo/redo history for pattern + scene edits (50 steps), persisted alongside scenes/pattern selection.
- Capability gates surface WebMIDI/Audio In support status directly in the UI.
- Importers normalize grid specs/velocities and soundbank manifests to handle malformed payloads more gracefully.

## Layout Notes

- Viewport locked, drawer scrolls internally.

## Browser support / limitations

- Web MIDI only over HTTPS/localhost after user permission; device lists stay empty when unsupported.
- Audio input uses `getUserMedia`; user denial disables monitoring/capture.
- AudioContext needs a user gesture before it can play in some browsers; first pad tap will resume the context.
- Background throttling can delay scheduled steps despite lookahead; keep tab focused for tight timing.

## BFCache Compatibility

- Web Audio: AudioContext is suspended on `pagehide` and resumed on `pageshow` to avoid active audio blocking BFCache restores.
- Media Input: Microphone streams and their AudioContext are stopped/closed on `pagehide`.
- MIDI: Device listeners detach on `pagehide` and reattach/refresh on `pageshow` when access is available.
- Scheduling: Lookahead intervals for sequencer/sync pause on `pagehide` and restart on `pageshow` when they were running.

## Deterministic FX & Export

- The FX chain now derives from a serializable `FxSettings` snapshot and only applies filter/drive/reverb updates via `setValueAtTime`, making the graph stable for live and rendered sessions alike.
- The convolution impulse uses the new seeded RNG helper, and the audio engine exposes `getFxSnapshot`/`setFxRandomSource` so exports can rebuild identical FX + randomness when supplied with the same seed.
- The offline WAV export now runs through the same `RenderClock` + `scheduleStep` loop as live playback, rebuilds the FX graph from the current `FxSnapshot`, and seeds the impulse response via `createSeededRandom`. `exportAudio` returns a `RenderMetadata` payload (seed, bpm, grid spec, scene/pattern chain, duration) andâ€”when `import.meta.env.DEV`â€”an optional debug timeline so the UI can attach a JSON blob alongside the WAV.
- To reproduce a bounce, pass the recorded `seed` back into `exportAudio` (or rehydrate the FX snapshot that produced it) so the same impulse response + scheduling is rebuilt; the metadata blob makes pairing the WAV with its deterministic context easy for debugging or downstream tooling.

### Export metadata UI
The Export audio card sits under the soundbank/Fx controls and invokes `exportAudio` for the current scene chain. Once the bounce finishes, the metadata panel appears below the export button and exposes the seed, BPM, grid spec, scene/pattern chain, event count, and rendered duration. Use the panel buttons to download the WAV/JSON, inspect the dev timeline (visible only in `process.dev`), or copy the seed for later replays.

### Reproducing exports with the seed
Copy the exported seed from the metadata panel (or the JSON blob) and supply it to `exportAudio(renderDuration, sampleRate, { seed: Number(seedValue) })` together with the scene's FX snapshot/grid spec, and the offline render will replay the exact same randomness, FX response, and scheduling that produced the mixdown.

## Recent Fixes / Stability & Diagrams

- PadGrid: Removed stray `button.pad-cell`; focus restore now uses stable PadCell refs to avoid runtime errors.
- TransportEngine: Scheduler is cleared/reseeded on config changes; step boundaries use absolute steps with wrap guards so tempo/division changes do not produce double/missed triggers.
- Docs: Mermaid diagrams fixed (valid IDs/arrows, GitHub-compatible).

## Feature Branch Changes (fix/padgrid-transport-scheduler-and-diagrams)

- Slot-based DrumMachine hardware with separate slots for transport, pads, and drawer; index layout slimmed down to `v-app` + slots.
- PadGrid refactor: per-cell pad refs, new keyboard navigation, and key labels introduced (currently not rendered).
- Drawer/panel stack re-ordered (Sound/FX/Patterns/Export), TransportBar styled with BPM/Division/Loop controls, global color/spacing variables and Nuxt global styles added.
- MIDI layer streamlined: mapping/learn persisted, simpler MIDI status access, layout metadata cleaned up.
- Sequencer components (`StepGrid.vue`, `StepCell.vue`) removed from the build; only Markdown stubs remain, so the UI currently renders pads/transport/FX only.

## Diagrams

- Transport timing: `diagrams/transport-engine.md`
- UI sequencer flow: `diagrams/ui-sequencer.md`
- Persistence + audio pipeline: `diagrams/persistence-and-audio.md`
- Control area mapping: `diagrams/control-area-mapping.md`
- Browser 4D encoder wiring: `diagrams/control-4d-encoder-browser.md`
- Browser file system access: `diagrams/browser-file-system-access.md`
- Browser import progress: `diagrams/library-import-progress.md`
- Browser recent files: `diagrams/recent-files.md`
- Browser favorites: `diagrams/favorites-flow.md`
- Browser sample preview: `diagrams/sample-preview.md`
- Browser sorting: `diagrams/browser-sorting.md`
- Browser quick-browse: `diagrams/quick-browse.md`
- Browser tag dialog: `diagrams/tag-dialog.md`
- Browser hierarchy: `diagrams/library-hierarchy.md`
- Browser performance: `diagrams/browser-performance.md`

## Current UI / Editing State

- 16-pad surface shows three states (selected, currently triggered at the playhead, or playing anywhere in the pattern) and derives pad labels from the active soundbank.
- Step toggles cycle velocity levels 0.7 â†’ 1.0 â†’ 1.25 â†’ off; accents (>=1.25) are tinted in the grid, and the playhead overlay tracks the normalized step even when looping.
- Patterns + scenes are stored in LocalStorage (v2 schema with selected/active ids) and a 50-step undo/redo history guards edits; scene playback always prepares the first scene pattern before transport start or external sync start.
- Scene chains advance at pattern boundaries and honor normalized grid specs when divisions change, so transport + sequencer stay aligned.

## Soundbanks & Persistence

- A default kit seeds four kicks/snares/hihats/claps across 16 pads; if no banks exist on load the bank is saved to IndexedDB and selected automatically.
- Soundbanks, samples (blobs), and per-bank pattern copies are persisted to IndexedDB (v2 database with soundbanks/samples/patterns stores); samples are rehydrated from blobs on load.
- Replacing a pad sample infers the format from the filename, revokes old blob URLs, updates the sequencer in place, and writes both the bank metadata and the blob to IDB.
- Soundbank import/export supports manifest JSON + sample files; pad assignments are hydrated against the manifest ids so banks can round-trip with external files.

## Import/Export Surface

- Pattern JSON import/export + MIDI import/export (tonejs/midi) are wired through `useImportExport`; MIDI uses the current mapping and pulls velocity into step velocities.
- Offline export now optionally renders per-pad stems (only for pads that have a sample in the current cache) alongside the mixdown; stem file names are slugged from the scene/bank name.
- `exportAudio` auto-downloads the mixdown WAV, returns metadata + optional debug timeline, and the Export panel exposes buttons for WAV, ZIP bundle (mixdown + render-meta + stems), or individual/all stems.
- Export duration is derived from the active scene's pattern chain (bars Ã— division) so renders match the current arrangement at the time you press Export.

## Roadmap

- Stabilize transport scheduling: normalize queued step indices across loops, clear/reseed scheduler queues on config changes, and extend tests for swing + lookahead edge cases.
- Fix PadGrid focus/activation: remove the stray root button or wire it correctly, attach `ref`s to `PadCell` for focus restoration, and add keyboard-focus tests.
- Expand automated coverage: integrate component tests for `PadGrid`/`StepGrid` interactions and regression tests around transport start/stop/reconfigure flows.
- UX polish: expose scheduler/debug timelines in dev mode, improve empty-state messaging for pads without a selected bank/pad, and add ARIA labels around sequencing controls.
- Stretch: FX chain enhancements (filter/drive) and an extended sample browser with drag/drop and manifest previews.

## Code Review Findings (2026-01-04)

- `pages/index.vue`: Main slot renders a blank placeholder and mounts only transport/pads/FX; there is no scaffold for displays, soft buttons, encoder, mode clusters, touch strip, or hover hints, so MK3 parity cannot be reached without adding new slots/components.
- `components/DrumMachine.vue`: The hardware shell is fixed to a two-column transport+drawer vs. pads layout with clamped widths; adding the MK3 top displays, left/right button columns, and touch strip would currently overflow and reintroduce page scroll. Needs a size refactor and new placeholder regions.
- `components/TransportBar.vue`: Transport buttons rely solely on icons, have no hover hints/tooltips, and miss MK3 semantics (play/stop toggle, stop-reset, shift+rec count-in, restart). The dense vertical stack will not fit once displays/soft buttons are added.
- `components/PadGrid.vue`: Pads expose neither tooltips nor pad labels/LED hints in the UI. `is-empty` derives from missing pad state rather than sample presence, so freshly loaded banks render as â€œemptyâ€ even when defaults exist.
- `components/PadGrid.vue`: KEY_LABELS are hard-coded to 16 entries; any future pad bank paging or alternate pad counts will desync labels and navigation unless the labels derive from the pads prop.

## Hardware Layout & UI Reference

### PadGrid (4Ã—4)
- 16 pads in a 4Ã—4 grid (pad1â€“pad16) with distinct states for selected, triggered (current step), and playing. Each PadCell is a native button.
- Accessibility: `aria-label` per pad, `aria-rowcount`/`aria-colcount`/`aria-rowindex`/`aria-colindex`, and `tabindex` in pad order; focus refs support keyboard focus moves. The pattern indicator sits next to the grid.

### Mode Buttons (left of PadGrid)
- Vertical stack of 8 mode buttons; sized to align with pad heights and the Softbutton 4 reference line above Display 1. Buttons expose `aria-label`/`title` and keyboard focus.

### Fixed Velocity + Pad Mode (top row)
- Fixed Velocity plus PAD MODE/KEYBOARD/CHORD/STEP row aligned to the Softbutton row above Display 2 as the horizontal reference.

### Softbutton references
- Softbutton 4 above Display 1 defines the vertical alignment line for the mode column. The softbutton row above Display 2 defines the horizontal reference for Fixed Velocity and Pad Mode buttons (see `diagrams/padgrid-modus-layout.md`).

### Accessibility
- PadGrid: ARIA grid metadata, labels, and focusable buttons.
- Mode/Pad-Mode/Fixed-Velocity buttons: native button semantics with labels/titles and consistent tab order.
- Softbuttons remain labeled reference points for screen readers to understand spatial layout.

### TransportBar
- Standalone transport/pattern/step control component. Props include `bpm`, `division`/`divisions`, `loop`, `patternBars`, `presetBars`/`presetDivision`, `selectedPad`, and flags (`isPlaying`, `isRecording`, `countInEnabled`, `metronomeEnabled`, `followEnabled`, `liveEraseEnabled`).
- Events cover transport (play/stop/stop-reset/restart), tempo (`update-bpm`, `increment-bpm`, `decrement-bpm`, `tap-tempo`), grid (`update-division`, `update-pattern-bars`, `update:preset-*`), loop (`update-loop`, `nudge-loop-range`, `update-loop-start`, `update-loop-end`), metronome/follow (`toggle-metronome`, `update:metronome-volume`, `toggle-follow`), count-in (`toggle-count-in`, `update-count-in-bars`), MIDI learn, and live erase (`toggle-live-erase`, `erase-pad`, `erase-current-step`). Buttons use native semantics plus `aria-label`/`title` for a11y/tooltips.

### Diagram
- Layout visualization with reference lines for dual displays, softbutton rows, mode column, Fixed Velocity/Pad Mode row, and PadGrid: see `diagrams/padgrid-modus-layout.md`.



=========================================
File: StepCell.md
=========================================

```vue
<template lang="pug">
  client-only(tag="div")
    button.step-cell(
      type="button",
      :class="cellClasses",
      :aria-pressed="isActive",
      @click="onToggle",
      @pointerdown="onPointerDown",
      @pointermove="onPointerMove",
      @pointerup="onPointerUp",
      @pointercancel="onPointerCancel",
      )
      span.step-tag {{ displayLabel }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'StepCell',

  props: {
    isAccent: {
      type: Boolean,
      required: false,
      default: false
    },
    isActive: {
      type: Boolean,
      required: false,
      default: false
    },
    isCurrent: {
      type: Boolean,
      required: false,
      default: false
    },
    displayLabel: {
      type: String,
      required: false,
      default: ''
    }
  },

    emits: [
    'cell:toggle',
    'cell:pointerdown',
    'cell:pointermove',
    'cell:pointerup',
    'cell:pointercancel'
  ],
  
  computed: {
    cellClasses(): Record<string, boolean> {
      return {
        'is-active': this.isActive,
        'is-accent': this.isAccent,
        'is-current': this.isCurrent
      }
    }
  },
  methods: {
    onToggle(): void {
      this.$emit('cell:toggle')
    },
    onPointerDown(event: PointerEvent): void {
      if (event.currentTarget instanceof HTMLElement) {
        event.currentTarget.setPointerCapture(event.pointerId)
      }
      this.$emit('cell:pointerdown', event)
    },
    onPointerMove(event: PointerEvent): void {
      this.$emit('cell:pointermove', event)
    },
    onPointerUp(event: PointerEvent): void {
      this.$emit('cell:pointerup', event)
    },
    onPointerCancel(event: PointerEvent): void {
      this.$emit('cell:pointercancel', event)
    }
  }
})
</script>

<style lang="less" scoped>
@import '@/styles/variables.less';
.step-cell {
  border: none;
  border-radius: @radius-s;
  background: fade(@color-accent-primary, 15%);
  color: @color-text-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: @font-size-xs;
  padding: @space-xs 0;
  transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
  position: relative;
  cursor: pointer;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  z-index: 1;

  &:not(.is-active):hover {
    background: fade(@color-accent-primary, 25%);
  }

  &:active {
    transform: scale(0.97);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px fade(@color-accent-primary, 60%);
  }

  &.is-active {
    background: fade(@color-accent-primary, 15%);
  }

  &.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 25%),
      fade(@color-accent-warning, 65%)
    );
  }

  &.is-active.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 35%),
      fade(@color-accent-primary, 35%)
    );
  }

  &.is-current {
    box-shadow: inset 0 0 0 2px fade(@color-accent-primary, 90%);
  }

  &.is-accent.is-current {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
    animation: accent-scan-pulse 160ms ease-out 1;
  }
}

.step-tag {
  font-size: @font-size-xs;
  letter-spacing: @letter-spacing-tight;
}

@keyframes accent-scan-pulse {
  from {
    transform: scale(1.02);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 95%),
      0 0 16px fade(@color-accent-warning, 38%);
  }
  to {
    transform: scale(1);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
  }
}
</style>
```


=========================================
File: StepGrid.md
=========================================

```vue
<template lang="pug">
  client-only(tag="div")
    .step-grid-shell(
      role="grid"
      :aria-label="stepGridLabel"
      :aria-colcount="totalSteps"
      tabindex="0"
      @keydown="onKeydown"
      ref="shell"
    )
      .step-row(role="row")
        StepCell(
          v-for="stepIndex in totalSteps"
          :key="stepIndex"
          :display-label="String(stepIndex)"
          :is-active="isActive(stepIndex - 1)"
          :is-accent="isAccent(stepIndex - 1)"
          :is-current="isCurrent(stepIndex - 1)"
          :class="{ 'is-pattern-start': isPatternStart(stepIndex - 1) }"
          role="gridcell"
          :aria-label="cellAriaLabel(stepIndex - 1)"
          :aria-selected="isActive(stepIndex - 1)"
          @cell:toggle="emitToggle(stepIndex - 1)"
          @cell:pointerdown="onCellPointerDown(stepIndex - 1, $event)"
          @cell:pointermove="onCellPointerMove($event)"
          @cell:pointerup="onCellPointerUp($event)"
          @cell:pointercancel="onCellPointerCancel($event)"
        )
        div.pattern-boundary(
          v-for="boundary in patternBoundaries"
          :key="boundary"
          :style="boundaryStyle(boundary)"
        )
        PlayheadOverlay(
          v-if="totalSteps > 0"
          :current-step="currentStepNormalized"
          :total-steps="totalSteps"
          :is-playing="isPlaying"
        )
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import StepCell from './StepCell.vue'
import PlayheadOverlay from './PlayheadOverlay.vue'
import type { GridSpec } from '@/types/time'
import type { DrumPadId, StepGrid } from '@/types/drums'
import { ACCENT_STEP_VELOCITY, clampVelocity } from '@/domain/velocity'

export default defineComponent({
  name: 'StepGrid',
  components: {
    StepCell,
    PlayheadOverlay
  },
  props: {
    gridSpec: { type: Object as () => GridSpec, required: true },
    steps: { type: Object as () => StepGrid, required: true },
    patternChain: {
      type: Array as () => Array<{ id: string; bars: number }> | null,
      default: null
    },
    selectedPad: { type: String as () => DrumPadId | null, default: null },
    currentStep: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true }
  },
  emits: ['step:toggle', 'playhead:scrub', 'step:velocity'],
  data() {
    return {
      dragState: null as null | {
        pointerId: number
        startY: number
        startVelocity: number
        stepIndex: number
      }
    }
  },
  computed: {
    totalSteps(): number {
      return Math.max(0, this.gridSpec.bars * this.gridSpec.division)
    },
    currentStepNormalized(): number {
      const steps = Math.max(this.totalSteps, 1)
      return ((this.currentStep % steps) + steps) % steps
    },
    stepGridLabel(): string {
      return this.selectedPad ? `Steps for ${this.selectedPad}` : 'Step grid'
    },
    patternBoundaries(): number[] {
      if (!this.patternChain || this.patternChain.length === 0) {
        return []
      }

      const boundaries: number[] = []
      const stepsPerBar = this.gridSpec.division
      let cumulative = 0

      this.patternChain.forEach((entry, index) => {
        cumulative += entry.bars * stepsPerBar
        if (index === this.patternChain!.length - 1) {
          return
        }
        if (cumulative < this.totalSteps) {
          boundaries.push(cumulative)
        }
      })

      return boundaries
    }
  },
  methods: {
    focusGrid(): void {
      const el = this.$refs.shell as HTMLElement | undefined
      el?.focus()
    },
    resolveStepPosition(index: number): { barIndex: number; stepInBar: number } {
      const barIndex = Math.floor(index / this.gridSpec.division)
      const stepInBar = index % this.gridSpec.division
      return { barIndex, stepInBar }
    },

    emitToggle(index: number): void {
      if (!this.selectedPad) {
        return
      }

      const { barIndex, stepInBar } = this.resolveStepPosition(index)

      this.$emit('step:toggle', {
        barIndex,
        stepInBar,
        padId: this.selectedPad
      })
    },

    velocityAt(index: number): number | null {
      if (!this.selectedPad) {
        return null
      }

      const { barIndex, stepInBar } = this.resolveStepPosition(index)

      return (
        this.steps[barIndex]?.[stepInBar]?.[this.selectedPad]?.velocity?.value ??
        null
      )
    },

    isActive(index: number): boolean {
      return this.velocityAt(index) !== null
    },

    isAccent(index: number): boolean {
      const velocity = this.velocityAt(index)
      const ACCENT_EPSILON = 0.01

      return (
        velocity !== null &&
        velocity >= ACCENT_STEP_VELOCITY - ACCENT_EPSILON
      )
    },

    isCurrent(index: number): boolean {
      return index === this.currentStepNormalized
    },

    onKeydown(event: KeyboardEvent): void {
      if (this.totalSteps <= 0) {
        return
      }

      const isArrowLeft = event.key === 'ArrowLeft'
      const isArrowRight = event.key === 'ArrowRight'

      if (!isArrowLeft && !isArrowRight) {
        return
      }

      event.preventDefault()

      const stepDelta = event.shiftKey ? this.gridSpec.division : 1
      const delta = isArrowLeft ? -stepDelta : stepDelta
      const steps = this.totalSteps
      const nextStep =
        ((this.currentStepNormalized + delta) % steps + steps) % steps

      this.$emit('playhead:scrub', { stepIndex: nextStep })
    },

    emitVelocity(index: number, velocity: number): void {
      if (!this.selectedPad) {
        return
      }
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      this.$emit('step:velocity', {
        barIndex,
        stepInBar,
        padId: this.selectedPad,
        velocity
      })
    },

    onCellPointerDown(index: number, event: PointerEvent): void {
      if (!this.selectedPad) {
        return
      }
      const startVelocity = this.velocityAt(index)
      if (startVelocity === null) {
        return
      }

      this.dragState = {
        pointerId: event.pointerId,
        startY: event.clientY,
        startVelocity,
        stepIndex: index
      }
    },

    onCellPointerMove(event: PointerEvent): void {
      if (!this.dragState || event.pointerId !== this.dragState.pointerId) {
        return
      }
      const deltaY = this.dragState.startY - event.clientY
      const VELOCITY_PER_PIXEL = 0.006
      const nextVelocity = clampVelocity(
        this.dragState.startVelocity + deltaY * VELOCITY_PER_PIXEL
      )
      this.emitVelocity(this.dragState.stepIndex, nextVelocity)
    },

    onCellPointerUp(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },

    onCellPointerCancel(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },

    cellAriaLabel(index: number): string {
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      const stepNumber = stepInBar + 1
      const barNumber = barIndex + 1
      const activeState = this.isActive(index) ? 'active' : 'inactive'
      return `Bar ${barNumber}, step ${stepNumber}, ${activeState}`
    },

    isPatternStart(index: number): boolean {
      if (!this.patternChain || this.patternChain.length === 0) {
        return false
      }
      if (index === 0) {
        return true
      }
      return this.patternBoundaries.includes(index)
    },

    boundaryStyle(startIndex: number): Record<string, string> {
      const leftPercent =
        this.totalSteps > 0 ? (startIndex / this.totalSteps) * 100 : 0
      return {
        left: `${leftPercent}%`
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.step-grid-shell {
  margin-top: 0;
  padding: 10px;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  position: relative;
  height: 100%;
  max-height: 96px;
  overflow: visible;
}

.step-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
  gap: 8px;
  position: relative;
  overflow: visible;

  >.playhead-overlay {
    pointer-events: none;
    z-index: 0;
  }

  >.step-cell {
    z-index: 1;
  }

  >.step-cell:nth-child(4n + 1) {
    border-left: 2px solid rgba(255, 255, 255, 0.12);
    padding-left: 12px;
  }

  >.step-cell.is-pattern-start {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-primary, 45%),
      0 0 10px fade(@color-accent-primary, 16%);
  }
}

.pattern-boundary {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  margin-left: -1px;
  background: linear-gradient(
    to bottom,
    fade(@color-accent-primary, 0%) 0%,
    fade(@color-accent-primary, 28%) 45%,
    fade(@color-accent-primary, 8%) 100%
  );
  pointer-events: none;
  z-index: 0;
}

@media (max-height: 820px) {
  .step-grid-shell {
    max-height: 88px;
    padding: 8px;
  }
}

@media (max-width: 640px) {
  .step-grid-shell {
    padding: 8px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(44px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 44px;
    padding: 10px 0;
    font-size: @font-size-xs;
  }
}

@media (max-width: 480px) {
  .step-grid-shell {
    padding: 6px;
    max-height: 80px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(48px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 48px;
    padding: 12px 0;
  }
}
</style>
```


=========================================
File: _archive/composables_dupes/useAudioEngine.client 2.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import type { DrumPadId } from '~/types/drums'
import type { SampleRef, Soundbank } from '~/types/audio'

interface TriggerRequest {
  padId: DrumPadId
  when: number
  velocity?: number
}

export function useAudioEngine() {
  const audioContext = ref<AudioContext | null>(null)
  const masterGain = ref<GainNode | null>(null)
  const sampleCache = ref<Map<DrumPadId, AudioBuffer>>(new Map())

  const ensureContext = () => {
    if (!audioContext.value) {
      const context = new AudioContext()
      const gain = context.createGain()
      gain.gain.value = 0.8
      gain.connect(context.destination)
      audioContext.value = context
      masterGain.value = gain
    }
    if (audioContext.value.state === 'suspended') {
      void audioContext.value.resume()
    }
    return audioContext.value as AudioContext
  }

  const decodeSample = async (sample: SampleRef): Promise<AudioBuffer | null> => {
    const ctx = ensureContext()
    if (!sample.url) {
      return sample.buffer ?? null
    }
    const response = await fetch(sample.url)
    const arrayBuffer = await response.arrayBuffer()
    const buffer = await ctx.decodeAudioData(arrayBuffer)
    return buffer
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    const buffer = sample.buffer ?? (await decodeSample(sample))
    if (buffer) {
      sampleCache.value.set(padId, buffer)
    }
  }

  const applySoundbank = async (bank: Soundbank) => {
    const entries = Object.entries(bank.pads)
    await Promise.all(
      entries.map(async ([padId, sample]) => {
        if (sample) {
          await setSampleForPad(padId as DrumPadId, sample)
        }
      })
    )
  }

  const trigger = async ({ padId, when, velocity = 1 }: TriggerRequest) => {
    const ctx = ensureContext()
    const buffer = sampleCache.value.get(padId) ?? null
    if (!buffer) {
      return
    }
    const source = ctx.createBufferSource()
    source.buffer = buffer
    const gain = ctx.createGain()
    gain.gain.value = velocity
    source.connect(gain)
    gain.connect(masterGain.value ?? ctx.destination)
    source.start(when)
  }

  onBeforeUnmount(() => {
    audioContext.value?.close()
    sampleCache.value.clear()
  })

  return {
    audioContext,
    masterGain,
    sampleCache,
    ensureContext,
    decodeSample,
    applySoundbank,
    setSampleForPad,
    trigger
  }
}



=========================================
File: _archive/composables_dupes/useImportExport.client 2.ts
=========================================

import { saveAs } from 'file-saver'
import type { Pattern } from '~/types/drums'
import type { MidiFileData } from '~/types/midi'

const encoderHeader = 'Drumcomputer Pattern Export'

export function useImportExport() {
  const exportPattern = (pattern: Pattern) => {
    const blob = new Blob([JSON.stringify(pattern, null, 2)], { type: 'application/json' })
    saveAs(blob, `${pattern.name}.json`)
  }

  const importPattern = async (file: File): Promise<Pattern> => {
    const text = await file.text()
    const parsed = JSON.parse(text) as Pattern
    return parsed
  }

  const exportMidi = (data: MidiFileData) => {
    const blob = new Blob([encoderHeader, JSON.stringify(data)], { type: 'application/json' })
    saveAs(blob, 'sequence.mid.json')
  }

  const exportAudio = (buffer: ArrayBuffer) => {
    const blob = new Blob([buffer], { type: 'audio/wav' })
    saveAs(blob, 'mixdown.wav')
  }

  return {
    exportPattern,
    importPattern,
    exportMidi,
    exportAudio
  }
}



=========================================
File: _archive/composables_dupes/useMidi.client 2.ts
=========================================

import { ref } from 'vue'
import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '~/types/midi'
import { defaultMidiMapping } from '~/domain/midiMapping'

export function useMidi() {
  const access = ref<MIDIAccess | null>(null)
  const inputs = ref<MidiDeviceInfo[]>([])
  const outputs = ref<MidiDeviceInfo[]>([])
  const mapping = ref<MidiMapping>(defaultMidiMapping())

  const supportsMidi = () => typeof navigator !== 'undefined' && Boolean((navigator as Navigator).requestMIDIAccess)

  const refreshDevices = () => {
    if (!access.value) return
    inputs.value = Array.from(access.value.inputs.values()).map((device: MIDIInput) => ({
      id: device.id,
      name: device.name ?? 'MIDI In',
      type: 'input'
    }))
    outputs.value = Array.from(access.value.outputs.values()).map((device: MIDIOutput) => ({
      id: device.id,
      name: device.name ?? 'MIDI Out',
      type: 'output'
    }))
  }

  const requestAccess = async () => {
    if (!supportsMidi()) {
      return
    }
    access.value = await (navigator as Navigator).requestMIDIAccess({ sysex: false })
    refreshDevices()
  }

  const listen = (cb: (message: MidiMessage) => void) => {
    access.value?.inputs.forEach((input: MIDIInput) => {
      input.onmidimessage = (event: MIDIMessageEvent) => {
        if (!event.data || event.data.length < 3) return
        const status = event.data[0]
        const data1 = event.data[1]
        const data2 = event.data[2]
        if (status === undefined || data1 === undefined || data2 === undefined) return

        const type = status & 0xf0
        if (type === 0x90 && data2 > 0) {
          cb({ type: 'noteon', note: data1, velocity: data2 / 127 })
        } else if (type === 0x80 || (type === 0x90 && data2 === 0)) {
          cb({ type: 'noteoff', note: data1, velocity: data2 / 127 })
        } else if (status === 0xf8) {
          cb({ type: 'clock' })
        } else if (status === 0xfa) {
          cb({ type: 'start' })
        } else if (status === 0xfc) {
          cb({ type: 'stop' })
        }
      }
    })
  }

  const send = (deviceId: string, message: MidiMessage) => {
    const output = access.value?.outputs.get(deviceId)
    if (!output) return
    switch (message.type) {
      case 'noteon':
        output.send([0x90, message.note ?? 0, Math.floor((message.velocity ?? 1) * 127)])
        break
      case 'noteoff':
        output.send([0x80, message.note ?? 0, 0])
        break
      case 'start':
        output.send([0xfa])
        break
      case 'stop':
        output.send([0xfc])
        break
      case 'clock':
        output.send([0xf8])
        break
      default:
        break
    }
  }

  const mapNoteToPad = (note: number) => mapping.value.noteMap[note]

  return {
    access,
    inputs,
    outputs,
    mapping,
    supportsMidi,
    requestAccess,
    refreshDevices,
    listen,
    send,
    mapNoteToPad
  }
}



=========================================
File: _archive/composables_dupes/useSequencer 2.ts
=========================================

import { ref } from 'vue'
import { quantizeToStep } from '~/domain/quantize'
import { normalizeGridSpec, secondsPerStep } from '~/domain/timing'
import type { DrumPadId, Pattern } from '~/types/drums'
import type { SampleRef, Soundbank } from '~/types/audio'
import type { GridSpec, StepAddress } from '~/types/time'
import { useTransportStore } from '~/stores/transport'
import { useScheduler } from './useScheduler'
import { useAudioEngine } from './useAudioEngine.client'

interface SequencerOptions {
  getPattern: () => Pattern
  lookahead?: number
  scheduleAheadSec?: number
}

interface ScheduledStep {
  when: number
  stepAddress: StepAddress
}

export function useSequencer(options: SequencerOptions) {
  const transport = useTransportStore()
  const audio = useAudioEngine()
  const scheduler = useScheduler({
    lookahead: options.lookahead ?? 25,
    scheduleAheadSec: options.scheduleAheadSec ?? 0.1,
    getTime: () => audio.ensureContext().currentTime
  })

  const currentStep = ref(0)
  const isRecording = ref(false)
  const pendingSteps = ref<ScheduledStep[]>([])
  let loopStartTime = 0

  const totalStepsForGrid = (gridSpec: GridSpec) => gridSpec.bars * gridSpec.division

  const scheduleStep = (when: number) => {
    const pattern = options.getPattern()
    const totalSteps = totalStepsForGrid(pattern.gridSpec)
    const stepIndex = currentStep.value % totalSteps
    const barIndex = Math.floor(stepIndex / pattern.gridSpec.division)
    const stepInBar = stepIndex % pattern.gridSpec.division
    pendingSteps.value.push({ when, stepAddress: { barIndex, stepInBar } })
    scheduler.schedule({
      when,
      callback: () => {
        playStep(pattern, when, { barIndex, stepInBar })
        currentStep.value = (currentStep.value + 1) % totalSteps
        transport.setCurrentStep(currentStep.value)
        if (transport.loop) {
          const stepDuration = secondsPerStep(transport.bpm, pattern.gridSpec.division)
          scheduleStep(when + stepDuration)
        }
      }
    })
  }

  const playStep = (pattern: Pattern, when: number, step: StepAddress) => {
    const bar = pattern.steps[step.barIndex]
    const stepRow = bar?.[step.stepInBar]
    if (!stepRow) return
    Object.entries(stepRow).forEach(([padId, cell]) => {
      audio.trigger({ padId: padId as DrumPadId, when, velocity: cell?.velocity?.value ?? 1 })
    })
  }

  const start = () => {
    if (transport.isPlaying) return
    const ctx = audio.ensureContext()
    const pattern = options.getPattern()
    const gridSpec = normalizeGridSpec(pattern.gridSpec)
    pattern.gridSpec = gridSpec
    transport.setGridSpec(gridSpec)
    loopStartTime = ctx.currentTime
    currentStep.value = 0
    pendingSteps.value = []
    transport.setCurrentStep(0)
    transport.setPlaying(true)
    scheduler.clear()
    scheduleStep(loopStartTime)
    scheduler.start()
    scheduler.tick()
  }

  const stop = () => {
    transport.setPlaying(false)
    scheduler.stop()
    scheduler.clear()
    pendingSteps.value = []
    currentStep.value = 0
    transport.setCurrentStep(0)
    loopStartTime = 0
  }

  const toggleStep = (barIndex: number, stepInBar: number, padId: DrumPadId) => {
    const pattern = options.getPattern()
    const bar = pattern.steps[barIndex] ?? {}
    const stepRow = bar[stepInBar] ?? {}
    const updated = { ...stepRow }
    if (updated[padId]) {
      delete updated[padId]
    } else {
      updated[padId] = { velocity: { value: 1 } }
    }
    pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
  }

  const recordHit = (padId: DrumPadId, velocity = 1, quantize = true) => {
    const pattern = options.getPattern()
    const ctx = audio.ensureContext()
    const gridSpec = pattern.gridSpec
    const stepDuration = secondsPerStep(transport.bpm, gridSpec.division)
    const anchor = transport.isPlaying ? loopStartTime : ctx.currentTime
    if (!transport.isPlaying) {
      loopStartTime = anchor
    }
    const sinceStart = ctx.currentTime - anchor
    const step = quantize
      ? quantizeToStep(sinceStart, stepDuration, gridSpec.bars, gridSpec.division)
      : {
          barIndex: Math.floor(currentStep.value / gridSpec.division),
          stepInBar: currentStep.value % gridSpec.division
        }
    toggleStep(step.barIndex, step.stepInBar, padId)
    audio.trigger({ padId, when: ctx.currentTime, velocity })
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    await audio.setSampleForPad(padId, sample)
  }

  const applySoundbank = async (bank: Soundbank) => {
    await audio.applySoundbank(bank)
  }

  return {
    currentStep,
    isRecording,
    pendingSteps,
    start,
    stop,
    toggleStep,
    recordHit,
    setSampleForPad,
    applySoundbank
  }
}



=========================================
File: _archive/composables_dupes/useSync.client 2.ts
=========================================

import { ref } from 'vue'
import type { SyncMode, SyncRole, SyncState } from '~/types/sync'

export function useSync(initialMode: SyncMode = 'internal') {
  const state = ref<SyncState>({ bpm: 120, phase: 0, isPlaying: false, mode: initialMode, role: 'master' })

  const setMode = (mode: SyncMode) => {
    state.value.mode = mode
  }

  const setRole = (role: SyncRole) => {
    state.value.role = role
  }

  const setPlaying = (isPlaying: boolean) => {
    state.value.isPlaying = isPlaying
  }

  const setBpm = (bpm: number) => {
    state.value.bpm = bpm
  }

  const tick = (phase: number) => {
    state.value.phase = phase
  }

  return {
    state,
    setMode,
    setRole,
    setPlaying,
    setBpm,
    tick
  }
}



=========================================
File: _archive/patches/useAudioEngine.patch
=========================================

diff --git a/composables/useAudioEngine.client.ts b/composables/useAudioEngine.client 2.ts
index 0121d6e..fbea6c1 100644
--- a/composables/useAudioEngine.client.ts
+++ b/composables/useAudioEngine.client 2.ts	
@@ -1,8 +1,6 @@
 import { onBeforeUnmount, ref } from 'vue'
-import type { DrumPadId } from '@/types/drums'
-import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
-import { createSeededRandom, type RandomSource } from '@/utils/seededRandom'
-import { createFxGraph, connectFxGraph, updateFxGraph, type FxGraphNodes } from '@/audio/fxGraph'
+import type { DrumPadId } from '~/types/drums'
+import type { SampleRef, Soundbank } from '~/types/audio'
 
 interface TriggerRequest {
   padId: DrumPadId
@@ -10,43 +8,10 @@ interface TriggerRequest {
   velocity?: number
 }
 
-const cloneFxSettings = (settings: FxSettings): FxSettings => ({
-  filter: { ...settings.filter },
-  drive: { ...settings.drive },
-  reverb: { ...settings.reverb }
-})
-
-const createAudioEngineInstance = () => {
+export function useAudioEngine() {
   const audioContext = ref<AudioContext | null>(null)
   const masterGain = ref<GainNode | null>(null)
   const sampleCache = ref<Map<DrumPadId, AudioBuffer>>(new Map())
-  const fxSettings = ref<FxSettings>({
-    filter: { enabled: true, frequency: 12000, q: 0.7 },
-    drive: { enabled: false, amount: 0.25 },
-    reverb: { enabled: false, mix: 0.15 }
-  })
-  const fxSnapshot = ref<FxSettings>(cloneFxSettings(fxSettings.value))
-  const fxGraph = ref<FxGraphNodes | null>(null)
-  let randomSource: RandomSource = createSeededRandom(0)
-  let wasRunningOnHide = false
-  let handlePageHide: (() => void) | null = null
-  let handlePageShow: (() => void) | null = null
-
-  const syncFxSnapshot = () => {
-    fxSnapshot.value = cloneFxSettings(fxSettings.value)
-    return fxSnapshot.value
-  }
-
-  const ensureFxGraph = (ctx: BaseAudioContext, snapshot: FxSettings) => {
-    if (!masterGain.value) {
-      return
-    }
-    if (!fxGraph.value) {
-      fxGraph.value = createFxGraph(ctx)
-      connectFxGraph(fxGraph.value, masterGain.value)
-    }
-    updateFxGraph(ctx, fxGraph.value, snapshot, randomSource)
-  }
 
   const ensureContext = () => {
     if (!audioContext.value) {
@@ -57,45 +22,21 @@ const createAudioEngineInstance = () => {
       audioContext.value = context
       masterGain.value = gain
     }
-    ensureFxGraph(audioContext.value as BaseAudioContext, fxSnapshot.value)
-    return audioContext.value as AudioContext
-  }
-
-  const resumeContext = async () => {
-    const ctx = ensureContext()
-    if (ctx.state === 'suspended') {
-      await ctx.resume()
-    }
-    return ctx
-  }
-
-  const getFxSnapshot = () => cloneFxSettings(fxSnapshot.value)
-
-  const setFxRandomSource = (source: RandomSource) => {
-    randomSource = source
-    if (fxGraph.value?.reverbNode) {
-      fxGraph.value.reverbNode.buffer = null
-    }
-    if (audioContext.value) {
-      ensureFxGraph(audioContext.value, fxSnapshot.value)
+    if (audioContext.value.state === 'suspended') {
+      void audioContext.value.resume()
     }
+    return audioContext.value as AudioContext
   }
 
   const decodeSample = async (sample: SampleRef): Promise<AudioBuffer | null> => {
     const ctx = ensureContext()
-    if (sample.buffer) {
-      return sample.buffer
-    }
-    if (sample.blob) {
-      const arrayBuffer = await sample.blob.arrayBuffer()
-      return ctx.decodeAudioData(arrayBuffer.slice(0))
+    if (!sample.url) {
+      return sample.buffer ?? null
     }
-    if (sample.url) {
-      const response = await fetch(sample.url)
-      const arrayBuffer = await response.arrayBuffer()
-      return ctx.decodeAudioData(arrayBuffer)
-    }
-    return null
+    const response = await fetch(sample.url)
+    const arrayBuffer = await response.arrayBuffer()
+    const buffer = await ctx.decodeAudioData(arrayBuffer)
+    return buffer
   }
 
   const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
@@ -116,17 +57,6 @@ const createAudioEngineInstance = () => {
     )
   }
 
-  const setFx = (partial: Partial<FxSettings>) => {
-    fxSettings.value = {
-      filter: { ...fxSettings.value.filter, ...(partial.filter ?? {}) },
-      drive: { ...fxSettings.value.drive, ...(partial.drive ?? {}) },
-      reverb: { ...fxSettings.value.reverb, ...(partial.reverb ?? {}) }
-    }
-    const snapshot = syncFxSnapshot()
-    const ctx = ensureContext()
-    ensureFxGraph(ctx, snapshot)
-  }
-
   const trigger = async ({ padId, when, velocity = 1 }: TriggerRequest) => {
     const ctx = ensureContext()
     const buffer = sampleCache.value.get(padId) ?? null
@@ -138,55 +68,11 @@ const createAudioEngineInstance = () => {
     const gain = ctx.createGain()
     gain.gain.value = velocity
     source.connect(gain)
-    if (fxGraph.value) {
-      gain.connect(fxGraph.value.fxInput)
-    } else {
-      gain.connect(masterGain.value ?? ctx.destination)
-    }
-    source.start(when)
-  }
-
-  const triggerClick = async (when: number, accented = false, volume = 0.12) => {
-    const ctx = ensureContext()
-    const osc = ctx.createOscillator()
-    const gain = ctx.createGain()
-    osc.type = 'square'
-    osc.frequency.value = accented ? 2200 : 1600
-    const base = Math.max(0, Math.min(1, volume))
-    gain.gain.setValueAtTime((accented ? 1.4 : 1) * base, when)
-    gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.06)
-    osc.connect(gain)
     gain.connect(masterGain.value ?? ctx.destination)
-    osc.start(when)
-    osc.stop(when + 0.08)
-  }
-
-  if (typeof window !== 'undefined') {
-    handlePageHide = () => {
-      if (audioContext.value) {
-        wasRunningOnHide = audioContext.value.state === 'running'
-        void audioContext.value.suspend().catch(() => undefined)
-      }
-    }
-
-    handlePageShow = () => {
-      if (wasRunningOnHide && audioContext.value) {
-        void audioContext.value.resume().catch(() => undefined)
-      }
-      wasRunningOnHide = false
-    }
-
-    window.addEventListener('pagehide', handlePageHide)
-    window.addEventListener('pageshow', handlePageShow)
+    source.start(when)
   }
 
   onBeforeUnmount(() => {
-    if (handlePageHide) {
-      window.removeEventListener('pagehide', handlePageHide)
-    }
-    if (handlePageShow) {
-      window.removeEventListener('pageshow', handlePageShow)
-    }
     audioContext.value?.close()
     sampleCache.value.clear()
   })
@@ -195,25 +81,10 @@ const createAudioEngineInstance = () => {
     audioContext,
     masterGain,
     sampleCache,
-    fxSettings,
     ensureContext,
-    resumeContext,
     decodeSample,
     applySoundbank,
-    setFx,
     setSampleForPad,
-    trigger,
-    triggerClick,
-    getFxSnapshot,
-    setFxRandomSource
-  }
-}
-
-let audioEngineInstance: ReturnType<typeof createAudioEngineInstance> | null = null
-
-export function useAudioEngine() {
-  if (!audioEngineInstance) {
-    audioEngineInstance = createAudioEngineInstance()
+    trigger
   }
-  return audioEngineInstance
 }



=========================================
File: _archive/patches/useImportExport.patch
=========================================

diff --git a/composables/useImportExport.client.ts b/composables/useImportExport.client 2.ts
index da2a9b0..1b1864b 100644
--- a/composables/useImportExport.client.ts
+++ b/composables/useImportExport.client 2.ts	
@@ -1,571 +1,35 @@
-import { ref } from 'vue'
 import { saveAs } from 'file-saver'
-import { Midi as MidiType } from '@tonejs/midi'
-import { defaultMidiMapping } from '@/domain/midiMapping'
-import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
-import { clampVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
-import { createRenderClock } from '@/domain/clock/renderClock'
-import { createFxGraph, connectFxGraph, updateFxGraph } from '@/audio/fxGraph'
-import { useAudioEngine } from './useAudioEngine.client'
-import { usePatternsStore } from '@/stores/patterns'
-import { useTransportStore } from '@/stores/transport'
-import { createSeededRandom } from '@/utils/seededRandom'
-import type { ScheduledTask } from './useScheduler'
-import { scheduleStep } from './useSequencer'
-import type { ScheduleStepOptions, ScheduledStep } from './useSequencer'
-import type { GridSpec } from '@/types/time'
-import type { MidiFileData, MidiMapping } from '@/types/midi'
-import type { SampleRef, Soundbank } from '@/types/audio'
-import type { RenderMetadata, RenderEvent } from '@/types/render'
-import type { DrumPadId, Pattern } from '@/types/drums'
+import type { Pattern } from '~/types/drums'
+import type { MidiFileData } from '~/types/midi'
 
-const Midi = MidiType
 const encoderHeader = 'Drumcomputer Pattern Export'
 
-const audioBufferToWav = (buffer: AudioBuffer) => {
-  const numOfChan = buffer.numberOfChannels
-  const length = buffer.length * numOfChan * 2 + 44
-  const result = new ArrayBuffer(length)
-  const view = new DataView(result)
-  let offset = 0
-
-  const writeString = (str: string) => {
-    for (let i = 0; i < str.length; i += 1) {
-      view.setUint8(offset + i, str.charCodeAt(i))
-    }
-    offset += str.length
-  }
-
-  const setUint16 = (data: number) => {
-    view.setUint16(offset, data, true)
-    offset += 2
-  }
-
-  const setUint32 = (data: number) => {
-    view.setUint32(offset, data, true)
-    offset += 4
-  }
-
-  writeString('RIFF')
-  setUint32(length - 8)
-  writeString('WAVE')
-  writeString('fmt ')
-  setUint32(16)
-  setUint16(1)
-  setUint16(numOfChan)
-  setUint32(buffer.sampleRate)
-  setUint32(buffer.sampleRate * numOfChan * 2)
-  setUint16(numOfChan * 2)
-  setUint16(16)
-  writeString('data')
-  setUint32(length - offset - 4)
-
-  const channels: Float32Array[] = []
-  for (let i = 0; i < numOfChan; i += 1) {
-    channels.push(buffer.getChannelData(i))
-  }
-
-  while (offset < length) {
-    for (let i = 0; i < numOfChan; i += 1) {
-      const channel = channels[i]
-      if (!channel) {
-        offset += 2
-        continue
-      }
-      const sampleIndex = Math.floor((offset - 44) / (2 * numOfChan))
-      const rawSample = channel[sampleIndex] ?? 0
-      const sample = Math.max(-1, Math.min(1, rawSample))
-      view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true)
-      offset += 2
-    }
-  }
-  return result
-}
-
-const normalizePattern = (pattern: Pattern): Pattern => {
-  const gridSpec: GridSpec = normalizeGridSpec(pattern.gridSpec)
-  const steps: Pattern['steps'] = {}
-  Object.entries(pattern.steps ?? {}).forEach(([barKey, barValue]) => {
-    const barIndex = Number(barKey)
-    if (Number.isNaN(barIndex)) return
-    const normalizedBar: Record<number, Partial<Record<DrumPadId, { velocity?: { value: number } }>>> = {}
-    Object.entries(barValue ?? {}).forEach(([stepKey, stepValue]) => {
-      const stepInBar = Number(stepKey)
-      if (Number.isNaN(stepInBar)) return
-      const normalizedRow: Partial<Record<DrumPadId, { velocity?: { value: number } }>> = {}
-      Object.entries(stepValue ?? {}).forEach(([padId, cell]) => {
-        if (!cell) return
-        normalizedRow[padId as DrumPadId] = {
-          velocity: { value: clampVelocity(cell.velocity?.value ?? DEFAULT_STEP_VELOCITY) }
-        }
-      })
-      if (Object.keys(normalizedRow).length > 0) {
-        normalizedBar[stepInBar] = normalizedRow
-      }
-    })
-    if (Object.keys(normalizedBar).length > 0) {
-      steps[barIndex] = normalizedBar
-    }
-  })
-  return {
-    ...pattern,
-    gridSpec,
-    steps
-  }
-}
-
-const patternFromMidi = (midi: MidiType, mapping: MidiMapping): Pattern => {
-  const gridSpec: GridSpec = { bars: 1, division: 16 }
-  const steps: Pattern['steps'] = {}
-  const track = midi.tracks[0]
-  if (!track) {
-    return normalizePattern({
-      id: 'imported-pattern',
-      name: 'Imported Pattern',
-      gridSpec,
-      steps
-    })
-  }
-  const ticksPerBeat = midi.header.ppq
-  const stepTicks = (ticksPerBeat * 4) / gridSpec.division
-  const notes = track.notes ?? []
-  interface Note {
-    midi: number
-    ticks: number
-    velocity?: number
-  }
-
-  interface Steps {
-    [barIndex: number]: {
-      [stepInBar: number]: Partial<Record<DrumPadId, { velocity?: { value: number } }>>
-    }
-  }
-
-  notes.forEach((note: Note) => {
-    const stepIndex: number = Math.round(note.ticks / stepTicks)
-    const barIndex: number = Math.floor(stepIndex / gridSpec.division)
-    const stepInBar: number = stepIndex % gridSpec.division
-    const pad: DrumPadId | undefined = mapping.noteMap[note.midi]
-    if (!pad) return
-    const bar: Steps[number] = steps[barIndex] ?? {}
-    const row: Steps[number][number] = bar[stepInBar] ?? {}
-    const velocity: number = typeof note.velocity === 'number' ? note.velocity : DEFAULT_STEP_VELOCITY
-    row[pad] = { velocity: { value: clampVelocity(velocity) } }
-    bar[stepInBar] = row
-    steps[barIndex] = bar
-  })
-  return normalizePattern({
-    id: 'imported-pattern',
-    name: track.name ?? 'Imported Pattern',
-    gridSpec,
-    steps
-  })
-}
-
 export function useImportExport() {
   const exportPattern = (pattern: Pattern) => {
-    const normalized = normalizePattern(pattern)
-    const blob = new Blob([JSON.stringify(normalized, null, 2)], { type: 'application/json' })
-    saveAs(blob, `${normalized.name}.json`)
+    const blob = new Blob([JSON.stringify(pattern, null, 2)], { type: 'application/json' })
+    saveAs(blob, `${pattern.name}.json`)
   }
 
   const importPattern = async (file: File): Promise<Pattern> => {
-    try {
-      const text = await file.text()
-      const parsed = JSON.parse(text) as Pattern
-      return normalizePattern(parsed)
-    } catch (error) {
-      console.error('Failed to import pattern', error)
-      return {
-        id: `imported-${Date.now()}`,
-        name: file.name,
-        gridSpec: { bars: 1, division: 16 },
-        steps: {}
-      }
-    }
-  }
-
-  const exportMidi = (pattern: Pattern, bpm: number, mapping: MidiMapping = defaultMidiMapping()) => {
-    if (typeof Midi === 'undefined') {
-      console.error('MIDI export is not available: Midi is undefined.')
-      return
-    }
-    const midi = new Midi()
-    midi.header.setTempo(bpm)
-    const track = midi.addTrack()
-    const ticksPerBeat = midi.header.ppq
-    const stepTicks = (ticksPerBeat * 4) / pattern.gridSpec.division
-    const totalSteps = pattern.gridSpec.bars * pattern.gridSpec.division
-    for (let i = 0; i < totalSteps; i += 1) {
-      const barIndex = Math.floor(i / pattern.gridSpec.division)
-      const stepInBar = i % pattern.gridSpec.division
-      const row = pattern.steps[barIndex]?.[stepInBar]
-      if (!row) continue
-      Object.entries(row).forEach(([padId, cell]) => {
-        const drumPad = padId as DrumPadId
-        const note = mapping.noteMapInverse?.[drumPad] ?? Object.entries(mapping.noteMap).find(([, pad]) => pad === drumPad)?.[0]
-        if (typeof note !== 'string' && typeof note !== 'number') return
-        const midiNote = typeof note === 'string' ? Number(note) : note
-        if (typeof midiNote !== 'number') return
-        track.addNote({
-          midi: midiNote,
-          time: (i * stepTicks) / ticksPerBeat,
-          duration: stepTicks / ticksPerBeat,
-          velocity: cell?.velocity?.value ?? 1
-        })
-      })
-    }
-    const midiArray = midi.toArray()
-    const midiBuffer = midiArray.buffer as ArrayBuffer
-    const blob = new Blob([midiBuffer], { type: 'audio/midi' })
-    saveAs(blob, `${pattern.name}.mid`)
-  }
-
-  const importMidi = async (file: File, mapping: MidiMapping = defaultMidiMapping()): Promise<Pattern> => {
-    if (typeof Midi === 'undefined') {
-      console.error('MIDI import is not available: Midi is undefined.')
-      return {
-        id: `imported-${Date.now()}`,
-        name: file.name,
-        gridSpec: { bars: 1, division: 16 },
-        steps: {}
-      }
-    }
-    const buffer = await file.arrayBuffer()
-    const midi = new Midi(buffer)
-    return patternFromMidi(midi, mapping)
-  }
-
-  const createScenePlaybackTracker = (patternsStore: ReturnType<typeof usePatternsStore>) => {
-    const scene = patternsStore.currentScene
-    const patternList = scene?.patternIds ?? []
-    const fallbackPattern: Pattern = patternsStore.patterns[0] ?? {
-      id: 'pattern-1',
-      name: 'Pattern 1',
-      gridSpec: { ...DEFAULT_GRID_SPEC },
-      steps: {}
-    }
-    let currentPatternId = patternList[0] ?? patternsStore.selectedPatternId ?? fallbackPattern.id
-    let scenePosition = patternList.length > 1 ? 1 : 0
-    const resolvePattern = (id: string) => patternsStore.patterns.find((pattern: Pattern) => pattern.id === id) ?? fallbackPattern
-    const getPattern = () => resolvePattern(currentPatternId)
-    const advancePattern = () => {
-      if (!scene || patternList.length === 0) {
-        return getPattern()
-      }
-      const nextId = patternList[scenePosition % patternList.length]
-      scenePosition = (scenePosition + 1) % patternList.length
-      if (nextId) {
-        currentPatternId = nextId
-      }
-      return getPattern()
-    }
-    const initialPattern = getPattern()
-    const patternChain = patternList.length > 0 ? [...patternList] : [patternsStore.selectedPatternId ?? initialPattern.id]
-    return {
-      sceneId: scene?.id ?? null,
-      patternChain,
-      initialPatternId: initialPattern.id,
-      getPattern,
-      advancePattern
-    }
-  }
-
-  const createOfflineScheduler = (limit: number, updateClock: (time: number) => void) => {
-    const tasks: ScheduledTask[] = []
-    return {
-      schedule(task: ScheduledTask) {
-        tasks.push(task)
-        tasks.sort((a, b) => a.when - b.when)
-      },
-      run() {
-        while (tasks.length > 0) {
-          const next = tasks[0]
-          if (!next || next.when > limit) break
-          tasks.shift()
-          updateClock(next.when)
-          next.callback()
-        }
-      }
-    }
+    const text = await file.text()
+    const parsed = JSON.parse(text) as Pattern
+    return parsed
   }
 
-  const hashSnapshot = (payload: string) => {
-    let hash = 0
-    for (let i = 0; i < payload.length; i += 1) {
-      hash = Math.imul(31, hash) + payload.charCodeAt(i)
-      hash >>>= 0
-    }
-    return hash.toString(36)
-  }
-
-  type StemExportFiles = Partial<Record<DrumPadId, { fileName: string; blob: Blob }>>
-
-  type ExportAudioResult = {
-    audioBlob: Blob
-    metadata: RenderMetadata
-    debugTimeline?: RenderEvent[]
-    stems?: StemExportFiles
-  }
-
-  const slugifyName = (value: string) => {
-    const cleaned = value
-      .trim()
-      .toLowerCase()
-      .replace(/[^a-z0-9]+/g, '_')
-      .replace(/^_+|_+$/g, '')
-    return cleaned || 'session'
-  }
-
-  const collectPadIdsFromPatternChain = (patternChain: string[], patternList: Pattern[]): DrumPadId[] => {
-    const padSet = new Set<DrumPadId>()
-    patternChain.forEach((patternId) => {
-      const pattern = patternList.find((entry) => entry.id === patternId)
-      if (!pattern) return
-      Object.values(pattern.steps ?? {}).forEach((bar) => {
-        Object.values(bar ?? {}).forEach((stepRow) => {
-          Object.keys(stepRow ?? {}).forEach((padId) => {
-            padSet.add(padId as DrumPadId)
-          })
-        })
-      })
-    })
-    return Array.from(padSet)
-  }
-
-  const exportAudio = async (
-    renderDurationSec: number,
-    sampleRate = 44100,
-    options: { seed?: number; stems?: boolean } = {}
-  ): Promise<ExportAudioResult> => {
-    const transport = useTransportStore()
-    const patterns = usePatternsStore()
-    const audio = useAudioEngine()
-    const duration = Math.max(0, renderDurationSec)
-    const frameCount = Math.max(1, Math.ceil(duration * sampleRate))
-    const seedValue = options.seed ?? Date.now()
-    const fxSnapshot = audio.getFxSnapshot()
-    const shouldDebug = import.meta.env?.DEV ?? false
-    const baseSampleCache = new Map(audio.sampleCache.value)
-
-    const metadataTracker = createScenePlaybackTracker(patterns)
-    const metadataPattern = metadataTracker.getPattern()
-    const initialGridSpec = normalizeGridSpec(metadataPattern.gridSpec ?? transport.gridSpec)
-    const metadata: RenderMetadata = {
-      seed: String(seedValue),
-      bpm: transport.bpm,
-      gridSpec: initialGridSpec,
-      sceneId: metadataTracker.sceneId,
-      patternChain: metadataTracker.patternChain,
-      initialPatternId: metadataTracker.initialPatternId,
-      durationSec: duration
-    }
-
-    const songSlug = slugifyName(patterns.currentScene?.name ?? metadataPattern.name ?? 'drum-session')
-    const candidatePadIds = collectPadIdsFromPatternChain(metadataTracker.patternChain, patterns.patterns)
-    const stemPadIds = options.stems
-      ? candidatePadIds.filter((padId) => baseSampleCache.has(padId))
-      : []
-
-    const renderPass = async (soloPadId?: DrumPadId, collectDebug = false) => {
-      const context = new OfflineAudioContext(2, frameCount, sampleRate)
-      const masterGainNode = context.createGain()
-      masterGainNode.gain.value = 0.8
-      masterGainNode.connect(context.destination)
-      const fxGraph = createFxGraph(context)
-      connectFxGraph(fxGraph, masterGainNode)
-
-      const rng = createSeededRandom(seedValue)
-      updateFxGraph(context, fxGraph, fxSnapshot, rng)
-
-      const sampleCache = new Map(baseSampleCache)
-      const shouldCollectDebugEvents = shouldDebug && collectDebug
-      const debugEvents: RenderEvent[] = []
-
-      const offlineEngine = {
-        trigger({ padId, when, velocity = 1 }: { padId: DrumPadId; when: number; velocity?: number }) {
-          if (soloPadId && padId !== soloPadId) return
-          const buffer = sampleCache.get(padId)
-          if (!buffer) return
-          const source = context.createBufferSource()
-          source.buffer = buffer
-          const gainNode = context.createGain()
-          gainNode.gain.value = velocity
-          source.connect(gainNode)
-          gainNode.connect(fxGraph.fxInput)
-          source.start(when)
-          if (shouldCollectDebugEvents) {
-            debugEvents.push({ time: when, padId, velocity })
-          }
-        }
-      }
-
-      let simulatedTime = 0
-      const baseClock = createRenderClock(context, true)
-      const renderClock: ScheduleStepOptions['clock'] = {
-        ctx: baseClock.ctx,
-        isOffline: true,
-        now: () => simulatedTime,
-        audioTime: () => baseClock.audioTime()
-      }
-
-      const offlineScheduler = createOfflineScheduler(duration, (time) => {
-        simulatedTime = time
-      })
-
-      const tracker = createScenePlaybackTracker(patterns)
-      const initialPatternForRender = tracker.getPattern()
-      const renderGridSpec = normalizeGridSpec(initialPatternForRender.gridSpec ?? transport.gridSpec)
-      const currentStep = ref(0)
-      const pendingSteps = ref<ScheduledStep[]>([])
-      const offlineTransportBase = {
-        loop: transport.loop,
-        bpm: transport.bpm,
-        gridSpec: renderGridSpec,
-        setCurrentStep: () => { },
-        setGridSpec(gridSpec: GridSpec) {
-          offlineTransportBase.gridSpec = normalizeGridSpec(gridSpec)
-        }
-      }
-      const offlineTransport = offlineTransportBase as unknown as ScheduleStepOptions['transport']
-
-      const stepOptions: ScheduleStepOptions = {
-        clock: renderClock,
-        scheduler: offlineScheduler,
-        audio: offlineEngine as ScheduleStepOptions['audio'],
-        transport: offlineTransport,
-        getPattern: () => tracker.getPattern(),
-        currentStep,
-        pendingSteps,
-        onPatternBoundary: () => {
-          const nextPattern = tracker.advancePattern()
-          offlineTransport.setGridSpec(nextPattern.gridSpec)
-          return nextPattern
-        }
-      }
-
-      scheduleStep(stepOptions, 0)
-      offlineScheduler.run()
-      simulatedTime = duration
-
-      const rendered = await context.startRendering()
-      return {
-        audioBuffer: rendered,
-        debugEvents: shouldCollectDebugEvents ? debugEvents : undefined
-      }
-    }
-
-    const mixdownResult = await renderPass(undefined, true)
-    const mixdownBlob = new Blob([audioBufferToWav(mixdownResult.audioBuffer)], { type: 'audio/wav' })
-    saveAs(mixdownBlob, 'mixdown.wav')
-
-    if (shouldDebug) {
-      const events = mixdownResult.debugEvents ?? []
-      const snapshotHash = hashSnapshot(JSON.stringify(fxSnapshot))
-      console.info(
-        'Offline export',
-        `seed=${seedValue}`,
-        `snapshot=${snapshotHash}`,
-        `events=${events.length}`,
-        `duration=${duration.toFixed(2)}`
-      )
-      if (events.length === 0) {
-        console.warn('Offline export scheduled zero events; verify the active pattern/scene contains steps')
-      }
-    }
-
-    const stemFiles: StemExportFiles = {}
-    for (const padId of stemPadIds) {
-      const stemResult = await renderPass(padId)
-      const stemBlob = new Blob([audioBufferToWav(stemResult.audioBuffer)], { type: 'audio/wav' })
-      const fileName = `${songSlug}_${padId}.wav`
-      stemFiles[padId] = { fileName, blob: stemBlob }
-    }
-
-    const result: ExportAudioResult = {
-      audioBlob: mixdownBlob,
-      metadata
-    }
-    if (shouldDebug && mixdownResult.debugEvents) {
-      result.debugTimeline = mixdownResult.debugEvents
-    }
-    if (Object.keys(stemFiles).length > 0) {
-      result.stems = stemFiles
-    }
-    return result
-  }
-
-  const exportSoundbank = (bank: Soundbank, samples: SampleRef[]) => {
-    const padEntries = Object.entries(bank.pads).reduce<Record<string, { id: string; name: string; format?: SampleRef['format'] }>>((acc, [padId, sample]) => {
-      if (sample) {
-        acc[padId] = { id: sample.id, name: sample.name, format: sample.format }
-      }
-      return acc
-    }, {})
-    const manifest = {
-      bank: { ...bank, pads: padEntries },
-      samples: samples.map((sample) => {
-        const entry: { id: string; name: string; format?: SampleRef['format'] } = {
-          id: sample.id,
-          name: sample.name
-        }
-        if (sample.format) {
-          entry.format = sample.format
-        }
-        return entry
-      })
-    }
-    saveAs(new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' }), `${bank.name}-manifest.json`)
-    samples.forEach((sample) => {
-      if (sample.blob) {
-        saveAs(sample.blob, sample.name)
-      }
-    })
-  }
-
-  const importSoundbank = async (manifestFile: File, sampleFiles: File[]): Promise<{ bank: Soundbank; samples: SampleRef[] }> => {
-    try {
-      const manifestText = await manifestFile.text()
-      const parsed = JSON.parse(manifestText) as { bank: Soundbank; samples: Array<Pick<SampleRef, 'id' | 'name' | 'format'>> }
-      const sampleMap = new Map(sampleFiles.map((file) => [file.name, file]))
-      const hydratedSamples: SampleRef[] = parsed.samples.map((sample) => {
-        const blob = sampleMap.get(sample.name)
-        if (blob) {
-          return { ...sample, blob }
-        }
-        return { ...sample }
-      })
-      const padAssignments: Partial<Record<string, SampleRef>> = {}
-      Object.entries(parsed.bank.pads ?? {}).forEach(([padId, sampleInfo]) => {
-        const found = hydratedSamples.find((sample) => sample.id === (sampleInfo as SampleRef).id)
-        if (found) {
-          padAssignments[padId] = found
-        }
-      })
-      const hydratedBank: Soundbank = { ...parsed.bank, pads: padAssignments }
-      return { bank: hydratedBank, samples: hydratedSamples }
-    } catch (error) {
-      console.error('Failed to import soundbank', error)
-      return {
-        bank: { id: 'invalid-bank', name: manifestFile.name, pads: {}, createdAt: Date.now(), updatedAt: Date.now() },
-        samples: []
-      }
-    }
-  }
-
-  const exportMidiData = (data: MidiFileData) => {
+  const exportMidi = (data: MidiFileData) => {
     const blob = new Blob([encoderHeader, JSON.stringify(data)], { type: 'application/json' })
     saveAs(blob, 'sequence.mid.json')
   }
 
+  const exportAudio = (buffer: ArrayBuffer) => {
+    const blob = new Blob([buffer], { type: 'audio/wav' })
+    saveAs(blob, 'mixdown.wav')
+  }
+
   return {
     exportPattern,
     importPattern,
     exportMidi,
-    importMidi,
-    exportMidiData,
-    exportAudio,
-    exportSoundbank,
-    importSoundbank
+    exportAudio
   }
 }



=========================================
File: _archive/patches/useMidi.patch
=========================================

diff --git a/composables/useMidi.client.ts b/composables/useMidi.client 2.ts
index 603f956..095082d 100644
--- a/composables/useMidi.client.ts
+++ b/composables/useMidi.client 2.ts	
@@ -1,17 +1,12 @@
-import { onBeforeUnmount, ref } from 'vue'
-import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '@/types/midi'
-import { defaultMidiMapping } from '@/domain/midiMapping'
+import { ref } from 'vue'
+import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '~/types/midi'
+import { defaultMidiMapping } from '~/domain/midiMapping'
 
 export function useMidi() {
   const access = ref<MIDIAccess | null>(null)
   const inputs = ref<MidiDeviceInfo[]>([])
   const outputs = ref<MidiDeviceInfo[]>([])
   const mapping = ref<MidiMapping>(defaultMidiMapping())
-  const selectedInputId = ref<string | null>(null)
-  const selectedOutputId = ref<string | null>(null)
-  const listeners = ref<Set<(message: MidiMessage) => void>>(new Set())
-  let handlePageHide: (() => void) | null = null
-  let handlePageShow: (() => void) | null = null
 
   const supportsMidi = () => typeof navigator !== 'undefined' && Boolean((navigator as Navigator).requestMIDIAccess)
 
@@ -35,59 +30,31 @@ export function useMidi() {
     }
     access.value = await (navigator as Navigator).requestMIDIAccess({ sysex: false })
     refreshDevices()
-    if (access.value) {
-      access.value.onstatechange = () => {
-        refreshDevices()
-        attachSelectedInput()
-      }
-    }
-  }
-
-  const handleMidiMessage = (event: MIDIMessageEvent) => {
-    if (!event.data || event.data.length < 1) return
-    const status = event.data[0]
-    const data1 = event.data[1]
-    const data2 = event.data[2]
-    if (status === undefined) return
-    const type = status & 0xf0
-    const hasNoteData = typeof data1 === 'number' && typeof data2 === 'number'
-    const message: MidiMessage | null =
-      type === 0x90 && hasNoteData && data2 > 0
-        ? { type: 'noteon', note: data1, velocity: data2 / 127 }
-        : type === 0x80 && hasNoteData
-          ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
-          : type === 0x90 && hasNoteData && data2 === 0
-            ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
-            : status === 0xf8
-              ? { type: 'clock' }
-              : status === 0xfa
-                ? { type: 'start' }
-                : status === 0xfc
-                  ? { type: 'stop' }
-                  : null
-    if (!message) return
-    listeners.value.forEach((cb) => cb(message))
-  }
-
-  const detachInputs = () => {
-    access.value?.inputs.forEach((input) => {
-      input.onmidimessage = null
-    })
-  }
-
-  const attachSelectedInput = () => {
-    detachInputs()
-    if (!selectedInputId.value) return
-    const input = access.value?.inputs.get(selectedInputId.value)
-    if (input) {
-      input.onmidimessage = handleMidiMessage
-    }
   }
 
   const listen = (cb: (message: MidiMessage) => void) => {
-    listeners.value.add(cb)
-    attachSelectedInput()
-    return () => listeners.value.delete(cb)
+    access.value?.inputs.forEach((input: MIDIInput) => {
+      input.onmidimessage = (event: MIDIMessageEvent) => {
+        if (!event.data || event.data.length < 3) return
+        const status = event.data[0]
+        const data1 = event.data[1]
+        const data2 = event.data[2]
+        if (status === undefined || data1 === undefined || data2 === undefined) return
+
+        const type = status & 0xf0
+        if (type === 0x90 && data2 > 0) {
+          cb({ type: 'noteon', note: data1, velocity: data2 / 127 })
+        } else if (type === 0x80 || (type === 0x90 && data2 === 0)) {
+          cb({ type: 'noteoff', note: data1, velocity: data2 / 127 })
+        } else if (status === 0xf8) {
+          cb({ type: 'clock' })
+        } else if (status === 0xfa) {
+          cb({ type: 'start' })
+        } else if (status === 0xfc) {
+          cb({ type: 'stop' })
+        }
+      }
+    })
   }
 
   const send = (deviceId: string, message: MidiMessage) => {
@@ -114,97 +81,18 @@ export function useMidi() {
     }
   }
 
-  const sendClockTick = () => {
-    if (selectedOutputId.value) {
-      send(selectedOutputId.value, { type: 'clock' })
-    }
-  }
-
-  const sendStart = () => {
-    if (selectedOutputId.value) {
-      send(selectedOutputId.value, { type: 'start' })
-    }
-  }
-
-  const sendStop = () => {
-    if (selectedOutputId.value) {
-      send(selectedOutputId.value, { type: 'stop' })
-    }
-  }
-
-  const setSelectedInput = (id: string | null) => {
-    selectedInputId.value = id
-    attachSelectedInput()
-  }
-
-  const setSelectedOutput = (id: string | null) => {
-    selectedOutputId.value = id
-  }
-
   const mapNoteToPad = (note: number) => mapping.value.noteMap[note]
-  const setPadForNote = (note: number, padId: MidiMapping['noteMap'][number]) => {
-    if (padId) {
-      mapping.value.noteMap[note] = padId
-    } else {
-      delete mapping.value.noteMap[note]
-    }
-  }
-
-  if (typeof window !== 'undefined') {
-    handlePageHide = () => {
-      detachInputs()
-      if (access.value) {
-        access.value.onstatechange = null
-      }
-    }
-    handlePageShow = () => {
-      if (access.value) {
-        refreshDevices()
-        attachSelectedInput()
-        access.value.onstatechange = () => {
-          refreshDevices()
-          attachSelectedInput()
-        }
-      }
-    }
-    window.addEventListener('pagehide', handlePageHide)
-    window.addEventListener('pageshow', handlePageShow)
-  }
-
-  onBeforeUnmount(() => {
-    if (handlePageHide) {
-      window.removeEventListener('pagehide', handlePageHide)
-    }
-    if (handlePageShow) {
-      window.removeEventListener('pageshow', handlePageShow)
-    }
-    detachInputs()
-    if (access.value) {
-      access.value.onstatechange = null
-    }
-  })
 
   return {
     access,
     inputs,
     outputs,
     mapping,
-    selectedInputId,
-    selectedOutputId,
     supportsMidi,
     requestAccess,
     refreshDevices,
     listen,
     send,
-    sendClockTick,
-    sendStart,
-    sendStop,
-    mapNoteToPad,
-    setPadForNote,
-    setMapping: (next: MidiMapping) => {
-      mapping.value = next
-    },
-    setSelectedInput,
-    setSelectedOutput
+    mapNoteToPad
   }
 }



=========================================
File: _archive/patches/useSequencer.patch
=========================================

diff --git a/composables/useSequencer.ts b/composables/useSequencer 2.ts
index 9d98b69..fda8093 100644
--- a/composables/useSequencer.ts
+++ b/composables/useSequencer 2.ts	
@@ -1,129 +1,31 @@
-import { ref, type Ref } from 'vue'
-import { quantizeToStep } from '@/domain/quantize'
-import { normalizeGridSpec, secondsPerStep } from '@/domain/timing'
-import type { DrumPadId, Pattern } from '@/types/drums'
-import type { SampleRef, Soundbank } from '@/types/audio'
-import type { GridSpec, StepAddress } from '@/types/time'
-import { useTransportStore } from '@/stores/transport'
-import { useScheduler, type ScheduledTask } from './useScheduler'
+import { ref } from 'vue'
+import { quantizeToStep } from '~/domain/quantize'
+import { normalizeGridSpec, secondsPerStep } from '~/domain/timing'
+import type { DrumPadId, Pattern } from '~/types/drums'
+import type { SampleRef, Soundbank } from '~/types/audio'
+import type { GridSpec, StepAddress } from '~/types/time'
+import { useTransportStore } from '~/stores/transport'
+import { useScheduler } from './useScheduler'
 import { useAudioEngine } from './useAudioEngine.client'
-import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
-import { createRenderClock, type RenderClock } from '@/domain/clock/renderClock'
 
 interface SequencerOptions {
   getPattern: () => Pattern
   lookahead?: number
   scheduleAheadSec?: number
-  onPatternBoundary?: () => Pattern | void
 }
 
-interface SchedulerLike {
-  schedule: (task: ScheduledTask) => void
-}
-
-export interface ScheduledStep {
+interface ScheduledStep {
   when: number
   stepAddress: StepAddress
 }
 
-const totalStepsForGrid = (gridSpec: GridSpec) => gridSpec.bars * gridSpec.division
-
-export interface ScheduleStepOptions {
-  clock: RenderClock
-  scheduler: SchedulerLike
-  audio: ReturnType<typeof useAudioEngine>
-  transport: ReturnType<typeof useTransportStore>
-  getPattern: () => Pattern
-  currentStep: Ref<number>
-  pendingSteps: Ref<ScheduledStep[]>
-  onPatternBoundary?: () => Pattern | void
-}
-
-export function scheduleStep(options: ScheduleStepOptions, when: number) {
-  const pattern = options.getPattern()
-  const totalSteps = totalStepsForGrid(pattern.gridSpec)
-  const loopStart = Math.min(
-    Math.max(0, options.transport.loopStart),
-    Math.max(0, totalSteps - 1)
-  )
-  const loopEnd = Math.min(
-    Math.max(loopStart + 1, options.transport.loopEnd),
-    totalSteps
-  )
-  const loopLength = Math.max(1, loopEnd - loopStart)
-  const stepIndex =
-    loopStart +
-    (((options.currentStep.value - loopStart) % loopLength) + loopLength) %
-      loopLength
-  const barIndex = Math.floor(stepIndex / pattern.gridSpec.division)
-  const stepInBar = stepIndex % pattern.gridSpec.division
-  const scheduledWhen = Math.max(when, options.clock.now())
-  options.pendingSteps.value.push({ when: scheduledWhen, stepAddress: { barIndex, stepInBar } })
-
-  options.scheduler.schedule({
-    when: scheduledWhen,
-    callback: () => {
-      const bar = pattern.steps[barIndex]
-      const stepRow = bar?.[stepInBar]
-      if (stepRow) {
-        Object.entries(stepRow).forEach(([padId, cell]) => {
-          options.audio.trigger({
-            padId: padId as DrumPadId,
-            when: scheduledWhen,
-            velocity: cell?.velocity?.value ?? 1
-          })
-        })
-      }
-
-      const rawNext = options.currentStep.value + 1
-      const nextStepInLoop =
-        loopStart + (((rawNext - loopStart) % loopLength) + loopLength) % loopLength
-      const isPatternBoundary = nextStepInLoop === 0
-
-      if (options.transport.metronomeEnabled) {
-        const isQuarter =
-          pattern.gridSpec.division % 4 === 0
-            ? stepInBar % (pattern.gridSpec.division / 4) === 0
-            : stepInBar === 0
-        if (isQuarter) {
-          void options.audio.triggerClick(
-            scheduledWhen,
-            isPatternBoundary,
-            options.transport.metronomeVolume
-          )
-        }
-      }
-
-      let nextPattern = pattern
-      if (isPatternBoundary && options.onPatternBoundary) {
-        const candidate = options.onPatternBoundary()
-        if (candidate) {
-          nextPattern = candidate
-          options.transport.setGridSpec(nextPattern.gridSpec)
-        } else {
-          nextPattern = options.getPattern()
-        }
-      }
-
-      options.currentStep.value = nextStepInLoop
-      options.transport.setCurrentStep(options.currentStep.value)
-
-      if (options.transport.loop) {
-        const stepDuration = secondsPerStep(options.transport.bpm, nextPattern.gridSpec.division)
-        scheduleStep(options, scheduledWhen + stepDuration)
-      }
-    }
-  })
-}
-
 export function useSequencer(options: SequencerOptions) {
   const transport = useTransportStore()
   const audio = useAudioEngine()
-  let renderClock: RenderClock | null = null
   const scheduler = useScheduler({
     lookahead: options.lookahead ?? 25,
     scheduleAheadSec: options.scheduleAheadSec ?? 0.1,
-    getTime: () => renderClock?.now() ?? 0
+    getTime: () => audio.ensureContext().currentTime
   })
 
   const currentStep = ref(0)
@@ -131,34 +33,52 @@ export function useSequencer(options: SequencerOptions) {
   const pendingSteps = ref<ScheduledStep[]>([])
   let loopStartTime = 0
 
-  const boundaryCallback = options.onPatternBoundary ?? (() => undefined)
-  const buildStepOptions = (clock: RenderClock): ScheduleStepOptions => ({
-    clock,
-    scheduler,
-    audio,
-    transport,
-    getPattern: options.getPattern,
-    currentStep,
-    pendingSteps,
-    onPatternBoundary: boundaryCallback
-  })
+  const totalStepsForGrid = (gridSpec: GridSpec) => gridSpec.bars * gridSpec.division
+
+  const scheduleStep = (when: number) => {
+    const pattern = options.getPattern()
+    const totalSteps = totalStepsForGrid(pattern.gridSpec)
+    const stepIndex = currentStep.value % totalSteps
+    const barIndex = Math.floor(stepIndex / pattern.gridSpec.division)
+    const stepInBar = stepIndex % pattern.gridSpec.division
+    pendingSteps.value.push({ when, stepAddress: { barIndex, stepInBar } })
+    scheduler.schedule({
+      when,
+      callback: () => {
+        playStep(pattern, when, { barIndex, stepInBar })
+        currentStep.value = (currentStep.value + 1) % totalSteps
+        transport.setCurrentStep(currentStep.value)
+        if (transport.loop) {
+          const stepDuration = secondsPerStep(transport.bpm, pattern.gridSpec.division)
+          scheduleStep(when + stepDuration)
+        }
+      }
+    })
+  }
 
-  const start = async () => {
+  const playStep = (pattern: Pattern, when: number, step: StepAddress) => {
+    const bar = pattern.steps[step.barIndex]
+    const stepRow = bar?.[step.stepInBar]
+    if (!stepRow) return
+    Object.entries(stepRow).forEach(([padId, cell]) => {
+      audio.trigger({ padId: padId as DrumPadId, when, velocity: cell?.velocity?.value ?? 1 })
+    })
+  }
+
+  const start = () => {
     if (transport.isPlaying) return
-    const ctx = await audio.resumeContext()
-    renderClock = createRenderClock(ctx)
+    const ctx = audio.ensureContext()
     const pattern = options.getPattern()
     const gridSpec = normalizeGridSpec(pattern.gridSpec)
     pattern.gridSpec = gridSpec
     transport.setGridSpec(gridSpec)
-    loopStartTime = renderClock.now()
-    currentStep.value = Math.max(0, transport.loopStart)
+    loopStartTime = ctx.currentTime
+    currentStep.value = 0
     pendingSteps.value = []
-    transport.setCurrentStep(currentStep.value)
+    transport.setCurrentStep(0)
     transport.setPlaying(true)
     scheduler.clear()
-    const stepOptions = buildStepOptions(renderClock)
-    scheduleStep(stepOptions, loopStartTime)
+    scheduleStep(loopStartTime)
     scheduler.start()
     scheduler.tick()
   }
@@ -168,10 +88,9 @@ export function useSequencer(options: SequencerOptions) {
     scheduler.stop()
     scheduler.clear()
     pendingSteps.value = []
-    currentStep.value = Math.max(0, transport.loopStart)
-    transport.setCurrentStep(currentStep.value)
+    currentStep.value = 0
+    transport.setCurrentStep(0)
     loopStartTime = 0
-    renderClock = null
   }
 
   const toggleStep = (barIndex: number, stepInBar: number, padId: DrumPadId) => {
@@ -179,29 +98,19 @@ export function useSequencer(options: SequencerOptions) {
     const bar = pattern.steps[barIndex] ?? {}
     const stepRow = bar[stepInBar] ?? {}
     const updated = { ...stepRow }
-    const nextVelocity = cycleVelocity(updated[padId]?.velocity?.value)
-    if (nextVelocity === null) {
+    if (updated[padId]) {
       delete updated[padId]
     } else {
-      updated[padId] = { velocity: { value: clampVelocity(nextVelocity) } }
+      updated[padId] = { velocity: { value: 1 } }
     }
     pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
   }
 
-  const setStepVelocity = (barIndex: number, stepInBar: number, padId: DrumPadId, velocity: number) => {
+  const recordHit = (padId: DrumPadId, velocity = 1, quantize = true) => {
     const pattern = options.getPattern()
-    const bar = pattern.steps[barIndex] ?? {}
-    const stepRow = bar[stepInBar] ?? {}
-    const updated = { ...stepRow, [padId]: { velocity: { value: clampVelocity(velocity || DEFAULT_STEP_VELOCITY) } } }
-    pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
-  }
-
-  const recordHit = async (padId: DrumPadId, velocity = 1, quantize = true) => {
-    const pattern = options.getPattern()
-    const ctx = await audio.resumeContext()
+    const ctx = audio.ensureContext()
     const gridSpec = pattern.gridSpec
     const stepDuration = secondsPerStep(transport.bpm, gridSpec.division)
-    const resolvedVelocity = clampVelocity(velocity)
     const anchor = transport.isPlaying ? loopStartTime : ctx.currentTime
     if (!transport.isPlaying) {
       loopStartTime = anchor
@@ -213,8 +122,8 @@ export function useSequencer(options: SequencerOptions) {
           barIndex: Math.floor(currentStep.value / gridSpec.division),
           stepInBar: currentStep.value % gridSpec.division
         }
-    setStepVelocity(step.barIndex, step.stepInBar, padId, resolvedVelocity)
-    audio.trigger({ padId, when: ctx.currentTime, velocity: resolvedVelocity })
+    toggleStep(step.barIndex, step.stepInBar, padId)
+    audio.trigger({ padId, when: ctx.currentTime, velocity })
   }
 
   const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
@@ -225,8 +134,6 @@ export function useSequencer(options: SequencerOptions) {
     await audio.applySoundbank(bank)
   }
 
-  const getAudioTime = () => renderClock?.now() ?? audio.ensureContext().currentTime
-
   return {
     currentStep,
     isRecording,
@@ -234,12 +141,8 @@ export function useSequencer(options: SequencerOptions) {
     start,
     stop,
     toggleStep,
-    setStepVelocity,
     recordHit,
-    fxSettings: audio.fxSettings,
-    setFx: audio.setFx,
     setSampleForPad,
-    applySoundbank,
-    getAudioTime
+    applySoundbank
   }
 }



=========================================
File: _archive/patches/useSync.patch
=========================================

diff --git a/composables/useSync.client.ts b/composables/useSync.client 2.ts
index d38d485..0655e26 100644
--- a/composables/useSync.client.ts
+++ b/composables/useSync.client 2.ts	
@@ -1,167 +1,35 @@
-import { onBeforeUnmount, ref } from 'vue'
-import { useScheduler } from './useScheduler'
-import type { ClockAuthority, SyncMode, SyncRole, SyncState } from '@/types/sync'
-import type { MidiMessage } from '@/types/midi'
+import { ref } from 'vue'
+import type { SyncMode, SyncRole, SyncState } from '~/types/sync'
 
-interface SyncDeps {
-  midi?: {
-    listen: (cb: (message: MidiMessage) => void) => () => void
-    sendClockTick: () => void
-    sendStart: () => void
-    sendStop: () => void
-    selectedOutputId: { value: string | null }
-  }
-  getAudioTime?: () => number
-  onExternalStart?: () => void
-  onExternalStop?: () => void
-}
-
-const MIDI_CLOCKS_PER_QUARTER = 24
-const CLOCK_AUTHORITY: ClockAuthority = 'audioContext'
-
-export function useSync(initialMode: SyncMode = 'internal', deps?: SyncDeps) {
-  // Coordinates transport sync between audio clock and MIDI clock roles (master/slave), handling clock ticks and start/stop events.
-  const state = ref<SyncState>({
-    bpm: 120,
-    phase: 0,
-    isPlaying: false,
-    mode: initialMode,
-    role: 'master',
-    linkAvailable: false,
-    clockAuthority: CLOCK_AUTHORITY,
-    bpmSource: 'transport'
-  })
-  const scheduler = deps?.getAudioTime
-    ? useScheduler({
-      lookahead: 25,
-      scheduleAheadSec: 0.05,
-      getTime: deps.getAudioTime
-    })
-    : null
-  const lastStableBpm = ref(state.value.bpm)
-  let nextClockAt: number | null = null
-  let midiUnsubscribe: (() => void) | null = null
-
-  const secondsPerClockTick = () => 60 / (state.value.bpm * MIDI_CLOCKS_PER_QUARTER)
-
-  const resetPhase = () => {
-    state.value.phase = 0
-  }
-
-  const stopClock = () => {
-    scheduler?.stop()
-    scheduler?.clear()
-    nextClockAt = null
-    deps?.midi?.sendStop()
-  }
-
-  const tick = () => {
-    state.value.phase = (state.value.phase + 1) % MIDI_CLOCKS_PER_QUARTER
-  }
-
-  const scheduleClockTick = () => {
-    if (!scheduler || nextClockAt === null) return
-    scheduler.schedule({
-      when: nextClockAt,
-      callback: () => {
-        deps?.midi?.sendClockTick()
-        tick()
-        if (nextClockAt !== null) {
-          nextClockAt = nextClockAt + secondsPerClockTick()
-          scheduleClockTick()
-        }
-      }
-    })
-  }
-
-  const startClock = () => {
-    stopClock()
-    if (state.value.mode !== 'midiClock' || state.value.role !== 'master') return
-    if (!deps?.midi?.selectedOutputId.value) return
-    if (!deps?.getAudioTime || !scheduler) return
-    const now = deps.getAudioTime()
-    nextClockAt = now + secondsPerClockTick()
-    deps.midi.sendStart()
-    scheduleClockTick()
-    scheduler.start()
-    scheduler.tick()
-  }
+export function useSync(initialMode: SyncMode = 'internal') {
+  const state = ref<SyncState>({ bpm: 120, phase: 0, isPlaying: false, mode: initialMode, role: 'master' })
 
   const setMode = (mode: SyncMode) => {
     state.value.mode = mode
-    state.value.bpm = lastStableBpm.value
-    stopClock()
-    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
-      startClock()
-    }
   }
 
   const setRole = (role: SyncRole) => {
     state.value.role = role
-    state.value.bpm = lastStableBpm.value
-    stopClock()
-    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
-      startClock()
-    }
   }
 
   const setPlaying = (isPlaying: boolean) => {
     state.value.isPlaying = isPlaying
-    if (isPlaying) {
-      startClock()
-    } else {
-      stopClock()
-    }
   }
 
   const setBpm = (bpm: number) => {
-    state.value.bpm = Math.max(20, Math.min(300, bpm))
-    lastStableBpm.value = state.value.bpm
-    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
-      startClock()
-    }
-  }
-
-  const handleMidiMessage = (message: MidiMessage) => {
-    if (state.value.mode !== 'midiClock' || state.value.role !== 'slave') return
-    if (message.type === 'start') {
-      state.value.isPlaying = true
-      resetPhase()
-      deps?.onExternalStart?.()
-    } else if (message.type === 'stop') {
-      state.value.isPlaying = false
-      resetPhase()
-      deps?.onExternalStop?.()
-    } else if (message.type === 'clock') {
-      tick()
-    }
+    state.value.bpm = bpm
   }
 
-  const startTransport = (bpm: number) => {
-    setBpm(bpm)
-    setPlaying(true)
+  const tick = (phase: number) => {
+    state.value.phase = phase
   }
 
-  const stopTransport = () => {
-    setPlaying(false)
-  }
-
-  if (deps?.midi) {
-    midiUnsubscribe = deps.midi.listen(handleMidiMessage)
-  }
-
-  onBeforeUnmount(() => {
-    stopClock()
-    midiUnsubscribe?.()
-  })
-
   return {
     state,
     setMode,
     setRole,
     setPlaying,
     setBpm,
-    startTransport,
-    stopTransport
+    tick
   }
 }



=========================================
File: alleDateien.md
=========================================

# Dateien mit <style>-Block

- app.vue
- components/DrumMachine.vue
- components/PadCell.vue
- components/PadGrid.vue
- components/PlayheadOverlay.vue
- components/StepGrid.vue
- components/TabPanel.vue
- components/TransportBar.vue
- components/panels/ExportPanel.vue
- components/panels/FxPanel.vue
- components/panels/PatternsPanel.vue
- components/panels/SoundPanel.vue
- layouts/default.vue


  div(style="color:white; padding:20px;")
  .drumshell
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    .hardware-top
      TransportBar(
        :bpm="bpm"
        :isPlaying="isPlaying"
        :loop="transport.loop"
        :division="gridSpec.division"
        :divisions="divisions"
        @play="start"
        @stop="stop"
        @bpm:update="updateBpm"
        @loop:update="setLoop"
        @division:update="setDivision"
      )

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    .main-shell
      .pads-panel
        PadGrid(
          :pads="pads"
          :selected-pad="selectedPadId"
          :pad-states="padStates"
          @pad:down="handlePad"
          @pad:select="selectPad"
        )

      .sequencer-panel
        StepGrid(
          :grid-spec="gridSpec"
          :steps="pattern.steps"
          :selected-pad="selectedPadId"
          :current-step="currentStep"
          :is-playing="isPlaying"
          @step:toggle="toggleStep"
        )

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DRAWER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    .drawer-wrapper
      .drawer-scroll
        TabPanel(v-model="drawerTab")
          template(#sound)
            SoundPanel(
              :banks="banks"
              :selected-bank-id="soundbanks.selectedBankId"
              @bank:select="selectBank"
              @pad:replace="replacePadSample"
            )

          template(#fx)
            FxPanel(
              :fxSettings="sequencer.fxSettings"
              @fx:update="updateFx"
            )

          template(#patterns)
            PatternsPanel(
              :patterns="patterns.patterns"
              :selected-pattern-id="patterns.selectedPatternId"
              :scenes="patterns.scenes"
              :active-scene-id="patterns.activeSceneId"
              @pattern:add="addPattern"
              @pattern:select="selectPattern"
              @pattern:rename="renamePattern"
              @pattern:undo="undoPattern"
              @pattern:redo="redoPattern"
              @scene:add="addScene"
              @scene:update="updateScene"
              @scene:select="selectScene"
            )

          template(#export)
            ExportPanel(
              :isExporting="isExporting"
              :exportError="exportError"
              :exportMetadata="exportMetadata"
              :audioBlob="exportAudioBlob"
              :hasZipArtifacts="hasZipArtifacts"
              :stemEntries="stemEntries"
              @export="exportBounce"
              @download:mixdown="downloadMixdown"
              @download:zip="downloadZip"
              @download:stem="downloadStem"
              @download:stems="downloadAllStems"
            )



=========================================
File: app.vue
=========================================

<template>
  <NuxtLayout>
  </NuxtLayout>
</template>

<style lang="less">
@import '@/styles/variables.less';

html,
body,
#__nuxt {
  height: 100%;
  margin:0;
}

body {
  overflow: hidden;
}
.v-application {
  height: 100%;
  background: @color-bg-root;
}
</style>



=========================================
File: assets/browser-implementation-prompts.md
=========================================

# Browser Implementation Prompts

Diese Datei enthÃ¤lt detaillierte Prompts fÃ¼r die schrittweise Implementierung der Browser-FunktionalitÃ¤t gemÃ¤ÃŸ `browserplan.md`. Jeder Prompt ist so gestaltet, dass ein Agent ihn ausfÃ¼hren kann.

---

## Globale Korrekturen (fÃ¼r alle Prompts)

- Store-/Component-Style beibehalten: keine Migration Options â†” Setup, bestehendes Pinia-Muster nutzen.
- SSR-/Nuxt4-Sicherheit: keine `window`/`localStorage`/`AudioContext` Zugriffe beim Import; client-only Code nur in `.client.ts` oder hinter `import.meta.client`/`process.client`/`typeof window !== 'undefined'`.
- Keine UI-Erweiterungen: keine neuen Buttons/Soft-Buttons/Template-Ã„nderungen. Nur verdrahten, wenn ein passender Trigger bereits existiert.
- Keine Breaking Changes: neue Interface-Methoden optional oder via Extension-Interface; alle Implementierungen/Mocks konsistent halten.
- Tests im vorhandenen Stil (Vitest/Mocha/Chai) belassen; keine neuen Runner/Helper einfÃ¼hren.

## Phase 1: Kern-Navigation

### Prompt 1.1: 4-D-Encoder Composable

**Aufgabe:** Implementiere `composables/use4DEncoder.ts` fÃ¼r die 4-D-Encoder-Navigation.

**Anforderungen:**
1. Erstelle die Datei `composables/use4DEncoder.ts`
2. Implementiere eine State-Machine mit drei Modi:
   - `field-select`: Encoder navigiert zwischen Filter-Feldern
   - `value-adjust`: Encoder Ã¤ndert Wert im aktuellen Feld
   - `list-navigate`: Encoder navigiert durch Ergebnisliste
3. UnterstÃ¼tze folgende Aktionen:
   - `tiltHorizontal(direction: 'left' | 'right')`: Wechselt zwischen Feldern
   - `tiltVertical(direction: 'up' | 'down')`: Navigiert in Listen
   - `turn(delta: number)`: Ã„ndert Werte (im value-adjust Modus) oder scrollt (im list-navigate Modus)
   - `press()`: BestÃ¤tigt Auswahl oder wechselt in nÃ¤chsten Modus
4. Verwalte eine Liste von `EncoderField[]` mit:
   ```typescript
   interface EncoderField {
     id: string
     label: string
     value: string | number
     options?: string[]  // FÃ¼r Drop-down-Felder
     min?: number        // FÃ¼r numerische Felder
     max?: number
     step?: number
   }
   ```
5. Exportiere reactive State und Methoden
6. Schreibe Unit-Tests in `tests/unitTests/use4DEncoder.spec.ts`:
   - Testen der Feld-Navigation
   - Testen der Wert-Ã„nderung
   - Testen der Modi-Wechsel
   - Testen der Press-Aktion
7. API ergÃ¤nzen: `setFields(fields: EncoderField[])`, optional `setMode(mode)`, State als refs (`mode`, `activeFieldIndex`, `activeListIndex`, `fields`)

**Constraints:**
- TypeScript strict mode
- Vue 3 Composition API (reactive, computed)
- Keine UI-Komponenten
- Kompatibel mit Nuxt 4

**Erfolg:** Tests laufen grÃ¼n, Composable ist einsatzbereit fÃ¼r Browser-Store-Integration.

---

### Prompt 1.2: Browser-Filter-Erweiterung

**Aufgabe:** Erweitere `stores/browser.ts` um erweiterte Filter-FunktionalitÃ¤t.

**Anforderungen:**
1. Ã–ffne `stores/browser.ts`
2. Definiere neuen Type `BrowserFilters` (siehe browserplan.md, Abschnitt C)
3. FÃ¼ge zum State hinzu:
   ```typescript
   filters: BrowserFilters
   availableCategories: string[]
   availableProducts: string[]
   availableBanks: string[]
   ```
4. Implementiere Actions:
   - `setFilter<K extends keyof BrowserFilters>(key: K, value: BrowserFilters[K])`: Setzt einzelnen Filter (typ-sicher)
   - `clearFilters()`: Setzt alle Filter zurÃ¼ck
   - `applyFilters()`: Wendet Filter auf Suchergebnisse an
   - `getAvailableOptions(filterKey: string)`: Gibt verfÃ¼gbare Optionen fÃ¼r Filter zurÃ¼ck
   - `getEncoderFields()`: Konvertiert aktuelle Filter zu EncoderField[] fÃ¼r 4D-Encoder
5. Erweitere `search()` Action um Filter-Anwendung
6. Aktualisiere `toDisplayModels()` um aktive Filter anzuzeigen
   - Nur erweitern, falls bestehende Anzeige-Slots dies bereits unterstÃ¼tzen (keine neuen UI-Elemente)
7. Erweitere bestehende Tests in `tests/unitTests/browserStore.spec.ts`:
   - Testen der Filter-Anwendung
   - Testen der Filter-Kombination (z.B. fileType + category)
   - Testen von getEncoderFields()

**Integration:**
- `getEncoderFields()` sollte Felder in dieser Reihenfolge zurÃ¼ckgeben:
  1. fileType (Type)
  2. contentType (Factory/User)
  3. category
  4. product
  5. bank
  6. tags (komma-separiert)
  7. favorites (boolean)

**Constraints:**
- Keine Breaking Changes an bestehenden Methods
- Backward-kompatibel mit existierendem Code
- Bestehende Tests mÃ¼ssen weiterhin grÃ¼n bleiben
- Client-only Persistence (localStorage) nur hinter Guard `import.meta.client`.
- `applyFilters()` darf das Verhalten unverÃ¤ndert lassen, wenn keine Filter gesetzt sind.

**Erfolg:** Erweiterte Filter funktionieren, getEncoderFields() liefert korrekte Daten, alle Tests grÃ¼n.

---

### Prompt 1.3: Control-Store 4D-Integration

**Aufgabe:** Integriere `use4DEncoder()` in `stores/control.ts` fÃ¼r Browser-Modi.

**Anforderungen:**
1. Ã–ffne `stores/control.ts`
2. Importiere `use4DEncoder` aus `composables/use4DEncoder.ts`
3. FÃ¼ge zum State hinzu:
   ```typescript
   encoder4D: ReturnType<typeof use4DEncoder> | null // mit markRaw/shallowRef setzen, keine SSR-Leaks
   ```
4. Erweitere `setMode()` Action:
   - Bei Wechsel zu BROWSER oder FILE Mode:
     - Initialisiere `encoder4D` falls noch nicht vorhanden
     - Hole Felder von Browser-Store via `browser.getEncoderFields()`
     - Setze Felder via `encoder4D.setFields(fields)`
5. FÃ¼ge neue Actions hinzu:
   - `tiltEncoder4D(direction: 'left' | 'right' | 'up' | 'down')`: Leitet an encoder4D weiter
   - `turnEncoder4D(delta: number)`: Leitet an encoder4D weiter, aktualisiert Browser-Filter
   - `pressEncoder4D()`: BestÃ¤tigt Auswahl, lÃ¤dt ggf. Item
6. Binde Encoder-Ã„nderungen an Browser-Store:
   - Bei Feld-Wechsel: Update Display-Highlight
   - Bei Wert-Ã„nderung: Rufe `browser.setFilter()` auf
   - Bei Press: Rufe `browser.importSelected()` auf (wenn in Liste)
7. Aktualisiere `toDisplayModels()` um markiertes Feld anzuzeigen (dÃ¼nne Klammern)
8. Erweitere Tests in `tests/unitTests/controlBrowserIntegration.spec.ts`:
   - Testen der 4D-Encoder-Initialisierung
   - Testen der Feld-Navigation
   - Testen der Filter-Synchronisation
   - Testen der Load-Aktion via Press

**Constraints:**
- Encoder nur fÃ¼r BROWSER/FILE Modi aktiv
- Andere Modi (CHANNEL, PLUGIN, etc.) unverÃ¤ndert
- DrumMachine.vue bleibt unverÃ¤ndert
- Keine neuen Soft-Buttons hinzufÃ¼gen; nur vorhandene Trigger verdrahten.

**Erfolg:** 4D-Encoder funktioniert im Browser-Mode, Filter werden korrekt gesetzt, Tests grÃ¼n.

---

## Phase 2: File System & Import

### Prompt 2.1: File System Access API Wrapper

**Aufgabe:** Implementiere echte Browser File System Access API in `services/fileSystemRepository.ts`.

**Anforderungen:**
1. Ã–ffne `services/fileSystemRepository.ts`
2. Erstelle neue Klasse `BrowserFileSystemRepository implements FileSystemRepository`
3. Implementiere Methoden:
   - `async requestAccess()`: Fordert User-Permission via `window.showDirectoryPicker()`
   - `async listDir(path: string)`: Listet Unterordner und Dateien
   - `async stat(path: string)`: PrÃ¼ft ob Pfad existiert und ob es Dir ist
   - `async readFileMeta(path: string)`: Liest Name und Extension
   - `async readFileBlob(path: string)`: Neue Methode zum Blob-Laden
4. Speichere `FileSystemDirectoryHandle` in privater Variable
5. Implementiere Pfad-zu-Handle-Mapping (z.B. Map oder Cache)
6. Feature-Detection:
   ```typescript
   function hasFileSystemAccess(): boolean {
     return typeof window !== 'undefined' && 'showDirectoryPicker' in window
   }
   ```
7. Erweitere `getFileSystemRepository()`:
   - Wenn File System Access API verfÃ¼gbar â†’ BrowserFileSystemRepository
   - Sonst â†’ existierendes Memory-FS (Fallback)
   - Neue Methoden optional halten oder Ã¼ber Extension-Interface abbilden, damit bestehende Implementierungen nicht brechen.
8. Schreibe Tests in `tests/unitTests/fileSystemRepository.spec.ts`:
   - Mock `showDirectoryPicker()`
   - Testen der Directory-Listing
   - Testen der Blob-Ladung
   - Testen des Fallbacks

**Security:**
- Permission muss von User explizit erteilt werden
- Handle nur wÃ¤hrend aktiver Session gÃ¼ltig
- Bei Permission-Denial: Graceful Fallback
- Client-only Guards (`import.meta.client`) fÃ¼r Browser-APIs; Window narrowing lokal lÃ¶sen.

**Constraints:**
- Keine Breaking Changes: neue Methoden optional oder via Extension-Interface; alle Mocks/Typen anpassen.
- Bestehende Memory-FS-Tests bleiben grÃ¼n

**Erfolg:** Echtes Dateisystem zugÃ¤nglich (wenn User erlaubt), Fallback funktioniert, Tests grÃ¼n.

---

### Prompt 2.2: Import-Workflow mit Progress

**Aufgabe:** Erweitere `services/libraryRepository.ts` um Import mit Fortschritts-Tracking.

**Anforderungen:**
1. Ã–ffne `services/libraryRepository.ts`
2. Definiere `ImportProgress` Interface (siehe browserplan.md, Abschnitt I)
3. FÃ¼ge zu `LibraryRepository` Interface hinzu:
   ```typescript
   importDirectory(
     path: string,
     options?: { recursive?: boolean },
     onProgress?: (progress: ImportProgress) => void
   ): Promise<void>
   ```
4. Implementiere `importDirectory()` in `createLocalRepository()`:
   - Hole File-Liste von `fileSystemRepository.listDir(path)`
   - Iteriere durch Dateien
   - Filtere auf unterstÃ¼tzte Formate (.wav, .mp3, .aiff, etc.)
   - FÃ¼r jede Datei:
     - Extrahiere Metadaten aus Pfad (Category/Product/Bank)
     - Rufe `importFile()` auf
     - Rufe `onProgress()` Callback auf
   - Bei recursive=true: Rekursiv in Unterordnern
5. Implementiere Metadaten-Extraktion:
   ```typescript
   function extractMetadataFromPath(path: string): Partial<LibraryItem> {
     // Schema: /Category/Product/Bank/SubBank/filename.wav
     const parts = path.split('/').filter(Boolean)
     return {
       category: parts[0],
       product: parts[1],
       bank: parts[2],
       subBank: parts[3],
       vendor: 'user'
     }
   }
   ```
6. Fehlerbehandlung:
   - Unsupported format â†’ Skip, in errors[] sammeln
   - Read error â†’ Skip, in errors[] sammeln
   - Am Ende: Wenn errors.length > 0, logge Warnung
7. Neue Methode optional halten oder via Extended-Interface; alle Implementierungen/Mocks anpassen.
8. Schreibe Tests in `tests/unitTests/libraryImport.spec.ts`:
   - Testen des Progress-Callbacks
   - Testen der Metadaten-Extraktion
   - Testen der rekursiven Import
   - Testen der Fehlerbehandlung

**Performance:**
- Stabiler Start: sequentiell importieren; optionale Parallelisierung/Debounce erst nach erfolgreichem Grundlauf.

**Erfolg:** Directory-Import funktioniert, Progress wird gemeldet, Metadaten extrahiert, Tests grÃ¼n.

---

### Prompt 2.3: Recent Files Tracking

**Aufgabe:** Implementiere `composables/useRecentFiles.ts` fÃ¼r Recent-Files-Tracking.

**Anforderungen:**
1. Erstelle `composables/useRecentFiles.ts`
2. Definiere `RecentFileEntry` Interface (siehe browserplan.md, Abschnitt E)
3. Implementiere Composable:
   ```typescript
   export function useRecentFiles() {
     const maxRecent = 50
     const storageKey = 'drumcomputer_recent_files_v1'
     
     function addRecent(entry: Omit<RecentFileEntry, 'timestamp'>): void
     function getRecent(limit?: number): RecentFileEntry[]
     function clearRecent(): void
     function removeRecent(id: string): void
     
     return { addRecent, getRecent, clearRecent, removeRecent }
   }
   ```
4. Implementiere localStorage-Persistence:
   - Bei `addRecent()`: FÃ¼ge an Anfang ein, begrenze auf maxRecent, speichere
   - Deduplizierung: Wenn ID bereits vorhanden, verschiebe nach vorne
   - Sortierung: Immer nach timestamp DESC
5. Integriere in `stores/browser.ts`:
   - Neue Action `loadRecentFiles()`: Ruft `getRecent()` auf, setzt results
   - In `importSelected()`: Rufe `addRecent()` auf
   - Neue Getter `recentFiles`: Gibt aktuelle Recent-Liste zurÃ¼ck
6. Aktualisiere `stores/control.ts` Recent-Page:
   - `leftModel.items` von `browser.recentFiles`
   - Zeige Datum relativ (z.B. "vor 5 Minuten", "heute", "gestern")
7. Schreibe Tests in `tests/unitTests/recentFiles.spec.ts`:
   - Testen der Deduplizierung
   - Testen der Max-Limit
   - Testen der Sortierung
   - Testen der localStorage-Persistence

**Constraints:**
- Client-only (localStorage nur im Browser, Guard `import.meta.client`; in SSR `getRecent()` => [])
- Graceful Degradation wenn localStorage voll

**Erfolg:** Recent Files werden getrackt, in Browser-Store verfÃ¼gbar, Tests grÃ¼n.

---

## Phase 3: Features

### Prompt 3.1: Favorites-System

**Aufgabe:** Implementiere Favorites-System in `services/libraryRepository.ts`.

**Anforderungen:**
1. Ã–ffne `services/libraryRepository.ts`
2. Erweitere `LibraryRepository` Interface:
   ```typescript
   addToFavorites(itemId: string): Promise<void>
   removeFromFavorites(itemId: string): Promise<void>
   getFavorites(): Promise<LibraryItem[]>
   isFavorite(itemId: string): Promise<boolean>
   ```
3. Implementiere in `createLocalRepository()`:
   - Neuer localStorage Key: `drumcomputer_favorites_v1`
   - Speichere Set von Item-IDs
   - `addToFavorites()`: FÃ¼ge ID zu Set hinzu, persistiere
   - `removeFromFavorites()`: Entferne ID von Set, persistiere
   - `getFavorites()`: Filtere items nach IDs im Set
   - `isFavorite()`: PrÃ¼fe ob ID im Set
4. Integriere in `stores/browser.ts`:
   - Neue Action `toggleFavorite(itemId: string)`: Toggle Favorite-Status
   - Erweitere `search()`: Wenn `filters.favorites === true`, nur Favoriten zurÃ¼ckgeben
   - Update `toDisplayModels()`: Zeige Stern-Symbol bei Favoriten (in subtitle)
5. FÃ¼ge zu Control-Store Browser-Page hinzu:
   - Falls bereits vorhanden: Soft-Button "Favorites" Toggle verdrahten
   - Kein neuer Button hinzufÃ¼gen
6. Schreibe Tests in `tests/unitTests/favorites.spec.ts`:
   - Testen von Add/Remove
   - Testen von Toggle
   - Testen des Favorites-Filters
   - Testen der Persistence

**UI-Integration (ohne Ã„nderungen):**
- Subtitle-Format: `"{tags} â˜…"` fÃ¼r Favoriten
- Soft-Button nur nutzen, wenn vorhanden

**Erfolg:** Favorites funktionieren, Filter anwendbar, Tests grÃ¼n.

---

### Prompt 3.2: Sample Preview/Prehear

**Aufgabe:** Implementiere `composables/useSamplePreview.client.ts` fÃ¼r Audio-Preview.

**Anforderungen:**
1. Erstelle `composables/useSamplePreview.client.ts`
2. Definiere `PreviewState` Interface (siehe browserplan.md, Abschnitt F)
3. Implementiere Composable:
   ```typescript
   export function useSamplePreview() {
     const audioContext = inject<AudioContext>('audioContext')
     const state = reactive<PreviewState>({ 
       isPlaying: false,
       currentFile: null,
       progress: 0,
       duration: 0
     })
     
     async function loadAndPlay(path: string, blob?: Blob): Promise<void>
     function stop(): void
     function pause(): void
     function resume(): void
     function seek(position: number): void
     
     return { state, loadAndPlay, stop, pause, resume, seek }
   }
   ```
4. Implementiere Audio-Loading:
   - Wenn blob gegeben: Decode blob
   - Sonst: Hole blob von fileSystemRepository, dann decode
   - Nutze `audioContext.decodeAudioData()`
5. Implementiere Playback:
   - Erstelle AudioBufferSourceNode
   - Verbinde mit audioContext.destination
   - Tracke Progress via requestAnimationFrame
   - Stop bei Ende automatisch
6. Integriere in `stores/browser.ts`:
   - Neue Action `prehearSelected()`: Ruft `preview.loadAndPlay()` auf
   - Neue Action `stopPrehear()`: Ruft `preview.stop()` auf
   - Neue Getter `previewState`: Gibt preview.state zurÃ¼ck
7. Aktualisiere `stores/control.ts`:
   - Bei BROWSER_PREHEAR: Rufe `browser.prehearSelected()` auf
   - Bei BROWSER_STOP: Rufe `browser.stopPrehear()` auf
   - Zeige Preview-Parameter in Encoder-Slots wÃ¤hrend Playback:
     - Preview Vol, Start, End, Tune (fÃ¼r Phase 4)
8. Schreibe Tests in `tests/unitTests/samplePreview.spec.ts`:
   - Mock AudioContext
   - Testen von Load & Play
   - Testen von Stop
   - Testen von Progress-Tracking

**Constraints:**
- Client-only (.client.ts Suffix)
- Nutze bestehenden AudioContext (wie im Projekt bereitgestellt), keine neuen Provider
- Cleanup bei Component-Unmount

**Erfolg:** Preview funktioniert, Audio wird abgespielt, Tests grÃ¼n.

---

### Prompt 3.3: Sortierung

**Aufgabe:** Implementiere Sortier-FunktionalitÃ¤t in `stores/browser.ts`.

**Anforderungen:**
1. Ã–ffne `stores/browser.ts`
2. Definiere `SortMode` Type (siehe browserplan.md, Abschnitt H)
3. FÃ¼ge zum State hinzu:
   ```typescript
   sortMode: SortMode
   ```
4. Implementiere Actions:
   - `setSortMode(mode: SortMode)`: Setzt Mode, ruft `sortResults()` auf
   - `sortResults()`: Sortiert `library.results` und `files.entries` nach Mode
5. Implementiere Sortier-Logik:
   - `name-asc`: Sortiere nach title/name aufsteigend
   - `name-desc`: Sortiere nach title/name absteigend
   - `date-asc`: Sortiere nach importedAt/timestamp aufsteigend (Ã¤lteste zuerst)
   - `date-desc`: Sortiere nach importedAt/timestamp absteigend (neueste zuerst)
   - `relevance`: Originale Reihenfolge (von search())
6. Integriere in FILE Mode:
   - Nur verdrahten, falls bereits ein passender Soft-Button existiert
   - Encoder-Field "Sort": Options: ["Name â†‘", "Name â†“", "Date â†‘", "Date â†“"]
7. Update Display:
   - Zeige aktuellen Sort-Mode in subtitle (z.B. "Sorted by Name â†‘")
8. Schreibe Tests in `tests/unitTests/browserSort.spec.ts`:
   - Testen aller Sort-Modi
   - Testen der Sortierung nach Mode-Wechsel
   - Testen der Persistenz des Sort-Modes

**Performance:**
- Sortierung nur bei Bedarf (lazy)
- Cache sortierte Liste bis nÃ¤chste Ã„nderung

**Erfolg:** Sortierung funktioniert fÃ¼r alle Modi, Tests grÃ¼n.

---

## Phase 4: Advanced Features

### Prompt 4.1: Quick-Browse System

**Aufgabe:** Implementiere `composables/useQuickBrowse.ts` fÃ¼r Browse-History.

**Anforderungen:**
1. Erstelle `composables/useQuickBrowse.ts`
2. Definiere `BrowseHistoryEntry` Interface (siehe browserplan.md, Abschnitt G)
3. Implementiere Composable:
   ```typescript
   export function useQuickBrowse() {
     const maxHistory = 50
     const storageKey = 'drumcomputer_quick_browse_v1'
     const history = ref<BrowseHistoryEntry[]>([])
     
     function recordBrowse(entry: Omit<BrowseHistoryEntry, 'timestamp'>): void
     function getLastBrowse(contextId: string): BrowseHistoryEntry | null
     function restoreBrowse(entry: BrowseHistoryEntry): void
     function clearHistory(): void
     
     return { history, recordBrowse, getLastBrowse, restoreBrowse, clearHistory }
   }
   ```
4. Implementiere History-Tracking:
   - Bei `recordBrowse()`: FÃ¼ge Entry mit timestamp hinzu
   - Gruppiere nach contextId (ein Entry pro Context)
   - Limit auf maxHistory
   - Persistiere in localStorage
5. Implementiere `restoreBrowse()`:
   - Setze Browser-Mode
   - Setze Query
   - Setze Filters
   - Rufe `browser.search()` auf
   - Selektiere Item (wenn selectedId vorhanden)
6. Integriere in `stores/browser.ts`:
   - In `importSelected()`: Rufe `quickBrowse.recordBrowse()` auf
   - Neue Action `openQuickBrowse(contextId: string)`: LÃ¤dt letzte Suche fÃ¼r Context
7. Integriere in `stores/control.ts`:
   - Nur verdrahten, wenn ein passender Trigger bereits existiert; keine neuen Buttons
   - Bei Trigger: Rufe `browser.openQuickBrowse(currentPadId)` auf
8. Schreibe Tests in `tests/unitTests/quickBrowse.spec.ts`:
   - Testen der History-Aufzeichnung
   - Testen von getLastBrowse()
   - Testen von restoreBrowse()
   - Testen der Context-Gruppierung

**Constraints:**
- Client-only Persistence (localStorage) nur hinter Guard `import.meta.client`.

**Context-ID-Schema:**
- Pads: `pad-{index}` (z.B. "pad-0")
- Plugin-Slots: `plugin-{soundIndex}-{slotIndex}`
- Sounds: `sound-{index}`

**Erfolg:** Quick-Browse funktioniert, History wird getrackt, Restore funktioniert, Tests grÃ¼n.

---

### Prompt 4.2: Tag-Management UI Flow

**Aufgabe:** Erweitere Browser-Store um Tag-Management mit Display-Overlay.

**Anforderungen:**
1. Ã–ffne `stores/browser.ts`
2. FÃ¼ge zum State hinzu:
   ```typescript
   tagDialogOpen: boolean
   tagDialogItemId: string | null
   availableTags: string[]  // Global alle vorhandenen Tags
   ```
3. Implementiere Actions:
   - `openTagDialog(itemId: string)`: Ã–ffnet Dialog, lÃ¤dt Tags
   - `closeTagDialog()`: SchlieÃŸt Dialog
   - `addTagToSelected(tag: string)`: FÃ¼gt Tag zum aktuellen Item hinzu
   - `removeTagFromSelected(tag: string)`: Entfernt Tag vom Item
   - `getAvailableTags()`: Gibt alle verwendeten Tags zurÃ¼ck
4. Implementiere Tag-Sammlung:
   - Beim App-Start: Scanne alle Library-Items, sammle Tags
   - Speichere in `availableTags`
   - Update bei jedem Import
5. Integriere 4D-Encoder fÃ¼r Tag-Dialog:
   - Wenn `tagDialogOpen === true`:
     - Encoder-Felder zeigen verfÃ¼gbare Tags
     - Turn scrollt durch Tags
     - Press fÃ¼gt Tag hinzu/entfernt Tag
     - Tilt right schlieÃŸt Dialog
6. Update Display-Models:
   - Wenn Tag-Dialog offen und Renderer unterstÃ¼tzt Overlay: Overlay-View
   - Linkes Display: "Add Tag" + verfÃ¼gbare Tags (mit Checkbox wenn bereits zugewiesen)
   - Rechtes Display: Aktuelle Tags des Items (mit Remove-Option)
7. Integriere in Control-Store:
   - Nur verdrahten, wenn ein Soft-Button "Tag" bereits existiert
   - In Tag-Dialog: Button "Close" schlieÃŸt Dialog (nur wenn vorhanden)
8. Schreibe Tests in `tests/unitTests/tagManagement.spec.ts`:
   - Testen der Tag-Dialog-Ã–ffnung
   - Testen von Add/Remove Tag
   - Testen der availableTags-Sammlung
   - Testen der Encoder-Navigation im Tag-Dialog

**UI-Flow (ohne Template-Ã„nderungen):**
1. User wÃ¤hlt Item in Browser-Liste
2. User drÃ¼ckt Soft-Button "Tag"
3. Display wechselt zu Tag-Dialog (via Display-Model)
4. User navigiert mit 4D-Encoder, fÃ¼gt Tags hinzu
5. User drÃ¼ckt "Close" oder Tilt right
6. Display kehrt zu Browser-Liste zurÃ¼ck

**Erfolg:** Tag-Dialog funktioniert, Tags kÃ¶nnen hinzugefÃ¼gt/entfernt werden, Tests grÃ¼n.

---

### Prompt 4.3: Category/Product/Bank Hierarchie

**Aufgabe:** Erweitere `services/libraryRepository.ts` um hierarchische Metadaten.

**Anforderungen:**
1. Ã–ffne `services/libraryRepository.ts`
2. Erweitere `LibraryItem` Interface (siehe browserplan.md, Abschnitt K):
   ```typescript
   category?: string
   product?: string
   bank?: string
   subBank?: string
   character?: string
   vendor?: 'factory' | 'user'
   ```
3. Erweitere `LibraryRepository` Interface:
   ```typescript
   getCategories(): Promise<string[]>
   getProducts(category?: string): Promise<string[]>
   getBanks(product?: string): Promise<string[]>
   getSubBanks(bank?: string): Promise<string[]>
   ```
4. Implementiere Hierarchie-Queries in `createLocalRepository()`:
   - Scanne alle Items, sammle unique Werte
   - Bei Filter-Parameter: Filtere auf Parent-Wert
   - Beispiel: `getProducts('Drums')` gibt nur Products in Category "Drums"
5. Update `importDirectory()` (von Prompt 2.2):
   - Nutze verbesserte `extractMetadataFromPath()` Funktion
   - Setze alle Metadaten-Felder
6. Integriere in `stores/browser.ts`:
   - Update `getAvailableOptions()`:
     - FÃ¼r "category": Rufe `repo.getCategories()` auf
     - FÃ¼r "product": Rufe `repo.getProducts(filters.category)` auf
     - FÃ¼r "bank": Rufe `repo.getBanks(filters.product)` auf
     - FÃ¼r "subBank": Rufe `repo.getSubBanks(filters.bank)` auf
   - Update `applyFilters()`: Filtere nach allen hierarchischen Feldern
7. Update 4D-Encoder-Felder:
   - Category-Feld: Optionen von `getCategories()`
   - Product-Feld: Optionen abhÃ¤ngig von gewÃ¤hlter Category
   - Bank-Feld: Optionen abhÃ¤ngig von gewÃ¤hltem Product
   - SubBank-Feld: Optionen abhÃ¤ngig von gewÃ¤hlter Bank
8. Schreibe Tests in `tests/unitTests/libraryHierarchy.spec.ts`:
   - Testen der Hierarchie-Queries
   - Testen der Filter-Kaskade (Category â†’ Product â†’ Bank)
   - Testen der Metadaten-Extraktion aus Pfaden
   - Neue Repo-Methoden optional oder via Extension-Interface; alle Implementierungen/Mocks anpassen.

**Pfad-Schema:**
```
/Drums/808/Kicks/Deep/kick_01.wav
 ^cat   ^prod ^bank ^sub
```

**Erfolg:** Hierarchie funktioniert, Filter sind abhÃ¤ngig voneinander, Tests grÃ¼n.

---

## ZusÃ¤tzliche Prompts

### Bonus Prompt: Missing Samples Dialog

**Aufgabe:** Implementiere Missing-Samples-Dialog-Logik (Optional).

**Anforderungen:**
1. Erstelle `composables/useMissingSamples.ts`
2. Implementiere Detection:
   - Beim Pattern/Soundbank-Laden: PrÃ¼fe ob alle Sample-Pfade existieren
   - Sammle fehlende Samples
3. Implementiere Dialog-State:
   ```typescript
   interface MissingSample {
     id: string
     name: string
     originalPath: string
     usedIn: string[]  // Sound/Group-IDs die dieses Sample nutzen
   }
   
   function useMissingSamples() {
     const missingSamples = ref<MissingSample[]>([])
     
     function detectMissing(): Promise<void>
     function ignoreSample(id: string): void
     function ignoreAll(): void
     function findSample(id: string, newPath: string): void
     function purgeSample(id: string): void
   }
   ```
4. Integriere in Load-Flow:
   - Nach Pattern-Load: Rufe `detectMissing()` auf
   - Wenn missingSamples.length > 0: Ã–ffne Dialog
5. Dialog-UI via Display-Models:
   - Linkes Display: Liste fehlender Samples
   - Rechtes Display: Aktionen (IGNORE, IGNORE ALL, FIND, PURGE)
6. Schreibe Tests

**Erfolg:** Dialog erkennt fehlende Samples, bietet Aktionen an.

---

### Bonus Prompt: Performance-Optimierung

**Aufgabe:** Optimiere Browser-Performance fÃ¼r groÃŸe Libraries.

**Anforderungen:**
1. Implementiere Virtual Scrolling fÃ¼r Ergebnisliste (>100 Items)
2. Implementiere Search-Debouncing (300ms)
3. Implementiere Caching fÃ¼r Category/Product-Listen
4. Migriere von localStorage zu IndexedDB (wenn Library >1000 Items)
5. Implementiere Lazy-Loading fÃ¼r Thumbnails/Waveforms
6. Schreibe Performance-Tests

**Erfolg:** Browser bleibt flÃ¼ssig bei 10.000+ Items.

> Hinweis: Bonus-Prompts (Missing Samples, Performance) beinhalten UI/Infra-Ã„nderungen und sind nur auszufÃ¼hren, wenn UI-Ã„nderungen explizit erlaubt werden.

---

## Prompts fÃ¼r Tests

### Test-Prompt: Integration-Tests

**Aufgabe:** Schreibe umfassende Integration-Tests.

**Anforderungen:**
1. Erweitere `tests/unitTests/controlBrowserIntegration.spec.ts`
2. Teste komplette Workflows:
   - Browser Ã¶ffnen â†’ Filter setzen â†’ Suche â†’ Item laden
   - Recent Files â†’ Quick-Browse â†’ Restore â†’ Load
   - Favorites â†’ Toggle â†’ Filter â†’ Load
   - Preview â†’ Play â†’ Stop â†’ Load
3. Teste Edge-Cases:
   - Leere Ergebnisliste
   - Permission Denial (File System)
   - Import-Fehler
   - Fehlende Samples

**Erfolg:** Alle Workflows getestet, Tests grÃ¼n.

---

## Reihenfolge der AusfÃ¼hrung

FÃ¼hre die Prompts in folgender Reihenfolge aus:

1. **Phase 1** (Kern-Navigation):
   - Prompt 1.1 (4D-Encoder)
   - Prompt 1.2 (Browser-Filter)
   - Prompt 1.3 (Control-Integration)

2. **Phase 2** (File System & Import):
   - Prompt 2.1 (File System API)
   - Prompt 2.2 (Import Workflow)
   - Prompt 2.3 (Recent Files)

3. **Phase 3** (Features):
   - Prompt 3.1 (Favorites)
   - Prompt 3.2 (Preview)
   - Prompt 3.3 (Sortierung)

4. **Phase 4** (Advanced):
   - Prompt 4.1 (Quick-Browse)
   - Prompt 4.2 (Tag-Management)
   - Prompt 4.3 (Hierarchie)

5. **Optional** (Bonus):
   - Bonus Prompt: Missing Samples
   - Bonus Prompt: Performance
   - Test-Prompt: Integration-Tests

Zwischen den Phasen: Tests laufen lassen und Lint-Checks durchfÃ¼hren.

---

## Hinweise fÃ¼r Agenten

- **Constraints beachten:** Keine UI-Ã„nderungen (Pug/Vuetify), nur Logik
- **Tests zuerst:** Implementiere Tests parallel oder vor der Implementierung
- **Kleine Commits:** Jeder Prompt = 1-3 Commits
- **Dokumentation:** JSDoc fÃ¼r alle neuen Funktionen
- **Backward-KompatibilitÃ¤t:** Bestehende Features nicht brechen
- **Performance:** Denke an Caching und Lazy-Loading

Bei Fragen oder Unklarheiten: Siehe `browserplan.md` fÃ¼r Details.



=========================================
File: assets/browserplan.md
=========================================

# Browser-Implementierungsplan fÃ¼r Drumcomputer

## Ãœberblick

Basierend auf dem MASCHINE MK3 Manual (Seiten 173-238) und der bestehenden Codebasis wird dieser Plan die fehlenden Browser-Funktionen definieren, die implementiert werden mÃ¼ssen, damit der Browser vollstÃ¤ndig funktioniert wie auf der Hardware.

**Ziel:** Lokales Dateisystem durchsuchbar machen, 4-D-Encoder-Navigation implementieren, und alle Browser-Features aus dem Manual umsetzen.

**Harte Constraints:**
- Keine UI-Ã„nderungen (keine Pug-Templates, Vuetify-Komponenten, CSS, Buttons)
- Nur Logik: Stores, Services, Composables, Methoden, Events
- DrumMachine bleibt zentral fÃ¼r Mode-Switching, Import, Auswahl, Preview/Load-Flow
- Minimal-invasive Ã„nderungen
- Tests mÃ¼ssen grÃ¼n bleiben

## Bestehende Implementierung

### Bereits vorhanden:
- **Store:** `stores/browser.ts` mit Modes (LIBRARY, FILES), Query, Results, File-Listing
- **Store:** `stores/control.ts` mit Browser-Pages, Soft-Buttons, Encoder-Params, Display-Models
- **Services:** 
  - `services/fileSystemRepository.ts` - Memory-basiertes Dateisystem (Stub)
  - `services/libraryRepository.ts` - LocalStorage-basierte Library mit Tags, Search, Import
- **Types:** `types/library.ts` - BrowserMode, BrowserResultItem, BrowserFileEntry
- **Components:**
  - `components/control/DualDisplay.vue` - Zeigt Browser/File-Views in beiden Displays
  - `components/control/SoftButtonStrip.vue` - 8 Soft-Buttons
  - `components/placeholders/FourDEncoderPlaceholder.vue` - Placeholder fÃ¼r 4D-Encoder
  - `components/SampleBrowser.vue` - Minimaler Stub

### Integration:
- `DrumMachine.vue` bindet Control-Store, zeigt DualDisplay und SoftButtonStrip
- Control-Store hat `applyAction()` fÃ¼r BROWSER_LOAD, BROWSER_SEARCH, BROWSER_CLEAR, etc.
- Browser-Store hat `toDisplayModels()` fÃ¼r Display-Darstellung
- Control-Store nutzt `setBrowserDisplay()` um Browser-Models zu Ã¼bernehmen

## Browser-Funktionen aus Manual (Seiten 173-238)

### 1. Dual-Display-Organisation (Seite 179)

**Linkes Display:** Suche eingrenzen durch:
- Dateityp-Filter (Type)
- Inhalte-Typ (Factory vs User)
- Produkt-Kategorie
- Produkt
- Bank
- Sub-Bank

**Rechtes Display:** Suche verfeinern durch:
- Type-Auswahl
- Character-Auswahl
- Ergebnisliste mit Details
- Drehen des 4-D-Encoders zum Navigieren
- DrÃ¼cken des 4-D-Encoders oder Button 8 (LOAD) zum Laden

### 2. 4-D-Encoder-Navigation (Seite 180)

Der 4-D-Encoder ermÃ¶glicht:
- **Links/Rechts bewegen:** Feld-Auswahl (zwischen Filtern wechseln)
- **Drehen:** Wert im ausgewÃ¤hlten Feld Ã¤ndern
- **Nach rechts bewegen:** Zur Ergebnisliste wechseln
- **Drehen in Ergebnisliste:** Element auswÃ¤hlen
- **DrÃ¼cken:** Auswahl laden

DÃ¼nne Klammern zeigen das ausgewÃ¤hlte Feld an.

### 3. Produkt-WÃ¤hler (Seite 180)

Funktion zum Eingrenzen auf:
- Produkt-Kategorie
- Bestimmtes Produkt
- Spezifische Bank des Produkts
- Direktes Laden von Produkt mit Preset-Datei

### 4. FILES-Bereich (Seite 230-232)

Kontext-MenÃ¼-Befehle:
- **Add to Favorites:** Ordner zu Favoriten hinzufÃ¼gen
- **Import to Library:** Ordner in Library importieren
- **Refresh:** Liste neu einlesen
- **Find in Explorer/Finder:** Ordner im OS Ã¶ffnen (nicht im Browser mÃ¶glich)
- **Sort by Name:** Nach Namen sortieren
- **Sort by Date:** Nach Datum sortieren

### 5. Library-Import (Seiten 231-232)

Workflow:
1. Ordner im FILES-Bereich auswÃ¤hlen
2. "Import to Library" auswÃ¤hlen
3. Dateien werden als User-Content in Library aufgenommen
4. Pfade in Preferences gespeichert
5. Dateien bleiben am ursprÃ¼nglichen Ort (nur Referenz)

### 6. Missing Samples (Seiten 233-234)

Dialog zum Auffinden fehlender Samples:
- IGNORE: Sample ignorieren
- IGNORE ALL: Alle ignorieren
- SpÃ¤ter: "Purge Missing Samples" oder "Find Missing Samples" im Kontext-MenÃ¼

### 7. Quick-Browse (Seiten 235-238)

Schnelles Wiederaufrufen einer vorherigen Suchanfrage:
- FÃ¼r Instrumenten-/Effekt-Presets
- FÃ¼r Samples
- Im Control-Modus: Button drÃ¼cken â†’ Quick-Browse Ã¶ffnet sich mit letzter Suche
- Im Browse-Modus: Zugriff auf Groups und Sounds

### 8. Soft-Button-Funktionen (aus control.ts, Seite 130-140)

Browser-Page hat bereits:
- **Search** / SHIFT: Plug-In Menu
- **Type:** Dateityp filtern
- **Tag:** Tags filtern
- **Favorites:** Favoriten anzeigen
- **Prehear** / SHIFT: Stop - Sample vorhÃ¶ren
- **Load:** Auswahl laden
- **Replace:** Auswahl ersetzen
- **Clear:** Auswahl lÃ¶schen

Recent-Page:
- **Recent:** Letzte Dateien
- **Clear Recent**
- **Fav:** Als Favorit markieren
- **Tag:** Tag hinzufÃ¼gen
- **Load Recent**
- **Prehear**
- **Replace**
- **Stop**

## Fehlende Implementierungen

### A. File System Access API Integration

**Problem:** `fileSystemRepository.ts` ist derzeit nur ein Memory-Stub.

**LÃ¶sung:** Neue Implementierung mit Browser File System Access API (wo verfÃ¼gbar):

```typescript
// services/fileSystemRepository.ts - Neue Klasse
class BrowserFileSystemRepository implements FileSystemRepository {
  private rootHandle: FileSystemDirectoryHandle | null = null
  
  async requestAccess(): Promise<boolean>
  async listDir(path: string): Promise<DirectoryListing>
  async stat(path: string): Promise<{ isDir: boolean }>
  async readFileMeta(path: string): Promise<{ name: string; extension?: string }>
  async readFileBlob(path: string): Promise<Blob>
}
```

**Fallback:** Wenn File System Access API nicht verfÃ¼gbar:
- Weiter Memory-FS nutzen
- Oder File-Input-Dialog fÃ¼r Einzel-Uploads

### B. 4-D-Encoder-Logik

**Problem:** Placeholder-Komponente existiert, aber keine Navigation-Logik.

**LÃ¶sung:** Neue Composable `composables/use4DEncoder.ts`:

```typescript
type EncoderAxis = 'vertical' | 'horizontal'
type EncoderMode = 'field-select' | 'value-adjust' | 'list-navigate'

interface Encoder4DState {
  mode: EncoderMode
  currentAxis: EncoderAxis
  selectedFieldIndex: number
  selectedListIndex: number
  fields: EncoderField[]
}

interface EncoderField {
  id: string
  label: string
  value: string | number
  options?: string[]
}

function use4DEncoder() {
  const state = reactive<Encoder4DState>({ ... })
  
  function tiltHorizontal(direction: 'left' | 'right'): void
  function tiltVertical(direction: 'up' | 'down'): void  
  function turn(delta: number): void
  function press(): void
  
  function setFields(fields: EncoderField[]): void
  function getSelectedField(): EncoderField | null
  function getSelectedValue(): any
  
  return { state, tiltHorizontal, tiltVertical, turn, press, setFields, ... }
}
```

**Integration:**
- `stores/control.ts` nutzt `use4DEncoder()` fÃ¼r Browser/File-Modi
- Browser-Store liefert Felder (Type, Tag, Category, etc.)
- Encoder-State synchronisiert mit Display-Models

### C. Erweiterte Browser-Filter

**Problem:** Browser-Store hat nur einfache Query-Suche.

**LÃ¶sung:** Erweiterte Filter in `stores/browser.ts`:

```typescript
type BrowserFilters = {
  fileType?: 'sample' | 'kit' | 'pattern' | 'preset' | 'all'
  contentType?: 'factory' | 'user' | 'all'
  category?: string
  product?: string
  bank?: string
  subBank?: string
  character?: string
  tags?: string[]
  favorites?: boolean
}

// In useBrowserStore
state: {
  // ... existing
  filters: BrowserFilters
  availableCategories: string[]
  availableProducts: string[]
  availableBanks: string[]
}

actions: {
  setFilter(key: keyof BrowserFilters, value: any): void
  clearFilters(): void
  applyFilters(): void
  getAvailableOptions(filterKey: string): string[]
}
```

### D. Favorites-System

**Problem:** Favoriten-Funktion nicht implementiert.

**LÃ¶sung:** Erweiterung von `services/libraryRepository.ts`:

```typescript
interface LibraryRepository {
  // ... existing methods
  addToFavorites(itemId: string): Promise<void>
  removeFromFavorites(itemId: string): Promise<void>
  getFavorites(): Promise<LibraryItem[]>
  isFavorite(itemId: string): Promise<boolean>
}

// Persistence Ã¼ber localStorage
const FAVORITES_KEY = 'drumcomputer_favorites_v1'
```

**Integration:**
- Soft-Button "Favorites" filtert Ergebnisse
- Browser-Store Action `toggleFavorite(id: string)`
- Display zeigt Favoriten-Status (z.B. Stern-Symbol in Subtitle)

### E. Recent-Files-Tracking

**Problem:** Recent-Page existiert in Control-Store, aber keine Tracking-Logik.

**LÃ¶sung:** Neue Composable `composables/useRecentFiles.ts`:

```typescript
interface RecentFileEntry {
  id: string
  path: string
  name: string
  timestamp: number
  type: 'sample' | 'kit' | 'pattern' | 'preset'
}

function useRecentFiles() {
  const maxRecent = 50
  
  function addRecent(entry: Omit<RecentFileEntry, 'timestamp'>): void
  function getRecent(limit?: number): RecentFileEntry[]
  function clearRecent(): void
  function removeRecent(id: string): void
  
  return { addRecent, getRecent, clearRecent, removeRecent }
}
```

**Persistence:** localStorage mit SchlÃ¼ssel `drumcomputer_recent_files_v1`

**Integration:**
- Browser-Store nutzt `useRecentFiles()` fÃ¼r Recent-Mode
- Bei jedem `importSelected()` â†’ `addRecent()`
- Control-Store Recent-Page zeigt `getRecent()`

### F. Prehear/Preview-Funktion

**Problem:** Prehear-Button existiert, aber keine Audio-Preview.

**LÃ¶sung:** Neue Composable `composables/useSamplePreview.client.ts`:

```typescript
interface PreviewState {
  isPlaying: boolean
  currentFile: string | null
  progress: number // 0-1
  duration: number
}

function useSamplePreview() {
  const audioContext = inject<AudioContext>('audioContext')
  const state = reactive<PreviewState>({ ... })
  
  async function loadAndPlay(path: string, blob?: Blob): Promise<void>
  function stop(): void
  function pause(): void
  function resume(): void
  function seek(position: number): void
  
  return { state, loadAndPlay, stop, pause, resume, seek }
}
```

**Integration:**
- Browser-Store Action `prehearSelected()`
- Control-Store `applyAction('BROWSER_PREHEAR')` â†’ `browser.prehearSelected()`
- Preview-Parameter in Encoder-Slots (Start, End, Tune, etc.)

### G. Quick-Browse-System

**Problem:** Quick-Browse nicht implementiert.

**LÃ¶sung:** Neue Composable `composables/useQuickBrowse.ts`:

```typescript
interface BrowseHistoryEntry {
  timestamp: number
  mode: BrowserMode
  query: string
  filters: BrowserFilters
  selectedId: string | null
  contextType: 'sample' | 'preset' | 'group' | 'sound'
  contextId: string // Pad-ID, Slot-ID, etc.
}

function useQuickBrowse() {
  const history: BrowseHistoryEntry[] = reactive([])
  
  function recordBrowse(entry: Omit<BrowseHistoryEntry, 'timestamp'>): void
  function getLastBrowse(contextId: string): BrowseHistoryEntry | null
  function restoreBrowse(entry: BrowseHistoryEntry): void
  function clearHistory(): void
  
  return { history, recordBrowse, getLastBrowse, restoreBrowse, clearHistory }
}
```

**Integration:**
- Bei `importSelected()` â†’ `recordBrowse()` mit Kontext
- Soft-Button oder Keyboard-Shortcut Ã¶ffnet Quick-Browse
- Browser-Store lÃ¤dt letzte Suche via `restoreBrowse()`

### H. Sortierung und Anzeige-Optionen

**Problem:** Keine Sortierung implementiert.

**LÃ¶sung:** Erweiterung von `stores/browser.ts`:

```typescript
type SortMode = 'name-asc' | 'name-desc' | 'date-asc' | 'date-desc' | 'relevance'

// In state
sortMode: SortMode

// Actions
setSortMode(mode: SortMode): void
sortResults(): void
```

**Integration:**
- File-Mode: Kontext-MenÃ¼-Simulation Ã¼ber Soft-Button
- Encoder-Parameter fÃ¼r Sort-Mode

### I. Import-Workflow mit Fortschritt

**Problem:** Import geschieht sofort ohne Feedback.

**LÃ¶sung:** Erweiterung von `services/libraryRepository.ts`:

```typescript
interface ImportProgress {
  total: number
  completed: number
  current: string
  errors: string[]
}

interface LibraryRepository {
  // ... existing
  importDirectory(
    path: string, 
    options?: { recursive?: boolean },
    onProgress?: (progress: ImportProgress) => void
  ): Promise<void>
}
```

**Integration:**
- Browser-Store Action `importDirectory(path, onProgress)`
- Display zeigt Fortschritt (optional Ã¼ber status-Panel)

### J. Tag-Management

**Problem:** Tags existieren, aber kein UI-Flow.

**LÃ¶sung:** Erweiterung von `stores/browser.ts`:

```typescript
// Actions
async showTagDialog(itemId: string): Promise<void>
async addTagToSelected(tag: string): Promise<void>
async removeTagFromSelected(tag: string): Promise<void>
getAvailableTags(): string[]
```

**Integration:**
- Soft-Button "Tag" Ã¶ffnet Tag-Dialog (als Display-Overlay)
- Encoder navigiert durch existierende Tags
- Encoder + Press fÃ¼gt neues Tag hinzu

### K. Category/Product/Bank-Hierarchie

**Problem:** Library hat flache Struktur.

**LÃ¶sung:** Erweiterte Metadaten in `services/libraryRepository.ts`:

```typescript
interface LibraryItem {
  // ... existing
  category?: string
  product?: string
  bank?: string
  subBank?: string
  character?: string
  vendor?: 'factory' | 'user'
}

interface LibraryRepository {
  // ... existing
  getCategories(): Promise<string[]>
  getProducts(category?: string): Promise<string[]>
  getBanks(product?: string): Promise<string[]>
  getSubBanks(bank?: string): Promise<string[]>
}
```

**Import-Pipeline:**
- Beim Import Metadaten aus Dateinamen/Pfaden extrahieren
- Schema: `/Category/Product/Bank/SubBank/filename.wav`
- Fallback: User-definierte Kategorien

## Implementierungs-Reihenfolge (PrioritÃ¤t)

### Phase 1: Kern-Navigation (HÃ¶chste PrioritÃ¤t)
1. **4-D-Encoder-Composable** (`composables/use4DEncoder.ts`)
   - State-Management fÃ¼r Encoder-Modi
   - Tilt/Turn/Press-Logik
   - Feld-Navigation und Wert-Ã„nderung

2. **Browser-Filter-Erweiterung** (`stores/browser.ts`)
   - BrowserFilters-Type
   - setFilter/clearFilters/applyFilters Actions
   - Integration mit 4D-Encoder

3. **Control-Store 4D-Integration** (`stores/control.ts`)
   - use4DEncoder() einbinden fÃ¼r Browser-Mode
   - Encoder-Events auf Browser-Actions mappen
   - Display-Update bei Feld-Wechsel

### Phase 2: File System & Import
4. **File System Access API** (`services/fileSystemRepository.ts`)
   - BrowserFileSystemRepository-Klasse
   - requestAccess() fÃ¼r User-Permission
   - Directory-Listing mit echter FS-API
   - Fallback-Strategie

5. **Import-Workflow** (`services/libraryRepository.ts`)
   - importDirectory() mit Progress
   - Metadaten-Extraktion (Category/Product/Bank)
   - Fehlerbehandlung

6. **Recent Files Tracking** (`composables/useRecentFiles.ts`)
   - localStorage-basiertes Tracking
   - Integration in Browser-Store
   - Recent-Page-Anbindung

### Phase 3: Features
7. **Favorites-System** (`services/libraryRepository.ts`)
   - addToFavorites/removeFromFavorites
   - localStorage-Persistence
   - Filter-Integration

8. **Prehear/Preview** (`composables/useSamplePreview.client.ts`)
   - Audio-Preview mit Web Audio
   - Play/Stop/Seek
   - Encoder-Parameter (Start, End, Tune)

9. **Sortierung** (`stores/browser.ts`)
   - SortMode-State
   - sortResults() Action
   - Display-Integration

### Phase 4: Advanced Features
10. **Quick-Browse** (`composables/useQuickBrowse.ts`)
    - History-Tracking
    - Context-basierte Wiederherstellung
    - Soft-Button-Integration

11. **Tag-Management-UI-Flow** (`stores/browser.ts`)
    - Tag-Dialog als Display-Overlay
    - Encoder-Navigation durch Tags
    - Add/Remove Actions

12. **Category/Product/Bank-Hierarchie**
    - Erweiterte Metadaten
    - Hierarchische Filter
    - Encoder-Navigation durch Hierarchie

## Integration-Punkte mit DrumMachine

### Mode-Switching
```typescript
// DrumMachine.vue bereits vorhanden
handleModePress(mode: string, shiftMode?: string) {
  const control = useControlStore()
  control.setMode(this.shiftHeld && shiftMode ? shiftMode : mode)
  
  // Neu: Bei Browser-Mode
  if (mode === 'BROWSER' || mode === 'FILE') {
    const browser = useBrowserStore()
    const encoder4D = use4DEncoder()
    
    // Browser-Display aktualisieren
    control.setBrowserDisplay(browser.toDisplayModels())
    
    // 4D-Encoder-Felder setzen
    encoder4D.setFields(browser.getEncoderFields())
  }
}
```

### Import/Load-Flow
```typescript
// Browser-Store Action (erweitert)
async importSelected() {
  if (!this.files.selectedPath && !this.library.selectedId) return
  
  const repo = getLibraryRepository()
  const recent = useRecentFiles()
  
  if (this.mode === 'FILES' && this.files.selectedPath) {
    const item = await repo.importFile(this.files.selectedPath)
    recent.addRecent({ id: item.id, path: item.path, name: item.name, type: 'sample' })
  }
  
  // QuickBrowse aufzeichnen
  const quickBrowse = useQuickBrowse()
  quickBrowse.recordBrowse({
    mode: this.mode,
    query: this.library.query,
    filters: this.filters,
    selectedId: this.library.selectedId,
    contextType: 'sample',
    contextId: getCurrentPadId() // Von DrumMachine
  })
  
  await this.search()
  
  // Event an DrumMachine (falls Sample geladen werden soll)
  emit('sample-imported', item)
}
```

### Preview/Prehear
```typescript
// Browser-Store Action (neu)
async prehearSelected() {
  const preview = useSamplePreview()
  const path = this.files.selectedPath || this.getSelectedItemPath()
  
  if (!path) return
  
  // Load & Play
  await preview.loadAndPlay(path)
  
  // Encoder zeigt Preview-Parameter
  this.previewMode = true
}
```

## Event-Flow-Diagramm

```
User interagiert mit 4D-Encoder (tilt/turn/press)
    â†“
use4DEncoder() verarbeitet Input
    â†“
Browser-Store aktualisiert Filter/Selection
    â†“
Browser-Store ruft toDisplayModels() auf
    â†“
Control-Store.setBrowserDisplay(models)
    â†“
DualDisplay rendert aktualisierte Panels
    â†“
User drÃ¼ckt LOAD-Button (Soft-Button 6)
    â†“
Control-Store.pressSoftButton(5) â†’ applyAction('BROWSER_LOAD')
    â†“
Browser-Store.importSelected()
    â†“
LibraryRepository.importFile() + useRecentFiles.addRecent()
    â†“
DrumMachine erhÃ¤lt 'sample-imported' Event
    â†“
DrumMachine lÃ¤dt Sample in aktiven Pad
```

## Testing-Strategie

### Unit Tests
- `tests/unitTests/use4DEncoder.spec.ts` - Encoder-Logik
- `tests/unitTests/browserFilters.spec.ts` - Filter-Funktionen
- `tests/unitTests/recentFiles.spec.ts` - Recent-Tracking
- `tests/unitTests/favorites.spec.ts` - Favorites-System
- `tests/unitTests/quickBrowse.spec.ts` - Quick-Browse-History
- `tests/unitTests/samplePreview.spec.ts` - Preview-FunktionalitÃ¤t

### Integration Tests
- `tests/unitTests/controlBrowserIntegration.spec.ts` (bereits vorhanden, erweitern)
  - 4D-Encoder â†’ Browser-Store
  - Soft-Button â†’ Import
  - Preview â†’ Audio-Engine

### Component Tests
- `tests/componentTests/DualDisplay.component.spec.ts` (neu)
  - Browser-View Rendering
  - File-View Rendering
  - Display-Model-Updates

## Performance-Ãœberlegungen

### Lazy Loading
- Verzeichnislisten nur bei Bedarf laden
- Thumbnails/Waveforms asynchron nachladen
- Search-Debouncing (300ms)

### Caching
- Category/Product/Bank-Listen cachen
- Recent Files in Memory halten
- Favorites-Set als lokale Kopie

### Optimierung
- Virtuelle Listen fÃ¼r groÃŸe Ergebnismengen (>100 Items)
- Web Workers fÃ¼r File-Scanning (wo mÃ¶glich)
- IndexedDB fÃ¼r groÃŸe Libraries (>1000 Items)

## Fehlerbehandlung

### File System Access
- Permission denied â†’ Fallback auf Memory-FS oder File-Input
- Invalid path â†’ Error in Display
- Missing files â†’ "Missing Samples" Dialog (bereits im Manual)

### Import
- Unsupported format â†’ Skip mit Warning
- Duplicate â†’ Merge oder Skip (User-Option)
- Disk full â†’ Error-Dialog

### Preview
- Load error â†’ Toast-Notification
- Unsupported format â†’ Fallback auf Info-Display
- Playback error â†’ Stop & Clear

## Accessibility

### Keyboard-Navigation
- Tab durch Filter-Felder
- Arrow-Keys fÃ¼r Listen-Navigation
- Enter fÃ¼r Auswahl/Laden
- Escape fÃ¼r Abbrechen

### Screen-Reader
- Aria-Labels fÃ¼r alle Filter
- Aria-Live fÃ¼r Ergebnisanzahl
- Aria-Selected fÃ¼r aktives Element

### Fokus-Management
- Fokus bleibt auf aktivem Feld
- Nach Import â†’ Fokus auf Ergebnisliste
- Nach Clear â†’ Fokus auf Search-Field

## Dokumentation

### FÃ¼r Entwickler
- JSDoc fÃ¼r alle neuen Composables
- Inline-Kommentare fÃ¼r komplexe Logik
- README-Update mit Browser-Workflow

### FÃ¼r User
- Tooltip-Hints im Display
- Keyboard-Shortcuts-Ãœbersicht
- Quick-Start-Guide (optional)

## Offene Fragen

1. **Sollte BrowserFileSystemRepository als Feature-Flag implementiert werden?**
   - Pro: Schrittweise EinfÃ¼hrung, Fallback immer verfÃ¼gbar
   - Con: Mehr Code-KomplexitÃ¤t

2. **Sollten Favorites/Recent/Tags in IndexedDB statt localStorage?**
   - Pro: Bessere Performance bei vielen Items, strukturierte Queries
   - Con: Mehr Setup-Code, Browser-KompatibilitÃ¤t

3. **Sollte Preview-Audio separater AudioContext sein?**
   - Pro: UnabhÃ¤ngig von Main-Engine, keine StÃ¶rungen
   - Con: Mehr Ressourcen, mÃ¶gliche Permission-Issues

4. **Wie tief sollte die Hierarchie gehen? (Category â†’ Product â†’ Bank â†’ SubBank)**
   - Aktuell: 4 Ebenen wie im Manual
   - Alternative: Flache Tags mit Prefixes

## Abschluss

Dieser Plan deckt alle Browser-Funktionen aus dem MASCHINE MK3 Manual (Seiten 173-238) ab und definiert eine schrittweise Implementierung ohne UI-Ã„nderungen. Die Logik wird in Stores, Services und Composables gekapselt und Ã¼ber die bestehende DrumMachine-Komponente koordiniert.

**NÃ¤chster Schritt:** Review dieses Plans mit dem Team, dann Phase 1 starten.



=========================================
File: audio/engine/play/playStep.ts
=========================================

// Plays an AudioBuffer at a scheduled AudioContext time with a fixed gain stage.
export function playStepAt(
  ctx: AudioContext,
  buffer: AudioBuffer,
  atTime: number,
  gainValue = 1
): void {
  const source = ctx.createBufferSource()
  const gain = ctx.createGain()

  gain.gain.value = gainValue

  source.buffer = buffer
  source.connect(gain).connect(ctx.destination)

  source.start(atTime)
}



=========================================
File: audio/engine/stepResolver.ts
=========================================

import type { StepGrid, DrumPadId } from '../../types/drums'
import type { GridSpec } from '../../types/time'

export interface StepNote {
  buffer: AudioBuffer
  velocity: number
}

export function createStepNoteResolver(
  steps: StepGrid,
  gridSpec: GridSpec,
  buffersByPad: Record<DrumPadId, AudioBuffer>
): (stepIndex: number) => StepNote[] {
  return (stepIndex: number): StepNote[] => {
    const result: StepNote[] = []

    const barIndex = Math.floor(stepIndex / gridSpec.division)
    const stepInBar = stepIndex % gridSpec.division

    const step = steps[barIndex]?.[stepInBar]
    if (!step) {
      return result
    }

    ; (Object.entries(step) as [DrumPadId, { velocity: { value: number } }][])
      .forEach(([padId, note]) => {
        const buffer = buffersByPad[padId]
        if (!buffer) {
          return
        }

        result.push({
          buffer,
          velocity: note.velocity.value
        })
      })

    return result
  }
}



=========================================
File: audio/engine/transportAudioHooks.ts
=========================================

import { velocityToGain } from '../../domain/velocity/velocityToGain'

export function createTransportAudioHooks(
  ctx: AudioContext,
  getStepNotes: (stepIndex: number) => Array<{
    buffer: AudioBuffer
    velocity: number
  }>
) {
  return {
    onStep(stepIndex: number, audioTime: number): void {
      const notes = getStepNotes(stepIndex)

      for (const note of notes) {
        const gainValue = velocityToGain(note.velocity)

        const source = ctx.createBufferSource()
        const gain = ctx.createGain()

        gain.gain.value = gainValue

        source.buffer = note.buffer
        source.connect(gain).connect(ctx.destination)
        source.start(audioTime)
      }
    }
  }
}



=========================================
File: audio/fxGraph.ts
=========================================

import type { FxSettings } from '@/types/audio'
import type { RandomSource } from '@/utils/seededRandom'

export interface FxGraphNodes {
  fxInput: GainNode
  driveNode: WaveShaperNode
  filterNode: BiquadFilterNode
  dryGain: GainNode
  wetGain: GainNode
  reverbNode: ConvolverNode
  connected: boolean
}

export const createFxGraph = (ctx: BaseAudioContext): FxGraphNodes => ({
  fxInput: ctx.createGain(),
  driveNode: ctx.createWaveShaper(),
  filterNode: (() => {
    const node = ctx.createBiquadFilter()
    node.type = 'lowpass'
    return node
  })(),
  dryGain: ctx.createGain(),
  wetGain: ctx.createGain(),
  reverbNode: ctx.createConvolver(),
  connected: false
})

export const connectFxGraph = (graph: FxGraphNodes, masterGain: GainNode) => {
  if (graph.connected) return
  graph.fxInput.connect(graph.driveNode)
  graph.driveNode.connect(graph.filterNode)
  graph.filterNode.connect(graph.dryGain)
  graph.filterNode.connect(graph.reverbNode)
  graph.reverbNode.connect(graph.wetGain)
  graph.dryGain.connect(masterGain)
  graph.wetGain.connect(masterGain)
  graph.connected = true
}

export const updateFxGraph = (ctx: BaseAudioContext, graph: FxGraphNodes, snapshot: FxSettings, rng: RandomSource) => {
  const now = ctx.currentTime
  const frequencyValue = snapshot.filter.enabled ? snapshot.filter.frequency : ctx.sampleRate / 2
  graph.filterNode.frequency.setValueAtTime(frequencyValue, now)
  graph.filterNode.Q.setValueAtTime(snapshot.filter.q, now)

  const amount = snapshot.drive.enabled ? snapshot.drive.amount : 0
  graph.driveNode.curve = createDriveCurve(amount)

  const mix = snapshot.reverb.enabled ? snapshot.reverb.mix : 0
  graph.dryGain.gain.setValueAtTime(Math.max(0, 1 - mix), now)
  graph.wetGain.gain.setValueAtTime(Math.max(0, Math.min(1, mix)), now)

  if (snapshot.reverb.enabled) {
    if (!graph.reverbNode.buffer) {
      graph.reverbNode.buffer = createImpulseResponse(ctx, rng)
    }
  } else if (graph.reverbNode.buffer) {
    graph.reverbNode.buffer = null
  }
}

const createDriveCurve = (amount: number) => {
  const k = Math.max(0, amount) * 50 + 1
  const samples = 1024
  const curve = new Float32Array(samples)
  for (let i = 0; i < samples; i += 1) {
    const x = (i * 2) / samples - 1
    curve[i] = ((1 + k) * x) / (1 + k * Math.abs(x))
  }
  return curve
}

const createImpulseResponse = (ctx: BaseAudioContext, rng: RandomSource, duration = 1.2, decay = 2.5) => {
  const length = Math.max(1, Math.floor(ctx.sampleRate * duration))
  const impulse = ctx.createBuffer(2, length, ctx.sampleRate)
  for (let channel = 0; channel < impulse.numberOfChannels; channel += 1) {
    const channelData = impulse.getChannelData(channel)
    for (let i = 0; i < length; i += 1) {
      channelData[i] = (rng() * 2 - 1) * Math.pow(1 - i / length, decay)
    }
  }
  return impulse
}



=========================================
File: components/DrumMachine.vue
=========================================

<template>
    <div class="hardware-stage">
      <div class="device-hardware" aria-label="Maschine MK3 layout placeholder">
        <div class="top-row">
          <div class="control-stack">
            <div class="control-area">
              <div class="control-fixed" aria-label="Fixed control buttons">
                <div class="control-btn-grid" aria-label="Control buttons">
                  <button
                    class="control-btn r1 c1"
                    type="button"
                    :class="{ active: isActiveMode('CHANNEL') }"
                    :title="modeTooltip('CHANNEL', 'CHANNEL', 'MIDI')"
                    :aria-label="modeTooltip('CHANNEL', 'CHANNEL', 'MIDI')"
                    @click="handleModePress('CHANNEL', 'CHANNEL_MIDI')"
                  >
                    <span class="control-btn__main">CHANNEL</span>
                    <span class="control-btn__sub">MIDI</span>
                  </button>

                  <button
                    class="control-btn r1 c2"
                    type="button"
                    :class="{ active: isActiveMode('PLUGIN') }"
                    :title="modeTooltip('PLUGIN', 'PLUG-IN', 'Instance')"
                    :aria-label="modeTooltip('PLUGIN', 'PLUG-IN', 'Instance')"
                    @click="handleModePress('PLUGIN', 'PLUGIN_INSTANCE')"
                  >
                    <span class="control-btn__main">PLUG-IN</span>
                    <span class="control-btn__sub">Instance</span>
                  </button>

                  <button
                    class="control-btn r2 c1"
                    type="button"
                    :class="{ active: isActiveMode('ARRANGER') }"
                    :title="modeTooltip('ARRANGER', 'ARRANGER')"
                    :aria-label="modeTooltip('ARRANGER', 'ARRANGER')"
                    @click="handleModePress('ARRANGER')"
                  >
                    <span class="control-btn__main">ARRANGER</span>
                  </button>

                  <button
                    class="control-btn r2 c2"
                    type="button"
                    :class="{ active: isActiveMode('MIXER') }"
                    :title="modeTooltip('MIXER', 'MIXER')"
                    :aria-label="modeTooltip('MIXER', 'MIXER')"
                    @click="handleModePress('MIXER')"
                  >
                    <span class="control-btn__main">MIXER</span>
                  </button>

                  <button
                    class="control-btn r3 c1"
                    type="button"
                    :class="{ active: isActiveMode('BROWSER') }"
                    :title="modeTooltip('BROWSER', 'BROWSER', '+Plug-In')"
                    :aria-label="modeTooltip('BROWSER', 'BROWSER', '+Plug-In')"
                    @click="handleModePress('BROWSER', 'BROWSER_PLUGIN_MENU')"
                  >
                    <span class="control-btn__main">BROWSER</span>
                    <span class="control-btn__sub">+Plug-In</span>
                  </button>

                  <button
                    class="control-btn r3 c2"
                    type="button"
                    :class="{ active: isActiveMode('SAMPLING') }"
                    :title="modeTooltip('SAMPLING', 'SAMPLING')"
                    :aria-label="modeTooltip('SAMPLING', 'SAMPLING')"
                    @click="handleModePress('SAMPLING')"
                  >
                    <span class="control-btn__main">SAMPLING</span>
                  </button>

                  <button
                    class="control-btn control-btn--icon r4 c1"
                    type="button"
                    aria-label="Page backwards"
                    :title="pageButtonTitle('prev')"
                    @click="prevPage"
                  >
                    <span class="control-btn__main">â—€</span>
                  </button>

                  <button
                    class="control-btn control-btn--icon r4 c2"
                    type="button"
                    aria-label="Page forwards"
                    :title="pageButtonTitle('next')"
                    @click="nextPage"
                  >
                    <span class="control-btn__main">â–¶</span>
                  </button>

                  <button
                    class="control-btn r5 c1"
                    type="button"
                    :class="{ active: isActiveMode('FILE') }"
                    :title="modeTooltip('FILE', 'FILE', 'Save')"
                    :aria-label="modeTooltip('FILE', 'FILE', 'Save')"
                    @click="handleModePress('FILE', 'FILE_SAVE')"
                  >
                    <span class="control-btn__main">FILE</span>
                    <span class="control-btn__sub">Save</span>
                  </button>

                  <button
                    class="control-btn r5 c2"
                    type="button"
                    :class="{ active: isActiveMode('SETTINGS') }"
                    :title="modeTooltip('SETTINGS', 'SETTINGS')"
                    :aria-label="modeTooltip('SETTINGS', 'SETTINGS')"
                    @click="handleModePress('SETTINGS')"
                  >
                    <span class="control-btn__main">SETTINGS</span>
                  </button>

                  <button
                    class="control-btn r6 c1"
                    type="button"
                    :class="{ active: isActiveMode('AUTO') }"
                    :title="modeTooltip('AUTO', 'AUTO')"
                    :aria-label="modeTooltip('AUTO', 'AUTO')"
                    @click="handleModePress('AUTO')"
                  >
                    <span class="control-btn__main">AUTO</span>
                  </button>

                  <button
                    class="control-btn r6 c2"
                    type="button"
                    :class="{ active: isActiveMode('MACRO') }"
                    :title="modeTooltip('MACRO', 'MACRO', 'Set')"
                    :aria-label="modeTooltip('MACRO', 'MACRO', 'Set')"
                    @click="handleModePress('MACRO', 'MACRO_SET')"
                  >
                    <span class="control-btn__main">MACRO</span>
                    <span class="control-btn__sub">Set</span>
                  </button>
                </div>
              </div>
              <div class="control-core">
                <div class="soft-row">
                  <div class="soft-row-grid">
                    <SoftButtonStrip
                      :buttons="activeSoftButtons"
                      :shift-held="shiftHeld"
                      @press="pressSoftButton"
                    />
                  </div>
                </div>
                <div class="display-block">
                  <div class="display-grid">
                    <DualDisplay
                      :left-model="leftDisplayModel"
                      :right-model="rightDisplayModel"
                      :mode-title="activeMode"
                      :page-label="pageLabel"
                      :param-slots-left="paramSlotsLeft"
                      :param-slots-right="paramSlotsRight"
                    />
                  </div>
                  <div class="display-param-labels" aria-hidden="true">
                    <span class="param-label" :title="softLabels[0]">{{ softLabels[0] }}</span>
                    <span class="param-label" :title="softLabels[1]">{{ softLabels[1] }}</span>
                    <span class="param-label" :title="softLabels[2]">{{ softLabels[2] }}</span>
                    <span class="param-label" :title="softLabels[3]">{{ softLabels[3] }}</span>
                    <span class="param-label" :title="softLabels[4]">{{ softLabels[4] }}</span>
                    <span class="param-label" :title="softLabels[5]">{{ softLabels[5] }}</span>
                    <span class="param-label" :title="softLabels[6]">{{ softLabels[6] }}</span>
                    <span class="param-label" :title="softLabels[7]">{{ softLabels[7] }}</span>
                  </div>
                </div>
                <div class="knob-row" aria-label="8 encoders">
                  <KnobControl
                    v-for="(param, index) in encoderParams"
                    :key="param.id || `encoder-${index}`"
                    :index="index"
                    :label="getParamName(index)"
                    :value="param.value"
                    :min="param.min"
                    :max="param.max"
                    :step="param.step"
                    :fine-step="param.fineStep ?? param.step"
                    :shift-held="shiftHeld"
                    @turn="onKnobTurn(index, $event)"
                  />
                </div>
              </div>
            </div>
            <div class="edit-area">
              <div class="encoder-slot">
                <FourDEncoder class="four-d-encoder" />
              </div>
              <div class="quick-edit-buttons" aria-label="Quick edit controls">
                <button class="quick-edit-btn control-btn" type="button">
                  <span class="control-btn__main">VOLUME</span>
                  <span class="control-btn__sub">Velocity</span>
                </button>
                <button class="quick-edit-btn control-btn" type="button">
                  <span class="control-btn__main">SWING</span>
                  <span class="control-btn__sub">Position</span>
                </button>
                <button class="quick-edit-btn control-btn" type="button">
                  <span class="control-btn__main">TEMPO</span>
                  <span class="control-btn__sub">Tune</span>
                </button>
              </div>
            </div>
            <div class="performance-vert">
              <button class="control-btn" type="button">
                <span class="control-btn__main">NOTE REPEAT</span>
                <span class="control-btn__sub">Arp</span>
              </button>
              <div class="performance-vert__spacer" aria-hidden="true"></div>
              <button class="control-btn" type="button">
                <span class="control-btn__main">LOCK</span>
                <span class="control-btn__sub">Ext Lock</span>
              </button>
            </div>

            <div class="performance-block">
              <div class="performance-btn-row">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PITCH</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">MOD</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PERFORMANCE</span>
                  <span class="control-btn__sub">Fx Select</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">NOTES</span>
                </button>
              </div>
              <div class="smart-strip" aria-hidden="true"></div>
              <div class="group-area">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">A</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">B</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">C</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">D</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">E</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">F</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">G</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">H</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="bottom-row">
          <div class="left-column">
            <div class="transport-area" title="Transport area (MK3-style)" aria-label="Transport area (MK3-style)">
              <div class="transport-grid">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">RESTART</span>
                  <span class="control-btn__sub">Loop</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">ERASE</span>
                  <span class="control-btn__sub">Replace</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">TAP</span>
                  <span class="control-btn__sub">Metro</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">FOLLOW</span>
                  <span class="control-btn__sub">Grid</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PLAY</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">REC</span>
                  <span class="control-btn__sub">Count In</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">STOP</span>
                </button>
                <button
                  class="control-btn"
                  type="button"
                  :class="{ active: shiftHeld }"
                  :title="shiftHeld ? 'SHIFT (held)' : 'SHIFT (hold for secondary actions)'"
                  aria-label="Hold to access secondary controls"
                  :aria-pressed="shiftHeld"
                  @pointerdown="onShiftDown"
                  @pointerup="onShiftUp"
                  @pointercancel="onShiftUp"
                  @pointerleave="onShiftUpIfPressed"
                >
                  <div class="shift-label">SHIFT</div>
                </button>
              </div>
            </div>
          </div>

          <div class="right-column">
            <div class="pad-top-buttons" aria-label="Pad top buttons">
              <button class="control-btn" type="button">
                <span class="control-btn__main">FIXED VELOCITY</span>
                <span class="control-btn__sub">16 Vel</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">PAD MODE</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">KEYBOARD</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">CHORDS</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">STEP</span>
              </button>
            </div>
            <div class="pads-and-strip">
              <div class="mode-buttons" aria-label="Mode buttons">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">SCENE</span>
                  <span class="control-btn__sub">Section</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PATTERN</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">EVENTS</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">VARIATION</span>
                  <span class="control-btn__sub">Navigate</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">DUPLICATE</span>
                  <span class="control-btn__sub">Double</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">SELECT</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">SOLO</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">MUTE</span>
                  <span class="control-btn__sub">Choke</span>
                </button>
              </div>
              <div class="pads-column">
                <div class="pads-stack" title="Pad grid with bank indicators">
                  <div class="pads-square">
                    <slot name="pads" :props="padsSlotProps" />
                  </div>
                  <div class="pad-grid-indicator">
                    <span
                      v-for="i in gridCount"
                      :key="i"
                      :class="['indicator-dot', { active: currentGridIndex === i - 1 }]"
                      :aria-label="`Pad Bank ${i}`"
                      :title="`Pad Bank ${i}`"
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
    </div>
  </div>
</template>




<script lang="ts">
import { defineComponent } from 'vue'
import { saveAs } from 'file-saver'
import { DEFAULT_GRID_SPEC, GRID_DIVISIONS, normalizeGridSpec } from '@/domain/timing'
// Hosts the drum machine hardware layout and wires transport, pads, drawer panels, persistence, MIDI, sync, and export flows.
import { useTransportStore } from '@/stores/transport'
import { usePatternsStore } from '@/stores/patterns'
import { useSoundbanksStore } from '@/stores/soundbanks'
import { useSessionStore } from '@/stores/session'
import { useControlStore, type ControlMode } from '@/stores/control'
import { useBrowserStore } from '@/stores/browser'
import { useSequencer } from '@/composables/useSequencer'
import { useSync } from '@/composables/useSync.client'
import { useMidi } from '@/composables/useMidi.client'
import { usePatternStorage } from '@/composables/usePatternStorage.client'
import { useSoundbankStorage } from '@/composables/useSoundbankStorage.client'
import { useImportExport } from '@/composables/useImportExport.client'
import { useCapabilities } from '@/composables/useCapabilities.client'
import { useMidiLearn } from '@/composables/useMidiLearn'
import { useShortcuts } from '@/composables/useShortcuts'
import { SHORTCUT_COMMANDS } from '@/composables/shortcutCommands'
import { getFileSystemRepository } from '@/services/fileSystemRepository'
import TransportBar from './TransportBar.vue'
import PadGrid from './PadGrid.vue'
import TabPanel from './TabPanel.vue'
import SoundPanel from './panels/SoundPanel.vue'
import FxPanel from './panels/FxPanel.vue'
import PatternsPanel from './panels/PatternsPanel.vue'
import ExportPanel from './panels/ExportPanel.vue'
import { createZip, type ZipEntry } from '@/utils/zip'
import type { DrumPadId, Scene } from '@/types/drums'
import type { GridSpec, TimeDivision } from '@/types/time'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import type { RenderEvent, RenderMetadata } from '@/types/render'
import type { StepGrid } from '@/types/drums'
import DualDisplay from './control/DualDisplay.vue'
import SoftButtonStrip from './control/SoftButtonStrip.vue'
import KnobControl from './KnobControl.vue'
import FourDEncoder from './control/FourDEncoder.vue'
import ModeColumnPlaceholder from './placeholders/ModeColumnPlaceholder.vue'
import TouchStripPlaceholder from './placeholders/TouchStripPlaceholder.vue'

const slugify = (value: string): string => {
  const cleaned = value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
  return cleaned || 'drum-session'
}

type StemFiles = Partial<
  Record<
    DrumPadId,
    {
      fileName: string
      blob: Blob
    }
  >
>

type StemEntry = {
  padId: DrumPadId
  label: string
  fileName: string
}

type PadState = {
  label: string
  isTriggered: boolean
  isPlaying: boolean
}

const VISIBLE_DIVISIONS: TimeDivision[] = GRID_DIVISIONS.filter((value) => value <= 16)

const collectPlayingPads = (steps: StepGrid): Set<DrumPadId> => {
  const set = new Set<DrumPadId>()

  Object.values(steps).forEach((bar) => {
    Object.values(bar).forEach((step) => {
      Object.keys(step).forEach((padId) => {
        set.add(padId as DrumPadId)
      })
    })
  })

  return set
}

export default defineComponent({
  name: 'DrumMachine',
  components: {
    TransportBar,
    PadGrid,
    TabPanel,
    SoundPanel,
    FxPanel,
    PatternsPanel,
    ExportPanel,
    DualDisplay,
    SoftButtonStrip,
    KnobControl,
    FourDEncoder,
    ModeColumnPlaceholder,
    TouchStripPlaceholder
  },
  // ModeColumnPlaceholder currently unused; consider removing or wiring into the layout.
  data() {
    const transport = useTransportStore()
    const patterns = usePatternsStore()
    const soundbanks = useSoundbanksStore()
    const session = useSessionStore()
    const control = useControlStore()
    const browser = useBrowserStore()
    const capabilitiesProbe = useCapabilities()
    session.setCapabilities(capabilitiesProbe.capabilities.value)

    const importExport = useImportExport()
    const midi = useMidi()
    const midiLearn = useMidiLearn(midi)
    const sequencer = useSequencer({
      getPattern: () => patterns.currentPattern,
      onPatternBoundary: () => patterns.advanceScenePlayback()
    })
    const handleExternalStart = () => {
      if (!transport.isPlaying) {
        patterns.prepareScenePlayback()
        void sequencer.start().catch((error) => {
          console.error('Failed to start sequencer from external sync', error)
        })
      }
    }
    const handleExternalStop = () => {
      if (transport.isPlaying) {
        sequencer.stop()
      }
    }
    const sync = useSync('internal', {
      midi,
      getAudioTime: () => sequencer.getAudioTime(),
      onExternalStart: handleExternalStart,
      onExternalStop: handleExternalStop
    })
    const patternStorage = usePatternStorage()
    const soundbankStorage = useSoundbankStorage()

    const pads: DrumPadId[] = [
      'pad1',
      'pad2',
      'pad3',
      'pad4',
      'pad5',
      'pad6',
      'pad7',
      'pad8',
      'pad9',
      'pad10',
      'pad11',
      'pad12',
      'pad13',
      'pad14',
      'pad15',
      'pad16'
    ]
    const divisions: TimeDivision[] = [...VISIBLE_DIVISIONS]
    const defaultBank: Soundbank = {
      id: 'default-kit',
      name: 'Default Kit',
      createdAt: Date.now(),
      updatedAt: Date.now(),
      pads: {
        pad1: { id: 'kick', name: 'Kick', url: '/samples/kick.wav', format: 'wav' },
        pad5: { id: 'kick-2', name: 'Kick 2', url: '/samples/kick.wav', format: 'wav' },
        pad9: { id: 'kick-3', name: 'Kick 3', url: '/samples/kick.wav', format: 'wav' },
        pad13: { id: 'kick-4', name: 'Kick 4', url: '/samples/kick.wav', format: 'wav' },
        pad2: { id: 'snare', name: 'Snare', url: '/samples/snare.wav', format: 'wav' },
        pad6: { id: 'snare-2', name: 'Snare 2', url: '/samples/snare.wav', format: 'wav' },
        pad10: { id: 'snare-3', name: 'Snare 3', url: '/samples/snare.wav', format: 'wav' },
        pad14: { id: 'snare-4', name: 'Snare 4', url: '/samples/snare.wav', format: 'wav' },
        pad3: { id: 'hihat', name: 'Hi-Hat', url: '/samples/hihat.wav', format: 'wav' },
        pad7: { id: 'hihat-2', name: 'Hi-Hat 2', url: '/samples/hihat.wav', format: 'wav' },
        pad11: { id: 'hihat-3', name: 'Hi-Hat 3', url: '/samples/hihat.wav', format: 'wav' },
        pad15: { id: 'hihat-4', name: 'Hi-Hat 4', url: '/samples/hihat.wav', format: 'wav' },
        pad4: { id: 'clap', name: 'Clap', url: '/samples/clap.wav', format: 'wav' },
        pad8: { id: 'clap-2', name: 'Clap 2', url: '/samples/clap.wav', format: 'wav' },
        pad12: { id: 'clap-3', name: 'Clap 3', url: '/samples/clap.wav', format: 'wav' },
        pad16: { id: 'clap-4', name: 'Clap 4', url: '/samples/clap.wav', format: 'wav' }
      }
    }

    if (soundbanks.banks.length === 0) {
      soundbanks.setBanks([defaultBank])
    }

    return {
      transport,
      patterns,
      soundbanks,
      session,
      control,
      browser,
      sequencer,
      sync,
      midi,
      midiLearn,
      patternStorage,
      soundbankStorage,
      pads,
      divisions,
      defaultBank,
      unwatchers: [] as Array<() => void>,
      exportMetadata: null as RenderMetadata | null,
      exportAudioBlob: null as Blob | null,
      exportTimeline: undefined as RenderEvent[] | undefined,
      exportStems: null as StemFiles | null,
      isExporting: false,
      exportError: null as string | null,
      exportAudioFn: importExport.exportAudio,
      selectedPadId: 'pad1' as DrumPadId,
      currentGridIndex: 0,
      padsPerGrid: 16,
      drawerTab: 'sound',
      countInTimer: null as number | null,
      tapTimestamps: [] as number[],
      liveEraseEnabled: false,
      presetBars: patterns.currentPattern?.gridSpec?.bars ?? DEFAULT_GRID_SPEC.bars,
      presetDivision: patterns.currentPattern?.gridSpec?.division ?? DEFAULT_GRID_SPEC.division,
      channelTarget: 'sound' as 'sound' | 'group' | 'master',
      midiMode: false,
      shiftPointerActive: false
    }
  },


computed: {
  activeMode(): ControlMode {
    return this.control.modeTitle as ControlMode
  },

  shiftHeld(): boolean {
    return this.control.shiftHeld
  },

  pageLabel(): string {
    return this.control.pageLabel
  },

  activeSoftButtons() {
    return this.control.activeSoftButtons
  },

  softLabels(): string[] {
    return this.control.softLabels
  },

  leftDisplayModel() {
    return this.control.leftModel
  },

  rightDisplayModel() {
    return this.control.rightModel
  },

  paramSlotsLeft() {
    return this.control.paramSlotsLeft
  },

  paramSlotsRight() {
    return this.control.paramSlotsRight
  },

  encoderParams() {
    return this.control.activeParams ?? []
  },

  gridSpec() {
    return this.patterns.currentPattern?.gridSpec ?? { ...DEFAULT_GRID_SPEC }
  },

  gridCount(): number {
    return Math.ceil(this.pads.length / this.padsPerGrid)
  },

  activePadGrid(): DrumPadId[] {
    const start = this.currentGridIndex * this.padsPerGrid
    return this.pads.slice(start, start + this.padsPerGrid)
  },

  pattern() {
    return (
      this.patterns.currentPattern ?? {
        id: 'pattern-1',
        name: 'Pattern 1',
        gridSpec: { ...DEFAULT_GRID_SPEC },
        steps: {}
      }
    )
  },

  currentStep() {
    return this.transport.currentStep
  },

  totalSteps(): number {
    return Math.max(1, this.gridSpec.bars * this.gridSpec.division)
  },

  patternChainEntries() {
    const chain = this.patterns.currentScene?.patternIds ?? []
    if (!Array.isArray(chain) || chain.length === 0) {
      return null
    }
    return chain
      .map((patternId) => {
        const entry = this.patterns.patterns.find((pattern) => pattern.id === patternId)
        if (!entry) return null
        return { id: patternId, bars: entry.gridSpec?.bars ?? this.gridSpec.bars }
      })
      .filter(Boolean) as Array<{ id: string; bars: number }> | null
  },

  bpm() {
    return this.transport.bpm
  },

  isPlaying() {
    return this.transport.isPlaying
  },

  midiInputs() {
    return this.midi.inputs
  },

  midiOutputs() {
    return this.midi.outputs
  },

  banks() {
    return this.soundbanks.banks
  },

  stemEntries(): StemEntry[] {
    if (!this.exportStems) return []
    const bankPads = this.soundbanks.currentBank?.pads ?? {}

    return Object.entries(this.exportStems).map(([padId, entry]) => ({
      padId: padId as DrumPadId,
      label: bankPads[padId as DrumPadId]?.name ?? padId,
      fileName: entry.fileName
    }))
  },

  syncState() {
    return this.sync.state
  },

  capabilities() {
    return this.session.capabilities
  }, 

  hasZipArtifacts(): boolean {
    return Boolean(this.exportMetadata && this.exportAudioBlob)
  },
  
  midiLearnLabel(): string {
    return (
      this.midiLearn.learningLabel ??
      this.midiLearn.status ??
      'Listening for MIDI...'
    )
  },
  
  padStates() {
    const bankPads = this.soundbanks.currentBank?.pads ?? {}
    const result = {} as Record<DrumPadId, PadState>

    const stepsPerPattern = Math.max(
      1,
      this.gridSpec.bars * this.gridSpec.division
    )

    const normalizedStep =
      ((this.currentStep % stepsPerPattern) + stepsPerPattern) %
      stepsPerPattern

    const barIndex = Math.floor(normalizedStep / this.gridSpec.division)
    const stepIndex = normalizedStep % this.gridSpec.division

    const currentRow =
      this.pattern.steps[barIndex]?.[stepIndex] ?? {}

    const triggered = new Set<DrumPadId>(
      Object.keys(currentRow) as DrumPadId[]
    )

    const playingPads = collectPlayingPads(this.pattern.steps)
    const visiblePads = this.activePadGrid
    visiblePads.forEach((pad) => {
      result[pad] = {
        label: bankPads[pad]?.name ?? pad.toUpperCase(),
        isTriggered: triggered.has(pad),
        isPlaying: this.isPlaying && playingPads.has(pad)
      }
    })

    return result
  },

  mainSlotProps() {
    return {
      stepGridProps: {
        gridSpec: this.gridSpec,
        steps: this.pattern.steps,
        patternChain: this.patternChainEntries,
        selectedPad: this.selectedPadId as DrumPadId | null,
        currentStep: this.currentStep,
        isPlaying: this.isPlaying,
        followEnabled: this.transport.followEnabled,
        loopStart: this.transport.loopStart,
        loopEnd: this.transport.loopEnd,
        'onStep:toggle': this.toggleStep,
        'onPlayhead:scrub': this.scrubPlayhead,
        'onStep:velocity': this.updateStepVelocity
      }
    }
  },
  

  transportSlotProps() {
    return {
      transportProps: {
        bpm: this.bpm,
        isPlaying: this.isPlaying,
        loop: this.transport.loop,
        division: this.gridSpec.division,
        divisions: this.divisions,
        isMidiLearning: this.midiLearn.isLearning,
        isRecording: this.transport.isRecording,
        countInEnabled: this.transport.countInEnabled,
        countInBars: this.transport.countInBars,
        metronomeEnabled: this.transport.metronomeEnabled,
        followEnabled: this.transport.followEnabled,
        patternBars: this.gridSpec.bars,
        loopStart: this.transport.loopStart,
        loopEnd: this.transport.loopEnd,
        totalSteps: this.totalSteps,
        selectedPad: this.selectedPadId,
        liveEraseEnabled: this.liveEraseEnabled,
        metronomeVolume: this.transport.metronomeVolume,
        presetBars: this.presetBars,
        presetDivision: this.presetDivision
        ,
        onPlay: this.start,
        onStop: this.stop,
        onStopReset: this.resetPlayhead,
        onRestart: this.restartLoop,
        onToggleRecord: this.toggleRecord,
        onToggleCountIn: this.toggleCountIn,
        onUpdateCountInBars: this.setCountInBars,
        onTapTempo: this.tapTempo,
        onToggleMetronome: this.toggleMetronome,
        onToggleFollow: this.toggleFollow,
        onUpdatePatternBars: this.setPatternBars,
        onNudgeLoopRange: this.nudgeLoopRange,
        onUpdateLoopStart: this.updateLoopStart,
        onUpdateLoopEnd: this.updateLoopEnd,
        'onUpdate:metronomeVolume': this.setMetronomeVolume,
        onToggleLiveErase: this.toggleLiveErase,
        onErasePad: this.eraseSelectedPad,
        onEraseCurrentStep: this.eraseSelectedPadAtCurrentStep,
        'onUpdate:presetBars': this.setPresetBars,
        'onUpdate:presetDivision': this.setPresetDivision,
        onApplyPatternPreset: this.applyPatternPreset,
        onUpdateBpm: this.updateBpm,
        onIncrementBpm: this.incrementBpm,
        onDecrementBpm: this.decrementBpm,
        onUpdateDivision: this.setDivision,
        onUpdateLoop: this.setLoop,
        onToggleMidiLearn: this.toggleMidiLearn
      },
      transportListeners: {
        play: this.start,
        stop: this.stop,
        'stop-reset': this.resetPlayhead,
        restart: this.restartLoop,
        'toggle-record': this.toggleRecord,
        'toggle-count-in': this.toggleCountIn,
        'update-count-in-bars': this.setCountInBars,
        'tap-tempo': this.tapTempo,
        'toggle-metronome': this.toggleMetronome,
        'toggle-follow': this.toggleFollow,
        'update-pattern-bars': this.setPatternBars,
        'nudge-loop-range': this.nudgeLoopRange,
        'update-loop-start': this.updateLoopStart,
        'update-loop-end': this.updateLoopEnd,
        'update:metronome-volume': this.setMetronomeVolume,
        'toggle-live-erase': this.toggleLiveErase,
        'erase-pad': this.eraseSelectedPad,
        'erase-current-step': this.eraseSelectedPadAtCurrentStep,
        'update:preset-bars': this.setPresetBars,
        'update:preset-division': this.setPresetDivision,
        'apply-pattern-preset': this.applyPatternPreset,
        'update-bpm': this.updateBpm,
        'increment-bpm': this.incrementBpm,
        'decrement-bpm': this.decrementBpm,
        'update-division': this.setDivision,
        'update-loop': this.setLoop,
        'toggle-midi-learn': this.toggleMidiLearn
      },
      midiLearnLabel: this.midiLearnLabel
    }
  },

  padsSlotProps() {
    return {
      padGridProps: {
        pads: this.activePadGrid,
        padStates: this.padStates,
        selectedPad: this.selectedPadId as DrumPadId | null,
        'onPad:down': this.handlePad,
        'onPad:select': this.selectPad
      }
    }
  },

  drawerSlotProps() {
    return {
      drawerTab: this.drawerTab,
      onUpdateDrawerTab: (value: string) => {
        this.drawerTab = value
      },
      soundProps: {
        banks: this.banks,
        selectedBankId: this.soundbanks.selectedBankId,
        'onBank:select': this.selectBank,
        'onPad:replace': this.replacePadSample
      },
      fxProps: {
        fxSettings: (this.sequencer.fxSettings ?? {}) as FxSettings,
        'onFx:update': this.updateFx
      },
      patternsProps: {
        patterns: this.patterns.patterns,
        selectedPatternId: this.patterns.selectedPatternId,
        scenes: this.patterns.scenes,
        activeSceneId: this.patterns.activeSceneId,
        'onPattern:add': this.addPattern,
        'onPattern:select': this.selectPattern,
        'onPattern:rename': this.renamePattern,
        'onPattern:undo': this.undoPattern,
        'onPattern:redo': this.redoPattern,
        'onScene:add': this.addScene,
        'onScene:update': this.updateScene,
        'onScene:select': this.selectScene,
        'onErase:pad': this.eraseSelectedPad,
        'onErase:step': this.eraseSelectedPadAtCurrentStep
      },
      exportProps: {
        isExporting: this.isExporting,
        exportError: this.exportError,
        exportMetadata: this.exportMetadata,
        audioBlob: this.exportAudioBlob,
        hasZipArtifacts: this.hasZipArtifacts,
        stemEntries: this.stemEntries,
        onExport: this.exportBounce,
        'onDownload:mixdown': this.downloadMixdown,
        'onDownload:zip': this.downloadZip,
        'onDownload:stem': this.downloadStem,
        'onDownload:stems': this.downloadAllStems
      },
      channelProps: {
        controlTarget: this.channelTarget,
        midiMode: this.midiMode,
        'onUpdate:control-target': (value: string) => {
          this.channelTarget = value as 'sound' | 'group' | 'master'
        },
        'onUpdate:midi-mode': (value: boolean) => {
          this.midiMode = Boolean(value)
        }
      }
    }
  }
},


  mounted() {
    this.registerShortcuts()
    window.addEventListener('keydown', this.handleGlobalShortcut)
    window.addEventListener('keydown', this.handleGridKeys)
    window.addEventListener('keydown', this.handleShiftKeyDown)
    window.addEventListener('keyup', this.handleShiftKeyUp)
    window.addEventListener('pointerup', this.handleGlobalPointerUp)
    const storedPatterns = this.patternStorage.load()
    if (storedPatterns.patterns.length > 0) {
      this.patterns.setPatterns(storedPatterns.patterns)
    }
    if (storedPatterns.scenes.length > 0) {
      this.patterns.setScenes(storedPatterns.scenes)
    }
    if (storedPatterns.selectedPatternId && this.patterns.patterns.find((pattern) => pattern.id === storedPatterns.selectedPatternId)) {
      this.patterns.selectPattern(storedPatterns.selectedPatternId)
    }
    this.patterns.selectScene(storedPatterns.activeSceneId ?? null)
    void this.initializeSoundbank()
    const persistPatterns = () =>
      this.patternStorage.save({
        patterns: this.patterns.patterns,
        scenes: this.patterns.scenes,
        selectedPatternId: this.patterns.selectedPatternId,
        activeSceneId: this.patterns.activeSceneId
      })
    const stopWatch = this.$watch(
      () => [this.patterns.patterns, this.patterns.scenes, this.patterns.selectedPatternId, this.patterns.activeSceneId],
      persistPatterns,
      { deep: true }
    )
    const stopBankPatternWatch = this.$watch(
      () => this.patterns.patterns,
      (value) => {
        const bankId = this.soundbanks.selectedBankId
        if (bankId) {
          void this.soundbankStorage.savePatterns(bankId, value)
        }
      },
      { deep: true }
    )
    void this.browser.setMode('LIBRARY')
    this.control.setBrowserDisplay(this.browser.toDisplayModels())
    const stopBrowserDisplayWatch = this.$watch(
      () => ({
        mode: this.browser.mode,
        query: this.browser.library.query,
        results: this.browser.library.results,
        selectedId: this.browser.library.selectedId,
        path: this.browser.files.currentPath,
        entries: this.browser.files.entries,
        selectedPath: this.browser.files.selectedPath
      }),
      () => {
        this.control.setBrowserDisplay(this.browser.toDisplayModels())
      },
      { deep: true }
    )
    const stopMidiListener = this.midi.listen((message) => {
      if (this.midiLearn.handleMessage(message)) {
        return
      }

      if (message.type === 'noteon' && typeof message.note === 'number') {
        const transportMap = this.midi.mapping?.transportMap
        const transportNote = transportMap?.play === message.note
          ? 'play'
          : transportMap?.stop === message.note
            ? 'stop'
            : transportMap?.bpmUp === message.note
              ? 'bpmUp'
              : transportMap?.bpmDown === message.note
                ? 'bpmDown'
                : null

        if (transportNote === 'play') {
          void this.start()
          return
        }
        if (transportNote === 'stop') {
          this.stop()
          return
        }
        if (transportNote === 'bpmUp') {
          this.updateBpm(this.bpm + 1)
          return
        }
        if (transportNote === 'bpmDown') {
          this.updateBpm(this.bpm - 1)
          return
        }

        const pad = this.midi.mapNoteToPad(message.note)
        if (pad) {
          this.handlePad(pad, message.velocity ?? 1)
        }
      }
    })
    this.unwatchers.push(stopWatch)
    this.unwatchers.push(stopBankPatternWatch)
    this.unwatchers.push(stopBrowserDisplayWatch)
    this.unwatchers.push(() => stopMidiListener?.())
  },
  beforeUnmount() {
    window.removeEventListener('keydown', this.handleGlobalShortcut)
    window.removeEventListener('keydown', this.handleGridKeys)
    window.removeEventListener('keydown', this.handleShiftKeyDown)
    window.removeEventListener('keyup', this.handleShiftKeyUp)
    window.removeEventListener('pointerup', this.handleGlobalPointerUp)
    this.clearCountInTimer()
    this.unwatchers.forEach((stop) => stop())
  },

  methods: {
    registerShortcuts() {
      const shortcuts = useShortcuts()
      // Transport
      shortcuts.register('TRANSPORT_PLAY', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_PLAY,
        handler: () => void this.start(),
        description: 'Play'
      })
      shortcuts.register('TRANSPORT_STOP', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_STOP,
        handler: () => this.stop(),
        description: 'Stop'
      })
      shortcuts.register('TRANSPORT_RECORD', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_RECORD,
        handler: () => this.toggleRecord(),
        description: 'Record'
      })
      shortcuts.register('TRANSPORT_TAP_TEMPO', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_TAP_TEMPO,
        handler: () => this.tapTempo(),
        description: 'Tap Tempo'
      })
      shortcuts.register('TRANSPORT_METRONOME', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_METRONOME,
        handler: () => this.toggleMetronome(),
        description: 'Toggle Metronome'
      })
      shortcuts.register('TRANSPORT_COUNT_IN', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_COUNT_IN,
        handler: () => this.toggleCountIn(),
        description: 'Toggle Count-In'
      })
      shortcuts.register('TRANSPORT_LOOP', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_LOOP,
        handler: () => this.transport.setLoop(!this.transport.loop),
        description: 'Toggle Loop'
      })
      shortcuts.register('TRANSPORT_FOLLOW', {
        keys: SHORTCUT_COMMANDS.TRANSPORT_FOLLOW,
        handler: () => this.toggleFollow(),
        description: 'Toggle Follow'
      })
      // Browser
      shortcuts.register('BROWSER_OPEN', {
        keys: SHORTCUT_COMMANDS.BROWSER_OPEN,
        handler: () => this.handleModePress('BROWSER'),
        description: 'Open Browser'
      })
      shortcuts.register('BROWSER_MODE_LIBRARY', {
        keys: SHORTCUT_COMMANDS.BROWSER_MODE_LIBRARY,
        handler: () => void this.browser.setMode('LIBRARY'),
        description: 'Browser: Library Mode'
      })
      shortcuts.register('BROWSER_MODE_FILES', {
        keys: SHORTCUT_COMMANDS.BROWSER_MODE_FILES,
        handler: () => void this.browser.setMode('FILES'),
        description: 'Browser: Files Mode'
      })
      shortcuts.register('BROWSER_IMPORT_TO_PAD', {
        keys: SHORTCUT_COMMANDS.BROWSER_IMPORT_TO_PAD,
        handler: () => void this.importSelectedToPad(),
        description: 'Import selected file to current pad'
      })
      // Pads
      const padMap: Record<string, DrumPadId> = {
        '1': 'pad1', '2': 'pad2', '3': 'pad3', '4': 'pad4',
        'q': 'pad5', 'w': 'pad6', 'e': 'pad7', 'r': 'pad8',
        'a': 'pad9', 's': 'pad10', 'd': 'pad11', 'f': 'pad12',
        'z': 'pad13', 'x': 'pad14', 'c': 'pad15', 'v': 'pad16'
      }
      Object.entries(padMap).forEach(([_key, padId], index) => {
        shortcuts.register(`PAD_SELECT_${index + 1}`, {
          keys: SHORTCUT_COMMANDS[`PAD_SELECT_${index + 1}` as keyof typeof SHORTCUT_COMMANDS],
          handler: () => void this.handlePad(padId),
          description: `Select Pad ${index + 1}`
        })
      })
      // Modes
      shortcuts.register('MODE_BROWSER', {
        keys: SHORTCUT_COMMANDS.MODE_BROWSER,
        handler: () => this.handleModePress('BROWSER'),
        description: 'Browser Mode'
      })
      // Undo/Redo
      shortcuts.register('UNDO', {
        keys: SHORTCUT_COMMANDS.UNDO,
        handler: () => this.undoPattern(),
        description: 'Undo'
      })
      shortcuts.register('REDO', {
        keys: SHORTCUT_COMMANDS.REDO,
        handler: () => this.redoPattern(),
        description: 'Redo'
      })
    },
    handleGlobalShortcut(event: KeyboardEvent) {
      // Skip if typing in input/textarea
      const target = event.target as HTMLElement
      if (target?.tagName === 'INPUT' || target?.tagName === 'TEXTAREA') return

      const shortcuts = useShortcuts()
      shortcuts.dispatch(event)
    },
    handleModePress(mode: ControlMode, shiftActionId?: string) {
      this.control.setMode(mode)
      if (mode === 'BROWSER') {
        void this.browser.setMode('LIBRARY')
        this.control.setBrowserDisplay(this.browser.toDisplayModels())
      } else if (mode === 'FILE') {
        void this.browser.setMode('FILES')
        this.control.setBrowserDisplay(this.browser.toDisplayModels())
      }
      if (this.shiftHeld && shiftActionId) {
        this.control.applyAction(shiftActionId, mode)
      }
    },
    isActiveMode(mode: ControlMode): boolean {
      return this.control.activeMode === mode
    },
    shortcutTitle(commandId: string, label: string): string {
      const shortcuts = useShortcuts()
      return shortcuts.title(commandId, label)
    },
    modeTooltip(mode: ControlMode, primary: string, secondary?: string) {
      const shortcuts = useShortcuts()
      const commandMap: Record<string, string> = {
        BROWSER: 'MODE_BROWSER',
        CHANNEL: 'MODE_CHANNEL',
        PLUGIN: 'MODE_PLUGIN',
        ARRANGER: 'MODE_ARRANGER',
        MIXER: 'MODE_MIXER',
        SAMPLING: 'MODE_SAMPLING'
      }
      const commandId = commandMap[mode]
      const base = secondary ? `${primary} (SHIFT: ${secondary})` : primary
      return commandId ? shortcuts.title(commandId, base) : base
    },
    pageButtonTitle(direction: 'prev' | 'next') {
      return `${direction === 'prev' ? 'Previous' : 'Next'} page (${this.pageLabel})`
    },
    prevPage() {
      this.control.prevPage()
    },
    nextPage() {
      this.control.nextPage()
    },
    pressSoftButton(index: number) {
      const btn = this.control.activeSoftButtons[index]
      const actionId = this.control.shiftHeld && btn?.shiftActionId ? btn.shiftActionId : btn?.actionId
      if (actionId === 'BROWSER_IMPORT_TO_PAD') {
        void this.importSelectedToPad()
        return
      }
      this.control.pressSoftButton(index)
    },
    onShiftDown(event: PointerEvent) {
      event.preventDefault()
      this.shiftPointerActive = true
      this.control.setShiftHeld(true)
    },
    onShiftUp() {
      this.shiftPointerActive = false
      this.control.setShiftHeld(false)
    },
    onShiftUpIfPressed() {
      if (this.shiftPointerActive) {
        this.onShiftUp()
      }
    },
    handleGlobalPointerUp() {
      if (this.shiftPointerActive) {
        this.onShiftUp()
      }
    },
    handleShiftKeyDown(event: KeyboardEvent) {
      if (event.key === 'Shift') {
        this.control.setShiftHeld(true)
      }
    },
    handleShiftKeyUp(event: KeyboardEvent) {
      if (event.key === 'Shift') {
        this.control.setShiftHeld(false)
      }
    },
    onKnobTurn(index: number, payload: { delta: number; fine?: boolean }) {
      const delta = payload?.delta ?? 0
      if (!delta) return
      this.control.turnEncoder(index, delta, { fine: payload?.fine ?? this.shiftHeld })
    },
    getParamName(index: number) {
      return this.encoderParams?.[index]?.name ?? `Encoder ${index + 1}`
    },
    addPattern(payload: { name?: string }) {
      this.patterns.addPattern(payload?.name)
    },
    selectPattern(id: string) {
      this.patterns.selectPattern(id)
    },
    renamePattern(payload: { id: string; name: string }) {
      this.patterns.renamePattern(payload.id, payload.name)
    },
    undoPattern() {
      this.patterns.undo()
    },
    redoPattern() {
      this.patterns.redo()
    },
    addScene(payload: { name?: string; patternIds?: string[] }) {
      this.patterns.addScene(payload?.name ?? 'Scene', payload?.patternIds ?? [])
    },
    updateScene(payload: { id: string; name?: string; patternIds?: string[] }) {
      const updates: Partial<Scene> = {}
      if (typeof payload.name === 'string') {
        updates.name = payload.name
      }
      if (Array.isArray(payload.patternIds)) {
        updates.patternIds = payload.patternIds
      }
      if (Object.keys(updates).length > 0) {
        this.patterns.updateScene(payload.id, updates)
      }
    },
    selectScene(id: string | null) {
      this.patterns.selectScene(id)
    },
    updateFx(settings: FxSettings) {
      this.sequencer.setFx(settings)
    },
    updateBpm(bpm: number) {
      this.transport.setBpm(bpm)
      this.sync.setBpm(bpm)
    },
    async start() {
      if (this.transport.isPlaying) return
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'play' })
      }
      this.patterns.prepareScenePlayback()
      await this.sequencer.start()
      this.sync.startTransport(this.transport.bpm)
    },
    stop() {
      if (!this.transport.isPlaying) {
        this.resetPlayhead()
        this.transport.setRecording(false)
        return
      }
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'stop' })
      }
      this.sequencer.stop()
      this.sync.stopTransport()
      this.transport.setRecording(false)
    },
    resetPlayhead() {
      this.transport.setCurrentStep(0)
    },
    restartLoop() {
      if (this.transport.isPlaying) {
        this.sequencer.stop()
        this.transport.setCurrentStep(this.transport.loopStart)
        this.patterns.prepareScenePlayback()
        void this.sequencer.start()
      } else {
        this.transport.setCurrentStep(this.transport.loopStart)
      }
    },
    toggleRecord() {
      const next = !this.transport.isRecording
      this.transport.setRecording(next)
      if (!next) {
        this.clearCountInTimer()
        return
      }
      if (!this.transport.isPlaying) {
        if (this.transport.countInEnabled) {
          this.startWithCountIn()
        } else {
          void this.start()
        }
      }
    },
    startWithCountIn() {
      this.clearCountInTimer()
      const bars = Math.max(1, this.transport.countInBars)
      const delayMs = (bars * 4 * 60 * 1000) / Math.max(1, this.bpm)
      this.countInTimer = window.setTimeout(() => {
        void this.start()
        this.transport.setRecording(true)
        this.clearCountInTimer()
      }, delayMs)
    },
    clearCountInTimer() {
      if (this.countInTimer != null) {
        window.clearTimeout(this.countInTimer)
        this.countInTimer = null
      }
    },
    toggleCountIn() {
      this.transport.setCountInEnabled(!this.transport.countInEnabled)
      if (!this.transport.countInEnabled) {
        this.clearCountInTimer()
      }
    },
    setCountInBars(value: number) {
      this.transport.setCountInBars(value ?? 1)
    },
    tapTempo() {
      const now = Date.now()
      this.tapTimestamps.push(now)
      const recent = this.tapTimestamps.slice(-4)
      this.tapTimestamps = recent
      if (recent.length < 2) return
      const intervals = []
      for (let i = 1; i < recent.length; i += 1) {
        intervals.push(recent[i] - recent[i - 1])
      }
      const avgMs = intervals.reduce((sum, val) => sum + val, 0) / intervals.length
      const bpm = Math.max(1, Math.round(60000 / avgMs))
      this.updateBpm(bpm)
    },
    toggleMetronome() {
      this.transport.setMetronomeEnabled(!this.transport.metronomeEnabled)
    },
    toggleFollow() {
      this.transport.setFollowEnabled(!this.transport.followEnabled)
    },
    setPatternBars(bars: number) {
      const normalized = Math.max(1, Math.min(8, Math.floor(bars))) as GridSpec['bars']
      const gridSpec = normalizeGridSpec({ ...this.gridSpec, bars: normalized })
      this.transport.setGridSpec(gridSpec)
      this.patterns.updateGridSpec(gridSpec)
      const total = gridSpec.bars * gridSpec.division
      this.transport.setLoopRange(0, total)
      this.resetPlayhead()
    },
    nudgeLoopRange(delta: number) {
      this.transport.nudgeLoopRange(delta)
      const clamped = Math.min(Math.max(this.transport.currentStep, this.transport.loopStart), this.transport.loopEnd - 1)
      this.transport.setCurrentStep(clamped)
    },
    updateLoopStart(value: number) {
      const nextStart = Math.max(0, Math.floor(value))
      const end = Math.max(nextStart + 1, this.transport.loopEnd)
      this.transport.setLoopRange(nextStart, end)
      const clamped = Math.min(Math.max(this.transport.currentStep, nextStart), end - 1)
      this.transport.setCurrentStep(clamped)
    },
    updateLoopEnd(value: number) {
      const total = this.totalSteps
      const nextEnd = Math.min(total, Math.max(1, Math.floor(value)))
      const start = Math.min(this.transport.loopStart, nextEnd - 1)
      this.transport.setLoopRange(start, nextEnd)
      const clamped = Math.min(Math.max(this.transport.currentStep, start), nextEnd - 1)
      this.transport.setCurrentStep(clamped)
    },
    setMetronomeVolume(value: number) {
      this.transport.setMetronomeVolume(value ?? 0.12)
    },
    setPresetBars(value: number) {
      const bars = Math.max(1, Math.min(8, Math.floor(value ?? 1))) as GridSpec['bars']
      this.presetBars = bars
    },
    setPresetDivision(value: TimeDivision | null) {
      if (value != null) {
        this.presetDivision = value
      }
    },
    applyPatternPreset() {
      const gridSpec = normalizeGridSpec({
        ...this.gridSpec,
        bars: this.presetBars,
        division: this.presetDivision
      })
      this.transport.setGridSpec(gridSpec)
      this.patterns.updateGridSpec(gridSpec)
      this.transport.setLoopRange(0, gridSpec.bars * gridSpec.division)
      this.resetPlayhead()
    },
    handleGridKeys(e: KeyboardEvent) {
      if (e.ctrlKey && !e.shiftKey) {
        const index = Number(e.key) - 1
        if (index >= 0 && index < this.gridCount) {
          e.preventDefault()
          this.selectPadGrid(index)
          return
        }
      }
      if (e.ctrlKey && e.key.toLowerCase() === 'z') {
        e.preventDefault()
        if (e.shiftKey) {
          this.redoPattern()
        } else {
          this.undoPattern()
        }
      }
    },
    async handlePad(pad: DrumPadId, velocity = 1) {
      if (this.liveEraseEnabled) {
        this.erasePadAtStep(pad, this.transport.currentStep)
        return
      }
      try {
        await this.sequencer.recordHit(pad, velocity, true)
      } catch (error) {
        console.error('Failed to trigger pad', error)
      }
      this.selectPad(pad)
    },
    selectPad(pad: DrumPadId) {
      this.selectedPadId = pad
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'pad', padId: pad })
      }
    },
    selectPadGrid(index: number) {
      if (index < 0 || index >= this.gridCount) return
      this.currentGridIndex = index
      const firstPad = this.activePadGrid[0]
      if (firstPad) {
        this.selectedPadId = firstPad
      }
    },
    toggleStep(payload: { barIndex: number; stepInBar: number; padId: DrumPadId }) {
      this.patterns.toggleStep(payload.barIndex, payload.stepInBar, payload.padId)
    },
    updateStepVelocity(payload: {
      barIndex: number
      stepInBar: number
      padId: DrumPadId
      velocity: number
    }) {
      this.patterns.setStepVelocity(
        payload.barIndex,
        payload.stepInBar,
        payload.padId,
        payload.velocity
      )
    },
    scrubPlayhead(payload: { stepIndex: number }) {
      this.transport.setCurrentStep(payload.stepIndex)
    },
    erasePadAtStep(pad: DrumPadId, stepIndex: number) {
      const stepsPerPattern = this.totalSteps
      const normalizedStep =
        ((stepIndex % stepsPerPattern) + stepsPerPattern) % stepsPerPattern
      const barIndex = Math.floor(normalizedStep / this.gridSpec.division)
      const stepInBar = normalizedStep % this.gridSpec.division
      this.patterns.eraseStepForPad(barIndex, stepInBar, pad)
    },
    eraseSelectedPad() {
      if (!this.selectedPadId) return
      this.patterns.erasePadEvents(this.selectedPadId)
    },
    eraseSelectedPadAtCurrentStep() {
      if (!this.selectedPadId) return
      this.erasePadAtStep(this.selectedPadId, this.transport.currentStep)
    },

    async requestMidi() {
      await this.midi.requestAccess()
      this.session.setCapabilities({
        supportsAudioInput: this.session.capabilities.supportsAudioInput,
        supportsWebMIDI: this.midi.supportsMidi()
      })
      if (this.midi.inputs.length > 0 && !this.midi.selectedInputId) {
        this.midi.setSelectedInput(this.midi.inputs[0]?.id ?? null)
      }
      if (this.midi.outputs.length > 0 && !this.midi.selectedOutputId) {
        this.midi.setSelectedOutput(this.midi.outputs[0]?.id ?? null)
      }
    },
    selectMidiInput(id: string) {
      this.midi.setSelectedInput(id)
    },
    selectMidiOutput(id: string) {
      this.midi.setSelectedOutput(id)
    },
    mapPadToNote(payload: { padId: DrumPadId; note: number }) {
      if (payload.note >= 0 && payload.note <= 127) {
        this.midi.setPadForNote(payload.note, payload.padId)
      }
    },
    setSyncMode(mode: string) {
      if (mode === 'internal' || mode === 'midiClock' || mode === 'abletonLink') {
        this.sync.setMode(mode)
      }
    },
    setSyncRole(role: string) {
      if (role === 'master' || role === 'slave') {
        this.sync.setRole(role)
      }
    },
    setLoop(loop: boolean) {
      this.transport.setLoop(loop)
    },
    incrementBpm() {
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'bpmUp' })
      }
      this.updateBpm(this.bpm + 1)
    },
    decrementBpm() {
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'bpmDown' })
      }
      this.updateBpm(this.bpm - 1)
    },
    toggleMidiLearn() {
      if (this.midiLearn.isLearning) {
        this.midiLearn.disable()
      } else {
        this.midiLearn.enable()
      }
    },
    toggleLiveErase() {
      this.liveEraseEnabled = !this.liveEraseEnabled
    },
    setDivision(division: TimeDivision) {
      const gridSpec = normalizeGridSpec({ ...this.gridSpec, division })
      this.transport.setGridSpec(gridSpec)
      this.patterns.updateGridSpec(gridSpec)
    },
    selectBank(id: string) {
      this.soundbanks.selectBank(id)
      void this.initializeSoundbank()
    },
    inferFormatFromName(name: string): SampleRef['format'] {
      const lower = name.toLowerCase()
      if (lower.endsWith('.wav')) return 'wav'
      if (lower.endsWith('.mp3')) return 'mp3'
      if (lower.endsWith('.ogg')) return 'ogg'
      if (lower.endsWith('.aac')) return 'aac'
      if (lower.endsWith('.flac')) return 'flac'
      return undefined
    },
    async replacePadSample(payload: { padId: DrumPadId; file: File }) {
      const bank = this.soundbanks.currentBank ?? this.defaultBank
      const existing = bank.pads[payload.padId]
      if (existing?.url && existing.url.startsWith('blob:')) {
        URL.revokeObjectURL(existing.url)
      }
      const sampleId = `${payload.padId}-${Date.now()}`
      const format = this.inferFormatFromName(payload.file.name) ?? 'wav'
      const sample: SampleRef = {
        id: sampleId,
        name: payload.file.name,
        format,
        blob: payload.file,
        url: URL.createObjectURL(payload.file)
      }
      const updatedBank: Soundbank = {
        ...bank,
        pads: { ...bank.pads, [payload.padId]: sample },
        updatedAt: Date.now()
      }
      this.soundbanks.upsertBank(updatedBank)
      await this.soundbankStorage.saveBank(updatedBank)
      await this.soundbankStorage.saveSample(sample as SampleRef & { blob: Blob })
      await this.sequencer.setSampleForPad(payload.padId, sample)
      await this.sequencer.applySoundbank(updatedBank)
    },
    async importSelectedToPad() {
      if (!this.browser.files.selectedPath) return
      const importedItem = await this.browser.importSelected({
        contextId: this.selectedPadId,
        contextType: 'sample'
      })
      if (!importedItem?.path) return
      const fileRepo = getFileSystemRepository()
      const blob = await fileRepo.readFileBlob?.(importedItem.path)
      if (!blob) return
      const file = new File([blob], importedItem.name, { type: blob.type || 'audio/wav' })
      await this.replacePadSample({ padId: this.selectedPadId, file })
    },
    async hydrateSamplesForBank(bank: Soundbank): Promise<Soundbank> {
      const hydratedPads: Partial<Record<DrumPadId, SampleRef>> = {}
      const entries = Object.entries(bank.pads)
      for (const [padId, sample] of entries) {
        if (!sample) continue
        let hydrated = sample
        if (!sample.blob) {
          const stored = await this.soundbankStorage.loadSample(sample.id)
          if (stored?.blob) {
            hydrated = { ...sample, blob: stored.blob }
          }
        }
        hydratedPads[padId as DrumPadId] = hydrated
      }
      return { ...bank, pads: hydratedPads }
    },
    async initializeSoundbank() {
      const storedBanks = await this.soundbankStorage.loadBanks()
      if (storedBanks.length > 0) {
        this.soundbanks.setBanks(storedBanks)
      } else if (this.soundbanks.banks.length === 0) {
        this.soundbanks.setBanks([this.defaultBank])
        await this.soundbankStorage.saveBank(this.defaultBank)
      }
      const bank = this.soundbanks.currentBank ?? this.soundbanks.banks[0] ?? this.defaultBank
      const hydratedBank = await this.hydrateSamplesForBank(bank)
      this.soundbanks.upsertBank(hydratedBank)
      const bankPatterns = await this.soundbankStorage.loadPatterns(hydratedBank.id)
      if (bankPatterns.length > 0) {
        this.patterns.setPatterns(bankPatterns)
      }
      await this.sequencer.applySoundbank(hydratedBank)
    },
    getScenePatternChain(): string[] {
      const chain = this.patterns.currentScene?.patternIds ?? []
      const filtered = chain.filter((patternId) => this.patterns.patterns.some((pattern) => pattern.id === patternId))
      if (filtered.length > 0) {
        return filtered
      }
      const fallback = this.patterns.selectedPatternId ?? this.patterns.patterns[0]?.id
      return fallback ? [fallback] : []
    },
    computeExportDuration(): number {
      const bpm = Math.max(1, this.transport.bpm)
      const chain = this.getScenePatternChain()
      const totalBars = chain.reduce((sum, patternId) => {
        const pattern = this.patterns.patterns.find((entry) => entry.id === patternId)
        return sum + (pattern?.gridSpec?.bars ?? DEFAULT_GRID_SPEC.bars)
      }, 0)
      const bars = totalBars || DEFAULT_GRID_SPEC.bars
      return (bars * 4 * 60) / bpm
    },
    async exportBounce() {
      if (this.isExporting) return
      this.isExporting = true
      this.exportError = null
      this.exportStems = null
      try {
        const result = await this.exportAudioFn(this.computeExportDuration())
        this.exportMetadata = result.metadata
        this.exportAudioBlob = result.audioBlob
        this.exportTimeline = result.debugTimeline
        this.exportStems = result.stems ?? null
      } catch (error) {
        console.error('Failed to export audio', error)
        this.exportError = 'Failed to export audio'
        this.exportStems = null
      } finally {
        this.isExporting = false
      }
    },
    downloadStem(pad: DrumPadId) {
      if (this.isExporting) return
      const entry = this.exportStems?.[pad]
      if (!entry) return
      saveAs(entry.blob, entry.fileName)
    },
    downloadMixdown() {
      if (this.isExporting) return
      if (!this.exportAudioBlob) return
      saveAs(this.exportAudioBlob, 'mixdown.wav')
    },
    downloadAllStems() {
      if (this.isExporting || !this.exportStems) return
      Object.values(this.exportStems).forEach((entry) => {
        saveAs(entry.blob, entry.fileName)
      })
    },
    async downloadZip() {
      if (this.isExporting || !this.hasZipArtifacts) return
      try {
        const metadata = this.exportMetadata
        const mixdown = this.exportAudioBlob
        if (!metadata || !mixdown) return
        const metadataBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' })
        const files = [
          { name: 'mixdown.wav', blob: mixdown },
          { name: 'render-meta.json', blob: metadataBlob }
        ]
        if (this.exportStems) {
          Object.entries(this.exportStems).forEach(([padId, entry]) => {
            files.push({ name: `stems/${padId}.wav`, blob: entry.blob })
          })
        }
        const entries: ZipEntry[] = await Promise.all(
          files.map(async (file) => ({
            name: file.name,
            data: new Uint8Array(await file.blob.arrayBuffer())
          }))
        )
        const zipped = createZip(entries)
        const songName = slugify(this.soundbanks.currentBank?.name ?? this.patterns.currentScene?.name ?? this.pattern?.name ?? 'drum-session')
        const seedSuffix = metadata.seed ?? Date.now().toString()
        saveAs(zipped, `${songName}_${seedSuffix}.zip`)
      } catch (error) {
        console.error('Failed to create ZIP archive', error)
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.device-root {
  height: 100%;
  width: 100%;
  overflow: hidden;
  background: @color-bg-root;
}

.device-stage {
  height: 100%;
  min-height: 0;

  display: grid;
  grid-template-columns: 1fr clamp(520px, 36vw, 760px);
  gap: @space-m;
  padding: @space-m;
}

.device-main {
  flex: 1 1 auto;
  min-width: 0;
  min-height: 0;
  overflow: hidden;
  background: @color-surface-1;
  border: 1px solid @color-border-1;
  border-radius: @radius-l;
}

.hardware-stage {
  --stage-pad: clamp(12px, 1.6vw, 24px);
  height: 100svh;
  min-height: 100svh;
  width: 100%;
  padding: var(--stage-pad);
  box-sizing: border-box;
  overflow: hidden;
  background: radial-gradient(130% 130% at 25% 20%, #2c313c 0%, #1a1e26 50%, #0d0f14 100%);
  display: flex;
  align-items: center;
  justify-content: center;
}

.device-hardware {
  position: relative;
  --device-w: 100%;
  --device-gap: clamp(8px, 1.2vh, 16px);
  --panel-radius: @radius-l;
  aspect-ratio: 1080 / 760;
  max-width: calc(100vw - (2 * var(--stage-pad)));
  max-height: calc(100svh - (2 * var(--stage-pad)));

  height: auto;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  gap: var(--device-gap);
  background: linear-gradient(180deg, #1f232c, #151821);
  border: 1px solid fade(#3b4355, 70%);
  border-radius: var(--panel-radius);
  padding: @space-m;
  box-sizing: border-box;
  overflow: hidden;
  box-shadow:
    0 30px 62px rgba(0, 0, 0, 0.6),
    0 2px 12px rgba(0, 0, 0, 0.55),
    inset 0 1px 0 rgba(255, 255, 255, 0.08),
    inset 0 -1px 0 rgba(0, 0, 0, 0.8);
  width: min(
    calc((100svh - (2 * var(--stage-pad))) * (1080 / 760))
  );
}

.top-row {
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: auto auto;
  gap: var(--device-gap);
  align-items: start;
  min-height: 0;
}

.control-stack {
  display: grid;
  grid-template-columns: var(--control-cols, repeat(8, 1fr));
  grid-template-rows: auto auto;
  column-gap: var(--control-col-gap, @space-xs);
  row-gap: var(--device-gap);
  width: 100%;
}

.control-area {
  --control-row-h: clamp(44px, 4.2vh, 56px);
  --control-cols: repeat(8, 1fr);
  --control-col-gap: @space-xs;
  grid-column: 1 / -1;
  grid-row: 1;
  display: grid;
  grid-template-columns: clamp(210px, 18%, 280px) 1fr;
  gap: var(--device-gap);
  min-width: 0;
  min-height: 0;
  align-items: stretch;
  width: 100%;
}

.control-fixed {
  min-width: 0;
  display: flex;
  align-items: flex-start;
}

.control-btn-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: repeat(6, var(--control-row-h));
  gap: @space-xxs;
  width: 100%;
  max-width: 100%;
}

.control-btn.r1 { grid-row: 1; }
.control-btn.r2 { grid-row: 2; }
.control-btn.r3 { grid-row: 3; }
.control-btn.r4 { grid-row: 4; }
.control-btn.r5 { grid-row: 5; }
.control-btn.r6 { grid-row: 6; }
.control-btn.c1 { grid-column: 1; }
.control-btn.c2 { grid-column: 2; }

.control-btn {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid fade(#3b4355, 65%);
  background: linear-gradient(180deg, #1c2230, #121826);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
  color: rgba(255, 255, 255, 0.88);
  line-height: 1.05;
  text-align: left;
  min-height: 44px;
  max-width: 100%;
}

.control-btn__main {
  font-weight: 800;
  letter-spacing: 0.06em;
  font-size: 12px;
  text-transform: uppercase;
}

.control-btn__sub {
  margin-top: 2px;
  font-weight: 400;
  font-style: italic;
  opacity: 0.75;
  font-size: 11px;
  letter-spacing: 0.02em;
  text-transform: none;
}

.control-btn--icon {
  align-items: center;
  text-align: center;
}

.control-btn--icon .control-btn__main {
  font-size: 16px;
  letter-spacing: 0;
}

.control-core {
  display: grid;
  grid-template-rows: repeat(6, var(--control-row-h));
  gap: 0;
  min-width: 0;
  --control-cols: repeat(8, 1fr);
  --control-col-gap: @space-xs;
}

.soft-row {
  grid-row: 1;
  height: var(--control-row-h);
  min-width: 0;
  display: flex;
  align-items: center;
}

.drum-machine-shell :deep(.soft-row) {
  grid-row: 1;
  height: var(--control-row-h);
  min-width: 0;
  display: flex;
  align-items: center;
}

.soft-row-grid {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
}

.soft-row :deep(.soft-strip) {
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
  height: 100%;
  grid-column: 1 / -1;
}

.soft-row :deep(.soft-btn) {
  min-height: 100%;
}

.soft-row :deep(*) {
  height: 100%;
  min-height: 0;
  width: 100%;
}

.display-block {
  grid-row: 2 / span 4;
  position: relative;
  min-width: 0;
  min-height: 0;
  height: calc(var(--control-row-h) * 4);
  display: grid;
  align-items: stretch;
}

.display-grid {
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--device-gap);
  height: 100%;
}

.drum-machine-shell :deep(.display-grid) {
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--device-gap);
  height: 100%;
}

.display-grid :deep(.dual-display-root),
.display-grid :deep(.dual-display),
.display-grid :deep(.dual-display-placeholder) {
  height: 100%;
  min-height: 0;
  grid-column: 1 / -1;
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
  row-gap: 0;
}

.display-grid :deep(.dual-display .display) {
  grid-column: span 4;
  min-width: 0;
}

.display-grid :deep(.dual-display .display:nth-child(1)) {
  grid-column: 1 / span 4;
}

.display-grid :deep(.dual-display .display:nth-child(2)) {
  grid-column: 5 / span 4;
}

.display-param-labels {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 0 8px 6px 8px;
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
  pointer-events: none;
}

.param-label {
  justify-self: center;
  font-size: 10px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  opacity: 0.75;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.knob-row {
  grid-row: 6;
  height: var(--control-row-h);
  display: grid;
  grid-template-columns: var(--control-cols);
  align-items: center;
  gap: var(--device-gap);
  padding: 12px 8px;
  min-width: 0;
  --knob-y: 0px;
}

.knob {
  justify-self: center;
  width: var(--control-row-h);
  height: var(--control-row-h);
  transform: translateY(var(--knob-y));
   --knob-angle: 0deg;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, #3a4150, #151a24 70%);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow:
    inset 0 2px 4px rgba(0,0,0,0.7),
    0 1px 0 rgba(255,255,255,0.06);
  position: relative;
}

.knob::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 50%;
  width: 2px;
  height: 38%;
  transform: translateX(-50%) rotate(var(--knob-angle));
  border-radius: 2px;
  background: rgba(246, 139, 30, 0.9);
  box-shadow: 0 0 6px rgba(246, 139, 30, 0.35);
}

.edit-area {
  --edit-btn-h: clamp(34px, 4.2vh, 44px);
  --edit-row-gap: @space-xxs;
  --edit-stack-d: calc((3 * var(--edit-btn-h)) + (2 * var(--edit-row-gap)));

  /* statt grid-column: 1 / span 3; */
  grid-column: 1 / 3;     
  grid-row: 6;             
  justify-self: normal;

  --core-w: calc(100% - var(--fixed-col-w) - var(--device-gap));

  margin-left: calc(var(--fixed-col-w) - var(--device-gap));
  width: calc(var(--core-w) * 0.375); /* 3/8 = 0.375 */

  display: grid;
  grid-template-columns: 1fr auto;
  grid-template-rows: repeat(3, var(--edit-btn-h));
  column-gap: var(--control-col-gap);
  row-gap: var(--edit-row-gap);
  flex-direction: column;
  align-items: start;
  justify-items: center;
  align-self: start;
  margin-top: calc(var(--device-gap) * 0.5);
  min-height: 0;
  min-width: 0;
}

.encoder-slot {
  grid-column: 1 / 3;
  grid-row: 1 / -1;
  display: grid;
  padding-left: 30%;
  align-items: start;
  justify-content: center;
  justify-self: start;
  align-self: start;
  width: var(--edit-stack-d);
  height: var(--edit-stack-d);
}



.quick-edit-buttons {
  grid-column: 3 / -1;
  grid-row: 1;
  display: grid;
  grid-template-rows: repeat(3, var(--edit-btn-h));
  row-gap: var(--edit-row-gap);
  align-content: start;
  align-items: start;

}

.quick-edit-btn {
  min-height: var(--edit-btn-h);
  height: var(--edit-btn-h);
  width: 100%;
}

.four-d-encoder {
  position: relative;
  border-radius: 50%;
  background: radial-gradient(circle at 35% 30%, #3c4352, #121722 70%);
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow:
    inset 0 3px 6px rgba(0,0,0,0.65),
    0 2px 6px rgba(0,0,0,0.45);
}

.four-d-encoder::after {
  content: '';
  position: absolute;
  top: 6%;
  left: 50%;
  width: 3px;
  height: 30%;
  transform: translateX(-50%);
  border-radius: 2px;
  background: rgba(246, 139, 30, 0.95);
  box-shadow: 0 0 10px rgba(246, 139, 30, 0.35);
}

.bottom-row {
  display: grid;
  grid-template-columns: clamp(220px, 24%, 320px) minmax(0, 1fr);
  grid-template-areas: 'left right';
  gap: var(--device-gap);
  min-height: 0;
}

.drum-machine-shell :deep(.bottom-row) {
  display: grid;
  grid-template-columns: clamp(220px, 24%, 320px) minmax(0, 1fr);
  grid-template-areas: 'left right';
  gap: var(--device-gap);
  min-height: 0;
}

.left-column {
  grid-area: left;
  display: flex;
  flex-direction: column;
  gap: @space-s;
  min-height: 0;
}

.transport-cluster {
  background: linear-gradient(180deg, #1f2531, #141924);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  min-height: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
}

.drawer-shell {
  flex: 1 1 auto;
  min-height: 0;
  max-height: clamp(260px, 36vh, 360px);
  overflow: auto;
  background: linear-gradient(180deg, #1c202b, #10141d);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
}

.drum-machine-shell :deep(.drawer-shell) {
  flex: 1 1 auto;
  min-height: 0;
  max-height: clamp(260px, 36vh, 360px);
  overflow: auto;
  background: linear-gradient(180deg, #1c202b, #10141d);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
}

.right-column {
  grid-area: right;
  display: flex;
  flex-direction: column;
  gap: var(--device-gap);
  min-height: 0;
}

.drum-machine-shell :deep(.right-column) {
  grid-area: right;
  display: flex;
  flex-direction: column;
  gap: var(--device-gap);
  min-height: 0;
}

.pads-and-strip {
  display: grid;
  //grid-template-columns: clamp(90px, 18%, 140px) minmax(0, 1fr);
  grid-template-areas: 'strip pads';
  gap: var(--device-gap);
  align-items: end;
  width: 100%;
  min-height: 0;
}

.drum-machine-shell :deep(.pads-and-strip) {
  display: grid;
  grid-template-areas: 'strip pads';
  gap: var(--device-gap);
  align-items: end;
  width: 100%;
  min-height: 0;
}

.strip-column {
  grid-area: strip;
  align-self: end;
  justify-self: start;
  min-height: 0;
}

.pads-column {
  grid-area: pads;
  min-width: 0;
}

.pads-stack {
  display: grid;
  grid-columns: 4 / -1;
  grid-rows: 4 / -1;
  flex-direction: column;
  gap: @space-xs;
  align-items: end;
  justify-content: end;
  //width: 80%;
  min-width: 0;
  min-height: 0;
  align-self: end;
  justify-self: end;
  background: linear-gradient(180deg, #191d27, #10141d);
  border: 1px solid fade(#3b4355, 60%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
}

.drum-machine-shell :deep(.pads-stack) {
  display: grid;
  grid-columns: 4 / -1;
  grid-rows: 4 / -1;
  flex-direction: column;
  gap: @space-xs;
  align-items: end;
  justify-content: end;
  min-width: 0;
  min-height: 0;
  align-self: end;
  justify-self: end;
  background: linear-gradient(180deg, #191d27, #10141d);
  border: 1px solid fade(#3b4355, 60%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
}

.pads-square {
  width: 100%;
  // max-width: clamp(420px, 62%, 960px);
  aspect-ratio: 1 / 1;
  min-height: 0;
  display: flex;
}

.drum-machine-shell :deep(.pads-square) {
  width: 100%;
  aspect-ratio: 1 / 1;
  min-height: 0;
  display: flex;
}

.pads-square > * {
  flex: 1 1 auto;
  min-width: 0;
  min-height: 0;
}

.pads-square > :deep(*) {
  flex: 1 1 auto;
  min-width: 0;
  min-height: 0;
}

.device-hardware.debug-overlay::before {
  content: '';
  position: absolute;
  inset: 0;
  background: url('/img/maschine-reference.png') center / contain no-repeat;
  opacity: 0.35;
  pointer-events: none;
  z-index: 5;
}

.device-hardware.debug-grid::after {
  content: '';
  position: absolute;
  inset: 0;
  background-image:
    linear-gradient(to right, rgba(255, 255, 255, 0.15) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255, 255, 255, 0.15) 1px, transparent 1px);
  background-size: 20px 20px;
  opacity: 0.15;
  pointer-events: none;
  z-index: 6;
}

.pad-grid-indicator {
  display: flex;
  justify-content: center;
  gap: @space-xs;
  padding: @space-xxs;
  background: rgba(255, 255, 255, 0.02);
  border-radius: @radius-s;
}

.drum-machine-shell :deep(.pad-grid-indicator) {
  display: flex;
  justify-content: center;
  gap: @space-xs;
  padding: @space-xxs;
  background: rgba(255, 255, 255, 0.02);
  border-radius: @radius-s;
}

.indicator-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #1f2734;
  box-shadow: inset 0 0 4px rgba(0,0,0,0.9);
}

.indicator-dot.active {
  background: #f68b1e;
  box-shadow:
    0 0 6px fade(#f68b1e, 60%),
    0 0 12px fade(#f68b1e, 35%);
}

@media (max-width: 1200px) {
  .bottom-row {
    grid-template-columns: 320px 1fr;
  }

  .pads-square {
    width: clamp(360px, 48vw, 520px);
  }

  .drum-machine-shell :deep(.bottom-row) {
    grid-template-columns: 320px 1fr;
  }

  .drum-machine-shell :deep(.pads-square) {
    width: clamp(360px, 48vw, 520px);
  }
}

@media (max-width: 960px) {
  .device-hardware {
    grid-template-rows: auto auto 1fr;
  }

  .top-row {
    grid-template-columns: 1fr;
    gap: @space-s;
    align-items: start;
  }
  
  .control-area {
    grid-template-columns: 1fr;
  }

  .bottom-row {
    grid-template-columns: 1fr;
  }

  .right-column {
    grid-template-columns: 1fr;
  }

  .pads-and-strip {
    grid-template-columns: 1fr;
    grid-template-areas:
      'strip'
      'pads';
    justify-items: center;
    align-items: center;
  }

  .drawer-shell {
    max-height: 45vh;
  }

  .drum-machine-shell :deep(.bottom-row) {
    grid-template-columns: 1fr;
  }

  .drum-machine-shell :deep(.right-column) {
    grid-template-columns: 1fr;
  }

  .drum-machine-shell :deep(.pads-and-strip) {
    grid-template-columns: 1fr;
    grid-template-areas:
      'strip'
      'pads';
    justify-items: center;
    align-items: center;
  }

  .drum-machine-shell :deep(.drawer-shell) {
    max-height: 45vh;
  }
}

.edit-area {
  grid-column: 1 / 3;
  grid-row: 2;
}

.performance-vert {
  grid-column: 4;
  grid-row: 2;
  display: grid;
  grid-template-rows: repeat(3, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  row-gap: var(--edit-row-gap, @space-xxs);
  align-self: end;
  justify-self: stretch;
  width: 100%;
}

.performance-vert .control-btn {
  width: 100%;
  min-height: var(--edit-btn-h, clamp(34px, 4.2vh, 44px));
}

.performance-vert__spacer {
  width: 100%;
  height: 100%;
}

.performance-block {
  grid-column: 1 / span 4;
  grid-row: 3;
  display: grid;
  grid-template-rows: auto auto auto;
  row-gap: var(--edit-row-gap, @space-xxs);
  align-self: start;
  justify-self: stretch;
  width: 100%;
}

.performance-btn-row {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: @space-xxs;
}

.performance-btn-row .control-btn {
  width: 100%;
  min-height: var(--edit-btn-h, clamp(34px, 4.2vh, 44px));
}

.smart-strip {
  width: 100%;
  height: clamp(46px, 5vh, 64px);
  border-radius: @radius-m;
  background: linear-gradient(90deg, #2a2f3a, #141824);
  border: 1px solid fade(#3b4355, 60%);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.group-area {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
}

.group-area .control-btn {
  width: 100%;
  min-height: var(--edit-btn-h, clamp(34px, 4.2vh, 44px));
}

.transport-area {
  background: linear-gradient(180deg, #1f2531, #141924);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  min-height: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
  width: 100%;
}

.drum-machine-shell :deep(.transport-area) {
  background: linear-gradient(180deg, #1f2531, #141924);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  min-height: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
  width: 100%;
}

.transport-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
}

.drum-machine-shell :deep(.transport-grid) {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
}

.shift-label {
  height: 14px;
  background: #fff;
  color: #000;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: 0.06em;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  border-radius: 4px;
}

.right-column {
  justify-content: flex-end;
}

.drum-machine-shell :deep(.right-column) {
  justify-content: flex-end;
}

.pads-and-strip {
  --pads-square-size: clamp(320px, 42vh, 520px);
  --pad-cell-size: calc(var(--pads-square-size) / 4);
  align-items: end;
  grid-template-columns: clamp(90px, 18%, 140px) minmax(0, 1fr);
}

.drum-machine-shell :deep(.pads-and-strip) {
  --pads-square-size: clamp(320px, 42vh, 520px);
  --pad-cell-size: calc(var(--pads-square-size) / 4);
  align-items: end;
  grid-template-columns: clamp(90px, 18%, 140px) minmax(0, 1fr);
}

.pad-top-buttons {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: @space-xxs;
  width: 100%;
  margin-bottom: @space-xs;
}

.pads-column {
  grid-area: pads;
  align-self: end;
}

.mode-buttons {
  grid-area: strip;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(8, 1fr);
  gap: @space-xxs;
  align-self: end;
  height: var(--pads-square-size);
}

.drum-machine-shell :deep(.mode-buttons) {
  grid-area: strip;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(8, 1fr);
  gap: @space-xxs;
  align-self: end;
  height: var(--pads-square-size);
}

.mode-buttons .control-btn {
  min-height: calc(var(--pad-cell-size) * 2);
}

.drum-machine-shell :deep(.mode-buttons .control-btn) {
  min-height: calc(var(--pad-cell-size) * 2);
}

.pads-stack {
  align-self: end;
}

.drum-machine-shell :deep(.pads-stack) {
  align-self: end;
}

.pads-square {
  max-width: var(--pads-square-size);
  aspect-ratio: 1 / 1;
}

.drum-machine-shell :deep(.pads-square) {
  max-width: var(--pads-square-size);
  aspect-ratio: 1 / 1;
}

.pad-grid-indicator {
  overflow: visible;
}

.drum-machine-shell :deep(.pad-grid-indicator) {
  overflow: visible;
}

.drawer-shell :deep([data-tab='fx']),
.drawer-shell :deep(.fx-panel) {
  display: none !important;
}

</style>



=========================================
File: components/FxPopup.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .fx-popup
      .fx-popup-header
        .fx-title {{ effectLabel }}
        .fx-context {{ contextLabel }}
        button.fx-close(@click="$emit('close')") âœ•
      .fx-popup-body
        FxPanel(
          :fx-settings="fxSettings"
          @fx:update="$emit('fx:update', $event)"
        )
</template>

<script lang="ts">
export default {
  name: 'FxPopup'
}
</script>

<style lang="less" scoped>
@import '@/styles/variables.less';

.fx-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: min(720px, 92vw);
  max-height: 92vh;
  display: flex;
  flex-direction: column;
  background: @color-surface-2;080b10;
  border: 1px solid @color-border-2;
  @radius-xl: 20px;
  z-index: 2000;
}

.fx-popup-header {
  flex: 0 0 auto;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);

  .fx-title {
    font-weight: 600;
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }

  .fx-context {
    margin-left: auto;
    font-size: 0.75rem;
    opacity: 0.6;
  }

  .fx-close {
    background: transparent;
    border: none;
    color: inherit;
    font-size: 1.2rem;
    cursor: pointer;
  }
}

.fx-popup-body {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}
</style>


=========================================
File: components/KnobControl.vue
=========================================

<template>
  <div
    class="knob"
    role="presentation"
    tabindex="0"
    :aria-label="ariaLabel"
    :title="label"
    :style="knobStyle"
    @wheel.prevent="onWheel"
    @pointerdown.prevent="onPointerDown"
    @keydown="onKeydown"
  ></div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

const clamp = (value: number, min: number, max: number): number => Math.max(min, Math.min(max, value))

export default defineComponent({
  name: 'KnobControl',
  props: {
    index: { type: Number, required: true },
    label: { type: String, default: '' },
    value: { type: Number, default: 0 },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 127 },
    step: { type: Number, default: 1 },
    fineStep: { type: Number, default: undefined },
    shiftHeld: { type: Boolean, default: false }
  },
  emits: ['turn'],
  data() {
    return {
      dragActive: false,
      lastClientY: 0,
      dragAccumulator: 0,
      pointerId: null as number | null
    }
  },
  computed: {
    progress(): number {
      const range = this.max - this.min
      if (range === 0) return 0
      return clamp((this.value - this.min) / range, 0, 1)
    },
    knobAngle(): number {
      // Map value range to -135..135 deg for indicator travel.
      return -135 + this.progress * 270
    },
    knobStyle(): Record<string, string> {
      return { '--knob-angle': `${this.knobAngle}deg` }
    },
    ariaLabel(): string {
      return this.label ? `${this.label}` : `Encoder ${this.index + 1}`
    }
  },
  beforeUnmount() {
    window.removeEventListener('pointermove', this.onPointerMove)
    window.removeEventListener('pointerup', this.onPointerUp)
  },
  methods: {
    emitTurn(delta: number, fine?: boolean) {
      if (!delta) return
      this.$emit('turn', { delta, fine: !!fine })
    },
    isFine(event?: WheelEvent | PointerEvent | KeyboardEvent): boolean {
      return this.shiftHeld || Boolean(event?.shiftKey)
    },
    onWheel(event: WheelEvent) {
      const direction = event.deltaY < 0 ? 1 : -1
      const magnitude = Math.abs(event.deltaY)
      const steps = magnitude > 60 ? 2 : 1
      this.emitTurn(direction * steps, this.isFine(event))
    },
    onKeydown(event: KeyboardEvent) {
      if (event.key === 'ArrowUp' || event.key === 'ArrowRight') {
        this.emitTurn(1, this.isFine(event))
        event.preventDefault()
      } else if (event.key === 'ArrowDown' || event.key === 'ArrowLeft') {
        this.emitTurn(-1, this.isFine(event))
        event.preventDefault()
      }
    },
    onPointerDown(event: PointerEvent) {
      this.dragActive = true
      this.lastClientY = event.clientY
      this.dragAccumulator = 0
      this.pointerId = event.pointerId
      const target = event.currentTarget as HTMLElement | null
      target?.setPointerCapture?.(event.pointerId)
      window.addEventListener('pointermove', this.onPointerMove)
      window.addEventListener('pointerup', this.onPointerUp)
    },
    onPointerMove(event: PointerEvent) {
      if (!this.dragActive) return
      if (this.pointerId !== null && event.pointerId !== this.pointerId) return
      const deltaY = this.lastClientY - event.clientY
      this.dragAccumulator += deltaY
      const stepPx = 6
      const steps = Math.trunc(this.dragAccumulator / stepPx)
      if (steps !== 0) {
        this.dragAccumulator -= steps * stepPx
        this.emitTurn(steps, this.isFine(event))
      }
      this.lastClientY = event.clientY
    },
    onPointerUp(event: PointerEvent) {
      if (this.pointerId !== null && event.pointerId !== this.pointerId) return
      this.dragActive = false
      this.pointerId = null
      this.dragAccumulator = 0
      window.removeEventListener('pointermove', this.onPointerMove)
      window.removeEventListener('pointerup', this.onPointerUp)
    }
  }
})
</script>



=========================================
File: components/MidiPanel.vue
=========================================

<template lang="pug">
v-card
  v-card-title MIDI
  v-card-text
    p(v-if="!supports") Web MIDI not supported in this browser.
    template(v-else)
      v-btn(color="primary" @click="$emit('request')") Request Access
      v-select(:items="devices" item-title="name" item-value="id" label="MIDI Inputs")
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { MidiDeviceInfo } from '~/types/midi'

export default defineComponent({
  name: 'MidiPanel',
  props: {
    devices: { type: Array as () => MidiDeviceInfo[], required: true },
    supports: { type: Boolean, required: true }
  },
  emits: ['request']
})
</script>



=========================================
File: components/PadCell.vue
=========================================

<template lang="pug">
  button.pad-cell(
    type="button"
    :class="padClasses"
    :title="padHint"
    :aria-label="padHint"
    :style="padStyle"
    @pointerdown.prevent="handleActivate"
    @click.prevent="handleActivate"
    @keydown.enter.prevent="handleActivate"
    @keydown.space.prevent="handleActivate"
    :aria-pressed="isSelected"
  )
    span.pad-label {{ label }}
    span.pad-key(v-if="keyLabel") {{ keyLabel }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { DrumPadId } from '@/types/drums'
// Represents a single drum pad cell, emitting pad hits and selection while reflecting trigger/play states.

export default defineComponent({
  name: 'PadCell',
  props: {
    padId: { type: String as () => DrumPadId, required: true },
    label: { type: String, required: true },
    isSelected: { type: Boolean, default: false },
    isTriggered: { type: Boolean, default: false },
    isPlaying: { type: Boolean, default: false },
    isEmpty: { type: Boolean, default: false },
    keyLabel: { type: String, default: null },
    padColor: { type: String, default: '#12c8ff' }
  },
  emits: ['pad:down', 'pad:select'],
  computed: {
    padClasses(): Record<string, boolean> {
      return {
        'is-selected': this.isSelected,
        'is-triggered': this.isTriggered,
        'is-playing': this.isPlaying,
        'is-empty': this.isEmpty
      }
    },

    padHint(): string {
      const key = this.keyLabel ? ` (${this.keyLabel})` : ''
      return `${this.label}${key} â€“ click or press to trigger/select`
    },

    padStyle(): Record<string, string> {
      return {
        '--pad-color-base': this.padColor
      }
    }
  },
  methods: {
    handleActivate() {
      this.$emit('pad:down', this.padId)
      this.$emit('pad:select', this.padId)
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.pad-cell {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  color: @color-text-primary;
  background: linear-gradient(
    180deg,
    color-mix(in srgb, var(--pad-color-base, #12c8ff) 80%, #ffffff 20%),
    color-mix(in srgb, var(--pad-color-base, #12c8ff) 85%, #000000 15%)
  );
  border: 1px solid #2c3342;
  border-radius: @radius-s;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.08),
    0 6px 14px rgba(0,0,0,0.45);
}

.pad-cell.is-empty {
  background-color: #f2f1e8;
  border-color: #d6d4c8;
}

.pad-cell.is-selected {
  border-color: @color-border-3;

  box-shadow:
    0 0 0 2px fade(@color-border-3, 25%),
    @shadow-box;
}

.pad-cell.is-triggered {
  background-color: ~"color-mix(
    in srgb,
    @color-surface-1 calc(100% - (var(--pad-velocity) * 60%)),
    #000000
  )";
}

.pad-cell.is-triggered .pad-label {
  opacity: 0.85;
}

.pad-cell:not(.is-empty).is-triggered::after {
  box-shadow: 0 0
    calc(10px * var(--pad-velocity))
    fade(@color-accent-primary, 40%);
}

.pad-cell.is-triggered:not(.is-playing) {
  background: linear-gradient(
    180deg,
    fade(@color-text-primary, 90%),
    fade(@color-text-primary, 65%)
  );
}

.pad-cell:active {
  transform: translateY(1px);
  box-shadow:
    inset 0 3px 6px rgba(0,0,0,0.8);
}

.pad-label {
  font-weight: 600;
  letter-spacing: 0.04em;
  color: #fefefe;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.pad-cell.is-playing {
  background: linear-gradient(
    180deg,
    fade(@color-accent-primary, 90%),
    fade(@color-accent-primary, 55%)
  );

  box-shadow:
    0 0 calc(18px * var(--pad-velocity))
      fade(@color-accent-primary, 70%),
    @shadow-box;
}

.pad-key {
  position: absolute;
  bottom: @space-xs;
  left: @space-xs;
  font-size: @font-size-xs;
  opacity: 0;
  pointer-events: none;
}

.pad-grid:focus-visible .pad-key {
  opacity: 0.35;
}
</style>



=========================================
File: components/PadGrid.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .pad-grid(
      role="grid"
      tabindex="0"
      aria-label="Pad grid"
      :aria-rowcount="4"
      :aria-colcount="4"
      @keydown.arrow-up.prevent="moveSelection(-4)"
      @keydown.arrow-down.prevent="moveSelection(4)"
      @keydown.arrow-left.prevent="moveSelection(-1)"
      @keydown.arrow-right.prevent="moveSelection(1)"
      @keydown.home.prevent="selectIndex(0)"
      @keydown.end.prevent="selectIndex(pads.length - 1)"
      @keydown.page-up.prevent="selectRow(0)"
      @keydown.page-down.prevent="selectRow(3)"
      :style="velocityStyle"
    )
      PadCell(
        v-for="(pad, index) in pads"
        :key="pad"
        :ref="setPadRef(pad)"
        :pad-id="pad"
        :label="padLabel(pad)"
        :is-selected="selectedPad === pad"
        :is-focusable="selectedPad === pad"
        :is-triggered="padStates[pad]?.isTriggered ?? false"
        :is-playing="padStates[pad]?.isPlaying ?? false"
        :is-empty="padIsEmpty(pad)"
        :key-label="keyLabels[index]"
        :pad-color="padColors[index] ?? padColors[0]"
        role="gridcell"
        :aria-label="padAriaLabel(pad)"
        :aria-rowindex="Math.floor(index / 4) + 1"
        :aria-colindex="(index % 4) + 1"
        @pad:down="$emit('pad:down', $event)"
        @pad:select="$emit('pad:select', $event)"
      )
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import PadCell from './PadCell.vue'
import type { DrumPadId } from '@/types/drums'
// Renders a 4x4 pad grid with keyboard navigation and selection, delegating interactions to PadCell instances.

const KEY_LABELS = [
  'Q','W','E','R',
  'A','S','D','F',
  'Z','X','C','V',
  '1','2','3','4'
]

type PadState = {
  label: string
  isTriggered: boolean
  isPlaying: boolean
}

export default defineComponent({
  name: 'PadGrid',
  components: { 
    PadCell,
    
    },

  props: {
    pads: { type: Array as () => DrumPadId[], required: true },
    selectedPad: { type: String as () => DrumPadId | null, default: null },
    velocity: { type: Number, default: 1 },
    padStates: {
      type: Object as () => Partial<Record<DrumPadId, PadState>>,
      default: () => ({})
    },
    padColors: {
      type: Array as () => string[],
      default: () => [
        '#12c8ff','#00d5ff','#00c3ff','#00b4ff',
        '#ffb840','#ff9f30','#ffb43c','#ff9c2a',
        '#ff3a3a','#ff4f4f','#ffd13a','#ffbc2a',
        '#46e3ff','#38d4ff','#2cc5ff','#20baff'
      ]
    }
  },

  emits: ['pad:down', 'pad:select'],

  data() {
    return {
      internalPadRefs: {} as Record<DrumPadId, InstanceType<typeof PadCell> | undefined>
    }
  },

  computed: {
    velocityStyle(): Record<string, string> {
      const clamped = Math.min(1, Math.max(0, this.velocity))
      return { '--pad-velocity': clamped.toString() }
    },

    keyLabels(): string[] {
      return KEY_LABELS
    },
    
    padRefs(): Record<DrumPadId, InstanceType<typeof PadCell> | undefined> {
      return this.internalPadRefs
    }
  },

  watch: {
    selectedPad(newPad: DrumPadId | null) {
      if (!newPad) return
      this.$nextTick(() => {
        const ref = this.padRefs[newPad]
        ref?.$el?.focus?.()
      })
    }
  },

  mounted() {
    if (this.pads.length !== this.keyLabels.length) {
      console.warn(
        `[PadGrid] pads (${this.pads.length}) â‰  keyLabels (${this.keyLabels.length})`
      )
    }
  },

  methods: {
    setPadRef(pad: DrumPadId) {
      return (el: InstanceType<typeof PadCell> | null) => {
        if (el) {
          this.internalPadRefs[pad] = el
        } else {
          delete this.internalPadRefs[pad]
        }
      }
    },

    padLabel(pad: DrumPadId): string {
      return this.padStates[pad]?.label ?? pad.toUpperCase()
    },

    padAriaLabel(pad: DrumPadId): string {
      const label = this.padLabel(pad)
      return `${label} pad`
    },

    padIsEmpty(pad: DrumPadId): boolean {
      return !this.padStates[pad]?.label
    },

    handlePadDown(pad: DrumPadId, velocity: number) {
      this.$emit('pad:down', pad, velocity)
    },

    handlePadSelect(pad: DrumPadId) {
      this.$emit('pad:select', pad)
    },

    selectIndex(index: number) {
      if (index < 0 || index >= this.pads.length) return
      this.$emit('pad:select', this.pads[index])
    },

    selectRow(row: number) {
      const columns = 4
      const index = row * columns
      if (index < this.pads.length) {
        this.$emit('pad:select', this.pads[index])
      }
    },

    moveSelection(offset: number) {
      if (!this.selectedPad) return

      const index = this.pads.indexOf(this.selectedPad)
      if (index === -1) return

      const columns = 4
      let nextIndex = index + offset

      if (offset === -1 && index % columns === 0) {
        nextIndex = index + (columns - 1)
      }

      if (offset === 1 && (index + 1) % columns === 0) {
        nextIndex = index - (columns - 1)
      }

      if (nextIndex < 0 || nextIndex >= this.pads.length) return
      this.$emit('pad:select', this.pads[nextIndex])
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.pad-grid {
  display: grid;
  grid-template-rows: repeat(4, minmax(0, 1fr));
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: @space-s;
  width:100%;
  height:100%;
  background: @color-surface-2;
  padding: @space-m;
  box-sizing: border-box;
  border-radius: @radius-l;
  border: 1px solid @color-border-2;

}

.pad-grid:focus-visible {
  outline: @outline-focus;
  outline-offset: @outline-focus-offset;
  border-color: #00f8ff;
}
.pad-cell.is-selected {
  border-color: @color-accent-primary;
  outline: 2px dashed #00f8ff;
  outline-offset: 3px;
}
.pad-cell:focus-visible:not(.is-selected) {
  outline: @outline-focus;
  outline-offset: @outline-focus-offset;
  box-shadow: 0 0 calc(12px * var(--pad-velocity)) ~"rgba(0, 255, 255, calc(0.2 + 0.6 * var(--pad-velocity)))";
  box-shadow: 0 0 calc(12px * var(--pad-velocity)) fade(@color-accent-primary, 60%);
}

</style>



=========================================
File: components/PlayheadOverlay.vue
=========================================

<template lang="pug">
  div.playhead-overlay(
    v-if="totalSteps > 0"
    :style="overlayStyle"
    :class="{ 'is-playing': isPlaying }"
  )
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { CSSProperties } from 'vue'

export default defineComponent({
  name: 'PlayheadOverlay',
  // Visual overlay that positions a playhead indicator across a step grid based on current playback state.
  props: {
    currentStep: { type: Number, required: true },
    totalSteps: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true }
  },
  computed: {
    safeTotalSteps(): number {
      return Math.max(this.totalSteps, 1)
    },
    clampedStep(): number {
      const maxIndex = this.safeTotalSteps - 1
      return Math.min(Math.max(0, this.currentStep), maxIndex)
    },
    stepWidthPercent(): number {
      return 100 / this.safeTotalSteps
    },
    overlayStyle(): CSSProperties {
      return {
        '--step-count': `${this.safeTotalSteps}`,
        '--step-index': `${this.clampedStep}`
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.playhead-overlay {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  --grid-gap: 8px;
  --step-count: 1;
  --step-index: 0;
  width: calc(
    (100% - (var(--grid-gap) * (var(--step-count) - 1))) / var(--step-count)
  );
  left: calc(
    var(--step-index) *
      (
        (100% - (var(--grid-gap) * (var(--step-count) - 1))) / var(--step-count) +
          var(--grid-gap)
      )
  );
  background: transparent;
  pointer-events: none;
  border-radius: @radius-xs;
  box-shadow:
    inset 0 0 0 1px fade(@color-accent-primary, 28%),
    inset 0 0 0 2px fade(@color-accent-primary, 12%);
  opacity: 0.97;
  transition: none;

  &.is-playing {
    transition: left 120ms linear;
  }

  &::before {
    content: '';
    position: absolute;
    top: 10%;
    bottom: 10%;
    left: 0;
    right: 0;
    margin: auto;
    background: linear-gradient(
      90deg,
      fade(@color-accent-primary, 0%) 0%,
      fade(@color-accent-primary, 28%) 45%,
      fade(@color-accent-primary, 46%) 50%,
      fade(@color-accent-primary, 28%) 55%,
      fade(@color-accent-primary, 0%) 100%
    );
    box-shadow:
      0 0 10px fade(@color-accent-primary, 30%),
      0 0 18px fade(@color-accent-primary, 16%),
      inset 0 0 8px fade(@color-accent-primary, 20%);
  }
}
</style>



=========================================
File: components/SampleBrowser.vue
=========================================

<template lang="pug">
v-card
  v-card-title Samples
  v-card-text
    p Add custom sample support here.
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'SampleBrowser'
})
</script>



=========================================
File: components/SoundbankManager.vue
=========================================

<template lang="pug">
v-card
  v-card-title Soundbanks
  v-card-text
    v-list
      v-list-item(v-for="bank in banks" :key="bank.id")
        v-list-item-title {{ bank.name }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { Soundbank } from '~/types/audio'

export default defineComponent({
  name: 'SoundbankManager',
  props: {
    banks: { type: Array as () => Soundbank[], required: true }
  }
})
</script>



=========================================
File: components/StepCell.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    button.step-cell(
      type="button"
      :class="cellClasses"
      :aria-pressed="isActive"
      @click="onToggle"
      @pointerdown="onPointerDown"
      @pointermove="onPointerMove"
      @pointerup="onPointerUp"
      @pointercancel="onPointerCancel"
    )
      span.step-tag {{ displayLabel }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'StepCell',
  props: {
    isAccent: { type: Boolean, default: false },
    isActive: { type: Boolean, default: false },
    isCurrent: { type: Boolean, default: false },
    displayLabel: { type: String, default: '' }
  },
  emits: [
    'cell:toggle',
    'cell:pointerdown',
    'cell:pointermove',
    'cell:pointerup',
    'cell:pointercancel'
  ],
  computed: {
    cellClasses(): Record<string, boolean> {
      return {
        'is-active': this.isActive,
        'is-accent': this.isAccent,
        'is-current': this.isCurrent
      }
    }
  },
  methods: {
    onToggle(): void {
      this.$emit('cell:toggle')
    },
    onPointerDown(event: PointerEvent): void {
      if (event.currentTarget instanceof HTMLElement) {
        event.currentTarget.setPointerCapture(event.pointerId)
      }
      this.$emit('cell:pointerdown', event)
    },
    onPointerMove(event: PointerEvent): void {
      this.$emit('cell:pointermove', event)
    },
    onPointerUp(event: PointerEvent): void {
      this.$emit('cell:pointerup', event)
    },
    onPointerCancel(event: PointerEvent): void {
      this.$emit('cell:pointercancel', event)
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.step-cell {
  border: none;
  border-radius: @radius-s;
  background: fade(@color-accent-primary, 15%);
  color: @color-text-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: @font-size-xs;
  padding: @space-xs 0;
  transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
  position: relative;
  cursor: pointer;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  z-index: 1;

  &:not(.is-active):hover {
    background: fade(@color-accent-primary, 25%);
  }

  &:active {
    transform: scale(0.97);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px fade(@color-accent-primary, 60%);
  }

  &.is-active {
    background: fade(@color-accent-primary, 15%);
  }

  &.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 25%),
      fade(@color-accent-warning, 65%)
    );
  }

  &.is-active.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 35%),
      fade(@color-accent-primary, 35%)
    );
  }

  &.is-current {
    box-shadow: inset 0 0 0 2px fade(@color-accent-primary, 90%);
  }

  &.is-accent.is-current {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
    animation: accent-scan-pulse 160ms ease-out 1;
  }
}

.step-tag {
  font-size: @font-size-xs;
  letter-spacing: @letter-spacing-tight;
}

@keyframes accent-scan-pulse {
  from {
    transform: scale(1.02);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 95%),
      0 0 16px fade(@color-accent-warning, 38%);
  }
  to {
    transform: scale(1);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
  }
}
</style>



=========================================
File: components/StepGrid.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .step-grid-shell(
      role="grid"
      :aria-label="stepGridLabel"
      :aria-colcount="totalSteps"
      tabindex="0"
      @keydown="onKeydown"
      ref="shell"
    )
      .step-row(role="row")
        StepCell(
          v-for="stepIndex in totalSteps"
          :key="stepIndex"
          :display-label="String(stepIndex)"
          :is-active="isActive(stepIndex - 1)"
          :is-accent="isAccent(stepIndex - 1)"
          :is-current="isCurrent(stepIndex - 1)"
          :class="{ 'is-pattern-start': isPatternStart(stepIndex - 1) }"
          role="gridcell"
          :aria-label="cellAriaLabel(stepIndex - 1)"
          :aria-selected="isActive(stepIndex - 1)"
          @cell:toggle="emitToggle(stepIndex - 1)"
          @cell:pointerdown="onCellPointerDown(stepIndex - 1, $event)"
          @cell:pointermove="onCellPointerMove($event)"
          @cell:pointerup="onCellPointerUp($event)"
          @cell:pointercancel="onCellPointerCancel($event)"
        )
        div.pattern-boundary(
          v-for="boundary in patternBoundaries"
          :key="boundary"
          :style="boundaryStyle(boundary)"
        )
      PlayheadOverlay(
        v-if="totalSteps > 0"
        :current-step="currentStepNormalized"
        :total-steps="totalSteps"
        :is-playing="isPlaying"
      )
      div.loop-overlay(:style="loopStyle" aria-hidden="true")
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import StepCell from './StepCell.vue'
import PlayheadOverlay from './PlayheadOverlay.vue'
import type { GridSpec } from '@/types/time'
import type { DrumPadId, StepGrid } from '@/types/drums'
import { ACCENT_STEP_VELOCITY, clampVelocity } from '@/domain/velocity'

export default defineComponent({
  name: 'StepGrid',
  components: {
    StepCell,
    PlayheadOverlay
  },
  props: {
    gridSpec: { type: Object as () => GridSpec, required: true },
    steps: { type: Object as () => StepGrid, required: true },
    patternChain: {
      type: Array as () => Array<{ id: string; bars: number }> | null,
      default: null
    },
    selectedPad: { type: String as () => DrumPadId | null, default: null },
    currentStep: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true },
    followEnabled: { type: Boolean, default: true },
    loopStart: { type: Number, default: 0 },
    loopEnd: { type: Number, default: 1 }
  },
  emits: ['step:toggle', 'playhead:scrub', 'step:velocity'],
  data() {
    return {
      dragState: null as null | {
        pointerId: number
        startY: number
        startVelocity: number
        stepIndex: number
      }
    }
  },
  computed: {
    totalSteps(): number {
      return Math.max(0, this.gridSpec.bars * this.gridSpec.division)
    },
    currentStepNormalized(): number {
      const steps = Math.max(this.totalSteps, 1)
      return ((this.currentStep % steps) + steps) % steps
    },
    stepGridLabel(): string {
      return this.selectedPad ? `Steps for ${this.selectedPad}` : 'Step grid'
    },
    patternBoundaries(): number[] {
      if (!this.patternChain || this.patternChain.length === 0) {
        return []
      }

      const boundaries: number[] = []
      const stepsPerBar = this.gridSpec.division
      let cumulative = 0

      this.patternChain.forEach((entry, index) => {
        cumulative += entry.bars * stepsPerBar
        if (index === this.patternChain!.length - 1) {
          return
        }
        if (cumulative < this.totalSteps) {
          boundaries.push(cumulative)
        }
      })

      return boundaries
    },
    loopStyle(): Record<string, string> {
      const total = Math.max(1, this.totalSteps)
      const clampedStart = Math.max(0, Math.min(this.loopStart, total - 1))
      const clampedEnd = Math.max(clampedStart + 1, Math.min(this.loopEnd, total))
      const left = (clampedStart / total) * 100
      const width = ((clampedEnd - clampedStart) / total) * 100
      return { left: `${left}%`, width: `${width}%` }
    }
  },
  methods: {
    focusGrid(): void {
      const el = this.$refs.shell as HTMLElement | undefined
      el?.focus()
    },
    resolveStepPosition(index: number): { barIndex: number; stepInBar: number } {
      const barIndex = Math.floor(index / this.gridSpec.division)
      const stepInBar = index % this.gridSpec.division
      return { barIndex, stepInBar }
    },
    emitToggle(index: number): void {
      if (!this.selectedPad) {
        return
      }
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      this.$emit('step:toggle', {
        barIndex,
        stepInBar,
        padId: this.selectedPad
      })
    },
    velocityAt(index: number): number | null {
      if (!this.selectedPad) {
        return null
      }

      const { barIndex, stepInBar } = this.resolveStepPosition(index)

      return (
        this.steps[barIndex]?.[stepInBar]?.[this.selectedPad]?.velocity?.value ??
        null
      )
    },
    isActive(index: number): boolean {
      return this.velocityAt(index) !== null
    },
    isAccent(index: number): boolean {
      const velocity = this.velocityAt(index)
      const ACCENT_EPSILON = 0.01

      return (
        velocity !== null &&
        velocity >= ACCENT_STEP_VELOCITY - ACCENT_EPSILON
      )
    },
    isCurrent(index: number): boolean {
      return this.followEnabled && index === this.currentStepNormalized
    },
    onKeydown(event: KeyboardEvent): void {
      if (this.totalSteps <= 0) {
        return
      }

      const isArrowLeft = event.key === 'ArrowLeft'
      const isArrowRight = event.key === 'ArrowRight'

      if (!isArrowLeft && !isArrowRight) {
        return
      }

      event.preventDefault()

      const stepDelta = event.shiftKey ? this.gridSpec.division : 1
      const delta = isArrowLeft ? -stepDelta : stepDelta
      const steps = this.totalSteps
      const nextStep =
        ((this.currentStepNormalized + delta) % steps + steps) % steps

      this.$emit('playhead:scrub', { stepIndex: nextStep })
    },
    emitVelocity(index: number, velocity: number): void {
      if (!this.selectedPad) {
        return
      }
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      this.$emit('step:velocity', {
        barIndex,
        stepInBar,
        padId: this.selectedPad,
        velocity
      })
    },
    onCellPointerDown(index: number, event: PointerEvent): void {
      if (!this.selectedPad) {
        return
      }
      const startVelocity = this.velocityAt(index)
      if (startVelocity === null) {
        return
      }

      this.dragState = {
        pointerId: event.pointerId,
        startY: event.clientY,
        startVelocity,
        stepIndex: index
      }
    },
    onCellPointerMove(event: PointerEvent): void {
      if (!this.dragState || event.pointerId !== this.dragState.pointerId) {
        return
      }
      const deltaY = this.dragState.startY - event.clientY
      const VELOCITY_PER_PIXEL = 0.006
      const nextVelocity = clampVelocity(
        this.dragState.startVelocity + deltaY * VELOCITY_PER_PIXEL
      )
      this.emitVelocity(this.dragState.stepIndex, nextVelocity)
    },
    onCellPointerUp(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },
    onCellPointerCancel(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },
    cellAriaLabel(index: number): string {
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      const stepNumber = stepInBar + 1
      const barNumber = barIndex + 1
      const activeState = this.isActive(index) ? 'active' : 'inactive'
      return `Bar ${barNumber}, step ${stepNumber}, ${activeState}`
    },
    isPatternStart(index: number): boolean {
      if (!this.patternChain || this.patternChain.length === 0) {
        return false
      }
      if (index === 0) {
        return true
      }
      return this.patternBoundaries.includes(index)
    },
    boundaryStyle(startIndex: number): Record<string, string> {
      const leftPercent =
        this.totalSteps > 0 ? (startIndex / this.totalSteps) * 100 : 0
      return {
        left: `${leftPercent}%`
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.step-grid-shell {
  margin-top: 0;
  padding: 10px;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  position: relative;
  height: 100%;
  max-height: 96px;
  overflow: visible;
}

.step-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
  gap: 8px;
  position: relative;
  overflow: visible;

  > .playhead-overlay {
    pointer-events: none;
    z-index: 0;
  }

  > .step-cell {
    z-index: 1;
  }

  > .step-cell:nth-child(4n + 1) {
    border-left: 2px solid rgba(255, 255, 255, 0.12);
    padding-left: 12px;
  }

  > .step-cell.is-pattern-start {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-primary, 45%),
      0 0 10px fade(@color-accent-primary, 16%);
  }
}

.pattern-boundary {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  margin-left: -1px;
  background: linear-gradient(
    to bottom,
    fade(@color-accent-primary, 0%) 0%,
    fade(@color-accent-primary, 28%) 45%,
    fade(@color-accent-primary, 8%) 100%
  );
  pointer-events: none;
  z-index: 0;
}

.loop-overlay {
  position: absolute;
  top: 0;
  bottom: 0;
  background: fade(@color-accent-primary, 12%);
  border-left: 2px solid fade(@color-accent-primary, 35%);
  border-right: 2px solid fade(@color-accent-primary, 35%);
  pointer-events: none;
  z-index: 0;
}

@media (max-height: 820px) {
  .step-grid-shell {
    max-height: 88px;
    padding: 8px;
  }
}

@media (max-width: 640px) {
  .step-grid-shell {
    padding: 8px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(44px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 44px;
    padding: 10px 0;
    font-size: @font-size-xs;
  }
}

@media (max-width: 480px) {
  .step-grid-shell {
    padding: 6px;
    max-height: 80px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(48px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 48px;
    padding: 12px 0;
  }
}
</style>



=========================================
File: components/SyncPanel.vue
=========================================

<template lang="pug">
v-card
  v-card-title Sync
  v-card-text
    v-select(:items="modes" v-model="mode" label="Mode")
    v-select(:items="roles" v-model="role" label="Role")
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { SyncState } from '~/types/sync'

export default defineComponent({
  name: 'SyncPanel',
  props: {
    syncState: { type: Object as () => SyncState, required: true }
  },
  emits: ['mode', 'role'],
  data() {
    return {
      modes: ['internal', 'midiClock', 'abletonLink'],
      roles: ['master', 'slave'],
      mode: this.syncState.mode,
      role: this.syncState.role
    }
  },
  watch: {
    mode(value: string) {
      this.$emit('mode', value)
    },
    role(value: string) {
      this.$emit('role', value)
    }
  }
})
</script>



=========================================
File: components/TabPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .drawer-shell
      v-tabs(
        v-model="internalTab"
        density="comfortable"
        variant="text"
        class="drawer-tabs"
      )
        v-tab(v-for="tab in tabs" :key="tab.value" :value="tab.value") {{ tab.label }}
      v-tabs-window(v-model="internalTab" class="drawer-window")
        v-tabs-window-item(value="sound")
          slot(name="sound")
        v-tabs-window-item(value="fx")
          slot(name="fx")
        v-tabs-window-item(value="patterns")
          slot(name="patterns")
        v-tabs-window-item(value="export")
          slot(name="export")
</template>

<script lang="ts">
import { defineComponent } from 'vue'

const tabs = [
  { label: 'Sound', value: 'sound' },
  { label: 'FX', value: 'fx' },
  { label: 'Patterns', value: 'patterns' },
  { label: 'Export', value: 'export' },
  { label: 'Channel', value: 'channel' }
]

export default defineComponent({
  name: 'TabPanel',
  // Drawer tab container that switches between sound, FX, patterns, and export slots.
  props: {
    modelValue: { type: String, default: 'sound' }
  },
  emits: ['update:modelValue'],
  computed: {
    internalTab: {
      get(): string {
        return this.modelValue
      },
      set(value: string) {
        this.$emit('update:modelValue', value)
      }
    },
    tabs() {
      return tabs
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.drawer-shell {
  margin-top: 24px;
  @radius-xl: 20px;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  padding: 0;
  display: flex;
  flex-direction: column;
  height: 100%;

  .drawer-tabs {
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    background: @color-surface-2;
    flex: 0 0 56px;
  }

  .drawer-window {
    background: @color-surface-2;
    border-radius: 0 0 16px 16px;
    padding: 16px;
    flex: 1 1 auto;
    overflow-y: auto;
    max-height: calc(100% - 56px);
  }
}

@media (max-height: 780px) {
  .drawer-shell {
    margin-top: 16px;
  }
}
</style>



=========================================
File: components/TransportBar.vue
=========================================

<template lang="pug">
client-only(tag="div")
  .transport-bar
    .transport-grid
      button.control-btn(type="button")
        span.control-btn__main RESTART
        span.control-btn__sub Loop
      button.control-btn(type="button")
        span.control-btn__main ERASE
        span.control-btn__sub Replace
      button.control-btn(type="button")
        span.control-btn__main TAP
        span.control-btn__sub Metro
      button.control-btn(type="button")
        span.control-btn__main FOLLOW
        span.control-btn__sub Grid
      button.control-btn(type="button")
        span.control-btn__main PLAY
      button.control-btn(type="button")
        span.control-btn__main REC
        span.control-btn__sub Count In
      button.control-btn(type="button")
        span.control-btn__main STOP
      button.control-btn(type="button")
        .shift-label SHIFT
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { TimeDivision } from '@/types/time'

export default defineComponent({
  name: 'TransportBar',
  // Provides playback controls plus BPM, division, loop, and MIDI learn toggles for the drum machine.
  props: {
    bpm: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true },
    loop: { type: Boolean, required: true },
    division: { type: Number as () => TimeDivision, required: true },
    divisions: { type: Array as () => TimeDivision[], required: true },
    isMidiLearning: { type: Boolean, default: false },
    isRecording: { type: Boolean, default: false },
    countInEnabled: { type: Boolean, default: false },
    countInBars: { type: Number, default: 1 },
    metronomeEnabled: { type: Boolean, default: false },
    followEnabled: { type: Boolean, default: true },
    patternBars: { type: Number, default: 1 },
    loopStart: { type: Number, default: 0 },
    loopEnd: { type: Number, default: 1 },
    totalSteps: { type: Number, default: 1 },
    selectedPad: { type: String, default: null },
    liveEraseEnabled: { type: Boolean, default: false },
    metronomeVolume: { type: Number, default: 0.12 },
    presetBars: { type: Number, default: 1 },
    presetDivision: { type: Number, default: 4 }
  },

  emits: [
    'play',
    'stop',
    'stop-reset',
    'restart',
    'toggle-record',
    'update-bpm',
    'increment-bpm',
    'decrement-bpm',
    'update-loop',
    'update-division',
    'toggle-midi-learn',
    'toggle-count-in',
    'update-count-in-bars',
    'tap-tempo',
    'toggle-metronome',
    'toggle-follow',
    'update-pattern-bars',
    'nudge-loop-range',
    'update-loop-start',
    'update-loop-end',
    'update:metronome-volume',
    'toggle-live-erase',
    'erase-pad',
    'erase-current-step',
    'update:preset-bars',
    'update:preset-division',
    'apply-pattern-preset'
  ],

  computed: {
    divisionItems(): Array<{ title: string; value: TimeDivision }> {
      return this.divisions.map((value) => ({ title: `1/${value}`, value }))
    }
  },

  methods: {
    onBpm(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-bpm', numeric)
      }
    },
    onDivision(value: TimeDivision | null) {
      if (value != null) {
        this.$emit('update-division', value)
      }
    },
    toggleLoop() {
      this.$emit('update-loop', !this.loop)
    },
    onCountInBars(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-count-in-bars', numeric)
      }
    },
    onPatternBars(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-pattern-bars', numeric)
      }
    },
    onLoopStart(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-loop-start', numeric)
      }
    },
    onLoopEnd(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-loop-end', numeric)
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.transport-bar {
  width: 100%;
  display: flex;
  flex-direction: column;
  background: @color-surface-1;
  border: 1px solid @color-border-1;
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), inset 0 -2px 6px rgba(0,0,0,0.65);
}

.transport-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
  width: 100%;
}

.control-btn {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid fade(#3b4355, 65%);
  background: linear-gradient(180deg, #1c2230, #121826);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
  color: rgba(255, 255, 255, 0.88);
  line-height: 1.05;
  text-align: left;
  min-height: 44px;
  max-width: 50%;
}

.control-btn__main {
  font-weight: 800;
  letter-spacing: 0.06em;
  font-size: 12px;
  text-transform: uppercase;
}

.control-btn__sub {
  margin-top: 2px;
  font-weight: 400;
  font-style: italic;
  opacity: 0.75;
  font-size: 11px;
  letter-spacing: 0.02em;
  text-transform: none;
}

.shift-label {
  height: 14px;
  background: #fff;
  color: #000;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: 0.06em;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  border-radius: 4px;
}
</style>



=========================================
File: components/control/DualDisplay.vue
=========================================

<template>
  <div class="dual-display dual-display-root" :title="`${modeTitle} â€¢ ${pageLabel}`">
    <div class="display left">
      <div class="display-header">
        <div class="display-title">{{ modeTitle }}</div>
        <div class="display-subtitle">{{ pageLabel }}</div>
      </div>
      <div class="display-body">
        <div class="panel" :class="panelClass(leftModel)">
          <template v-if="leftModel.view === 'BROWSER'">
            <div class="panel-header">{{ leftModel.title || 'Browser' }}</div>
            <input
              v-model="browserQuery"
              type="search"
              class="browser-search"
              placeholder="Search presets or samples"
              aria-label="Browser search"
            />
            <ul class="item-list">
              <li
                v-for="item in filteredItems(leftModel)"
                :key="item.title"
                :class="{ active: item.active }"
              >
                <div class="item-title">{{ item.title }}</div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
          </template>
          <template v-else-if="leftModel.view === 'FILE'">
            <div class="panel-header">{{ leftModel.title || 'Files' }}</div>
            <input
              v-model="fileQuery"
              type="search"
              class="browser-search"
              placeholder="Filter files"
              aria-label="File search"
            />
            <div class="file-list-wrapper">
              <ul class="item-list">
                <li v-for="item in filteredItems(leftModel)" :key="item.title">
                  <div class="item-title">{{ item.title }}</div>
                  <div class="item-subtitle">{{ item.subtitle }}</div>
                </li>
              </ul>
            </div>
            <div v-if="leftModel.summary" class="panel-hint">{{ leftModel.summary }}</div>
          </template>
          <template v-else-if="leftModel.view === 'SAMPLING'">
            <div class="panel-header">{{ leftModel.title || 'Sampling' }}</div>
            <ul class="item-list">
              <li v-for="item in leftModel.items" :key="item.title">
                <div class="item-title">{{ item.title }}</div>
                <div class="item-subtitle">{{ item.value || item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="leftModel.summary" class="panel-hint">{{ leftModel.summary }}</div>
          </template>
          <template v-else-if="leftModel.view === 'MIXER' || leftModel.view === 'ARRANGER' || leftModel.view === 'SETTINGS' || leftModel.view === 'INFO'">
            <div class="panel-header">{{ leftModel.title || 'Details' }}</div>
            <ul class="item-list">
              <li v-for="item in leftModel.items" :key="item.title" :class="{ active: item.active }">
                <div class="item-title">
                  {{ item.title }}
                  <span v-if="item.value" class="item-value">{{ item.value }}</span>
                </div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="leftModel.summary" class="panel-hint">{{ leftModel.summary }}</div>
          </template>
          <template v-else>
            <div class="panel-header">{{ leftModel.title || 'Display L' }}</div>
            <div class="panel-hint">{{ leftModel.summary || 'Ready' }}</div>
          </template>
        </div>
        <div class="param-slots">
          <div
            v-for="(param, index) in paramSlotsLeft"
            :key="param.id || index"
            class="param-slot"
          >
            <div class="param-name">{{ param.name }}</div>
            <div class="param-value">{{ formatParam(param.value, param) }}</div>
          </div>
        </div>
      </div>
    </div>
    <div class="display right">
      <div class="display-header">
        <div class="display-title">{{ rightModel.title || 'Display R' }}</div>
        <div class="display-subtitle">{{ rightModel.summary || modeTitle }}</div>
      </div>
      <div class="display-body">
        <div class="panel" :class="panelClass(rightModel)">
          <template v-if="rightModel.view === 'BROWSER'">
            <div class="panel-header">{{ rightModel.title || 'Results' }}</div>
            <ul class="item-list">
              <li v-for="item in filteredItems(rightModel)" :key="item.title" :class="{ active: item.active }">
                <div class="item-title">{{ item.title }}</div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="rightModel.summary" class="panel-hint">{{ rightModel.summary }}</div>
          </template>
          <template v-else-if="rightModel.view === 'MIXER' || rightModel.view === 'ARRANGER' || rightModel.view === 'SETTINGS' || rightModel.view === 'INFO' || rightModel.view === 'FILE'">
            <div class="panel-header">{{ rightModel.title || 'Details' }}</div>
            <template v-if="rightModel.view === 'FILE'">
              <input
                v-model="fileQuery"
                type="search"
                class="browser-search"
                placeholder="Filter files"
                aria-label="File search"
              />
              <div class="file-list-wrapper">
                <ul class="item-list">
                  <li v-for="item in filteredItems(rightModel)" :key="item.title" :class="{ active: item.active }">
                    <div class="item-title">
                      {{ item.title }}
                      <span v-if="item.value" class="item-value">{{ item.value }}</span>
                    </div>
                    <div class="item-subtitle">{{ item.subtitle }}</div>
                  </li>
                </ul>
              </div>
            </template>
            <template v-else>
              <ul class="item-list">
                <li v-for="item in rightModel.items" :key="item.title" :class="{ active: item.active }">
                  <div class="item-title">
                    {{ item.title }}
                    <span v-if="item.value" class="item-value">{{ item.value }}</span>
                  </div>
                  <div class="item-subtitle">{{ item.subtitle }}</div>
                </li>
              </ul>
            </template>
            <div v-if="rightModel.summary" class="panel-hint">{{ rightModel.summary }}</div>
          </template>
          <template v-else-if="rightModel.view === 'SAMPLING'">
            <div class="panel-header">{{ rightModel.title || 'Sampling' }}</div>
            <div class="panel-hint">{{ rightModel.summary || 'Set slice or record' }}</div>
          </template>
          <template v-else>
            <div class="panel-header">{{ rightModel.title || 'Display R' }}</div>
            <div class="panel-hint">{{ rightModel.summary || 'Ready' }}</div>
          </template>
        </div>
        <div class="param-slots">
          <div
            v-for="(param, index) in paramSlotsRight"
            :key="param.id || index"
            class="param-slot"
          >
            <div class="param-name">{{ param.name }}</div>
            <div class="param-value">{{ formatParam(param.value, param) }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, type PropType } from 'vue'
import { useBrowserStore } from '@/stores/browser'
import { useControlStore } from '@/stores/control'

type ListItem = {
  title: string
  subtitle?: string
  active?: boolean
  value?: string
}

type DisplayPanelModel = {
  view: string
  title?: string
  summary?: string
  items?: ListItem[]
}

type ParamSlot = {
  id: string
  name: string
  value: number
  format?: string
}

export default defineComponent({
  name: 'DualDisplay',
  props: {
    leftModel: {
      type: Object as PropType<DisplayPanelModel>,
      required: true
    },
    rightModel: {
      type: Object as PropType<DisplayPanelModel>,
      required: true
    },
    modeTitle: {
      type: String,
      default: ''
    },
    pageLabel: {
      type: String,
      default: ''
    },
    paramSlotsLeft: {
      type: Array as PropType<ParamSlot[]>,
      default: () => []
    },
    paramSlotsRight: {
      type: Array as PropType<ParamSlot[]>,
      default: () => []
    }
  },
  data() {
    return {
      browserQuery: '',
      fileQuery: '',
      browserStore: useBrowserStore(),
      controlStore: useControlStore()
    }
  },
  watch: {
    browserQuery(value: string) {
      if (this.controlStore.activeMode === 'BROWSER') {
        void this.browserStore.setQuery(value)
      }
    },
    'browserStore.library.query'(value: string) {
      if (value !== this.browserQuery) {
        this.browserQuery = value
      }
    }
  },
  methods: {
    formatParam(value: number, param: ParamSlot) {
      if (param.format) {
        return `${value}${param.format}`
      }
      return typeof value === 'number' ? Math.round(value * 100) / 100 : value
    },
    panelClass(model: DisplayPanelModel) {
      return `panel-${(model.view || 'empty').toString().toLowerCase()}`
    },
    filteredItems(model: DisplayPanelModel) {
      if (!model?.items || !Array.isArray(model.items)) return []
      const query = model.view === 'FILE' ? this.fileQuery : this.browserQuery
      if (!query) return model.items
      const lowerQuery = query.toLowerCase()
      return model.items.filter((item) => {
        return (
          item.title?.toLowerCase().includes(lowerQuery) ||
          item.subtitle?.toLowerCase().includes(lowerQuery)
        )
      })
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.dual-display {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: @space-s;
}

.display {
  border-radius: @radius-s;
  background: linear-gradient(180deg, #0f141d, #0b0f16);
  border: 1px solid #2c3545;
  box-shadow:
    inset 0 0 18px rgba(0, 0, 0, 0.65),
    0 8px 28px rgba(0, 0, 0, 0.65);
  color: #9fd4ff;
  min-height: 108px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.display-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: @space-xs;
  font-size: @font-size-s;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: @space-xs @space-s;
  color: #cfe9ff;
  border-bottom: 1px solid fade(#cfe9ff, 10%);
}

.display-title {
  font-weight: 600;
}

.display-subtitle {
  font-size: @font-size-xs;
  opacity: 0.8;
}

.display-body {
  flex: 1 1 auto;
  padding: @space-s;
  font-size: @font-size-s;
  opacity: 0.9;
  color: #8fc2ff;
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: @space-s;
}

.panel {
  background: linear-gradient(180deg, #131925, #0d111a);
  border: 1px solid #1e2634;
  border-radius: @radius-xs;
  padding: @space-xs;
  box-shadow: inset 0 0 8px rgba(0,0,0,0.35);
  // Allow flex child to shrink below content size for scroll container
  min-height: 0;
  display: flex;
  flex-direction: column;
}

.file-list-wrapper {
  // Scrollable container for FILE view lists
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  overflow-x: hidden;
  margin-bottom: @space-xxs;
}

.panel-header {
  font-size: @font-size-s;
  font-weight: 600;
  margin-bottom: @space-xxs;
}

.panel-hint {
  margin-top: @space-xxs;
  font-size: @font-size-xs;
  color: #b6d5ff;
  opacity: 0.8;
}

.browser-search {
  width: 100%;
  background: #0b1017;
  border: 1px solid #1f2a3a;
  border-radius: @radius-xs;
  padding: @space-xxs @space-xs;
  color: #cfe9ff;
  margin-bottom: @space-xxs;
  font-size: @font-size-s;
}

.item-list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.item-list li {
  padding: 6px 8px;
  border-radius: 6px;
  border: 1px solid transparent;
  background: rgba(255, 255, 255, 0.02);
}

.item-list li.active {
  border-color: #3f73ff;
  background: rgba(63, 115, 255, 0.12);
}

.item-title {
  display: flex;
  justify-content: space-between;
  font-weight: 600;
  color: #cfe9ff;
}

.item-subtitle {
  font-size: @font-size-xs;
  opacity: 0.8;
}

.item-value {
  font-size: @font-size-xs;
  color: #8fc2ff;
}

.param-slots {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: @space-xxs;
}

.param-slot {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid #1f2a3a;
  border-radius: @radius-xs;
  padding: 6px 8px;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.param-name {
  font-size: @font-size-xs;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: #cfe9ff;
}

.param-value {
  font-size: @font-size-s;
  color: #8fc2ff;
}
</style>



=========================================
File: components/control/FourDEncoder.vue
=========================================

<template>
  <div
    class="encoder"
    role="button"
    tabindex="0"
    aria-label="4D encoder: tilt left/right, turn up/down, press to confirm"
    title="4D encoder: tilt â†•â†”, turn to browse, press to confirm"
    @pointerdown.prevent="onPointerDown"
    @keydown="onKeydown"
  >
    <div class="encoder-cap">âº</div>
    <div class="encoder-arrows">â†• â†”</div>
    <div class="encoder-label">Push to confirm</div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import { useControlStore } from '@/stores/control'

const VERTICAL_STEP_PX = 6
const HORIZONTAL_THRESHOLD_PX = 12

export default defineComponent({
  name: 'FourDEncoder',
  data() {
    return {
      dragActive: false,
      lastX: 0,
      lastY: 0,
      accumX: 0,
      accumY: 0,
      pointerId: null as number | null
    }
  },
  computed: {
    control() {
      return useControlStore()
    }
  },
  beforeUnmount() {
    window.removeEventListener('pointermove', this.onPointerMove)
    window.removeEventListener('pointerup', this.onPointerUp)
  },
  methods: {
    onPointerDown(event: PointerEvent) {
      this.dragActive = true
      this.lastX = event.clientX
      this.lastY = event.clientY
      this.accumX = 0
      this.accumY = 0
      this.pointerId = event.pointerId
      const target = event.currentTarget as HTMLElement | null
      target?.setPointerCapture?.(event.pointerId)
      window.addEventListener('pointermove', this.onPointerMove)
      window.addEventListener('pointerup', this.onPointerUp)
    },
    onPointerMove(event: PointerEvent) {
      if (!this.dragActive) return
      if (this.pointerId !== null && event.pointerId !== this.pointerId) return
      const deltaX = event.clientX - this.lastX
      const deltaY = this.lastY - event.clientY
      this.accumX += deltaX
      this.accumY += deltaY

      // Horizontal tilt
      if (Math.abs(this.accumX) >= HORIZONTAL_THRESHOLD_PX) {
        const direction = this.accumX > 0 ? 'right' : 'left'
        this.control.tiltEncoder4D(direction)
        this.accumX = 0
      }

      // Vertical turn (convert pixels to steps)
      const steps = Math.trunc(this.accumY / VERTICAL_STEP_PX)
      if (steps !== 0) {
        this.accumY -= steps * VERTICAL_STEP_PX
        this.control.turnEncoder4D(steps)
      }

      this.lastX = event.clientX
      this.lastY = event.clientY
    },
    onPointerUp(event: PointerEvent) {
      if (this.pointerId !== null && event.pointerId !== this.pointerId) return
      const isClick = Math.abs(this.accumX) < HORIZONTAL_THRESHOLD_PX && Math.abs(this.accumY) < VERTICAL_STEP_PX
      if (isClick) {
        void this.control.pressEncoder4D()
      }
      this.dragActive = false
      this.pointerId = null
      this.accumX = 0
      this.accumY = 0
      window.removeEventListener('pointermove', this.onPointerMove)
      window.removeEventListener('pointerup', this.onPointerUp)
    },
    onKeydown(event: KeyboardEvent) {
      if (event.key === 'ArrowUp') {
        this.control.turnEncoder4D(1)
        event.preventDefault()
      } else if (event.key === 'ArrowDown') {
        this.control.turnEncoder4D(-1)
        event.preventDefault()
      } else if (event.key === 'ArrowLeft') {
        this.control.tiltEncoder4D('left')
        event.preventDefault()
      } else if (event.key === 'ArrowRight') {
        this.control.tiltEncoder4D('right')
        event.preventDefault()
      } else if (event.key === 'Enter' || event.key === ' ') {
        void this.control.pressEncoder4D()
        event.preventDefault()
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.encoder {
  align-self: stretch;
  min-width: 120px;
  padding: @space-s @space-m;
  border-radius: @radius-m;
  background: linear-gradient(180deg, #181c26, #0f121a);
  border: 1px solid #2d3542;
  color: @color-text-primary;
  display: grid;
  place-items: center;
  gap: @space-xs;
  text-align: center;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.04),
    0 4px 12px rgba(0,0,0,0.4);
}

.encoder:focus-visible {
  outline: 2px solid #f68b1e;
  outline-offset: 2px;
}

.encoder-cap {
  font-size: 24px;
  color: #f68b1e;
}

.encoder-arrows {
  letter-spacing: 0.25em;
}

.encoder-label {
  font-size: @font-size-xs;
  opacity: 0.85;
}
</style>



=========================================
File: components/control/SoftButtonStrip.vue
=========================================

<template>
  <div class="soft-strip">
    <button
      v-for="(btn, index) in normalizedButtons"
      :key="index"
      class="soft-btn"
      type="button"
      :title="buttonTitle(btn, index)"
      :aria-label="buttonTitle(btn, index)"
      :disabled="!btn.enabled"
      @click="$emit('press', index)"
    >
      <span class="symbol">{{ index + 1 }}</span>
      <span class="label">{{ btn.label }}</span>
    </button>
  </div>
</template>

<script lang="ts">
import { defineComponent, type PropType } from 'vue'

type SoftButtonModel = {
  label: string
  actionId: string
  enabled: boolean
  shiftLabel?: string | undefined
  description?: string | undefined
}

const normalizeButtons = (buttons: SoftButtonModel[]): SoftButtonModel[] => {
  const normalized = buttons.map((btn) => ({
    label: btn.label ?? '',
    actionId: btn.actionId ?? 'noop',
    enabled: btn.enabled !== false,
    shiftLabel: btn.shiftLabel ?? undefined,
    description: btn.description ?? undefined
  }))
  while (normalized.length < 8) {
    normalized.push({
      label: '',
      actionId: 'noop',
      enabled: false,
      shiftLabel: undefined,
      description: undefined
    })
  }
  return normalized.slice(0, 8)
}

export default defineComponent({
  name: 'SoftButtonStrip',
  props: {
    buttons: {
      type: Array as PropType<SoftButtonModel[]>,
      default: () => []
    },
    shiftHeld: {
      type: Boolean,
      default: false
    }
  },
  emits: ['press'],
  computed: {
    normalizedButtons(): SoftButtonModel[] {
      return normalizeButtons(this.buttons ?? [])
    }
  },
  methods: {
    buttonTitle(btn: SoftButtonModel, index: number) {
      const label = btn.label || `Soft ${index + 1}`
      if (btn.shiftLabel) {
        return this.shiftHeld ? `${label} (${btn.shiftLabel})` : `${label} (SHIFT: ${btn.shiftLabel})`
      }
      return label
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.soft-strip {
  display: grid;
  grid-template-columns: repeat(8, minmax(0, 1fr));
  gap: @space-xs;
}

.soft-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  padding: @space-xxs @space-xs;
  border: 1px solid #3a3f49;
  border-radius: 6px;
  background: linear-gradient(180deg, #cfd2d8, #9ea3ab);
  color: #1c1f24;
  font-size: @font-size-xs;
  cursor: pointer;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.6),
    inset 0 -1px 0 rgba(0,0,0,0.25);
}

.soft-btn:disabled {
  opacity: 0.55;
  cursor: not-allowed;
}

.soft-btn:hover:enabled {
  background: linear-gradient(180deg, #ffffff, #c7ccd4);
  border-color: #ffffff;
  box-shadow:
    0 0 8px fade(#ffffff, 35%),
    inset 0 1px 0 rgba(255,255,255,0.9);
}

.symbol {
  font-size: @font-size-s;
  line-height: 1;
}

.label {
  font-size: @font-size-xs;
  line-height: 1.1;
  opacity: 0.8;
}
</style>



=========================================
File: components/panels/ChannelPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Channel & MIDI
      .panel-body
        v-select(
          label="Control target"
          dense
          :items="controlTargets"
          item-title="title"
          item-value="value"
          :model-value="controlTarget"
          @update:model-value="$emit('update:control-target', $event)"
          hide-details
        )
        v-switch(
          label="MIDI Mode (Shift+Channel)"
          dense
          :model-value="midiMode"
          @update:model-value="$emit('update:midi-mode', $event)"
        )
        p.helper Soft labels/knobs are contextual; this panel is a stub for Channel Properties.
</template>

<script lang="ts">
import { defineComponent } from 'vue'

const controlTargets = [
  { title: 'Sound', value: 'sound' },
  { title: 'Group', value: 'group' },
  { title: 'Master', value: 'master' }
]

export default defineComponent({
  name: 'ChannelPanel',
  props: {
    controlTarget: { type: String, default: 'sound' },
    midiMode: { type: Boolean, default: false }
  },
  emits: ['update:control-target', 'update:midi-mode'],
  computed: {
    controlTargets() {
      return controlTargets
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #8bd1ff;
    margin-bottom: 12px;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .helper {
    font-size: 0.75rem;
    opacity: 0.8;
    letter-spacing: 0.06em;
  }
}
</style>



=========================================
File: components/panels/ExportPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Export
      .panel-body
        v-btn(
          color="primary"
          block
          :loading="isExporting"
          :disabled="isExporting"
          @click="$emit('export')"
        ) Export mixdown
        v-alert(
          v-if="exportError"
          type="error"
          dense
          class="mt-2"
        ) {{ exportError }}
        .metadata-grid
          .metadata-row
            span.label Seed
            span.value {{ metadata?.seed ?? 'â€”' }}
          .metadata-row
            span.label BPM
            span.value {{ metadata?.bpm ?? 'â€”' }}
          .metadata-row
            span.label Duration
            span.value {{ formattedDuration }}
          .metadata-row
            span.label Grid
            span.value {{ gridLabel }}
        v-btn(
          color="secondary"
          block
          :disabled="!audioBlob || isExporting"
          class="mt-2"
          @click="$emit('download:mixdown')"
        ) Download WAV
        v-btn(
          color="secondary"
          block
          :disabled="!hasZipArtifacts || isExporting"
          class="mt-2"
          variant="outlined"
          @click="$emit('download:zip')"
        ) Download ZIP bundle
        v-divider(class="my-3")
        .stem-header(v-if="stemEntries.length > 0")
          span Stem exports
          v-btn(text small class="ml-auto" :disabled="isExporting" @click="$emit('download:stems')") Download all
        v-list(v-if="stemEntries.length > 0" density="compact")
          v-list-item(v-for="stem in stemEntries" :key="stem.padId")
            v-list-item-title {{ stem.label }}
            v-list-item-subtitle {{ stem.fileName }}
            template(#append)
              v-btn(text small :disabled="isExporting" @click="$emit('download:stem', stem.padId)") Download
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { DrumPadId } from '@/types/drums'
import type { RenderMetadata } from '@/types/render'

type StemEntry = {
  padId: DrumPadId
  label: string
  fileName: string
}

export default defineComponent({
  name: 'ExportPanel',
  // Panel that triggers audio export and lists metadata plus downloadable mixdown and stems.
  props: {
    isExporting: { type: Boolean, required: true },
    exportError: { type: String, default: null },
    exportMetadata: { type: Object as () => RenderMetadata | null, default: null },
    audioBlob: { type: Object as () => Blob | null, default: null },
    hasZipArtifacts: { type: Boolean, required: true },
    stemEntries: {
      type: Array as () => StemEntry[],
      default: () => []
    }
  },
  emits: ['export', 'download:mixdown', 'download:zip', 'download:stem', 'download:stems'],
  computed: {
    metadata() {
      return this.exportMetadata
    },
    gridLabel(): string {
      const spec = this.exportMetadata?.gridSpec
      if (!spec) return 'â€”'
      return `${spec.bars} bar${spec.bars === 1 ? '' : 's'} â€¢ 1/${spec.division}`
    },
    formattedDuration(): string {
      const duration = this.exportMetadata?.durationSec
      if (typeof duration !== 'number') return 'â€”'
      return `${duration.toFixed(2)}s`
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #fe9b8b;
    margin-bottom: 10px;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .metadata-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 6px 10px;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: rgba(255, 255, 255, 0.7);
  }

  .metadata-row {
    display: contents;
  }

  .metadata-row .label {
    font-weight: 600;
  }

  .stem-header {
    display: flex;
    align-items: center;
    font-size: 0.75rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }
}
</style>



=========================================
File: components/panels/FxPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
    .panel-header FX
      v-expansion-panels(
        v-model="activeSlot"
        accordion
        class="fx-panels"
      )
        v-expansion-panel(value="filter")
          v-expansion-panel-title Filter
          v-expansion-panel-text
            v-switch(
              label="Enabled"
              dense
              :model-value="localFx.filter.enabled"
              @update:model-value="toggleFilter"
            )
            v-slider(
              dense
              v-if="localFx.filter.enabled"
              label="Cutoff"
              hide-details
              min="200"
              max="18000"
              step="50"
              thumb-label
              :model-value="localFx.filter.frequency"
              @update:model-value="setFilterFreq"
            )
            v-slider(
              dense
              v-if="localFx.filter.enabled"
              label="Resonance (Q)"
              hide-details
              min="0.1"
              max="12"
              step="0.1"
              thumb-label
              :model-value="localFx.filter.q"
              @update:model-value="setFilterQ"
            )
        v-expansion-panel(value="drive")
          v-expansion-panel-title Drive
          v-expansion-panel-text
            v-switch(
              label="Enabled"
              dense
              :model-value="localFx.drive.enabled"
              @update:model-value="toggleDrive"
            )
            v-slider(
              dense
              v-if="localFx.drive.enabled"
              label="Amount"
              hide-details
              min="0"
              max="1"
              step="0.05"
              thumb-label
              :model-value="localFx.drive.amount"
              @update:model-value="setDriveAmount"
            )
        v-expansion-panel(value="reverb")
          v-expansion-panel-title Reverb
          v-expansion-panel-text
            v-switch(
              label="Enabled"
              dense
              :model-value="localFx.reverb.enabled"
              @update:model-value="toggleReverb"
            )
            v-slider(
              dense
              v-if="localFx.reverb.enabled"
              label="Mix"
              hide-details
              min="0"
              max="0.6"
              step="0.02"
              thumb-label
              :model-value="localFx.reverb.mix"
              @update:model-value="setReverbMix"
            )
        v-expansion-panel(value="routing")
          v-expansion-panel-title Routing
          v-expansion-panel-text
            p Subtle master shaping slot. No additional controls yet.
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { FxSettings } from '@/types/audio'

export default defineComponent({
  name: 'FxPanel',
  props: {
    fxSettings: { type: Object as () => FxSettings, required: true }
  },
  emits: ['fx:update'],
  data() {
    return {
      activeSlot: 'filter',
      localFx: { ...this.fxSettings }
    }
  },
  watch: {
    fxSettings: {
      deep: true,
      handler(value: FxSettings) {
        this.localFx = {
          ...value,
          filter: { ...value.filter },
          drive: { ...value.drive },
          reverb: { ...value.reverb }
        }
      }
    }
  },
  methods: {
    emitFx() {
      this.$emit('fx:update', {
        filter: { ...this.localFx.filter },
        drive: { ...this.localFx.drive },
        reverb: { ...this.localFx.reverb }
      })
    },
    toggleFilter(enabled: boolean) {
      this.localFx.filter.enabled = enabled
      this.emitFx()
    },
    setFilterFreq(value: number) {
      this.localFx.filter.frequency = value
      this.emitFx()
    },
    setFilterQ(value: number) {
      this.localFx.filter.q = value
      this.emitFx()
    },
    toggleDrive(enabled: boolean) {
      this.localFx.drive.enabled = enabled
      this.emitFx()
    },
    setDriveAmount(value: number) {
      this.localFx.drive.amount = value
      this.emitFx()
    },
    toggleReverb(enabled: boolean) {
      this.localFx.reverb.enabled = enabled
      this.emitFx()
    },
    setReverbMix(value: number) {
      this.localFx.reverb.mix = value
      this.emitFx()
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 12px;
  color: #f5f7fb;

  .panel-header {
    text-transform: uppercase;
    letter-spacing: 0.2em;
    font-size: 0.8rem;
    color: #ffc952;
    margin-bottom: 8px;
  }

  .fx-panels {
    background: transparent;
    border: none;

    .v-expansion-panel {
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      transition: border 0.3s ease;

      &:last-child {
        border-bottom: none;
      }
    }

    .v-expansion-panel-title {
      font-weight: 600;
      letter-spacing: 0.3em;
      text-transform: uppercase;
    }

    .v-expansion-panel-text {
      padding: 8px 0 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
  }
}

.fx-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: min(720px, 92vw);
  max-height: 92vh;
  display: flex;
  flex-direction: column;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  @radius-xl: 20px;
  z-index: 2000;
}


</style>



=========================================
File: components/panels/PatternsPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Patterns
      .panel-body
        v-row
          v-col(cols="12" md="6")
            v-select(
              label="Current Pattern"
              dense
              :items="patternItems"
              item-title="title"
              item-value="value"
              :model-value="selectedPatternId"
              @update:model-value="handlePatternSelect"
              hide-details
            )
            v-text-field(
              label="Rename Pattern"
              dense
              :model-value="renameValue"
              :placeholder="currentPattern?.name || 'Pattern'"
              @update:model-value="updateRenameValue"
              @change="submitRename"
              hide-details
            )
            v-text-field(
              label="New Pattern Name"
              dense
              :model-value="newPatternName"
              @update:model-value="setNewPatternName"
              hide-details
            )
            v-btn(
              color="primary"
              block
              class="mt-1"
              @click="addPattern"
            ) Add Pattern
            v-row(class="mt-2" dense)
              v-col(cols="6")
                v-btn(
                  color="secondary"
                  block
                  @click="emitPatternUndo"
                ) Undo
              v-col(cols="6")
                v-btn(
                  color="secondary"
                  block
                  variant="outlined"
                  @click="emitPatternRedo"
                ) Redo
          v-col(cols="12" md="6")
            v-select(
              label="Active Scene"
              dense
              :items="sceneItems"
              item-title="title"
              item-value="value"
              :model-value="activeSceneId"
              @update:model-value="selectScene"
              hide-details
              clearable
            )
            v-text-field(
              label="Scene Name"
              dense
              :model-value="sceneName"
              @update:model-value="updateSceneName"
              @change="emitSceneUpdate"
              hide-details
            )
            v-combobox(
              label="Pattern Chain"
              dense
              clearable
              multiple
              chips
              :items="patternItems"
              item-title="title"
              item-value="value"
              :model-value="scenePatternIds"
              @update:model-value="setScenePatternIds"
              hide-details
            )
            v-btn(
              color="secondary"
              block
              class="mt-1"
              @click="addScene"
            ) Add Scene
        v-row(class="mt-2" dense)
          v-col(cols="6")
            v-btn(
              color="error"
              block
              variant="tonal"
              @click="$emit('erase:pad')"
            ) Erase selected pad
          v-col(cols="6")
            v-btn(
              color="error"
              block
              variant="outlined"
              @click="$emit('erase:step')"
            ) Erase selected pad @ step
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { Pattern, Scene } from '@/types/drums'

export default defineComponent({
  name: 'PatternsPanel',
  // Panel for selecting, naming, undoing, and organizing patterns and scenes.
  props: {
    patterns: { type: Array as () => Pattern[], required: true },
    selectedPatternId: { type: String, required: false },
    scenes: { type: Array as () => Scene[], required: true },
    activeSceneId: { type: String as () => string | null, default: null }
  },
  emits: ['pattern:add', 'pattern:select', 'pattern:rename', 'pattern:undo', 'pattern:redo', 'scene:add', 'scene:update', 'scene:select', 'erase:pad', 'erase:step'],
  data() {
    return {
      newPatternName: '',
      renameValue: '',
      sceneName: '',
      scenePatternIds: [] as string[]
    }
  },
  computed: {
    patternItems(): Array<{ title: string; value: string }> {
      return this.patterns.map((pattern) => ({ title: pattern.name, value: pattern.id }))
    },
    sceneItems(): Array<{ title: string; value: string | null }> {
      return [{ title: 'None', value: null }, ...this.scenes.map((scene) => ({ title: scene.name, value: scene.id }))]
    },
    currentScene(): Scene | null {
      return this.scenes.find((scene) => scene.id === this.activeSceneId) ?? null
    },
    currentPattern(): Pattern | null {
      return this.patterns.find((pattern) => pattern.id === this.selectedPatternId) ?? null
    }
  },
  watch: {
    currentScene: {
      immediate: true,
      handler(scene: Scene | null) {
        this.sceneName = scene?.name ?? ''
        this.scenePatternIds = [...(scene?.patternIds ?? [])]
      }
    },
    currentPattern: {
      immediate: true,
      handler(pattern: Pattern | null) {
        this.renameValue = pattern?.name ?? ''
      }
    }
  },
  methods: {
    addPattern() {
      this.$emit('pattern:add', { name: this.newPatternName.trim() || undefined })
      this.newPatternName = ''
    },
    handlePatternSelect(id: string | null) {
      if (id) this.$emit('pattern:select', id)
    },
    emitPatternUndo() {
      this.$emit('pattern:undo')
    },
    emitPatternRedo() {
      this.$emit('pattern:redo')
    },
    updateRenameValue(value: string) {
      this.renameValue = value
    },
    setNewPatternName(value: string) {
      this.newPatternName = value
    },
    submitRename() {
      if (this.currentPattern && this.renameValue.trim().length > 0) {
        this.$emit('pattern:rename', { id: this.currentPattern.id, name: this.renameValue.trim() })
      }
    },
    selectScene(id: string | null) {
      this.$emit('scene:select', id)
    },
    updateSceneName(value: string) {
      this.sceneName = value
      this.emitSceneUpdate()
    },
    setScenePatternIds(value: string[]) {
      this.scenePatternIds = value
      this.emitSceneUpdate()
    },
    emitSceneUpdate() {
      if (this.currentScene) {
        this.$emit('scene:update', {
          id: this.currentScene.id,
          name: this.sceneName.trim() || this.currentScene.name,
          patternIds: this.scenePatternIds
        })
      }
    },
    addScene() {
      this.$emit('scene:add', { name: this.sceneName.trim() || 'Scene', patternIds: this.scenePatternIds })
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: #9d7eff;
    margin-bottom: 12px;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
}
</style>



=========================================
File: components/panels/SoundPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Sound
      .panel-body
        v-select(
          label="Bank"
          dense
          :items="bankItems"
          item-title="title"
          item-value="value"
          :model-value="selectedBankId"
          @update:model-value="selectBank"
          hide-details
        )
        v-select(
          label="Pad"
          dense
          :items="padItems"
          item-title="title"
          item-value="value"
          v-model="padTarget"
          hide-details
        )
        p.current-sample Label: {{ currentSampleLabel }}
        input(
          ref="fileInput"
          type="file"
          accept="audio/*"
          class="d-none"
          @change="onFileChange"
        )
        v-btn(color="primary" class="mt-3" block @click="triggerFile") Replace sample
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { Soundbank } from '@/types/audio'
import type { DrumPadId } from '@/types/drums'

export default defineComponent({
  name: 'SoundPanel',
  props: {
    banks: { type: Array as () => Soundbank[], required: true },
    selectedBankId: { type: String, default: null }
  },
  emits: ['bank:select', 'pad:replace'],
  data() {
    return {
      padTarget: 'pad1' as DrumPadId
    }
  },
  computed: {
    bankItems(): Array<{ title: string; value: string }> {
      return this.banks.map((bank) => ({ title: bank.name, value: bank.id }))
    },
    padItems(): Array<{ title: string; value: DrumPadId }> {
      return Array.from({ length: 16 }, (_, index) => {
        const id = `pad${index + 1}` as DrumPadId
        return { title: id.toUpperCase(), value: id }
      })
    },
    currentSampleLabel(): string {
      const bank = this.banks.find((entry) => entry.id === this.selectedBankId)
      const sample = bank?.pads?.[this.padTarget]
      return sample?.name ?? 'Default'
    }
  },
  methods: {
    selectBank(value: string) {
      this.$emit('bank:select', value)
    },
    triggerFile() {
      const input = this.$refs.fileInput as HTMLInputElement | undefined
      input?.click()
    },
    onFileChange(event: Event) {
      const input = event.target as HTMLInputElement | null
      const files = input?.files
      if (!files || files.length === 0) return
      const file = files[0]
      this.$emit('pad:replace', { padId: this.padTarget, file })
      if (input) {
        input.value = ''
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    margin-bottom: 12px;
    color: #62e3ff;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .current-sample {
    font-size: 0.75rem;
    opacity: 0.85;
    letter-spacing: 0.08em;
  }
}
</style>



=========================================
File: components/placeholders/DualDisplayPlaceholder.vue
=========================================

<template>
  <div class="dual-display" title="Dual displays with contextual soft labels">
    <div class="display left">
      <div class="display-header">Display L</div>
      <div class="display-body">Status / lists / presets</div>
    </div>
    <div class="display right">
      <div class="display-header">Display R</div>
      <div class="display-body">Params / meters / browser</div>
    </div>
  </div>
</template>

<style scoped lang="less">
@import '@/styles/variables.less';

.dual-display {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: @space-s;
}

.display {
  border-radius: @radius-s;
  background: linear-gradient(180deg, #0f141d, #0b0f16);
  border: 1px solid #2c3545;
  box-shadow:
    inset 0 0 18px rgba(0, 0, 0, 0.65),
    0 8px 28px rgba(0, 0, 0, 0.65);
  color: #9fd4ff;
  min-height: 108px;
  display: flex;
  flex-direction: column;
}

.display-header {
  font-size: @font-size-s;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: @space-xs @space-s;
  color: #cfe9ff;
}

.display-body {
  flex: 1 1 auto;
  padding: @space-s;
  font-size: @font-size-s;
  opacity: 0.9;
  color: #8fc2ff;
}
</style>



=========================================
File: components/placeholders/FourDEncoderPlaceholder.vue
=========================================

<template>
  <div class="encoder" title="4D encoder: tilt â†•â†”, turn to browse, press to confirm">
    <div class="encoder-cap">âº</div>
    <div class="encoder-arrows">â†• â†”</div>
    <div class="encoder-label">Push to confirm</div>
  </div>
</template>

<style scoped lang="less">
@import '@/styles/variables.less';

.encoder {
  align-self: stretch;
  min-width: 120px;
  padding: @space-s @space-m;
  border-radius: @radius-m;
  background: linear-gradient(180deg, #181c26, #0f121a);
  border: 1px solid #2d3542;
  color: @color-text-primary;
  display: grid;
  place-items: center;
  gap: @space-xs;
  text-align: center;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.04),
    0 4px 12px rgba(0,0,0,0.4);
}

.encoder-cap {
  font-size: 24px;
  color: #f68b1e;
}

.encoder-arrows {
  letter-spacing: 0.25em;
}

.encoder-label {
  font-size: @font-size-xs;
  opacity: 0.85;
}
</style>



=========================================
File: components/placeholders/ModeColumnPlaceholder.vue
=========================================

<template>
  <div class="mode-column" title="Mode column with shift-layer hints">
    <button
      v-for="mode in modes"
      :key="mode.label"
      class="mode-btn"
      type="button"
      :title="mode.hint"
      :aria-label="mode.hint"
    >
      <span class="symbol">{{ mode.symbol }}</span>
      <span class="text">{{ mode.label }}</span>
    </button>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

type ModeButton = {
  label: string
  symbol: string
  hint: string
}

const DEFAULT_MODES: ModeButton[] = [
  { label: 'Scene', symbol: '', hint: 'Scene mode (hold to pin); Shift: Scene grid alt' },
  { label: 'Pattern', symbol: '', hint: 'Pattern mode (hold to pin); Shift: Duplicate pattern' },
  { label: 'Events', symbol: '', hint: 'Events/step mode; Shift: Clear events' },
  { label: 'Variation', symbol: '', hint: 'Variation/randomize; Shift: Humanize' },
  { label: 'Duplicate', symbol: '', hint: 'Duplicate selection; Shift: Copy to new slot' },
  { label: 'Select', symbol: '', hint: 'Select pad/group; Shift: Group select' },
  { label: 'Solo', symbol: '', hint: 'Solo (momentary/pin); Shift: Mute layer' },
  { label: 'Mute', symbol: '', hint: 'Mute (momentary/pin); Shift: Solo layer' },
  { label: 'Shift', symbol: 'â‡§', hint: 'Hold for secondary functions' }
]

export default defineComponent({
  name: 'ModeColumnPlaceholder',
  props: {
    modes: {
      type: Array as () => ModeButton[],
      default: () => DEFAULT_MODES
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.mode-column {
  display: flex;
  flex-direction: column;
  gap: @space-xs;
}

.mode-btn {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: @space-xs;
  padding: @space-xs @space-s;
  border: 1px solid #2f3645;
  border-radius: @radius-s;
  background: linear-gradient(180deg, #191e29, #111520);
  color: @color-text-primary;
  font-size: @font-size-xs;
  cursor: default;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
}

.mode-btn:hover {
  border-color: #f68b1e;
  background: linear-gradient(180deg, #222836, #161a25);
  box-shadow:
    0 0 8px fade(#f68b1e, 30%),
    inset 0 1px 0 rgba(255,255,255,0.06);
}

.symbol {
  font-size: @font-size-s;
  color: #f68b1e;
}

.text {
  flex: 1 1 auto;
  text-align: left;
}
</style>



=========================================
File: components/placeholders/ScreenKnobRingPlaceholder.vue
=========================================

<template>
  <div class="knob-ring" title="Screen knobs with selector overlays">
    <div
      v-for="knob in knobs"
      :key="knob.label"
      class="knob"
      :title="knob.hint"
      :aria-label="knob.hint"
    >
      <div class="knob-cap">â—¯</div>
      <div class="knob-label">{{ knob.label }}</div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

type Knob = {
  label: string
  hint: string
}

const DEFAULT_KNOBS: Knob[] = [
  { label: 'Volume', hint: 'Volume (screen knob 1)' },
  { label: 'Swing', hint: 'Swing (screen knob 2)' },
  { label: 'Tempo', hint: 'Tempo (screen knob 3)' },
  { label: 'Lock', hint: 'Lock (screen knob 4)' },
  { label: 'Group', hint: 'Group selector (screen knob 5)' },
  { label: 'Pattern', hint: 'Pattern param (screen knob 6)' },
  { label: 'Pad Mode', hint: 'Pad mode (screen knob 7)' },
  { label: 'Keyboard', hint: 'Keyboard/step (screen knob 8)' }
]

export default defineComponent({
  name: 'ScreenKnobRingPlaceholder',
  props: {
    knobs: {
      type: Array as () => Knob[],
      default: () => DEFAULT_KNOBS
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.knob-ring {
  display: grid;
  grid-template-columns: repeat(8, minmax(0, 1fr));
  gap: @space-s;
}

.knob {
  background: linear-gradient(180deg, #171c27, #0f131c);
  border: 1px solid #2f3644;
  border-radius: @radius-s;
  padding: @space-xs;
  text-align: center;
  color: @color-text-primary;
  font-size: @font-size-xs;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
}

.knob:hover {
  border-color: #f68b1e;
  box-shadow:
    0 0 8px fade(#f68b1e, 35%),
    inset 0 1px 0 rgba(255,255,255,0.07);
}

.knob-cap {
  font-size: 18px;
  line-height: 1.1;
}

.knob-label {
  opacity: 0.8;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
</style>



=========================================
File: components/placeholders/SoftButtonStripPlaceholder.vue
=========================================

<template>
  <div class="soft-strip">
    <button
      v-for="btn in buttons"
      :key="btn.symbol"
      class="soft-btn"
      type="button"
      :title="btn.hint"
      :aria-label="btn.hint"
    >
      <span class="symbol">{{ btn.symbol }}</span>
      <span class="label">{{ btn.label }}</span>
    </button>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

type SoftButton = {
  symbol: string
  label: string
  hint: string
}

const DEFAULT_BUTTONS: SoftButton[] = [
  { symbol: '', label: '', hint: 'Soft button 1 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 2 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 3 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 4 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 5 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 6 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 7 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 8 (contextual)' }
]

export default defineComponent({
  name: 'SoftButtonStripPlaceholder',
  props: {
    buttons: {
      type: Array as () => SoftButton[],
      default: () => DEFAULT_BUTTONS
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.soft-strip {
  display: grid;
  grid-template-columns: repeat(8, minmax(0, 1fr));
  gap: @space-xs;
}

.soft-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  padding: @space-xxs @space-xs;
  border: 1px solid #3a3f49;
  border-radius: 6px;
  background: linear-gradient(180deg, #cfd2d8, #9ea3ab);
  color: #1c1f24;
  font-size: @font-size-xs;
  cursor: default;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.6),
    inset 0 -1px 0 rgba(0,0,0,0.25);
}

.soft-btn:hover {
  background: linear-gradient(180deg, #ffffff, #c7ccd4);
  border-color: #ffffff;
  box-shadow:
    0 0 8px fade(#ffffff, 35%),
    inset 0 1px 0 rgba(255,255,255,0.9);
}

.symbol {
  font-size: @font-size-s;
  line-height: 1;
}

.label {
  font-size: @font-size-xs;
  line-height: 1.1;
  opacity: 0.8;
}
</style>



=========================================
File: components/placeholders/TouchStripPlaceholder.vue
=========================================

<template>
  <div class="touch-strip" title="Touch strip for performance / pitch / mod">
    <div class="strip-track">
      <div class="strip-indicator" />
    </div>
    <div class="strip-label">Touch Strip â‰¡</div>
  </div>
</template>

<style scoped lang="less">
@import '@/styles/variables.less';

.touch-strip {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: @space-xs;
  width: 100%;
}

.strip-track {
  width: 20px;
  flex: 1 1 0;
  min-height: 160px;
  border-radius: @radius-m;
  background: linear-gradient(180deg, #1b2130, #0e121b);
  border: 1px solid #2c3443;
  position: relative;
  display: flex;
  align-items: center;
  box-shadow: inset 0 0 12px rgba(0,0,0,0.6);
}

.strip-indicator {
  width: 100%;
  height: 14%;
  border-radius: @radius-s;
  background: fade(#f68b1e, 35%);
  box-shadow: 0 0 10px fade(#f68b1e, 45%);
}

.strip-label {
  font-size: @font-size-xs;
  color: fade(@color-text-secondary, 80%);
}
</style>



=========================================
File: composables/shortcutCommands.ts
=========================================

/**
 * Global keyboard shortcuts catalog.
 * Defines all command IDs and their default key bindings.
 */

export const SHORTCUT_COMMANDS = {
  // Transport
  TRANSPORT_PLAY: 'Space',
  TRANSPORT_STOP: 'Shift+Space',
  TRANSPORT_RECORD: 'Ctrl+R',
  TRANSPORT_TAP_TEMPO: 'T',
  TRANSPORT_METRONOME: 'M',
  TRANSPORT_COUNT_IN: 'C',
  TRANSPORT_LOOP: 'L',
  TRANSPORT_FOLLOW: 'F',

  // Browser
  BROWSER_OPEN: 'B',
  BROWSER_CLOSE: 'Escape',
  BROWSER_SEARCH_FOCUS: '/',
  BROWSER_PREVIEW_PLAY: 'P',
  BROWSER_PREVIEW_STOP: 'Shift+P',
  BROWSER_LOAD_SELECTED: 'Enter',
  BROWSER_IMPORT_TO_PAD: 'Ctrl+Enter',
  BROWSER_FAVORITE_TOGGLE: 'Shift+F',
  BROWSER_MODE_LIBRARY: 'Shift+L',
  BROWSER_MODE_FILES: 'Shift+B',

  // Pads (grid-style layout: 1-4 / Q-R / A-F / Z-V)
  PAD_SELECT_1: '1',
  PAD_SELECT_2: '2',
  PAD_SELECT_3: '3',
  PAD_SELECT_4: '4',
  PAD_SELECT_5: 'Q',
  PAD_SELECT_6: 'W',
  PAD_SELECT_7: 'E',
  PAD_SELECT_8: 'R',
  PAD_SELECT_9: 'A',
  PAD_SELECT_10: 'S',
  PAD_SELECT_11: 'D',
  PAD_SELECT_12: 'F',
  PAD_SELECT_13: 'Z',
  PAD_SELECT_14: 'X',
  PAD_SELECT_15: 'C',
  PAD_SELECT_16: 'V',

  PAD_MUTE: 'Shift+M',
  PAD_SOLO: 'Shift+S',
  PAD_ERASE: 'Shift+E',
  PAD_DUPLICATE: 'Shift+D',

  // 4D Encoder (fallback, already in component)
  ENCODER_TURN_UP: 'ArrowUp',
  ENCODER_TURN_DOWN: 'ArrowDown',
  ENCODER_TILT_LEFT: 'ArrowLeft',
  ENCODER_TILT_RIGHT: 'ArrowRight',
  ENCODER_PRESS: 'Enter',

  // Modes
  MODE_CHANNEL: 'Ctrl+1',
  MODE_PLUGIN: 'Ctrl+2',
  MODE_ARRANGER: 'Ctrl+3',
  MODE_MIXER: 'Ctrl+4',
  MODE_BROWSER: 'Ctrl+B',
  MODE_SAMPLING: 'Ctrl+5',

  // Pattern/Scene
  PATTERN_NEW: 'Ctrl+N',
  PATTERN_DUPLICATE: 'Ctrl+D',
  PATTERN_CLEAR: 'Ctrl+Delete',
  SCENE_PLAY: 'Ctrl+Space',
  SCENE_STOP: 'Ctrl+Shift+Space',

  // Undo/Redo
  UNDO: 'Ctrl+Z',
  REDO: 'Ctrl+Shift+Z'
} as const

export type ShortcutCommandId = keyof typeof SHORTCUT_COMMANDS



=========================================
File: composables/use4DEncoder.ts
=========================================

import { computed, ref } from 'vue'

export type EncoderMode = 'field-select' | 'value-adjust' | 'list-navigate'

export interface EncoderField {
  id: string
  label: string
  value: string | number
  options?: string[]
  min?: number
  max?: number
  step?: number
}

const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(max, value))

export const use4DEncoder = () => {
  const mode = ref<EncoderMode>('field-select')
  const fields = ref<EncoderField[]>([])
  const activeFieldIndex = ref(0)
  const activeListIndex = ref(0)

  const activeField = computed(() => fields.value[activeFieldIndex.value] ?? null)

  const setFields = (nextFields: EncoderField[]) => {
    fields.value = [...nextFields]
    if (fields.value.length === 0) {
      activeFieldIndex.value = 0
      return
    }
    activeFieldIndex.value = clamp(activeFieldIndex.value, 0, fields.value.length - 1)
  }

  const setMode = (nextMode: EncoderMode) => {
    mode.value = nextMode
  }

  const tiltHorizontal = (direction: 'left' | 'right') => {
    if (fields.value.length === 0) return
    const delta = direction === 'left' ? -1 : 1
    const maxIndex = fields.value.length - 1
    activeFieldIndex.value = clamp(activeFieldIndex.value + delta, 0, maxIndex)
    mode.value = 'field-select'
  }

  const tiltVertical = (direction: 'up' | 'down') => {
    const delta = direction === 'up' ? -1 : 1
    activeListIndex.value = Math.max(0, activeListIndex.value + delta)
    mode.value = 'list-navigate'
  }

  const updateFieldValue = (delta: number) => {
    const index = activeFieldIndex.value
    const field = fields.value[index]
    if (!field) return
    if (field.options && field.options.length > 0) {
      const startIndex = Math.max(0, field.options.findIndex((option) => option === field.value))
      const nextIndex = clamp(startIndex + delta, 0, field.options.length - 1)
      const nextValue = field.options[nextIndex] ?? field.value
      fields.value.splice(index, 1, { ...field, value: nextValue })
      return
    }
    if (typeof field.value === 'number') {
      const step = field.step ?? 1
      const min = field.min ?? Number.NEGATIVE_INFINITY
      const max = field.max ?? Number.POSITIVE_INFINITY
      const nextValue = clamp(field.value + delta * step, min, max)
      fields.value.splice(index, 1, { ...field, value: nextValue })
    }
  }

  const turn = (delta: number) => {
    if (mode.value === 'list-navigate') {
      activeListIndex.value = Math.max(0, activeListIndex.value + delta)
      return
    }
    if (mode.value !== 'value-adjust') return
    updateFieldValue(delta)
  }

  const press = () => {
    if (mode.value === 'field-select') {
      mode.value = 'value-adjust'
      return
    }
    if (mode.value === 'value-adjust') {
      mode.value = 'list-navigate'
      return
    }
    mode.value = 'field-select'
  }

  return {
    mode,
    fields,
    activeFieldIndex,
    activeListIndex,
    activeField,
    tiltHorizontal,
    tiltVertical,
    turn,
    press,
    setFields,
    setMode
  }
}

export type Use4DEncoderReturn = ReturnType<typeof use4DEncoder>



=========================================
File: composables/useAudioEngine.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import type { DrumPadId } from '@/types/drums'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import { createSeededRandom, type RandomSource } from '@/utils/seededRandom'
import { createFxGraph, connectFxGraph, updateFxGraph, type FxGraphNodes } from '@/audio/fxGraph'

interface TriggerRequest {
  padId: DrumPadId
  when: number
  velocity?: number
}

const cloneFxSettings = (settings: FxSettings): FxSettings => ({
  filter: { ...settings.filter },
  drive: { ...settings.drive },
  reverb: { ...settings.reverb }
})

const createAudioEngineInstance = () => {
  const audioContext = ref<AudioContext | null>(null)
  const masterGain = ref<GainNode | null>(null)
  const sampleCache = ref<Map<DrumPadId, AudioBuffer>>(new Map())
  const fxSettings = ref<FxSettings>({
    filter: { enabled: true, frequency: 12000, q: 0.7 },
    drive: { enabled: false, amount: 0.25 },
    reverb: { enabled: false, mix: 0.15 }
  })
  const fxSnapshot = ref<FxSettings>(cloneFxSettings(fxSettings.value))
  const fxGraph = ref<FxGraphNodes | null>(null)
  let randomSource: RandomSource = createSeededRandom(0)
  let wasRunningOnHide = false
  let handlePageHide: (() => void) | null = null
  let handlePageShow: (() => void) | null = null

  const syncFxSnapshot = () => {
    fxSnapshot.value = cloneFxSettings(fxSettings.value)
    return fxSnapshot.value
  }

  const ensureFxGraph = (ctx: BaseAudioContext, snapshot: FxSettings) => {
    if (!masterGain.value) {
      return
    }
    if (!fxGraph.value) {
      fxGraph.value = createFxGraph(ctx)
      connectFxGraph(fxGraph.value, masterGain.value)
    }
    updateFxGraph(ctx, fxGraph.value, snapshot, randomSource)
  }

  const ensureContext = () => {
    if (!audioContext.value) {
      const context = new AudioContext()
      const gain = context.createGain()
      gain.gain.value = 0.8
      gain.connect(context.destination)
      audioContext.value = context
      masterGain.value = gain
    }
    ensureFxGraph(audioContext.value as BaseAudioContext, fxSnapshot.value)
    return audioContext.value as AudioContext
  }

  const resumeContext = async () => {
    const ctx = ensureContext()
    if (ctx.state === 'suspended') {
      await ctx.resume()
    }
    return ctx
  }

  const getFxSnapshot = () => cloneFxSettings(fxSnapshot.value)

  const setFxRandomSource = (source: RandomSource) => {
    randomSource = source
    if (fxGraph.value?.reverbNode) {
      fxGraph.value.reverbNode.buffer = null
    }
    if (audioContext.value) {
      ensureFxGraph(audioContext.value, fxSnapshot.value)
    }
  }

  const decodeSample = async (sample: SampleRef): Promise<AudioBuffer | null> => {
    const ctx = ensureContext()
    if (sample.buffer) {
      return sample.buffer
    }
    if (sample.blob) {
      const arrayBuffer = await sample.blob.arrayBuffer()
      return ctx.decodeAudioData(arrayBuffer.slice(0))
    }
    if (sample.url) {
      const response = await fetch(sample.url)
      const arrayBuffer = await response.arrayBuffer()
      return ctx.decodeAudioData(arrayBuffer)
    }
    return null
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    const buffer = sample.buffer ?? (await decodeSample(sample))
    if (buffer) {
      sampleCache.value.set(padId, buffer)
    }
  }

  const applySoundbank = async (bank: Soundbank) => {
    const entries = Object.entries(bank.pads)
    await Promise.all(
      entries.map(async ([padId, sample]) => {
        if (sample) {
          await setSampleForPad(padId as DrumPadId, sample)
        }
      })
    )
  }

  const setFx = (partial: Partial<FxSettings>) => {
    fxSettings.value = {
      filter: { ...fxSettings.value.filter, ...(partial.filter ?? {}) },
      drive: { ...fxSettings.value.drive, ...(partial.drive ?? {}) },
      reverb: { ...fxSettings.value.reverb, ...(partial.reverb ?? {}) }
    }
    const snapshot = syncFxSnapshot()
    const ctx = ensureContext()
    ensureFxGraph(ctx, snapshot)
  }

  const trigger = async ({ padId, when, velocity = 1 }: TriggerRequest) => {
    const ctx = ensureContext()
    const buffer = sampleCache.value.get(padId) ?? null
    if (!buffer) {
      return
    }
    const source = ctx.createBufferSource()
    source.buffer = buffer
    const gain = ctx.createGain()
    gain.gain.value = velocity
    source.connect(gain)
    if (fxGraph.value) {
      gain.connect(fxGraph.value.fxInput)
    } else {
      gain.connect(masterGain.value ?? ctx.destination)
    }
    source.start(when)
  }

  const triggerClick = async (when: number, accented = false, volume = 0.12) => {
    const ctx = ensureContext()
    const osc = ctx.createOscillator()
    const gain = ctx.createGain()
    osc.type = 'square'
    osc.frequency.value = accented ? 2200 : 1600
    const base = Math.max(0, Math.min(1, volume))
    gain.gain.setValueAtTime((accented ? 1.4 : 1) * base, when)
    gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.06)
    osc.connect(gain)
    gain.connect(masterGain.value ?? ctx.destination)
    osc.start(when)
    osc.stop(when + 0.08)
  }

  if (typeof window !== 'undefined') {
    handlePageHide = () => {
      if (audioContext.value) {
        wasRunningOnHide = audioContext.value.state === 'running'
        void audioContext.value.suspend().catch(() => undefined)
      }
    }

    handlePageShow = () => {
      if (wasRunningOnHide && audioContext.value) {
        void audioContext.value.resume().catch(() => undefined)
      }
      wasRunningOnHide = false
    }

    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)
  }

  onBeforeUnmount(() => {
    if (handlePageHide) {
      window.removeEventListener('pagehide', handlePageHide)
    }
    if (handlePageShow) {
      window.removeEventListener('pageshow', handlePageShow)
    }
    audioContext.value?.close()
    sampleCache.value.clear()
  })

  return {
    audioContext,
    masterGain,
    sampleCache,
    fxSettings,
    ensureContext,
    resumeContext,
    decodeSample,
    applySoundbank,
    setFx,
    setSampleForPad,
    trigger,
    triggerClick,
    getFxSnapshot,
    setFxRandomSource
  }
}

let audioEngineInstance: ReturnType<typeof createAudioEngineInstance> | null = null

export function useAudioEngine() {
  if (!audioEngineInstance) {
    audioEngineInstance = createAudioEngineInstance()
  }
  return audioEngineInstance
}



=========================================
File: composables/useAudioInput.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'

export interface AudioInputState {
  stream?: MediaStream
  error?: string
}

export function useAudioInput() {
  const state = ref<AudioInputState>({})
  const sourceNode = ref<MediaStreamAudioSourceNode | null>(null)
  const audioContext = ref<AudioContext | null>(null)
  let handlePageHide: (() => void) | null = null

  const requestMic = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const context = new AudioContext()
      sourceNode.value = context.createMediaStreamSource(stream)
      audioContext.value = context
      state.value = { stream }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'microphone request failed'
      state.value = { error: message }
    }
  }

  const stop = () => {
    state.value.stream?.getTracks().forEach((track) => track.stop())
    void audioContext.value?.close()
    audioContext.value = null
    state.value = {}
  }

  if (typeof window !== 'undefined') {
    handlePageHide = () => {
      stop()
      sourceNode.value = null
    }
    window.addEventListener('pagehide', handlePageHide)
  }

  onBeforeUnmount(() => {
    if (handlePageHide) {
      window.removeEventListener('pagehide', handlePageHide)
    }
    stop()
    sourceNode.value = null
  })

  return {
    state,
    sourceNode,
    requestMic,
    stop
  }
}



=========================================
File: composables/useCapabilities.client.ts
=========================================

import { ref } from 'vue'

export interface Capabilities {
  supportsWebMIDI: boolean
  supportsAudioInput: boolean
}

export function useCapabilities() {
  const capabilities = ref<Capabilities>({ supportsWebMIDI: false, supportsAudioInput: false })

  const evaluate = () => {
    capabilities.value = {
      supportsWebMIDI: typeof navigator !== 'undefined' && 'requestMIDIAccess' in navigator,
      supportsAudioInput: typeof navigator !== 'undefined' && Boolean(navigator.mediaDevices?.getUserMedia)
    }
  }

  evaluate()

  return {
    capabilities,
    evaluate
  }
}



=========================================
File: composables/useImportExport.client.ts
=========================================

import { ref } from 'vue'
import { saveAs } from 'file-saver'
import { Midi as MidiType } from '@tonejs/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import { clampVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock } from '@/domain/clock/renderClock'
import { createFxGraph, connectFxGraph, updateFxGraph } from '@/audio/fxGraph'
import { useAudioEngine } from './useAudioEngine.client'
import { usePatternsStore } from '@/stores/patterns'
import { useTransportStore } from '@/stores/transport'
import { createSeededRandom } from '@/utils/seededRandom'
import type { ScheduledTask } from './useScheduler'
import { scheduleStep } from './useSequencer'
import type { ScheduleStepOptions, ScheduledStep } from './useSequencer'
import type { GridSpec } from '@/types/time'
import type { MidiFileData, MidiMapping } from '@/types/midi'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { RenderMetadata, RenderEvent } from '@/types/render'
import type { DrumPadId, Pattern } from '@/types/drums'

const Midi = MidiType
const encoderHeader = 'Drumcomputer Pattern Export'

const audioBufferToWav = (buffer: AudioBuffer) => {
  const numOfChan = buffer.numberOfChannels
  const length = buffer.length * numOfChan * 2 + 44
  const result = new ArrayBuffer(length)
  const view = new DataView(result)
  let offset = 0

  const writeString = (str: string) => {
    for (let i = 0; i < str.length; i += 1) {
      view.setUint8(offset + i, str.charCodeAt(i))
    }
    offset += str.length
  }

  const setUint16 = (data: number) => {
    view.setUint16(offset, data, true)
    offset += 2
  }

  const setUint32 = (data: number) => {
    view.setUint32(offset, data, true)
    offset += 4
  }

  writeString('RIFF')
  setUint32(length - 8)
  writeString('WAVE')
  writeString('fmt ')
  setUint32(16)
  setUint16(1)
  setUint16(numOfChan)
  setUint32(buffer.sampleRate)
  setUint32(buffer.sampleRate * numOfChan * 2)
  setUint16(numOfChan * 2)
  setUint16(16)
  writeString('data')
  setUint32(length - offset - 4)

  const channels: Float32Array[] = []
  for (let i = 0; i < numOfChan; i += 1) {
    channels.push(buffer.getChannelData(i))
  }

  while (offset < length) {
    for (let i = 0; i < numOfChan; i += 1) {
      const channel = channels[i]
      if (!channel) {
        offset += 2
        continue
      }
      const sampleIndex = Math.floor((offset - 44) / (2 * numOfChan))
      const rawSample = channel[sampleIndex] ?? 0
      const sample = Math.max(-1, Math.min(1, rawSample))
      view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true)
      offset += 2
    }
  }
  return result
}

const normalizePattern = (pattern: Pattern): Pattern => {
  const gridSpec: GridSpec = normalizeGridSpec(pattern.gridSpec)
  const steps: Pattern['steps'] = {}
  Object.entries(pattern.steps ?? {}).forEach(([barKey, barValue]) => {
    const barIndex = Number(barKey)
    if (Number.isNaN(barIndex)) return
    const normalizedBar: Record<number, Partial<Record<DrumPadId, { velocity?: { value: number } }>>> = {}
    Object.entries(barValue ?? {}).forEach(([stepKey, stepValue]) => {
      const stepInBar = Number(stepKey)
      if (Number.isNaN(stepInBar)) return
      const normalizedRow: Partial<Record<DrumPadId, { velocity?: { value: number } }>> = {}
      Object.entries(stepValue ?? {}).forEach(([padId, cell]) => {
        if (!cell) return
        normalizedRow[padId as DrumPadId] = {
          velocity: { value: clampVelocity(cell.velocity?.value ?? DEFAULT_STEP_VELOCITY) }
        }
      })
      if (Object.keys(normalizedRow).length > 0) {
        normalizedBar[stepInBar] = normalizedRow
      }
    })
    if (Object.keys(normalizedBar).length > 0) {
      steps[barIndex] = normalizedBar
    }
  })
  return {
    ...pattern,
    gridSpec,
    steps
  }
}

const patternFromMidi = (midi: MidiType, mapping: MidiMapping): Pattern => {
  const gridSpec: GridSpec = { bars: 1, division: 16 }
  const steps: Pattern['steps'] = {}
  const track = midi.tracks[0]
  if (!track) {
    return normalizePattern({
      id: 'imported-pattern',
      name: 'Imported Pattern',
      gridSpec,
      steps
    })
  }
  const ticksPerBeat = midi.header.ppq
  const stepTicks = (ticksPerBeat * 4) / gridSpec.division
  const notes = track.notes ?? []
  interface Note {
    midi: number
    ticks: number
    velocity?: number
  }

  interface Steps {
    [barIndex: number]: {
      [stepInBar: number]: Partial<Record<DrumPadId, { velocity?: { value: number } }>>
    }
  }

  notes.forEach((note: Note) => {
    const stepIndex: number = Math.round(note.ticks / stepTicks)
    const barIndex: number = Math.floor(stepIndex / gridSpec.division)
    const stepInBar: number = stepIndex % gridSpec.division
    const pad: DrumPadId | undefined = mapping.noteMap[note.midi]
    if (!pad) return
    const bar: Steps[number] = steps[barIndex] ?? {}
    const row: Steps[number][number] = bar[stepInBar] ?? {}
    const velocity: number = typeof note.velocity === 'number' ? note.velocity : DEFAULT_STEP_VELOCITY
    row[pad] = { velocity: { value: clampVelocity(velocity) } }
    bar[stepInBar] = row
    steps[barIndex] = bar
  })
  return normalizePattern({
    id: 'imported-pattern',
    name: track.name ?? 'Imported Pattern',
    gridSpec,
    steps
  })
}

export function useImportExport() {
  const exportPattern = (pattern: Pattern) => {
    const normalized = normalizePattern(pattern)
    const blob = new Blob([JSON.stringify(normalized, null, 2)], { type: 'application/json' })
    saveAs(blob, `${normalized.name}.json`)
  }

  const importPattern = async (file: File): Promise<Pattern> => {
    try {
      const text = await file.text()
      const parsed = JSON.parse(text) as Pattern
      return normalizePattern(parsed)
    } catch (error) {
      console.error('Failed to import pattern', error)
      return {
        id: `imported-${Date.now()}`,
        name: file.name,
        gridSpec: { bars: 1, division: 16 },
        steps: {}
      }
    }
  }

  const exportMidi = (pattern: Pattern, bpm: number, mapping: MidiMapping = defaultMidiMapping()) => {
    if (typeof Midi === 'undefined') {
      console.error('MIDI export is not available: Midi is undefined.')
      return
    }
    const midi = new Midi()
    midi.header.setTempo(bpm)
    const track = midi.addTrack()
    const ticksPerBeat = midi.header.ppq
    const stepTicks = (ticksPerBeat * 4) / pattern.gridSpec.division
    const totalSteps = pattern.gridSpec.bars * pattern.gridSpec.division
    for (let i = 0; i < totalSteps; i += 1) {
      const barIndex = Math.floor(i / pattern.gridSpec.division)
      const stepInBar = i % pattern.gridSpec.division
      const row = pattern.steps[barIndex]?.[stepInBar]
      if (!row) continue
      Object.entries(row).forEach(([padId, cell]) => {
        const drumPad = padId as DrumPadId
        const note = mapping.noteMapInverse?.[drumPad] ?? Object.entries(mapping.noteMap).find(([, pad]) => pad === drumPad)?.[0]
        if (typeof note !== 'string' && typeof note !== 'number') return
        const midiNote = typeof note === 'string' ? Number(note) : note
        if (typeof midiNote !== 'number') return
        track.addNote({
          midi: midiNote,
          time: (i * stepTicks) / ticksPerBeat,
          duration: stepTicks / ticksPerBeat,
          velocity: cell?.velocity?.value ?? 1
        })
      })
    }
    const midiArray = midi.toArray()
    const midiBuffer = midiArray.buffer as ArrayBuffer
    const blob = new Blob([midiBuffer], { type: 'audio/midi' })
    saveAs(blob, `${pattern.name}.mid`)
  }

  const importMidi = async (file: File, mapping: MidiMapping = defaultMidiMapping()): Promise<Pattern> => {
    if (typeof Midi === 'undefined') {
      console.error('MIDI import is not available: Midi is undefined.')
      return {
        id: `imported-${Date.now()}`,
        name: file.name,
        gridSpec: { bars: 1, division: 16 },
        steps: {}
      }
    }
    const buffer = await file.arrayBuffer()
    const midi = new Midi(buffer)
    return patternFromMidi(midi, mapping)
  }

  const createScenePlaybackTracker = (patternsStore: ReturnType<typeof usePatternsStore>) => {
    const scene = patternsStore.currentScene
    const patternList = scene?.patternIds ?? []
    const fallbackPattern: Pattern = patternsStore.patterns[0] ?? {
      id: 'pattern-1',
      name: 'Pattern 1',
      gridSpec: { ...DEFAULT_GRID_SPEC },
      steps: {}
    }
    let currentPatternId = patternList[0] ?? patternsStore.selectedPatternId ?? fallbackPattern.id
    let scenePosition = patternList.length > 1 ? 1 : 0
    const resolvePattern = (id: string) => patternsStore.patterns.find((pattern: Pattern) => pattern.id === id) ?? fallbackPattern
    const getPattern = () => resolvePattern(currentPatternId)
    const advancePattern = () => {
      if (!scene || patternList.length === 0) {
        return getPattern()
      }
      const nextId = patternList[scenePosition % patternList.length]
      scenePosition = (scenePosition + 1) % patternList.length
      if (nextId) {
        currentPatternId = nextId
      }
      return getPattern()
    }
    const initialPattern = getPattern()
    const patternChain = patternList.length > 0 ? [...patternList] : [patternsStore.selectedPatternId ?? initialPattern.id]
    return {
      sceneId: scene?.id ?? null,
      patternChain,
      initialPatternId: initialPattern.id,
      getPattern,
      advancePattern
    }
  }

  const createOfflineScheduler = (limit: number, updateClock: (time: number) => void) => {
    const tasks: ScheduledTask[] = []
    return {
      schedule(task: ScheduledTask) {
        tasks.push(task)
        tasks.sort((a, b) => a.when - b.when)
      },
      run() {
        while (tasks.length > 0) {
          const next = tasks[0]
          if (!next || next.when > limit) break
          tasks.shift()
          updateClock(next.when)
          next.callback()
        }
      }
    }
  }

  const hashSnapshot = (payload: string) => {
    let hash = 0
    for (let i = 0; i < payload.length; i += 1) {
      hash = Math.imul(31, hash) + payload.charCodeAt(i)
      hash >>>= 0
    }
    return hash.toString(36)
  }

  type StemExportFiles = Partial<Record<DrumPadId, { fileName: string; blob: Blob }>>

  type ExportAudioResult = {
    audioBlob: Blob
    metadata: RenderMetadata
    debugTimeline?: RenderEvent[]
    stems?: StemExportFiles
  }

  const slugifyName = (value: string) => {
    const cleaned = value
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '')
    return cleaned || 'session'
  }

  const collectPadIdsFromPatternChain = (patternChain: string[], patternList: Pattern[]): DrumPadId[] => {
    const padSet = new Set<DrumPadId>()
    patternChain.forEach((patternId) => {
      const pattern = patternList.find((entry) => entry.id === patternId)
      if (!pattern) return
      Object.values(pattern.steps ?? {}).forEach((bar) => {
        Object.values(bar ?? {}).forEach((stepRow) => {
          Object.keys(stepRow ?? {}).forEach((padId) => {
            padSet.add(padId as DrumPadId)
          })
        })
      })
    })
    return Array.from(padSet)
  }

  const exportAudio = async (
    renderDurationSec: number,
    sampleRate = 44100,
    options: { seed?: number; stems?: boolean } = {}
  ): Promise<ExportAudioResult> => {
    const transport = useTransportStore()
    const patterns = usePatternsStore()
    const audio = useAudioEngine()
    const duration = Math.max(0, renderDurationSec)
    const frameCount = Math.max(1, Math.ceil(duration * sampleRate))
    const seedValue = options.seed ?? Date.now()
    const fxSnapshot = audio.getFxSnapshot()
    const shouldDebug = import.meta.env?.DEV ?? false
    const baseSampleCache = new Map(audio.sampleCache.value)

    const metadataTracker = createScenePlaybackTracker(patterns)
    const metadataPattern = metadataTracker.getPattern()
    const initialGridSpec = normalizeGridSpec(metadataPattern.gridSpec ?? transport.gridSpec)
    const metadata: RenderMetadata = {
      seed: String(seedValue),
      bpm: transport.bpm,
      gridSpec: initialGridSpec,
      sceneId: metadataTracker.sceneId,
      patternChain: metadataTracker.patternChain,
      initialPatternId: metadataTracker.initialPatternId,
      durationSec: duration
    }

    const songSlug = slugifyName(patterns.currentScene?.name ?? metadataPattern.name ?? 'drum-session')
    const candidatePadIds = collectPadIdsFromPatternChain(metadataTracker.patternChain, patterns.patterns)
    const stemPadIds = options.stems
      ? candidatePadIds.filter((padId) => baseSampleCache.has(padId))
      : []

    const renderPass = async (soloPadId?: DrumPadId, collectDebug = false) => {
      const context = new OfflineAudioContext(2, frameCount, sampleRate)
      const masterGainNode = context.createGain()
      masterGainNode.gain.value = 0.8
      masterGainNode.connect(context.destination)
      const fxGraph = createFxGraph(context)
      connectFxGraph(fxGraph, masterGainNode)

      const rng = createSeededRandom(seedValue)
      updateFxGraph(context, fxGraph, fxSnapshot, rng)

      const sampleCache = new Map(baseSampleCache)
      const shouldCollectDebugEvents = shouldDebug && collectDebug
      const debugEvents: RenderEvent[] = []

      const offlineEngine = {
        trigger({ padId, when, velocity = 1 }: { padId: DrumPadId; when: number; velocity?: number }) {
          if (soloPadId && padId !== soloPadId) return
          const buffer = sampleCache.get(padId)
          if (!buffer) return
          const source = context.createBufferSource()
          source.buffer = buffer
          const gainNode = context.createGain()
          gainNode.gain.value = velocity
          source.connect(gainNode)
          gainNode.connect(fxGraph.fxInput)
          source.start(when)
          if (shouldCollectDebugEvents) {
            debugEvents.push({ time: when, padId, velocity })
          }
        }
      }

      let simulatedTime = 0
      const baseClock = createRenderClock(context, true)
      const renderClock: ScheduleStepOptions['clock'] = {
        ctx: baseClock.ctx,
        isOffline: true,
        now: () => simulatedTime,
        audioTime: () => baseClock.audioTime()
      }

      const offlineScheduler = createOfflineScheduler(duration, (time) => {
        simulatedTime = time
      })

      const tracker = createScenePlaybackTracker(patterns)
      const initialPatternForRender = tracker.getPattern()
      const renderGridSpec = normalizeGridSpec(initialPatternForRender.gridSpec ?? transport.gridSpec)
      const currentStep = ref(0)
      const pendingSteps = ref<ScheduledStep[]>([])
      const offlineTransportBase = {
        loop: transport.loop,
        bpm: transport.bpm,
        gridSpec: renderGridSpec,
        setCurrentStep: () => { },
        setGridSpec(gridSpec: GridSpec) {
          offlineTransportBase.gridSpec = normalizeGridSpec(gridSpec)
        }
      }
      const offlineTransport = offlineTransportBase as unknown as ScheduleStepOptions['transport']

      const stepOptions: ScheduleStepOptions = {
        clock: renderClock,
        scheduler: offlineScheduler,
        audio: offlineEngine as ScheduleStepOptions['audio'],
        transport: offlineTransport,
        getPattern: () => tracker.getPattern(),
        currentStep,
        pendingSteps,
        onPatternBoundary: () => {
          const nextPattern = tracker.advancePattern()
          offlineTransport.setGridSpec(nextPattern.gridSpec)
          return nextPattern
        }
      }

      scheduleStep(stepOptions, 0)
      offlineScheduler.run()
      simulatedTime = duration

      const rendered = await context.startRendering()
      return {
        audioBuffer: rendered,
        debugEvents: shouldCollectDebugEvents ? debugEvents : undefined
      }
    }

    const mixdownResult = await renderPass(undefined, true)
    const mixdownBlob = new Blob([audioBufferToWav(mixdownResult.audioBuffer)], { type: 'audio/wav' })
    saveAs(mixdownBlob, 'mixdown.wav')

    if (shouldDebug) {
      const events = mixdownResult.debugEvents ?? []
      const snapshotHash = hashSnapshot(JSON.stringify(fxSnapshot))
      console.info(
        'Offline export',
        `seed=${seedValue}`,
        `snapshot=${snapshotHash}`,
        `events=${events.length}`,
        `duration=${duration.toFixed(2)}`
      )
      if (events.length === 0) {
        console.warn('Offline export scheduled zero events; verify the active pattern/scene contains steps')
      }
    }

    const stemFiles: StemExportFiles = {}
    for (const padId of stemPadIds) {
      const stemResult = await renderPass(padId)
      const stemBlob = new Blob([audioBufferToWav(stemResult.audioBuffer)], { type: 'audio/wav' })
      const fileName = `${songSlug}_${padId}.wav`
      stemFiles[padId] = { fileName, blob: stemBlob }
    }

    const result: ExportAudioResult = {
      audioBlob: mixdownBlob,
      metadata
    }
    if (shouldDebug && mixdownResult.debugEvents) {
      result.debugTimeline = mixdownResult.debugEvents
    }
    if (Object.keys(stemFiles).length > 0) {
      result.stems = stemFiles
    }
    return result
  }

  const exportSoundbank = (bank: Soundbank, samples: SampleRef[]) => {
    const padEntries = Object.entries(bank.pads).reduce<Record<string, { id: string; name: string; format?: SampleRef['format'] }>>((acc, [padId, sample]) => {
      if (sample) {
        acc[padId] = { id: sample.id, name: sample.name, format: sample.format }
      }
      return acc
    }, {})
    const manifest = {
      bank: { ...bank, pads: padEntries },
      samples: samples.map((sample) => {
        const entry: { id: string; name: string; format?: SampleRef['format'] } = {
          id: sample.id,
          name: sample.name
        }
        if (sample.format) {
          entry.format = sample.format
        }
        return entry
      })
    }
    saveAs(new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' }), `${bank.name}-manifest.json`)
    samples.forEach((sample) => {
      if (sample.blob) {
        saveAs(sample.blob, sample.name)
      }
    })
  }

  const importSoundbank = async (manifestFile: File, sampleFiles: File[]): Promise<{ bank: Soundbank; samples: SampleRef[] }> => {
    try {
      const manifestText = await manifestFile.text()
      const parsed = JSON.parse(manifestText) as { bank: Soundbank; samples: Array<Pick<SampleRef, 'id' | 'name' | 'format'>> }
      const sampleMap = new Map(sampleFiles.map((file) => [file.name, file]))
      const hydratedSamples: SampleRef[] = parsed.samples.map((sample) => {
        const blob = sampleMap.get(sample.name)
        if (blob) {
          return { ...sample, blob }
        }
        return { ...sample }
      })
      const padAssignments: Partial<Record<string, SampleRef>> = {}
      Object.entries(parsed.bank.pads ?? {}).forEach(([padId, sampleInfo]) => {
        const found = hydratedSamples.find((sample) => sample.id === (sampleInfo as SampleRef).id)
        if (found) {
          padAssignments[padId] = found
        }
      })
      const hydratedBank: Soundbank = { ...parsed.bank, pads: padAssignments }
      return { bank: hydratedBank, samples: hydratedSamples }
    } catch (error) {
      console.error('Failed to import soundbank', error)
      return {
        bank: { id: 'invalid-bank', name: manifestFile.name, pads: {}, createdAt: Date.now(), updatedAt: Date.now() },
        samples: []
      }
    }
  }

  const exportMidiData = (data: MidiFileData) => {
    const blob = new Blob([encoderHeader, JSON.stringify(data)], { type: 'application/json' })
    saveAs(blob, 'sequence.mid.json')
  }

  return {
    exportPattern,
    importPattern,
    exportMidi,
    importMidi,
    exportMidiData,
    exportAudio,
    exportSoundbank,
    importSoundbank
  }
}



=========================================
File: composables/useMidi.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '@/types/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'

export function useMidi() {
  const access = ref<MIDIAccess | null>(null)
  const inputs = ref<MidiDeviceInfo[]>([])
  const outputs = ref<MidiDeviceInfo[]>([])
  const mapping = ref<MidiMapping>(defaultMidiMapping())
  const selectedInputId = ref<string | null>(null)
  const selectedOutputId = ref<string | null>(null)
  const listeners = ref<Set<(message: MidiMessage) => void>>(new Set())
  let handlePageHide: (() => void) | null = null
  let handlePageShow: (() => void) | null = null

  const supportsMidi = () => typeof navigator !== 'undefined' && Boolean((navigator as Navigator).requestMIDIAccess)

  const refreshDevices = () => {
    if (!access.value) return
    inputs.value = Array.from(access.value.inputs.values()).map((device: MIDIInput) => ({
      id: device.id,
      name: device.name ?? 'MIDI In',
      type: 'input'
    }))
    outputs.value = Array.from(access.value.outputs.values()).map((device: MIDIOutput) => ({
      id: device.id,
      name: device.name ?? 'MIDI Out',
      type: 'output'
    }))
  }

  const requestAccess = async () => {
    if (!supportsMidi()) {
      return
    }
    access.value = await (navigator as Navigator).requestMIDIAccess({ sysex: false })
    refreshDevices()
    if (access.value) {
      access.value.onstatechange = () => {
        refreshDevices()
        attachSelectedInput()
      }
    }
  }

  const handleMidiMessage = (event: MIDIMessageEvent) => {
    if (!event.data || event.data.length < 1) return
    const status = event.data[0]
    const data1 = event.data[1]
    const data2 = event.data[2]
    if (status === undefined) return
    const type = status & 0xf0
    const hasNoteData = typeof data1 === 'number' && typeof data2 === 'number'
    const message: MidiMessage | null =
      type === 0x90 && hasNoteData && data2 > 0
        ? { type: 'noteon', note: data1, velocity: data2 / 127 }
        : type === 0x80 && hasNoteData
          ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
          : type === 0x90 && hasNoteData && data2 === 0
            ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
            : status === 0xf8
              ? { type: 'clock' }
              : status === 0xfa
                ? { type: 'start' }
                : status === 0xfc
                  ? { type: 'stop' }
                  : null
    if (!message) return
    listeners.value.forEach((cb) => cb(message))
  }

  const detachInputs = () => {
    access.value?.inputs.forEach((input) => {
      input.onmidimessage = null
    })
  }

  const attachSelectedInput = () => {
    detachInputs()
    if (!selectedInputId.value) return
    const input = access.value?.inputs.get(selectedInputId.value)
    if (input) {
      input.onmidimessage = handleMidiMessage
    }
  }

  const listen = (cb: (message: MidiMessage) => void) => {
    listeners.value.add(cb)
    attachSelectedInput()
    return () => listeners.value.delete(cb)
  }

  const send = (deviceId: string, message: MidiMessage) => {
    const output = access.value?.outputs.get(deviceId)
    if (!output) return
    switch (message.type) {
      case 'noteon':
        output.send([0x90, message.note ?? 0, Math.floor((message.velocity ?? 1) * 127)])
        break
      case 'noteoff':
        output.send([0x80, message.note ?? 0, 0])
        break
      case 'start':
        output.send([0xfa])
        break
      case 'stop':
        output.send([0xfc])
        break
      case 'clock':
        output.send([0xf8])
        break
      default:
        break
    }
  }

  const sendClockTick = () => {
    if (selectedOutputId.value) {
      send(selectedOutputId.value, { type: 'clock' })
    }
  }

  const sendStart = () => {
    if (selectedOutputId.value) {
      send(selectedOutputId.value, { type: 'start' })
    }
  }

  const sendStop = () => {
    if (selectedOutputId.value) {
      send(selectedOutputId.value, { type: 'stop' })
    }
  }

  const setSelectedInput = (id: string | null) => {
    selectedInputId.value = id
    attachSelectedInput()
  }

  const setSelectedOutput = (id: string | null) => {
    selectedOutputId.value = id
  }

  const mapNoteToPad = (note: number) => mapping.value.noteMap[note]
  const setPadForNote = (note: number, padId: MidiMapping['noteMap'][number]) => {
    if (padId) {
      mapping.value.noteMap[note] = padId
    } else {
      delete mapping.value.noteMap[note]
    }
  }

  if (typeof window !== 'undefined') {
    handlePageHide = () => {
      detachInputs()
      if (access.value) {
        access.value.onstatechange = null
      }
    }
    handlePageShow = () => {
      if (access.value) {
        refreshDevices()
        attachSelectedInput()
        access.value.onstatechange = () => {
          refreshDevices()
          attachSelectedInput()
        }
      }
    }
    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)
  }

  onBeforeUnmount(() => {
    if (handlePageHide) {
      window.removeEventListener('pagehide', handlePageHide)
    }
    if (handlePageShow) {
      window.removeEventListener('pageshow', handlePageShow)
    }
    detachInputs()
    if (access.value) {
      access.value.onstatechange = null
    }
  })

  return {
    access,
    inputs,
    outputs,
    mapping,
    selectedInputId,
    selectedOutputId,
    supportsMidi,
    requestAccess,
    refreshDevices,
    listen,
    send,
    sendClockTick,
    sendStart,
    sendStop,
    mapNoteToPad,
    setPadForNote,
    setMapping: (next: MidiMapping) => {
      mapping.value = next
    },
    setSelectedInput,
    setSelectedOutput
  }
}



=========================================
File: composables/useMidiLearn.ts
=========================================

import { computed, onBeforeUnmount, ref } from 'vue'
import { defaultMidiMapping } from '@/domain/midiMapping'
import type { MidiMessage, MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

type LearnTarget =
  | { type: 'pad'; padId: DrumPadId }
  | { type: 'transport'; action: 'play' | 'stop' | 'bpmUp' | 'bpmDown' }

const STORAGE_KEY = 'drumcomputer:midi-mapping'

const loadMapping = (): MidiMapping => {
  if (typeof localStorage === 'undefined') return defaultMidiMapping()
  try {
    const raw = localStorage.getItem(STORAGE_KEY)
    if (!raw) return defaultMidiMapping()
    const parsed = JSON.parse(raw) as MidiMapping
    return {
      noteMap: parsed.noteMap ?? {},
      noteMapInverse: parsed.noteMapInverse ?? {},
      transportMap: parsed.transportMap ?? {}
    }
  } catch {
    return defaultMidiMapping()
  }
}

const persistMapping = (mapping: MidiMapping) => {
  if (typeof localStorage === 'undefined') return
  const payload: MidiMapping = {
    noteMap: mapping.noteMap ?? {},
    noteMapInverse: mapping.noteMapInverse ?? {},
    transportMap: mapping.transportMap ?? {}
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(payload))
}

export function useMidiLearn(midi: {
  mapping: { value: MidiMapping }
  setPadForNote: (note: number, padId: DrumPadId | undefined) => void
  mapNoteToPad: (note: number) => DrumPadId | undefined
  listen: (cb: (message: MidiMessage) => void) => () => void
}) {
  // Manages MIDI learn flow for pads and transport actions with persistence to localStorage.
  const isLearning = ref(false)
  const target = ref<LearnTarget | null>(null)
  const status = ref<string | null>(null)
  let unsubscribe: (() => void) | null = null

  midi.mapping.value = loadMapping()

  const learningLabel = computed(() => {
    if (!isLearning.value || !target.value) return null
    if (target.value.type === 'pad') {
      return `Learning: ${target.value.padId}`
    }
    return `Learning: ${target.value.action}`
  })

  const clear = () => {
    target.value = null
    status.value = null
  }

  const midiListen = (cb: (message: MidiMessage) => void) => {
    return midi.listen ? midi.listen(cb) : () => undefined
  }

  const disable = () => {
    isLearning.value = false
    if (unsubscribe) {
      unsubscribe()
      unsubscribe = null
    }
    clear()
  }

  const enable = () => {
    if (isLearning.value) return
    isLearning.value = true
    unsubscribe = midiListen(handleMessage)
  }

  const setTarget = (next: LearnTarget | null) => {
    target.value = next
    status.value = null
  }

  const setTransportMapping = (
    action: 'play' | 'stop' | 'bpmUp' | 'bpmDown',
    note: number
  ) => {
    midi.mapping.value.transportMap = midi.mapping.value.transportMap ?? {}
    midi.mapping.value.transportMap[action] = note
    persistMapping(midi.mapping.value)
  }

  const handlePadMapping = (note: number, padId: DrumPadId) => {
    if (midi.mapping.value.noteMapInverse?.[padId] !== undefined) {
      const prevNote = midi.mapping.value.noteMapInverse?.[padId]
      if (typeof prevNote === 'number') {
        delete midi.mapping.value.noteMap[prevNote]
      }
    }
    midi.mapping.value.noteMapInverse = midi.mapping.value.noteMapInverse ?? {}
    midi.mapping.value.noteMapInverse[padId] = note
    midi.mapping.value.noteMap[note] = padId
    midi.setPadForNote(note, padId)
    persistMapping(midi.mapping.value)
  }

  const handleMessage = (message: MidiMessage): boolean => {
    if (!isLearning.value || !target.value) return false
    if (message.type !== 'noteon' || typeof message.note !== 'number') {
      return false
    }

    if (target.value.type === 'pad') {
      handlePadMapping(message.note, target.value.padId)
      status.value = `Mapped ${target.value.padId} to note ${message.note}`
    } else {
      setTransportMapping(target.value.action, message.note)
      status.value = `Mapped ${target.value.action} to note ${message.note}`
    }

    clear()
    return true
  }

  onBeforeUnmount(() => {
    disable()
  })

  return {
    isLearning,
    target,
    status,
    learningLabel,
    enable,
    disable,
    setTarget,
    handleMessage,
    loadMapping,
    persistMapping
  }
}



=========================================
File: composables/usePatternStorage.client.ts
=========================================

import { ref } from 'vue'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import type { Pattern, Scene } from '@/types/drums'

const STORAGE_KEY = 'drum-machine/patterns'
const STORAGE_VERSION = 'v2'

interface StoredPatternsV1 {
  version: typeof STORAGE_VERSION
  savedAt: number
  patterns: Pattern[]
}

interface StoredPatternsV2 {
  version: typeof STORAGE_VERSION
  savedAt: number
  patterns: Pattern[]
  scenes: Scene[]
  selectedPatternId: string
  activeSceneId: string | null
}

type StoredPayload = StoredPatternsV1 | StoredPatternsV2

interface StoredState {
  patterns: Pattern[]
  scenes: Scene[]
  selectedPatternId: string
  activeSceneId: string | null
}

const ensurePatternShape = (pattern: Pattern | Partial<Pattern>, index: number): Pattern => {
  return {
    id: pattern?.id ?? `pattern-${index + 1}`,
    name: pattern?.name ?? `Pattern ${index + 1}`,
    gridSpec: normalizeGridSpec(pattern?.gridSpec ?? DEFAULT_GRID_SPEC),
    steps: pattern?.steps ?? {}
  }
}

export function usePatternStorage() {
  const lastSavedAt = ref<number | null>(null)

  const save = (payload: StoredState) => {
    if (typeof window === 'undefined') return
    const normalizedPatterns = payload.patterns.map((pattern, index) => ensurePatternShape(pattern, index))
    const stored: StoredPatternsV2 = {
      version: STORAGE_VERSION,
      savedAt: Date.now(),
      patterns: normalizedPatterns,
      scenes: payload.scenes ?? [],
      selectedPatternId: payload.selectedPatternId,
      activeSceneId: payload.activeSceneId ?? null
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(stored))
    lastSavedAt.value = stored.savedAt
  }

  const load = (): StoredState => {
    if (typeof window === 'undefined') {
      return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null }
    }
    const raw = localStorage.getItem(STORAGE_KEY)
    if (!raw) {
      return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null }
    }
    try {
      const parsed = JSON.parse(raw) as Partial<StoredPayload>
      const version = parsed.version
      const basePatterns = Array.isArray(parsed.patterns)
        ? parsed.patterns.map((pattern, index) => ensurePatternShape(pattern, index))
        : []
      const baseState: StoredState = {
        patterns: basePatterns,
        scenes: [],
        selectedPatternId: basePatterns[0]?.id ?? 'pattern-1',
        activeSceneId: null
      }
      if (version === 'v2') {
        const parsedV2 = parsed as Partial<StoredPatternsV2>
        if (typeof parsedV2.savedAt === 'number') {
          lastSavedAt.value = parsedV2.savedAt
        }
        return {
          patterns: basePatterns,
          scenes: Array.isArray(parsedV2.scenes) ? parsedV2.scenes : [],
          selectedPatternId: parsedV2.selectedPatternId ?? baseState.selectedPatternId,
          activeSceneId: parsedV2.activeSceneId ?? null
        }
      }
      if (typeof (parsed as Partial<StoredPatternsV1>).savedAt === 'number') {
        lastSavedAt.value = (parsed as Partial<StoredPatternsV1>).savedAt ?? null
      }
      return baseState
    } catch (error) {
      console.error('Failed to parse patterns from LocalStorage', error)
      return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null }
    }
  }

  const clear = () => {
    if (typeof window === 'undefined') return
    localStorage.removeItem(STORAGE_KEY)
  }

  return {
    save,
    load,
    clear,
    lastSavedAt
  }
}



=========================================
File: composables/useQuickBrowse.ts
=========================================

import { ref } from 'vue'
import type { BrowserMode } from '../types/library'
import type { BrowserFilters } from '../stores/browser'

export interface BrowseHistoryEntry {
  timestamp: number
  mode: BrowserMode
  query: string
  filters: BrowserFilters
  selectedId: string | null
  contextType: 'sample' | 'preset' | 'group' | 'sound'
  contextId: string
}

const maxHistory = 50
const storageKey = 'drumcomputer_quick_browse_v1'

const hasClientStorage = (): boolean => {
  if (typeof window === 'undefined' || typeof localStorage === 'undefined') return false
  if (typeof import.meta !== 'undefined' && 'client' in import.meta && !import.meta.client) return false
  return true
}

const readStorage = (): BrowseHistoryEntry[] => {
  if (!hasClientStorage()) return []
  try {
    const raw = localStorage.getItem(storageKey)
    if (!raw) return []
    const parsed = JSON.parse(raw)
    if (!Array.isArray(parsed)) return []
    return parsed
      .filter((entry) => entry && typeof entry.contextId === 'string' && typeof entry.timestamp === 'number')
      .map((entry) => ({
        timestamp: Number(entry.timestamp),
        mode: entry.mode as BrowserMode,
        query: String(entry.query ?? ''),
        filters: (entry.filters ?? {}) as BrowserFilters,
        selectedId: entry.selectedId ?? null,
        contextType: entry.contextType as BrowseHistoryEntry['contextType'],
        contextId: String(entry.contextId)
      }))
  } catch {
    return []
  }
}

const writeStorage = (entries: BrowseHistoryEntry[]) => {
  if (!hasClientStorage()) return
  try {
    localStorage.setItem(storageKey, JSON.stringify(entries))
  } catch {
    // ignore storage errors
  }
}

const sortHistory = (entries: BrowseHistoryEntry[]) => [...entries].sort((a, b) => b.timestamp - a.timestamp)

export function useQuickBrowse() {
  const history = ref<BrowseHistoryEntry[]>(sortHistory(readStorage()))

  function recordBrowse(entry: Omit<BrowseHistoryEntry, 'timestamp'>): void {
    if (!hasClientStorage()) return
    const timestamp = Date.now()
    const withoutContext = history.value.filter((item) => item.contextId !== entry.contextId)
    const next = sortHistory([{ ...entry, timestamp }, ...withoutContext]).slice(0, maxHistory)
    history.value = next
    writeStorage(next)
  }

  function getLastBrowse(contextId: string): BrowseHistoryEntry | null {
    return history.value.find((entry) => entry.contextId === contextId) ?? null
  }

  function restoreBrowse(entry: BrowseHistoryEntry): void {
    void import('../stores/browser').then(async ({ useBrowserStore }) => {
      const browser = useBrowserStore()
      await browser.setMode(entry.mode)
      browser.filters = { ...entry.filters }
      browser.library.query = entry.query
      await browser.search()
      if (entry.selectedId) {
        await browser.selectResult(entry.selectedId)
      }
    })
  }

  function clearHistory(): void {
    history.value = []
    writeStorage([])
  }

  return { history, recordBrowse, getLastBrowse, restoreBrowse, clearHistory }
}



=========================================
File: composables/useRecentFiles.ts
=========================================

export interface RecentFileEntry {
  id: string
  path: string
  name: string
  timestamp: number
  type: 'sample' | 'kit' | 'pattern' | 'preset'
}

const maxRecent = 50
const storageKey = 'drumcomputer_recent_files_v1'

const hasClientStorage = (): boolean => {
  if (typeof window === 'undefined' || typeof localStorage === 'undefined') return false
  if (typeof import.meta !== 'undefined' && 'client' in import.meta && !import.meta.client) return false
  return true
}

const readStorage = (): RecentFileEntry[] => {
  if (!hasClientStorage()) return []
  try {
    const raw = localStorage.getItem(storageKey)
    if (!raw) return []
    const parsed = JSON.parse(raw)
    if (!Array.isArray(parsed)) return []
    return parsed
      .filter((entry) => entry && typeof entry.id === 'string' && typeof entry.timestamp === 'number')
      .map((entry) => ({
        id: String(entry.id),
        path: String(entry.path ?? ''),
        name: String(entry.name ?? ''),
        timestamp: Number(entry.timestamp),
        type: entry.type ?? 'sample'
      }))
  } catch {
    return []
  }
}

const writeStorage = (entries: RecentFileEntry[]): void => {
  if (!hasClientStorage()) return
  try {
    localStorage.setItem(storageKey, JSON.stringify(entries))
  } catch {
    // ignore storage errors (quota etc.)
  }
}

const sortByTimestamp = (entries: RecentFileEntry[]): RecentFileEntry[] =>
  [...entries].sort((a, b) => b.timestamp - a.timestamp)

export function useRecentFiles() {
  function addRecent(entry: Omit<RecentFileEntry, 'timestamp'>): void {
    if (!hasClientStorage()) return
    const timestamp = Date.now()
    const existing = readStorage().filter((item) => item.id !== entry.id)
    const next = sortByTimestamp([{ ...entry, timestamp }, ...existing]).slice(0, maxRecent)
    writeStorage(next)
  }

  function getRecent(limit?: number): RecentFileEntry[] {
    const entries = sortByTimestamp(readStorage())
    if (limit && limit > 0) return entries.slice(0, limit)
    return entries
  }

  function clearRecent(): void {
    if (!hasClientStorage()) return
    writeStorage([])
  }

  function removeRecent(id: string): void {
    if (!hasClientStorage()) return
    const next = readStorage().filter((entry) => entry.id !== id)
    writeStorage(next)
  }

  return { addRecent, getRecent, clearRecent, removeRecent }
}



=========================================
File: composables/useSamplePreview.client.ts
=========================================

import { inject, onBeforeUnmount, reactive } from 'vue'
import { getFileSystemRepository } from '../services/fileSystemRepository'

export interface PreviewState {
  isPlaying: boolean
  currentFile: string | null
  progress: number
  duration: number
}

const clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(max, value))

const readBlobArrayBuffer = async (blob: Blob): Promise<ArrayBuffer> => {
  if (typeof blob.arrayBuffer === 'function') {
    return blob.arrayBuffer()
  }
  return new Promise<ArrayBuffer>((resolve, reject) => {
    const reader = new FileReader()
    reader.onload = () => resolve(reader.result as ArrayBuffer)
    reader.onerror = () => reject(reader.error ?? new Error('Failed to read blob'))
    reader.readAsArrayBuffer(blob)
  })
}

export function useSamplePreview() {
  const audioContext = inject<AudioContext | null>('audioContext', null)
  const state = reactive<PreviewState>({
    isPlaying: false,
    currentFile: null,
    progress: 0,
    duration: 0
  })

  let sourceNode: AudioBufferSourceNode | null = null
  let buffer: AudioBuffer | null = null
  let startTime = 0
  let pausedAt = 0
  let rafId = 0

  const cancelProgress = () => {
    if (rafId) {
      cancelAnimationFrame(rafId)
      rafId = 0
    }
  }

  const updateProgress = () => {
    if (!audioContext || !buffer || !state.isPlaying) return
    const elapsed = audioContext.currentTime - startTime
    const duration = buffer.duration || 0
    state.progress = duration > 0 ? clamp(elapsed / duration, 0, 1) : 0
    if (state.progress >= 1) {
      stop()
      return
    }
    rafId = requestAnimationFrame(updateProgress)
  }

  const detachSource = () => {
    if (sourceNode) {
      sourceNode.onended = null
      try {
        sourceNode.stop()
      } catch {
        // ignore
      }
      try {
        sourceNode.disconnect()
      } catch {
        // ignore
      }
      sourceNode = null
    }
  }

  const createSource = () => {
    if (!audioContext || !buffer) return
    const node = audioContext.createBufferSource()
    node.buffer = buffer
    node.connect(audioContext.destination)
    node.onended = () => {
      if (state.isPlaying) {
        stop()
      }
    }
    sourceNode = node
  }

  async function loadAndPlay(path: string, blob?: Blob): Promise<void> {
    if (!audioContext) return
    stop()
    const repo = getFileSystemRepository()
    const fileBlob = blob ?? (await repo.readFileBlob?.(path))
    if (!fileBlob) return
    const arrayBuffer = await readBlobArrayBuffer(fileBlob)
    buffer = await audioContext.decodeAudioData(arrayBuffer.slice(0))
    state.duration = buffer?.duration ?? 0
    state.currentFile = path
    state.progress = 0
    pausedAt = 0
    if (audioContext.state === 'suspended') {
      await audioContext.resume()
    }
    createSource()
    if (!sourceNode) return
    startTime = audioContext.currentTime
    sourceNode.start(0)
    state.isPlaying = true
    cancelProgress()
    rafId = requestAnimationFrame(updateProgress)
  }

  function stop(): void {
    cancelProgress()
    detachSource()
    state.isPlaying = false
    state.progress = 0
    state.duration = buffer?.duration ?? 0
    pausedAt = 0
  }

  function pause(): void {
    if (!audioContext || !state.isPlaying) return
    pausedAt = audioContext.currentTime - startTime
    state.isPlaying = false
    cancelProgress()
    detachSource()
  }

  function resume(): void {
    if (!audioContext || !buffer || state.isPlaying) return
    const offset = clamp(pausedAt, 0, buffer.duration)
    createSource()
    if (!sourceNode) return
    startTime = audioContext.currentTime - offset
    sourceNode.start(0, offset)
    state.isPlaying = true
    cancelProgress()
    rafId = requestAnimationFrame(updateProgress)
  }

  function seek(position: number): void {
    if (!buffer) return
    const offset = clamp(position, 0, 1) * buffer.duration
    pausedAt = offset
    state.progress = buffer.duration > 0 ? clamp(offset / buffer.duration, 0, 1) : 0
    if (state.isPlaying) {
      detachSource()
      createSource()
      if (!sourceNode || !audioContext) return
      startTime = audioContext.currentTime - offset
      sourceNode.start(0, offset)
    }
  }

  onBeforeUnmount(() => {
    stop()
  })

  return { state, loadAndPlay, stop, pause, resume, seek }
}



=========================================
File: composables/useScheduler.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'

export interface SchedulerConfig {
  lookahead: number
  scheduleAheadSec: number
  getTime: () => number
}

export interface ScheduledTask {
  when: number
  callback: () => void
}

export function useScheduler(config: SchedulerConfig) {
  const tasks = ref<ScheduledTask[]>([])
  const intervalId = ref<number | null>(null)
  let wasRunningOnHide = false

  const tick = () => {
    const now = config.getTime()
    const windowLimit = now + config.scheduleAheadSec
    const ready = tasks.value.filter((task) => task.when <= windowLimit)
    tasks.value = tasks.value.filter((task) => task.when > windowLimit)
    ready.forEach((task) => task.callback())
  }

  const start = () => {
    if (intervalId.value !== null) return
    intervalId.value = window.setInterval(tick, config.lookahead)
  }

  const stop = () => {
    if (intervalId.value !== null) {
      clearInterval(intervalId.value)
      intervalId.value = null
    }
  }

  const schedule = (task: ScheduledTask) => {
    tasks.value.push(task)
  }

  const clear = () => {
    tasks.value = []
  }

  if (typeof window !== 'undefined') {
    const handlePageHide = () => {
      if (intervalId.value !== null) {
        wasRunningOnHide = true
        stop()
      } else {
        wasRunningOnHide = false
      }
    }

    const handlePageShow = () => {
      if (wasRunningOnHide) {
        start()
        tick()
      }
    }

    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)

    onBeforeUnmount(() => {
      stop()
      window.removeEventListener('pagehide', handlePageHide)
      window.removeEventListener('pageshow', handlePageShow)
    })
  } else {
    onBeforeUnmount(stop)
  }

  return {
    start,
    stop,
    clear,
    tick,
    schedule
  }
}



=========================================
File: composables/useSequencer.ts
=========================================

import { ref, type Ref } from 'vue'
import { quantizeToStep } from '@/domain/quantize'
import { normalizeGridSpec, secondsPerStep } from '@/domain/timing'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { GridSpec, StepAddress } from '@/types/time'
import { useTransportStore } from '@/stores/transport'
import { useScheduler, type ScheduledTask } from './useScheduler'
import { useAudioEngine } from './useAudioEngine.client'
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock, type RenderClock } from '@/domain/clock/renderClock'

interface SequencerOptions {
  getPattern: () => Pattern
  lookahead?: number
  scheduleAheadSec?: number
  onPatternBoundary?: () => Pattern | void
}

interface SchedulerLike {
  schedule: (task: ScheduledTask) => void
}

export interface ScheduledStep {
  when: number
  stepAddress: StepAddress
}

const totalStepsForGrid = (gridSpec: GridSpec) => gridSpec.bars * gridSpec.division

export interface ScheduleStepOptions {
  clock: RenderClock
  scheduler: SchedulerLike
  audio: ReturnType<typeof useAudioEngine>
  transport: ReturnType<typeof useTransportStore>
  getPattern: () => Pattern
  currentStep: Ref<number>
  pendingSteps: Ref<ScheduledStep[]>
  onPatternBoundary?: () => Pattern | void
}

export function scheduleStep(options: ScheduleStepOptions, when: number) {
  const pattern = options.getPattern()
  const totalSteps = totalStepsForGrid(pattern.gridSpec)
  const loopStart = Math.min(
    Math.max(0, options.transport.loopStart),
    Math.max(0, totalSteps - 1)
  )
  const loopEnd = Math.min(
    Math.max(loopStart + 1, options.transport.loopEnd),
    totalSteps
  )
  const loopLength = Math.max(1, loopEnd - loopStart)
  const stepIndex =
    loopStart +
    (((options.currentStep.value - loopStart) % loopLength) + loopLength) %
      loopLength
  const barIndex = Math.floor(stepIndex / pattern.gridSpec.division)
  const stepInBar = stepIndex % pattern.gridSpec.division
  const scheduledWhen = Math.max(when, options.clock.now())
  options.pendingSteps.value.push({ when: scheduledWhen, stepAddress: { barIndex, stepInBar } })

  options.scheduler.schedule({
    when: scheduledWhen,
    callback: () => {
      const bar = pattern.steps[barIndex]
      const stepRow = bar?.[stepInBar]
      if (stepRow) {
        Object.entries(stepRow).forEach(([padId, cell]) => {
          options.audio.trigger({
            padId: padId as DrumPadId,
            when: scheduledWhen,
            velocity: cell?.velocity?.value ?? 1
          })
        })
      }

      const rawNext = options.currentStep.value + 1
      const nextStepInLoop =
        loopStart + (((rawNext - loopStart) % loopLength) + loopLength) % loopLength
      const isPatternBoundary = nextStepInLoop === 0

      if (options.transport.metronomeEnabled) {
        const isQuarter =
          pattern.gridSpec.division % 4 === 0
            ? stepInBar % (pattern.gridSpec.division / 4) === 0
            : stepInBar === 0
        if (isQuarter) {
          void options.audio.triggerClick(
            scheduledWhen,
            isPatternBoundary,
            options.transport.metronomeVolume
          )
        }
      }

      let nextPattern = pattern
      if (isPatternBoundary && options.onPatternBoundary) {
        const candidate = options.onPatternBoundary()
        if (candidate) {
          nextPattern = candidate
          options.transport.setGridSpec(nextPattern.gridSpec)
        } else {
          nextPattern = options.getPattern()
        }
      }

      options.currentStep.value = nextStepInLoop
      options.transport.setCurrentStep(options.currentStep.value)

      if (options.transport.loop) {
        const stepDuration = secondsPerStep(options.transport.bpm, nextPattern.gridSpec.division)
        scheduleStep(options, scheduledWhen + stepDuration)
      }
    }
  })
}

export function useSequencer(options: SequencerOptions) {
  const transport = useTransportStore()
  const audio = useAudioEngine()
  let renderClock: RenderClock | null = null
  const scheduler = useScheduler({
    lookahead: options.lookahead ?? 25,
    scheduleAheadSec: options.scheduleAheadSec ?? 0.1,
    getTime: () => renderClock?.now() ?? 0
  })

  const currentStep = ref(0)
  const isRecording = ref(false)
  const pendingSteps = ref<ScheduledStep[]>([])
  let loopStartTime = 0

  const boundaryCallback = options.onPatternBoundary ?? (() => undefined)
  const buildStepOptions = (clock: RenderClock): ScheduleStepOptions => ({
    clock,
    scheduler,
    audio,
    transport,
    getPattern: options.getPattern,
    currentStep,
    pendingSteps,
    onPatternBoundary: boundaryCallback
  })

  const start = async () => {
    if (transport.isPlaying) return
    const ctx = await audio.resumeContext()
    renderClock = createRenderClock(ctx)
    const pattern = options.getPattern()
    const gridSpec = normalizeGridSpec(pattern.gridSpec)
    pattern.gridSpec = gridSpec
    transport.setGridSpec(gridSpec)
    loopStartTime = renderClock.now()
    currentStep.value = Math.max(0, transport.loopStart)
    pendingSteps.value = []
    transport.setCurrentStep(currentStep.value)
    transport.setPlaying(true)
    scheduler.clear()
    const stepOptions = buildStepOptions(renderClock)
    scheduleStep(stepOptions, loopStartTime)
    scheduler.start()
    scheduler.tick()
  }

  const stop = () => {
    transport.setPlaying(false)
    scheduler.stop()
    scheduler.clear()
    pendingSteps.value = []
    currentStep.value = Math.max(0, transport.loopStart)
    transport.setCurrentStep(currentStep.value)
    loopStartTime = 0
    renderClock = null
  }

  const toggleStep = (barIndex: number, stepInBar: number, padId: DrumPadId) => {
    const pattern = options.getPattern()
    const bar = pattern.steps[barIndex] ?? {}
    const stepRow = bar[stepInBar] ?? {}
    const updated = { ...stepRow }
    const nextVelocity = cycleVelocity(updated[padId]?.velocity?.value)
    if (nextVelocity === null) {
      delete updated[padId]
    } else {
      updated[padId] = { velocity: { value: clampVelocity(nextVelocity) } }
    }
    pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
  }

  const setStepVelocity = (barIndex: number, stepInBar: number, padId: DrumPadId, velocity: number) => {
    const pattern = options.getPattern()
    const bar = pattern.steps[barIndex] ?? {}
    const stepRow = bar[stepInBar] ?? {}
    const updated = { ...stepRow, [padId]: { velocity: { value: clampVelocity(velocity || DEFAULT_STEP_VELOCITY) } } }
    pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
  }

  const recordHit = async (padId: DrumPadId, velocity = 1, quantize = true) => {
    const pattern = options.getPattern()
    const ctx = await audio.resumeContext()
    const gridSpec = pattern.gridSpec
    const stepDuration = secondsPerStep(transport.bpm, gridSpec.division)
    const resolvedVelocity = clampVelocity(velocity)
    const anchor = transport.isPlaying ? loopStartTime : ctx.currentTime
    if (!transport.isPlaying) {
      loopStartTime = anchor
    }
    const sinceStart = ctx.currentTime - anchor
    const step = quantize
      ? quantizeToStep(sinceStart, stepDuration, gridSpec.bars, gridSpec.division)
      : {
          barIndex: Math.floor(currentStep.value / gridSpec.division),
          stepInBar: currentStep.value % gridSpec.division
        }
    setStepVelocity(step.barIndex, step.stepInBar, padId, resolvedVelocity)
    audio.trigger({ padId, when: ctx.currentTime, velocity: resolvedVelocity })
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    await audio.setSampleForPad(padId, sample)
  }

  const applySoundbank = async (bank: Soundbank) => {
    await audio.applySoundbank(bank)
  }

  const getAudioTime = () => renderClock?.now() ?? audio.ensureContext().currentTime

  return {
    currentStep,
    isRecording,
    pendingSteps,
    start,
    stop,
    toggleStep,
    setStepVelocity,
    recordHit,
    fxSettings: audio.fxSettings,
    setFx: audio.setFx,
    setSampleForPad,
    applySoundbank,
    getAudioTime
  }
}



=========================================
File: composables/useShortcuts.ts
=========================================

/**
 * Global keyboard shortcut registry and dispatcher.
 * Provides command-based shortcuts with tooltip integration.
 */

export interface ShortcutCommand {
  keys: string // e.g., "Ctrl+K", "Shift+Space", "1"
  handler: () => void | Promise<void>
  description: string // human-readable action name
}

interface ParsedKey {
  ctrl: boolean
  shift: boolean
  alt: boolean
  meta: boolean
  key: string
}

const registry = new Map<string, ShortcutCommand>()

/**
 * Parse key combo string into normalized form.
 * @example parseKeyCombo("Ctrl+K") â†’ { ctrl: true, shift: false, alt: false, meta: false, key: "k" }
 */
function parseKeyCombo(combo: string): ParsedKey {
  const parts = combo.split('+').map((s) => s.trim())
  const parsed: ParsedKey = {
    ctrl: false,
    shift: false,
    alt: false,
    meta: false,
    key: ''
  }

  for (const part of parts) {
    const lower = part.toLowerCase()
    if (lower === 'ctrl' || lower === 'control') {
      parsed.ctrl = true
    } else if (lower === 'shift') {
      parsed.shift = true
    } else if (lower === 'alt') {
      parsed.alt = true
    } else if (lower === 'meta' || lower === 'cmd') {
      parsed.meta = true
    } else {
      parsed.key = part.toLowerCase()
    }
  }

  return parsed
}

/**
 * Check if keyboard event matches parsed key combo.
 */
function matchesCombo(event: KeyboardEvent, combo: ParsedKey): boolean {
  const eventKey = event.key.toLowerCase()

  // Normalize Space key
  const normalizedKey = eventKey === ' ' ? 'space' : eventKey

  if (normalizedKey !== combo.key) return false
  if (event.ctrlKey !== combo.ctrl) return false
  if (event.shiftKey !== combo.shift) return false
  if (event.altKey !== combo.alt) return false
  if (event.metaKey !== combo.meta) return false

  return true
}

/**
 * Register a keyboard shortcut command.
 */
export function registerShortcut(commandId: string, command: ShortcutCommand): void {
  registry.set(commandId, command)
}

/**
 * Unregister a keyboard shortcut command.
 */
export function unregisterShortcut(commandId: string): void {
  registry.delete(commandId)
}

/**
 * Dispatch keyboard event to registered shortcuts.
 * Returns true if a command was executed.
 */
export function dispatchShortcut(event: KeyboardEvent): boolean {
  // Sort by key length descending (longest match wins)
  const commands = Array.from(registry.entries()).sort((a, b) => b[1].keys.length - a[1].keys.length)

  for (const [_id, command] of commands) {
    const parsed = parseKeyCombo(command.keys)
    if (matchesCombo(event, parsed)) {
      event.preventDefault()
      void command.handler()
      return true
    }
  }

  return false
}

/**
 * Get shortcut keys for a command ID.
 */
export function getShortcutKeys(commandId: string): string | null {
  return registry.get(commandId)?.keys ?? null
}

/**
 * Generate tooltip with shortcut hint.
 * @example shortcutTitle("TRANSPORT_PLAY", "Play") â†’ "Play (Space)"
 */
export function shortcutTitle(commandId: string, label: string): string {
  const keys = getShortcutKeys(commandId)
  return keys ? `${label} (${keys})` : label
}

/**
 * Get all registered commands (for debugging/settings UI).
 */
export function getAllCommands(): Array<{ id: string; command: ShortcutCommand }> {
  return Array.from(registry.entries()).map(([id, command]) => ({ id, command }))
}

/**
 * Clear all registered shortcuts (for testing).
 */
export function clearShortcuts(): void {
  registry.clear()
}

/**
 * Composable hook for shortcut management in components.
 */
export function useShortcuts() {
  return {
    register: registerShortcut,
    unregister: unregisterShortcut,
    dispatch: dispatchShortcut,
    getKeys: getShortcutKeys,
    title: shortcutTitle,
    getAll: getAllCommands,
    clear: clearShortcuts
  }
}



=========================================
File: composables/useSoundbankStorage.client.ts
=========================================

import { ref } from 'vue'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { Soundbank, SampleRef } from '@/types/audio'

const DB_NAME = 'drum-machine-db'
const DB_VERSION = 2

interface StoredSampleRecord {
  id: string
  name: string
  format?: string
  blob: Blob
}

interface StoredPatternRecord {
  id: string
  bankId: string
  pattern: Pattern
}

const stripNonSerializableSample = (sample?: SampleRef): SampleRef | undefined => {
  if (!sample) return undefined
  const sanitized: SampleRef = {
    id: sample.id,
    name: sample.name
  }
  if (sample.url !== undefined) {
    sanitized.url = sample.url
  }
  if (sample.format !== undefined) {
    sanitized.format = sample.format
  }
  return sanitized
}

const serializeSoundbank = (bank: Soundbank): Soundbank => {
  const pads: Partial<Record<DrumPadId, SampleRef>> = {}
  Object.entries(bank.pads).forEach(([padId, sample]) => {
    const sanitized = stripNonSerializableSample(sample)
    if (sanitized) {
      pads[padId as DrumPadId] = sanitized
    }
  })
  return {
    id: bank.id,
    name: bank.name,
    createdAt: bank.createdAt,
    updatedAt: bank.updatedAt,
    pads
  }
}

export function useSoundbankStorage() {
  const dbRef = ref<IDBDatabase | null>(null)

  const open = (): Promise<IDBDatabase> => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION)
      request.onupgradeneeded = () => {
        const db = request.result
        if (!db.objectStoreNames.contains('soundbanks')) {
          db.createObjectStore('soundbanks', { keyPath: 'id' })
        }
        if (!db.objectStoreNames.contains('samples')) {
          db.createObjectStore('samples', { keyPath: 'id' })
        }
        if (!db.objectStoreNames.contains('patterns')) {
          const store = db.createObjectStore('patterns', { keyPath: 'id' })
          store.createIndex('bankId', 'bankId', { unique: false })
        }
      }
      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        dbRef.value = request.result
        resolve(request.result)
      }
    })
  }

  const ensureDb = async () => {
    if (dbRef.value) return dbRef.value
    return open()
  }

  const saveBank = async (bank: Soundbank) => {
    const db = await ensureDb()
    return new Promise<void>((resolve, reject) => {
      const tx = db.transaction(['soundbanks'], 'readwrite')
      tx.objectStore('soundbanks').put(serializeSoundbank(bank))
      tx.oncomplete = () => resolve()
      tx.onerror = () => reject(tx.error)
    })
  }

  const saveSample = async (sample: SampleRef & { blob: Blob }) => {
    const db = await ensureDb()
    return new Promise<void>((resolve, reject) => {
      const tx = db.transaction(['samples'], 'readwrite')
      const record: StoredSampleRecord = { id: sample.id, name: sample.name, blob: sample.blob }
      if (sample.format) {
        record.format = sample.format
      }
      tx.objectStore('samples').put(record)
      tx.oncomplete = () => resolve()
      tx.onerror = () => reject(tx.error)
    })
  }

  const loadBanks = async (): Promise<Soundbank[]> => {
    const db = await ensureDb()
    return new Promise((resolve, reject) => {
      const tx = db.transaction(['soundbanks'], 'readonly')
      const request = tx.objectStore('soundbanks').getAll()
      request.onsuccess = () => resolve((request.result as Soundbank[]) ?? [])
      request.onerror = () => reject(request.error)
    })
  }

  const loadSample = async (sampleId: string): Promise<SampleRef | null> => {
    const db = await ensureDb()
    return new Promise((resolve, reject) => {
      const tx = db.transaction(['samples'], 'readonly')
      const request = tx.objectStore('samples').get(sampleId)
      request.onsuccess = () => {
        const result = request.result as StoredSampleRecord | undefined
        if (!result) {
          resolve(null)
          return
        }
        const restored: SampleRef = { id: result.id, name: result.name, blob: result.blob }
        const format = result.format as SampleRef['format'] | undefined
        if (format) {
          restored.format = format
        }
        resolve(restored)
      }
      request.onerror = () => reject(request.error)
    })
  }

  const savePatterns = async (bankId: string, patterns: Pattern[]) => {
    const db = await ensureDb()
    return new Promise<void>((resolve, reject) => {
      const tx = db.transaction(['patterns'], 'readwrite')
      patterns.forEach((pattern) => {
        const record: StoredPatternRecord = { id: `${bankId}:${pattern.id}`, bankId, pattern }
        tx.objectStore('patterns').put(record)
      })
      tx.oncomplete = () => resolve()
      tx.onerror = () => reject(tx.error)
    })
  }

  const loadPatterns = async (bankId: string): Promise<Pattern[]> => {
    const db = await ensureDb()
    return new Promise((resolve, reject) => {
      const tx = db.transaction(['patterns'], 'readonly')
      const index = tx.objectStore('patterns').index('bankId')
      const request = index.getAll(bankId)
      request.onsuccess = () => {
        const records = (request.result as StoredPatternRecord[] | undefined) ?? []
        resolve(records.map((record) => record.pattern))
      }
      request.onerror = () => reject(request.error)
    })
  }

  return {
    saveBank,
    saveSample,
    loadBanks,
    loadSample,
    savePatterns,
    loadPatterns
  }
}



=========================================
File: composables/useSync.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import { useScheduler } from './useScheduler'
import type { ClockAuthority, SyncMode, SyncRole, SyncState } from '@/types/sync'
import type { MidiMessage } from '@/types/midi'

interface SyncDeps {
  midi?: {
    listen: (cb: (message: MidiMessage) => void) => () => void
    sendClockTick: () => void
    sendStart: () => void
    sendStop: () => void
    selectedOutputId: { value: string | null }
  }
  getAudioTime?: () => number
  onExternalStart?: () => void
  onExternalStop?: () => void
}

const MIDI_CLOCKS_PER_QUARTER = 24
const CLOCK_AUTHORITY: ClockAuthority = 'audioContext'

export function useSync(initialMode: SyncMode = 'internal', deps?: SyncDeps) {
  // Coordinates transport sync between audio clock and MIDI clock roles (master/slave), handling clock ticks and start/stop events.
  const state = ref<SyncState>({
    bpm: 120,
    phase: 0,
    isPlaying: false,
    mode: initialMode,
    role: 'master',
    linkAvailable: false,
    clockAuthority: CLOCK_AUTHORITY,
    bpmSource: 'transport'
  })
  const scheduler = deps?.getAudioTime
    ? useScheduler({
      lookahead: 25,
      scheduleAheadSec: 0.05,
      getTime: deps.getAudioTime
    })
    : null
  const lastStableBpm = ref(state.value.bpm)
  let nextClockAt: number | null = null
  let midiUnsubscribe: (() => void) | null = null

  const secondsPerClockTick = () => 60 / (state.value.bpm * MIDI_CLOCKS_PER_QUARTER)

  const resetPhase = () => {
    state.value.phase = 0
  }

  const stopClock = () => {
    scheduler?.stop()
    scheduler?.clear()
    nextClockAt = null
    deps?.midi?.sendStop()
  }

  const tick = () => {
    state.value.phase = (state.value.phase + 1) % MIDI_CLOCKS_PER_QUARTER
  }

  const scheduleClockTick = () => {
    if (!scheduler || nextClockAt === null) return
    scheduler.schedule({
      when: nextClockAt,
      callback: () => {
        deps?.midi?.sendClockTick()
        tick()
        if (nextClockAt !== null) {
          nextClockAt = nextClockAt + secondsPerClockTick()
          scheduleClockTick()
        }
      }
    })
  }

  const startClock = () => {
    stopClock()
    if (state.value.mode !== 'midiClock' || state.value.role !== 'master') return
    if (!deps?.midi?.selectedOutputId.value) return
    if (!deps?.getAudioTime || !scheduler) return
    const now = deps.getAudioTime()
    nextClockAt = now + secondsPerClockTick()
    deps.midi.sendStart()
    scheduleClockTick()
    scheduler.start()
    scheduler.tick()
  }

  const setMode = (mode: SyncMode) => {
    state.value.mode = mode
    state.value.bpm = lastStableBpm.value
    stopClock()
    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
      startClock()
    }
  }

  const setRole = (role: SyncRole) => {
    state.value.role = role
    state.value.bpm = lastStableBpm.value
    stopClock()
    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
      startClock()
    }
  }

  const setPlaying = (isPlaying: boolean) => {
    state.value.isPlaying = isPlaying
    if (isPlaying) {
      startClock()
    } else {
      stopClock()
    }
  }

  const setBpm = (bpm: number) => {
    state.value.bpm = Math.max(20, Math.min(300, bpm))
    lastStableBpm.value = state.value.bpm
    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
      startClock()
    }
  }

  const handleMidiMessage = (message: MidiMessage) => {
    if (state.value.mode !== 'midiClock' || state.value.role !== 'slave') return
    if (message.type === 'start') {
      state.value.isPlaying = true
      resetPhase()
      deps?.onExternalStart?.()
    } else if (message.type === 'stop') {
      state.value.isPlaying = false
      resetPhase()
      deps?.onExternalStop?.()
    } else if (message.type === 'clock') {
      tick()
    }
  }

  const startTransport = (bpm: number) => {
    setBpm(bpm)
    setPlaying(true)
  }

  const stopTransport = () => {
    setPlaying(false)
  }

  if (deps?.midi) {
    midiUnsubscribe = deps.midi.listen(handleMidiMessage)
  }

  onBeforeUnmount(() => {
    stopClock()
    midiUnsubscribe?.()
  })

  return {
    state,
    setMode,
    setRole,
    setPlaying,
    setBpm,
    startTransport,
    stopTransport
  }
}



=========================================
File: config/pwa.ts
=========================================

export const pwaConfig = {
  registerType: 'autoUpdate',
  manifest: {
    name: 'Drumcomputer',
    short_name: 'Drumcomputer',
    theme_color: '#121212',
    background_color: '#121212',
    display: 'standalone'
  },
  workbox: {
    globPatterns: ['**/*.{js,css,html,png,svg,ico}']
  }
}



=========================================
File: control-review.md
=========================================

# Control-Bereich Review: Offene Punkte und Empfehlungen

## Ãœbersicht
Der Control-Bereich der MASCHINE MK3 bietet Zugriff auf alle Parameter des gewÃ¤hlten Modus und enthÃ¤lt fest zugeordnete Buttons fÃ¼r Browser, Arranger, Mixer, Sample-Editor, File, Settings, Auto, Macro sowie dynamische Softbuttons und Drehregler. Die Hardware-Logik und UI-Struktur sind in der Codebasis teilweise abgebildet, jedoch fehlen noch einige zentrale Funktionen und UI-Elemente.

---

## Fehlende Implementierungen & offene Punkte

### 1. Modus- und Control-Buttons
- **CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, FILE, SETTINGS, AUTO, MACRO:**
  - Es fehlen dedizierte Komponenten/Buttons fÃ¼r diese Funktionen im Control-Bereich.
  - SHIFT-Funktionen (z.B. SHIFT+CHANNEL fÃ¼r MIDI, SHIFT+PLUG-IN fÃ¼r Instance) sind nicht als UI-Elemente oder Logik abgebildet.
  - Die Zuordnung und das visuelle Layout dieser Buttons gemÃ¤ÃŸ Hardware-Referenz sind nicht vollstÃ¤ndig umgesetzt.

### 2. Softbuttons & Displays
- **Softbuttons 1-8 Ã¼ber den Displays:**
  - Die dynamische Anpassung der Softbutton-Funktionen je nach Modus ist nicht vollstÃ¤ndig implementiert.
  - Die Anzeige der jeweiligen Aktion unter jedem Button im Display fehlt.
  - Die Verbindung zwischen Softbuttons und den Displays (z.B. Anzeige der Parameter, dynamische Labels) ist nicht klar dokumentiert und technisch nicht vollstÃ¤ndig umgesetzt.

### 3. Drehregler
- **Drehregler 1-8:**
  - Die Steuerung der im Display angezeigten Parameter Ã¼ber die Drehregler ist nicht als UI/Logik vorhanden.
  - Die Verbindung zwischen Regler und Parameter (z.B. Mapping, Value-Feedback) fehlt.

### 4. Page-Buttons
- **Page-Buttons:**
  - Die Funktion zum Wechseln von Parameter-Pages ist nicht als UI-Element oder Logik abgebildet.
  - Die Anzeige und Navigation zwischen Pages fehlt.

### 5. File- und Settings-Buttons
- **FILE, SETTINGS:**
  - Schnellzugriff auf Dateioperationen und Einstellungen (Metronom, Count-in) ist nicht als Button oder Panel vorhanden.
  - SHIFT-Funktionen (z.B. Save) fehlen.

### 6. Auto- und Macro-Buttons
- **AUTO, MACRO:**
  - Modulations- und Macro-Funktionen sind nicht als UI-Elemente oder Logik abgebildet.
  - SHIFT-Funktionen (z.B. Festsetzen, Macro-Set) fehlen.

### 7. Sampling-Button
- **SAMPLING:**
  - Der direkte Zugriff auf den Sample-Editor ist nicht als Button oder Panel vorhanden.

### 8. Browser-Button
- **BROWSER:**
  - Der Browser-Zugriff ist nicht als Button oder Panel implementiert.
  - SHIFT-Funktion fÃ¼r Plug-in-MenÃ¼ fehlt.

### 9. Arranger- und Mixer-Button
- **ARRANGER, MIXER:**
  - Zugriff auf Arranger- und Mixer-Views ist nicht als Button oder Panel vorhanden.

### 10. Accessibility & Dokumentation
- **ARIA, Tabindex, Fokussteuerung:**
  - FÃ¼r die neuen Control-Buttons und Panels mÃ¼ssen Accessibility-Attribute ergÃ¤nzt werden.
- **Dokumentation:**
  - Die Zuordnung und Logik der Control-Buttons, Softbuttons und Drehregler muss in README.md und als Diagramm dokumentiert werden.

---

## Empfehlungen zur Fertigstellung der Control-Sektion
1. **Komponenten fÃ¼r alle Control-Buttons und deren SHIFT-Funktionen erstellen** (CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, FILE, SETTINGS, AUTO, MACRO).
2. **Softbutton-Logik dynamisch an Modus koppeln** und Anzeige der jeweiligen Aktion im Display ergÃ¤nzen.
3. **Drehregler-UI und Parameter-Mapping implementieren** (inkl. Value-Feedback im Display).
4. **Page-Button-Komponente und Page-Navigation ergÃ¤nzen**.
5. **Panels fÃ¼r File, Settings, Sampling, Browser, Arranger, Mixer erstellen** und Buttons verknÃ¼pfen.
6. **Accessibility fÃ¼r alle neuen UI-Elemente sicherstellen**.
7. **README.md und Diagramm im diagrams-Ordner aktualisieren**: Hardware-Referenz, UI-Logik, Button-Zuordnung, Regler-Mapping.

---

## Schnellreferenz: MASCHINE MK3 Control-Bereich
- **Buttons:** CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, FILE, SETTINGS, AUTO, MACRO, Softbuttons 1-8
- **Displays:** Anzeige von Parametern, dynamischen Labels, Value-Feedback
- **Drehregler:** Steuerung der Parameter im Display
- **Page-Buttons:** Navigation zwischen Parameter-Pages

---

**Fazit:**
Die Control-Sektion ist in der Codebasis noch nicht vollstÃ¤ndig umgesetzt. Es fehlen zentrale UI-Komponenten, Logik fÃ¼r dynamische Softbuttons, Regler-Mapping, Page-Navigation und Panels fÃ¼r die wichtigsten Control-Funktionen. Die Hardware-Referenz und UI-Logik mÃ¼ssen in README.md und als Diagramm dokumentiert werden.

---

**Siehe MASCHINE MK3 Benutzerhandbuch S. 51â€“53 fÃ¼r vollstÃ¤ndige Hardware-Referenz.**


Project Code Export
Date: Mon Jan 05 2026 22:32:12 GMT+0100 (MitteleuropÃ¤ische Normalzeit)
Exported Folder: Drumcomputer

Project Structure:
ğŸ“ Drumcomputer/
  ğŸ“„ .DS_Store
  ğŸ“„ .eslintignore
  ğŸ“„ .eslintrc.cjs
  ğŸ“ .git/ (14 items)
    ğŸ“„ ...
  ğŸ“ .github/
    ğŸ“„ copilot-instructions.md
  ğŸ“„ .gitignore
  ğŸ“„ .gitignore 2
  ğŸ“„ .mocharc.json
  ğŸ“ .nuxt/ (20 items)
    ğŸ“„ ...
  ğŸ“ .output/
    ğŸ“„ nitro.json
    ğŸ“ public/
      ğŸ“„ .DS_Store
      ğŸ“„ 200.html
      ğŸ“„ 404.html
      ğŸ“ _nuxt/
        ğŸ“„ 8lhYhilz.js
        ğŸ“„ BcY0Gv0j.js
        ğŸ“„ COoUNM8i.js
        ğŸ“„ DIH0URZr.js
        ğŸ“ builds/
          ğŸ“„ latest.json
          ğŸ“ meta/
            ğŸ“„ 629ec0ae-23ae-4fb0-8373-e872df67a147.json
        ğŸ“„ cGd0K_ah.js
        ğŸ“„ default.BPHV4dOG.css
        ğŸ“„ entry.CYGvhC7V.css
        ğŸ“„ error-404.2GhCpCfF.css
        ğŸ“„ error-500.DqdIhFrl.css
        ğŸ“„ index.CPPe_DuI.css
        ğŸ“„ ukUhDa61.js
      ğŸ“„ index.html
      ğŸ“ samples/
        ğŸ“„ clap.wav
        ğŸ“„ hihat.wav
        ğŸ“„ kick.wav
        ğŸ“„ snare.wav
  ğŸ“ .vscode/ (1 items)
    ğŸ“„ ...
  ğŸ“„ Components.md
  ğŸ“„ Composables.md
  ğŸ“„ Domain.md
  ğŸ“ Flashpost-tests/
    ğŸ“„ flashpost.db
    ğŸ“„ flashpostCollections.db
    ğŸ“„ flashpostCookies.db
    ğŸ“„ flashpostHistory.db
    ğŸ“„ flashpostUserPreference.db
    ğŸ“„ flashpostVariable.db
  ğŸ“„ LICENSE
  ğŸ“„ README 2.md
  ğŸ“„ README.md
  ğŸ“„ ROADMAP.md
  ğŸ“„ StepCell.md
  ğŸ“„ StepGrid.md
  ğŸ“„ alleDateien.md
  ğŸ“„ app.vue
  ğŸ“ assets/ (2 items)
    ğŸ“„ ...
  ğŸ“ audio/
    ğŸ“ engine/
      ğŸ“ play/
        ğŸ“„ playStep.ts
      ğŸ“„ stepResolver.ts
      ğŸ“„ transportAudioHooks.ts
    ğŸ“„ fxGraph.ts
  ğŸ“ components/
    ğŸ“„ .DS_Store
    ğŸ“„ DrumMachine.vue
    ğŸ“„ FxPopup.vue
    ğŸ“„ MidiPanel.vue
    ğŸ“„ PadCell.vue
    ğŸ“„ PadGrid 2.vue
    ğŸ“„ PadGrid.vue
    ğŸ“„ PlayheadOverlay.vue
    ğŸ“„ SampleBrowser.vue
    ğŸ“„ SoundbankManager.vue
    ğŸ“„ StepCell.vue
    ğŸ“„ StepGrid 2.vue
    ğŸ“„ StepGrid.vue
    ğŸ“„ SyncPanel.vue
    ğŸ“„ TabPanel.vue
    ğŸ“„ TransportBar 2.vue
    ğŸ“„ TransportBar.vue
    ğŸ“ control/
      ğŸ“„ DualDisplay.vue
      ğŸ“„ SoftButtonStrip.vue
    ğŸ“ panels/
      ğŸ“„ ChannelPanel.vue
      ğŸ“„ ExportPanel.vue
      ğŸ“„ FxPanel.vue
      ğŸ“„ PatternsPanel.vue
      ğŸ“„ SoundPanel.vue
    ğŸ“ placeholders/
      ğŸ“„ DualDisplayPlaceholder.vue
      ğŸ“„ FourDEncoderPlaceholder.vue
      ğŸ“„ ModeColumnPlaceholder.vue
      ğŸ“„ ScreenKnobRingPlaceholder.vue
      ğŸ“„ SoftButtonStripPlaceholder.vue
      ğŸ“„ TouchStripPlaceholder.vue
  ğŸ“ composables/
    ğŸ“„ useAudioEngine.client 2.ts
    ğŸ“„ useAudioEngine.client.ts
    ğŸ“„ useAudioInput.client.ts
    ğŸ“„ useCapabilities.client.ts
    ğŸ“„ useImportExport.client 2.ts
    ğŸ“„ useImportExport.client.ts
    ğŸ“„ useMidi.client 2.ts
    ğŸ“„ useMidi.client.ts
    ğŸ“„ useMidiLearn.ts
    ğŸ“„ usePatternStorage.client.ts
    ğŸ“„ useScheduler.ts
    ğŸ“„ useSequencer 2.ts
    ğŸ“„ useSequencer.ts
    ğŸ“„ useSoundbankStorage.client.ts
    ğŸ“„ useSync.client 2.ts
    ğŸ“„ useSync.client.ts
  ğŸ“ config/
    ğŸ“„ pwa.ts
  ğŸ“„ control-review.md
  ğŸ“ diagrams/
    ğŸ“„ class-diagram.md
    ğŸ“„ control-area-mapping.md
    ğŸ“„ padgrid-modus-layout.md
    ğŸ“„ persistence-and-audio.md
    ğŸ“„ transport-engine.md
    ğŸ“„ ui-sequencer.md
    ğŸ“„ use-cases.md
  ğŸ“ dist/ (6 items)
    ğŸ“„ ...
  ğŸ“ domain/
    ğŸ“„ .DS_Store
    ğŸ“ clock/
      ğŸ“„ renderClock.ts
      ğŸ“„ scheduler.ts
    ğŸ“„ midiMapping.ts
    ğŸ“„ quantize.ts
    ğŸ“„ timing.ts
    ğŸ“ transport/
      ğŸ“„ audioHooks.ts
      ğŸ“„ transportEngine.ts
      ğŸ“„ types.ts
    ğŸ“„ validators.ts
    ğŸ“ velocity/
      ğŸ“„ velocityToGain.ts
    ğŸ“„ velocity.ts
  ğŸ“„ eslint.config.cjs
  ğŸ“„ eslint.config.js
  ğŸ“„ functionsList.json
  ğŸ“ iMac/
    ğŸ“ Repositories/
      ğŸ“ FullStackDeveloperCourse/
        ğŸ“ JavaScriptAdvanced/
          ğŸ“ CertificationProjects/
            ğŸ“ Drumcomputer/
              ğŸ“ node_modules/ (1 items)
                ğŸ“„ ...
  ğŸ“„ implementationPlan.json
  ğŸ“ layouts/
    ğŸ“„ default.vue
  ğŸ“„ maschinemk3.jpg
  ğŸ“„ nimamk3.json
  ğŸ“ node_modules/ (754 items)
    ğŸ“„ ...
  ğŸ“„ nuxt.config.ts
  ğŸ“„ package-lock.json
  ğŸ“„ package.json
  ğŸ“ pages/
    ğŸ“„ index.vue
  ğŸ“ plugins/
    ğŸ“„ vuetify.client.ts
    ğŸ“„ vuetify.ts
  ğŸ“„ promptingAgentInstructions.json
  ğŸ“ public/
    ğŸ“„ .DS_Store
    ğŸ“ samples/
      ğŸ“„ clap.wav
      ğŸ“„ hihat.wav
      ğŸ“„ kick.wav
      ğŸ“„ snare.wav
  ğŸ“ scripts/
    ğŸ“„ dev.mjs
  ğŸ“ stores/
    ğŸ“„ control.ts
    ğŸ“„ patterns.ts
    ğŸ“„ session.ts
    ğŸ“„ soundbanks.ts
    ğŸ“„ transport.ts
  ğŸ“ styles/
    ğŸ“„ drum-machine.less
    ğŸ“„ globals.less
    ğŸ“„ variables.less
    ğŸ“„ vuetify-overrides.less
  ğŸ“ tests/
    ğŸ“ componentTests/
      ğŸ“„ PadCell.component.spec.ts
      ğŸ“„ PadGrid.component.spec.ts
    ğŸ“ unitTests/
      ğŸ“„ transportEngine.spec.ts
  ğŸ“„ tsconfig.json
  ğŸ“„ tsconfig.test.json
  ğŸ“ types/
    ğŸ“„ audio.ts
    ğŸ“„ drums.ts
    ğŸ“„ file-saver.d.ts
    ğŸ“„ midi.ts
    ğŸ“„ persistence.ts
    ğŸ“„ process.d.ts
    ğŸ“„ render.ts
    ğŸ“„ shims-vue.d.ts
    ğŸ“„ sync.ts
    ğŸ“„ time.ts
  ğŸ“„ uiList.json
  ğŸ“ utils/
    ğŸ“„ seededRandom.ts
    ğŸ“„ zip.ts


=========================================
File: .eslintignore
=========================================

.nuxt
node_modules
.output
.dist
coverage



=========================================
File: .eslintrc.cjs
=========================================

module.exports = {
  root: true,
  env: {
    browser: true,
    es2021: true
  },
  extends: ['eslint:recommended', 'plugin:vue/vue3-recommended', 'plugin:@typescript-eslint/recommended'],
  parser: 'vue-eslint-parser',
  parserOptions: {
    parser: '@typescript-eslint/parser',
    ecmaVersion: 'latest',
    sourceType: 'module'
  },
  rules: {
    '@typescript-eslint/no-explicit-any': 'error'
  }
}



=========================================
File: .github/copilot-instructions.md
=========================================

# Copilot Instructions for Drumcomputer

## ProjektÃ¼berblick
- Nuxt 4 Drumcomputer mit Vue 3 Options API, TypeScript (strict), Vuetify 3 (Pug + Less), Web Audio, Web MIDI und IndexedDB.
- Hauptkomponenten: PadGrid, PadCell, DrumMachine, TransportBar, FxPopup, Panels (Sound, FX, Patterns, Export).
- Audio-Engine: Lookahead-Scheduler, quantisierte Aufnahme, 16-Pad-Sequencer, FX-Chain (Filter/Drive/Reverb), deterministische Exporte mit Seed.
- Persistenz: Soundbanks, Patterns und Samples werden in IndexedDB gespeichert und beim Laden rehydriert.
- MIDI: Mapping, Clock (Master/Slave), WebMIDI-Capabilities, Sync-Panel.

## Wichtige Workflows
- **Entwicklung:**
  - `npm install` â€“ AbhÃ¤ngigkeiten installieren
  - `npm run dev` â€“ Entwicklungsserver starten
  - `npm run lint` â€“ Linting
  - `npm run typecheck` â€“ TypeScript-Checks
- **Port/HMR anpassen:**
  - Beispiel: `PORT=3001 HMR_PORT=24679 npm run dev`
- **Tests:**
  - Komponententests: `tests/componentTests/`
  - Unittests: `tests/unitTests/`
- **Export:**
  - Audio-Export via ExportPanel, deterministisch mit Seed und Metadaten (siehe `useImportExport` und `exportAudio`).

## Architektur & Patterns
- **Stores:** Pinia fÃ¼r Transport, Patterns, Session, Soundbanks (`stores/`)
- **Composables:** Audio, Scheduler, Sequencer, MIDI, Sync, Import/Export, Soundbank-Storage (`composables/`)
- **Domain-Logik:** Timing, Quantisierung, Velocity, Transport, Clock, FX (`domain/`)
- **Diagrams:** Architektur, Transport, UI, Persistenz (`diagrams/`)
- **Persistenz:** IndexedDB fÃ¼r Soundbanks/Samples/Patterns, LocalStorage fÃ¼r Patterns/Scenes (v2 Schema)
- **UI:** Responsive, 16-Pad-Grid, Transport, FX, Panels (Pattern, Export, Sound, FX)
- **Export:** Mixdown + Stems, Metadaten-Blob, deterministische Reproduktion via Seed

## Konventionen & Besonderheiten
- **AudioContext** ist die einzige Zeitquelle (auch fÃ¼r MIDI-Clock).
- **Undo/Redo:** 50 Schritte fÃ¼r Pattern/Scene-Edits, persistiert mit Auswahl.
- **Capability Gates:** UI zeigt WebMIDI/Audio-In-Support an.
- **Import/Export:** JSON/MIDI fÃ¼r Patterns, Soundbank-Manifest + Blobs, WAV-Export mit Metadaten.
- **Fehlende Komponenten:** StepGrid/StepCell sind nur als Markdown-Doku vorhanden, nicht im Build.
- **Panels:** Viele Panels existieren im Code, sind aber nicht immer im UI gemountet (siehe `pages/index.vue`).
- **Focus/Accessibility:** PadGrid/PadCell benÃ¶tigen explizite Refs fÃ¼r Fokussteuerung.

## Beispiele & Referenzen
- **Audio-Engine:** `audio/engine/`, `audio/fxGraph.ts`, `audio/stepResolver.ts`
- **Stores:** `stores/`
- **Composables:** `composables/`
- **Panels:** `components/panels/`
- **Export:** `useImportExport`, `exportAudio`, ExportPanel
- **Diagrams:** `diagrams/`

## Hinweise fÃ¼r KI-Agenten
- Halte dich an die bestehenden Patterns und Strukturen.
- PrÃ¼fe, ob Komponenten im UI gemountet sind, bevor du UI-Ã„nderungen vorschlÃ¤gst.
- Beachte deterministische Exporte (Seed, Metadaten) und die zentrale Rolle von AudioContext.
- Dokumentiere neue Patterns/Workflows in der README oder als Kommentar im Code.



=========================================
File: .gitignore
=========================================

node_modules
.nitro
.nuxt
.env
.DS_Store
npm-debug.log*
pnpm-lock.yaml
yarn.lock
Components.md
Composables.md
Domain.md
alleDateien.md
StepCell.md
StepGrid.md
dist
ROADMAP.md
nimamk3.json
uiList.json
functionsList.json
maschinemk3.jpg


=========================================
File: .gitignore 2
=========================================

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.*
!.env.example

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Sveltekit cache directory
.svelte-kit/

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Firebase cache directory
.firebase/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v3
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Vite logs files
vite.config.js.timestamp-*
vite.config.ts.timestamp-*



=========================================
File: .mocharc.json
=========================================

{
  "timeout": 5000,
  "color": true,
  "extension": [
    "js"
  ]
}


=========================================
File: Components.md
=========================================

## SoundPanel.vue
```vue
<template>
  <div class="sound-panel">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'SoundPanel'
})
</script>

<style scoped>
.sound-panel {
  background: #222;
  padding: 16px;
  border-radius: 8px;
  min-height: 100px;
}
</style>
```
## PatternsPanel.vue
```vue
<template>
  <div class="patterns-panel">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'PatternsPanel'
})
</script>

<style scoped>
.patterns-panel {
  background: #222;
  padding: 16px;
  border-radius: 8px;
  min-height: 100px;
}
</style>
```
## FxPanel.vue
```vue
<template>
  <div class="fx-panel">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'FxPanel'
})
</script>

<style scoped>
.fx-panel {
  background: #222;
  padding: 16px;
  border-radius: 8px;
  min-height: 100px;
}
</style>
```
## ExportPanel.vue
```vue
<template>
  <div class="export-panel">
    <button @click="$emit('export')">Exportieren</button>
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'ExportPanel',
  emits: ['export']
})
</script>

<style scoped>
.export-panel {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 8px;
  background: #222;
  padding: 16px;
  border-radius: 8px;
}
.export-panel button {
  background: #444;
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 1em;
  transition: background 0.1s;
}
.export-panel button:hover {
  background: #ff9800;
}
</style>
```
## TransportBar.vue
```vue
<template>
  <div class="transport-bar">
    <button @click="$emit('play')">Play</button>
    <button @click="$emit('stop')">Stop</button>
    <button @click="$emit('record')">Record</button>
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'TransportBar',
  emits: ['play', 'stop', 'record']
})
</script>

<style scoped>
.transport-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #222;
  padding: 8px 16px;
  border-radius: 8px;
}
.transport-bar button {
  background: #444;
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 1em;
  transition: background 0.1s;
}
.transport-bar button:hover {
  background: #ff9800;
}
</style>
```
## TabPanel.vue
```vue
<template>
  <div class="tab-panel">
    <div class="tab-bar">
      <button
        v-for="(tab, idx) in tabs"
        :key="tab.key"
        :class="{ active: tab.key === activeTab }"
        @click="$emit('update:activeTab', tab.key)"
      >
        {{ tab.label }}
      </button>
    </div>
    <div class="tab-content">
      <slot :name="activeTab" />
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'TabPanel',
  props: {
    tabs: {
      type: Array,
      required: true
    },
    activeTab: {
      type: String,
      required: true
    }
  },
  emits: ['update:activeTab']
})
</script>

<style scoped>
.tab-panel {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
}
.tab-bar {
  display: flex;
  border-bottom: 1px solid #444;
}
.tab-bar button {
  background: none;
  border: none;
  color: #fff;
  padding: 8px 16px;
  cursor: pointer;
  font-size: 1em;
  outline: none;
  transition: background 0.1s;
}
.tab-bar button.active {
  background: #222;
  border-bottom: 2px solid #ff9800;
}
.tab-content {
  flex: 1;
  padding: 16px;
  background: #222;
}
</style>
```
## StepGrid.vue
```vue
<template>
  <div class="step-grid">
    <StepCell
      v-for="(step, idx) in steps"
      :key="idx"
      :active="step.active"
      :selected="step.selected"
      :playing="step.playing"
      :label="step.label"
      @click="$emit('stepClick', idx)"
      @mousedown="$emit('stepMousedown', idx)"
      @mouseup="$emit('stepMouseup', idx)"
      @mouseenter="$emit('stepMouseenter', idx)"
      @mouseleave="$emit('stepMouseleave', idx)"
    >
      {{ step.label }}
    </StepCell>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import StepCell from './StepCell.vue'

export default defineComponent({
  name: 'StepGrid',
  components: { StepCell },
  props: {
    steps: {
      type: Array,
      required: true
    }
  },
  emits: [
    'stepClick',
    'stepMousedown',
    'stepMouseup',
    'stepMouseenter',
    'stepMouseleave'
  ]
})
</script>

<style scoped>
.step-grid {
  display: grid;
  grid-template-columns: repeat(16, 1fr);
  gap: 2px;
  width: 100%;
  height: 100%;
}
</style>
```
## StepCell.vue
```vue
<template>
  <div
    class="step-cell"
    :class="{ active, selected, playing }"
    @click="$emit('click')"
    @mousedown="$emit('mousedown')"
    @mouseup="$emit('mouseup')"
    @mouseenter="$emit('mouseenter')"
    @mouseleave="$emit('mouseleave')"
    tabindex="0"
    :aria-label="label"
  >
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'StepCell',
  props: {
    active: Boolean,
    selected: Boolean,
    playing: Boolean,
    label: String
  },
  emits: ['click', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave']
})
</script>

<style scoped>
.step-cell {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  background: #333;
  color: #fff;
  cursor: pointer;
  user-select: none;
  outline: none;
  transition: background 0.1s;
}
.step-cell.active {
  background: #ff9800;
}
.step-cell.selected {
  border: 2px solid #fff;
}
.step-cell.playing {
  background: #4caf50;
}
</style>
```
## PlayheadOverlay.vue
```vue
<template>
  <div class="playhead-overlay" :style="overlayStyle">
    <div class="playhead" :style="playheadStyle"></div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'PlayheadOverlay',
  props: {
    position: {
      type: Number,
      required: true
    },
    total: {
      type: Number,
      required: true
    }
  },
  computed: {
    overlayStyle(): Record<string, string> {
      return {
        position: 'absolute',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        pointerEvents: 'none'
      }
    },
    playheadStyle(): Record<string, string> {
      const percent = (this.position / this.total) * 100
      return {
        position: 'absolute',
        top: '0',
        left: percent + '%',
        width: '2px',
        height: '100%',
        background: '#ff9800',
        zIndex: '2'
      }
    }
  }
})
</script>

<style scoped>
.playhead-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}
.playhead {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: #ff9800;
  z-index: 2;
}
</style>
```
## PadGrid.vue
```vue
<template>
  <div class="pad-grid">
    <PadCell
      v-for="(pad, idx) in pads"
      :key="pad.id"
      :active="pad.active"
      :triggered="pad.triggered"
      :playing="pad.playing"
      :label="pad.label"
      @padDown="$emit('padDown', pad.id)"
      @padUp="$emit('padUp', pad.id)"
    >
      {{ pad.label }}
    </PadCell>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import PadCell from './PadCell.vue'

export default defineComponent({
  name: 'PadGrid',
  components: { PadCell },
  props: {
    pads: {
      type: Array,
      required: true
    }
  },
  emits: ['padDown', 'padUp']
})
</script>

<style scoped>
.pad-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 8px;
  width: 100%;
  height: 100%;
}
</style>
```
## PadCell.vue
```vue
<template>
  <div
    class="pad-cell"
    :class="{ active, triggered, playing }"
    @mousedown="onPadDown"
    @mouseup="onPadUp"
    @mouseleave="onPadUp"
    @touchstart.prevent="onPadDown"
    @touchend.prevent="onPadUp"
    @keydown.space.prevent="onPadDown"
    @keyup.space.prevent="onPadUp"
    tabindex="0"
    :aria-label="label"
  >
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'PadCell',
  props: {
    active: Boolean,
    triggered: Boolean,
    playing: Boolean,
    label: String
  },
  emits: ['padDown', 'padUp'],
  methods: {
    onPadDown() {
      this.$emit('padDown')
    },
    onPadUp() {
      this.$emit('padUp')
    }
  }
})
</script>

<style scoped>
.pad-cell {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  background: #222;
  color: #fff;
  cursor: pointer;
  user-select: none;
  outline: none;
  transition: background 0.1s;
}
.pad-cell.active {
  background: #444;
}
.pad-cell.triggered {
  background: #ff9800;
}
.pad-cell.playing {
  background: #4caf50;
}
</style>
```
## FxPopup.vue
```vue
<template>
  <div class="fx-popup" v-if="visible">
    <slot />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'FxPopup',
  props: {
    visible: {
      type: Boolean,
      required: true
    }
  }
})
</script>

<style scoped>
.fx-popup {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
</style>
```
# Komponenten

## DrumMachine.vue
```vue
<template>
  <slot
    name="main"
    :props="mainSlotProps"
  />
  <slot
    name="transport"
    :props="transportSlotProps"
  />
  <slot
    name="pads"
    :props="padsSlotProps"
  />
  <slot
    name="drawer"
    :props="drawerSlotProps"
  />
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import { saveAs } from 'file-saver'
import { DEFAULT_GRID_SPEC, GRID_DIVISIONS, normalizeGridSpec } from '@/domain/timing'
import { useTransportStore } from '@/stores/transport'
import { usePatternsStore } from '@/stores/patterns'
import { useSoundbanksStore } from '@/stores/soundbanks'
import { useSessionStore } from '@/stores/session'
import { useSequencer } from '@/composables/useSequencer'
import { useSync } from '@/composables/useSync.client'
import { useMidi } from '@/composables/useMidi.client'
import { usePatternStorage } from '@/composables/usePatternStorage.client'
import { useSoundbankStorage } from '@/composables/useSoundbankStorage.client'
import { useImportExport } from '@/composables/useImportExport.client'
import { useCapabilities } from '@/composables/useCapabilities.client'
import { useMidiLearn } from '@/composables/useMidiLearn'
import TransportBar from './TransportBar.vue'
import PadGrid from './PadGrid.vue'
import StepGridComponent from './StepGrid.vue'
import TabPanel from './TabPanel.vue'
import SoundPanel from './panels/SoundPanel.vue'
import FxPanel from './panels/FxPanel.vue'
import PatternsPanel from './panels/PatternsPanel.vue'
import ExportPanel from './panels/ExportPanel.vue'
import { createZip, type ZipEntry } from '@/utils/zip'
import type { DrumPadId, Scene } from '@/types/drums'
import type { TimeDivision, GridSpec } from '@/types/time'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import type { RenderEvent, RenderMetadata } from '@/types/render'
import type { StepGrid } from '@/types/drums'

const slugify = (value: string): string => {
  const cleaned = value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
  return cleaned || 'drum-session'
}

type StemFiles = Partial<
  Record<
    DrumPadId,
    {
      fileName: string
      blob: Blob
    }
  >
>

type StemEntry = {
  padId: DrumPadId
  label: string
  fileName: string
}

type PadState = {
  label: string
  isTriggered: boolean
  isPlaying: boolean
}

const VISIBLE_DIVISIONS: TimeDivision[] = GRID_DIVISIONS.filter((value) => value <= 16)

const collectPlayingPads = (steps: StepGrid): Set<DrumPadId> => {
  const set = new Set<DrumPadId>()

  Object.values(steps).forEach((bar) => {
    Object.values(bar).forEach((step) => {
      Object.keys(step).forEach((padId) => {
        set.add(padId as DrumPadId)
      })
    })
  })

  return set
}

export default defineComponent({
  name: 'DrumMachine',
  components: {
    TransportBar,
    PadGrid,
    StepGrid: StepGridComponent,
    TabPanel,
    SoundPanel,
    FxPanel,
    PatternsPanel,
    ExportPanel
  },
  data() {
    const transport = useTransportStore()
    const patterns = usePatternsStore()
    const soundbanks = useSoundbanksStore()
    const session = useSessionStore()
    const capabilitiesProbe = useCapabilities()
    session.setCapabilities(capabilitiesProbe.capabilities.value)

    const importExport = useImportExport()
    const midi = useMidi()
    const midiLearn = useMidiLearn(midi)
    const sequencer = useSequencer({
      getPattern: () => patterns.currentPattern,
      onPatternBoundary: () => patterns.advanceScenePlayback()
    })
    const handleExternalStart = () => {
      if (!transport.isPlaying) {
        patterns.prepareScenePlayback()
        void sequencer.start().catch((error) => {
          console.error('Failed to start sequencer from external sync', error)
        })
      }
    }
    const handleExternalStop = () => {
      if (transport.isPlaying) {
        sequencer.stop()
      }
    }
    const sync = useSync('internal', {
      midi,
      getAudioTime: () => sequencer.getAudioTime(),
      onExternalStart: handleExternalStart,
      onExternalStop: handleExternalStop
    })
    const patternStorage = usePatternStorage()
    const soundbankStorage = useSoundbankStorage()

    const pads: DrumPadId[] = [
      'pad1',
      'pad2',
      'pad3',
      'pad4',
      'pad5',
      'pad6',
      'pad7',
      'pad8',
      'pad9',
      'pad10',
      'pad11',
      'pad12',
      'pad13',
      'pad14',
      'pad15',
      'pad16'
    ]
    const divisions: TimeDivision[] = [...VISIBLE_DIVISIONS]
    const defaultBank: Soundbank = {
      id: 'default-kit',
      name: 'Default Kit',
      createdAt: Date.now(),
      updatedAt: Date.now(),
      pads: {
        pad1: { id: 'kick', name: 'Kick', url: '/samples/kick.wav', format: 'wav' },
        pad5: { id: 'kick-2', name: 'Kick 2', url: '/samples/kick.wav', format: 'wav' },
        pad9: { id: 'kick-3', name: 'Kick 3', url: '/samples/kick.wav', format: 'wav' },
        pad13: { id: 'kick-4', name: 'Kick 4', url: '/samples/kick.wav', format: 'wav' },
        pad2: { id: 'snare', name: 'Snare', url: '/samples/snare.wav', format: 'wav' },
        pad6: { id: 'snare-2', name: 'Snare 2', url: '/samples/snare.wav', format: 'wav' },
        pad10: { id: 'snare-3', name: 'Snare 3', url: '/samples/snare.wav', format: 'wav' },
        pad14: { id: 'snare-4', name: 'Snare 4', url: '/samples/snare.wav', format: 'wav' },
        pad3: { id: 'hihat', name: 'Hi-Hat', url: '/samples/hihat.wav', format: 'wav' },
        pad7: { id: 'hihat-2', name: 'Hi-Hat 2', url: '/samples/hihat.wav', format: 'wav' },
        pad11: { id: 'hihat-3', name: 'Hi-Hat 3', url: '/samples/hihat.wav', format: 'wav' },
        pad15: { id: 'hihat-4', name: 'Hi-Hat 4', url: '/samples/hihat.wav', format: 'wav' },
        pad4: { id: 'clap', name: 'Clap', url: '/samples/clap.wav', format: 'wav' },
        pad8: { id: 'clap-2', name: 'Clap 2', url: '/samples/clap.wav', format: 'wav' },
        pad12: { id: 'clap-3', name: 'Clap 3', url: '/samples/clap.wav', format: 'wav' },
        pad16: { id: 'clap-4', name: 'Clap 4', url: '/samples/clap.wav', format: 'wav' }
      }
    }

    if (soundbanks.banks.length === 0) {
      soundbanks.setBanks([defaultBank])
    }

    return {
      transport,
      patterns,
      soundbanks,
      session,
      sequencer,
      sync,
      midi,
      midiLearn,
      patternStorage,
      soundbankStorage,
      pads,
      divisions,
      defaultBank,
      unwatchers: [] as Array<() => void>,
      stepGridRef: null as (InstanceType<typeof StepGridComponent> & { focusGrid?: () => void }) | null,
      exportMetadata: null as RenderMetadata | null,
      exportAudioBlob: null as Blob | null,
      exportTimeline: undefined as RenderEvent[] | undefined,
      exportStems: null as StemFiles | null,
      isExporting: false,
      exportError: null as string | null,
      exportAudioFn: importExport.exportAudio,
      selectedPadId: 'pad1' as DrumPadId,
      drawerTab: 'sound'
    }
  },
  // ...restlicher Code siehe Datei DrumMachine.vue ...
</script>
```

## DrumMachineSlots.vue
```vue
<template>
  <div class="drum-machine-slots">
    <slot name="transport" />
    <slot name="pads" />
    <slot name="drawer" />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'DrumMachineSlots'
})
</script>

<style scoped>
.drum-machine-slots {
  display: flex;
  flex-direction: column;
  height: 100%;
}
</style>
```



=========================================
File: Composables.md
=========================================

# Composables

## useAudioEngine.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'
import type { DrumPadId } from '@/types/drums'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import { createSeededRandom, type RandomSource } from '@/utils/seededRandom'
import { createFxGraph, connectFxGraph, updateFxGraph, type FxGraphNodes } from '@/audio/fxGraph'

interface TriggerRequest {
	padId: DrumPadId
	when: number
	velocity?: number
}

const cloneFxSettings = (settings: FxSettings): FxSettings => ({
	filter: { ...settings.filter },
	drive: { ...settings.drive },
	reverb: { ...settings.reverb }
})

const createAudioEngineInstance = () => {
	const audioContext = ref<AudioContext | null>(null)
	const masterGain = ref<GainNode | null>(null)
	const sampleCache = ref<Map<DrumPadId, AudioBuffer>>(new Map())
	const fxSettings = ref<FxSettings>({
		filter: { enabled: true, frequency: 12000, q: 0.7 },
		drive: { enabled: false, amount: 0.25 },
		reverb: { enabled: false, mix: 0.15 }
	})
	const fxSnapshot = ref<FxSettings>(cloneFxSettings(fxSettings.value))
	const fxGraph = ref<FxGraphNodes | null>(null)
	let randomSource: RandomSource = createSeededRandom(0)
	let wasRunningOnHide = false
	let handlePageHide: (() => void) | null = null
	let handlePageShow: (() => void) | null = null

	const syncFxSnapshot = () => {
		fxSnapshot.value = cloneFxSettings(fxSettings.value)
		return fxSnapshot.value
	}

	const ensureFxGraph = (ctx: BaseAudioContext, snapshot: FxSettings) => {
		if (!masterGain.value) {
			return
		}
		if (!fxGraph.value) {
			fxGraph.value = createFxGraph(ctx)
			connectFxGraph(fxGraph.value, masterGain.value)
		}
		updateFxGraph(ctx, fxGraph.value, snapshot, randomSource)
	}

	const ensureContext = () => {
		if (!audioContext.value) {
			const context = new AudioContext()
			const gain = context.createGain()
			gain.gain.value = 0.8
			gain.connect(context.destination)
			audioContext.value = context
			masterGain.value = gain
		}
		ensureFxGraph(audioContext.value as BaseAudioContext, fxSnapshot.value)
		return audioContext.value as AudioContext
	}

	const resumeContext = async () => {
		const ctx = ensureContext()
		if (ctx.state === 'suspended') {
			await ctx.resume()
		}
		return ctx
	}

	const getFxSnapshot = () => cloneFxSettings(fxSnapshot.value)

	const setFxRandomSource = (source: RandomSource) => {
		randomSource = source
		if (fxGraph.value?.reverbNode) {
			fxGraph.value.reverbNode.buffer = null
		}
		if (audioContext.value) {
			ensureFxGraph(audioContext.value, fxSnapshot.value)
		}
	}

	const decodeSample = async (sample: SampleRef): Promise<AudioBuffer | null> => {
		const ctx = ensureContext()
		if (sample.buffer) {
			return sample.buffer
		}
		if (sample.blob) {
			const arrayBuffer = await sample.blob.arrayBuffer()
			return ctx.decodeAudioData(arrayBuffer.slice(0))
		}
		if (sample.url) {
			const response = await fetch(sample.url)
			const arrayBuffer = await response.arrayBuffer()
			return ctx.decodeAudioData(arrayBuffer)
		}
		return null
	}

	const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
		const buffer = sample.buffer ?? (await decodeSample(sample))
		if (buffer) {
			sampleCache.value.set(padId, buffer)
		}
	}

	const applySoundbank = async (bank: Soundbank) => {
		const entries = Object.entries(bank.pads)
		await Promise.all(
			entries.map(async ([padId, sample]) => {
				if (sample) {
					await setSampleForPad(padId as DrumPadId, sample)
				}
			})
		)
	}

	const setFx = (partial: Partial<FxSettings>) => {
		fxSettings.value = {
			filter: { ...fxSettings.value.filter, ...(partial.filter ?? {}) },
			drive: { ...fxSettings.value.drive, ...(partial.drive ?? {}) },
			reverb: { ...fxSettings.value.reverb, ...(partial.reverb ?? {}) }
		}
		const snapshot = syncFxSnapshot()
		const ctx = ensureContext()
		ensureFxGraph(ctx, snapshot)
	}

	const trigger = async ({ padId, when, velocity = 1 }: TriggerRequest) => {
		const ctx = ensureContext()
		const buffer = sampleCache.value.get(padId) ?? null
		if (!buffer) {
			return
		}
		const source = ctx.createBufferSource()
		source.buffer = buffer
		const gain = ctx.createGain()
		gain.gain.value = velocity
		source.connect(gain)
		if (fxGraph.value) {
			gain.connect(fxGraph.value.fxInput)
		} else {
			gain.connect(masterGain.value ?? ctx.destination)
		}
		source.start(when)
	}

	if (typeof window !== 'undefined') {
		handlePageHide = () => {
			if (audioContext.value) {
				wasRunningOnHide = audioContext.value.state === 'running'
				void audioContext.value.suspend().catch(() => undefined)
			}
		}

		handlePageShow = () => {
			if (wasRunningOnHide && audioContext.value) {
				void audioContext.value.resume().catch(() => undefined)
			}
			wasRunningOnHide = false
		}

		window.addEventListener('pagehide', handlePageHide)
		window.addEventListener('pageshow', handlePageShow)
	}

	onBeforeUnmount(() => {
		if (handlePageHide) {
			window.removeEventListener('pagehide', handlePageHide)
		}
		if (handlePageShow) {
			window.removeEventListener('pageshow', handlePageShow)
		}
		audioContext.value?.close()
		sampleCache.value.clear()
	})

	return {
		audioContext,
		masterGain,
		sampleCache,
		fxSettings,
		ensureContext,
		resumeContext,
		decodeSample,
		applySoundbank,
		setFx,
		setSampleForPad,
		trigger,
		getFxSnapshot,
		setFxRandomSource
	}
}

let audioEngineInstance: ReturnType<typeof createAudioEngineInstance> | null = null

export function useAudioEngine() {
	if (!audioEngineInstance) {
		audioEngineInstance = createAudioEngineInstance()
	}
	return audioEngineInstance
}

```

## useAudioInput.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'

export interface AudioInputState {
	stream?: MediaStream
	error?: string
}

export function useAudioInput() {
	const state = ref<AudioInputState>({})
	const sourceNode = ref<MediaStreamAudioSourceNode | null>(null)
	const audioContext = ref<AudioContext | null>(null)
	let handlePageHide: (() => void) | null = null

	const requestMic = async () => {
		try {
			const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
			const context = new AudioContext()
			sourceNode.value = context.createMediaStreamSource(stream)
			audioContext.value = context
			state.value = { stream }
		} catch (error) {
			const message = error instanceof Error ? error.message : 'microphone request failed'
			state.value = { error: message }
		}
	}

	const stop = () => {
		state.value.stream?.getTracks().forEach((track) => track.stop())
		void audioContext.value?.close()
		audioContext.value = null
		state.value = {}
	}

	if (typeof window !== 'undefined') {
		handlePageHide = () => {
			stop()
			sourceNode.value = null
		}
		window.addEventListener('pagehide', handlePageHide)
	}

	onBeforeUnmount(() => {
		if (handlePageHide) {
			window.removeEventListener('pagehide', handlePageHide)
		}
		stop()
		sourceNode.value = null
	})

	return {
		state,
		sourceNode,
		requestMic,
		stop
	}
}
```

## useCapabilities.client.ts
```typescript
import { ref } from 'vue'

export interface Capabilities {
	supportsWebMIDI: boolean
	supportsAudioInput: boolean
}

export function useCapabilities() {
	const capabilities = ref<Capabilities>({ supportsWebMIDI: false, supportsAudioInput: false })

	const evaluate = () => {
		capabilities.value = {
			supportsWebMIDI: typeof navigator !== 'undefined' && 'requestMIDIAccess' in navigator,
			supportsAudioInput: typeof navigator !== 'undefined' && Boolean(navigator.mediaDevices?.getUserMedia)
		}
	}

	evaluate()

	return {
		capabilities,
		evaluate
	}
}
```

## useImportExport.client.ts
```typescript
import { ref } from 'vue'
import { saveAs } from 'file-saver'
import { Midi as MidiType } from '@tonejs/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import { clampVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock } from '@/domain/clock/renderClock'
import { createFxGraph, connectFxGraph, updateFxGraph } from '@/audio/fxGraph'
import { useAudioEngine } from './useAudioEngine.client'
import { usePatternsStore } from '@/stores/patterns'
import { useTransportStore } from '@/stores/transport'
import { createSeededRandom } from '@/utils/seededRandom'
import type { ScheduledTask } from './useScheduler'
import { scheduleStep } from './useSequencer'
import type { ScheduleStepOptions, ScheduledStep } from './useSequencer'
import type { GridSpec } from '@/types/time'
import type { MidiFileData, MidiMapping } from '@/types/midi'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { RenderMetadata, RenderEvent } from '@/types/render'
import type { DrumPadId, Pattern } from '@/types/drums'

// ...existing code...
```

## useMidi.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'
import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '@/types/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'

// ...existing code...
```

## useMidiLearn.ts
```typescript
import { computed, onBeforeUnmount, ref } from 'vue'
import { defaultMidiMapping } from '@/domain/midiMapping'
import type { MidiMessage, MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

// ...existing code...
```

## usePatternStorage.client.ts
```typescript
import { ref } from 'vue'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import type { Pattern, Scene } from '@/types/drums'

// ...existing code...
```

## useScheduler.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'

// ...existing code...
```

## useSequencer.ts
```typescript
import { ref, type Ref } from 'vue'
import { quantizeToStep } from '@/domain/quantize'
import { normalizeGridSpec, secondsPerStep } from '@/domain/timing'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { GridSpec, StepAddress } from '@/types/time'
import { useTransportStore } from '@/stores/transport'
import { useScheduler, type ScheduledTask } from './useScheduler'
import { useAudioEngine } from './useAudioEngine.client'
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock, type RenderClock } from '@/domain/clock/renderClock'

// ...existing code...
```

## useSoundbankStorage.client.ts
```typescript
import { ref } from 'vue'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { Soundbank, SampleRef } from '@/types/audio'

// ...existing code...
```

## useSync.client.ts
```typescript
import { onBeforeUnmount, ref } from 'vue'
import { useScheduler } from './useScheduler'
import type { ClockAuthority, SyncMode, SyncRole, SyncState } from '@/types/sync'
import type { MidiMessage } from '@/types/midi'

// ...existing code...
```



=========================================
File: Domain.md
=========================================

# Domain

## midiMapping.ts
```typescript
import type { MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

const defaultPads: DrumPadId[] = [
	'pad1',
	'pad2',
	'pad3',
	'pad4',
	'pad5',
	'pad6',
	'pad7',
	'pad8',
	'pad9',
	'pad10',
	'pad11',
	'pad12',
	'pad13',
	'pad14',
	'pad15',
	'pad16'
]

export function defaultMidiMapping(): MidiMapping {
	const noteMap: Partial<Record<number, DrumPadId>> = {}
	const noteMapInverse: Partial<Record<DrumPadId, number>> = {}
	defaultPads.forEach((padId, index) => {
		const note = 36 + index
		noteMap[note] = padId
		noteMapInverse[padId] = note
	})
	return { noteMap, noteMapInverse, transportMap: {} }
}

```

## quantize.ts
```typescript
import type { StepAddress } from '@/types/time'

export function quantizeToStep(time: number, secondsPerStep: number, bars: number, division: number): StepAddress {
	const totalSteps = bars * division
	const stepIndex = Math.max(0, Math.min(totalSteps - 1, Math.round(time / secondsPerStep)))
	return {
		barIndex: Math.floor(stepIndex / division),
		stepInBar: stepIndex % division
	}
}

```

## timing.ts
```typescript
import type { GridSpec, TimeDivision } from '@/types/time'

export const GRID_DIVISIONS: readonly TimeDivision[] = [1, 2, 4, 8, 16, 32, 64] as const
export const DEFAULT_GRID_SPEC: GridSpec = { bars: 1, division: 16 }

export function secondsPerStep(bpm: number, division: number): number {
	return (60 / bpm) * (4 / division)
}

export function stepsPerBar(gridSpec: GridSpec): number {
	return gridSpec.division
}

export function normalizeGridSpec(gridSpec?: Partial<GridSpec>): GridSpec {
	const division = GRID_DIVISIONS.includes((gridSpec?.division ?? DEFAULT_GRID_SPEC.division) as TimeDivision)
		? (gridSpec?.division as TimeDivision)
		: DEFAULT_GRID_SPEC.division
	const bars: GridSpec['bars'] =
		gridSpec?.bars === 1 || gridSpec?.bars === 2 || gridSpec?.bars === 4 || gridSpec?.bars === 8
			? gridSpec.bars
			: DEFAULT_GRID_SPEC.bars

	return { bars, division }
}

```

## validators.ts
```typescript
import { GRID_DIVISIONS } from './timing'
import type { GridSpec } from '../types/time'

export function isValidGridSpec(gridSpec: GridSpec): boolean {
	return gridSpec.bars >= 1 && gridSpec.bars <= 8 && GRID_DIVISIONS.includes(gridSpec.division)
}

```

## velocity.ts
```typescript
export const STEP_VELOCITY_LEVELS = [0.7, 1, 1.25] as const
export const DEFAULT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[0]
export const ACCENT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[STEP_VELOCITY_LEVELS.length - 1]!

const EPSILON = 0.001

const matchesLevel = (value: number, level: number) => Math.abs(value - level) < EPSILON

export function clampVelocity(value?: number): number {
	const resolved = typeof value === 'number' ? value : DEFAULT_STEP_VELOCITY
	const clamped = Math.max(STEP_VELOCITY_LEVELS[0], Math.min(ACCENT_STEP_VELOCITY, resolved))
	const closest = STEP_VELOCITY_LEVELS.find((level) => matchesLevel(clamped, level))
	return closest ?? clamped
}

export function cycleVelocity(current?: number): number | null {
	if (typeof current !== 'number') {
		return DEFAULT_STEP_VELOCITY
	}
	const index = STEP_VELOCITY_LEVELS.findIndex((level) => matchesLevel(current, level))
	if (index === -1) {
		return DEFAULT_STEP_VELOCITY
	}
	const nextIndex = index + 1
	if (nextIndex >= STEP_VELOCITY_LEVELS.length) {
		return null
	}
	const nextValue = STEP_VELOCITY_LEVELS[nextIndex]
	if (typeof nextValue !== 'number') {
		return null
	}
	return nextValue
}

export function velocityToIntensity(value?: number): number {
	if (!value) return 0
	return Math.min(1, value / ACCENT_STEP_VELOCITY)
}

```

### clock/renderClock.ts
```typescript
export interface RenderClock {
	readonly ctx: BaseAudioContext

	/**
	 * Indicates whether the clock is used for offline rendering.
	 * Offline clocks must not rely on real-time scheduling.
	 */
	readonly isOffline: boolean

	/**
	 * Current audio time in seconds.
	 * This is always based on the underlying AudioContext.
	 */
	audioTime(): number

	/**
	 * Alias for audioTime(), for compatibility.
	 */
	now(): number
}

export function createRenderClock(


	ctx: BaseAudioContext,
	isOffline = false
): RenderClock {
	return {
		ctx,
		isOffline,
		audioTime: () => ctx.currentTime,
		now: () => ctx.currentTime
	}
}

```

### clock/scheduler.ts
```typescript
import type { RenderClock } from './renderClock'

export type ScheduledFn = (audioTime: number) => void

export interface SchedulerOptions {
	readonly lookaheadSec: number
	readonly intervalMs: number
}

export interface Scheduler {
	start(): void
	stop(): void
	schedule(atTimeSec: number, fn: ScheduledFn): void
	clear(): void
}

interface ScheduledItem {
	at: number
	fn: ScheduledFn
}

const DEFAULT_OPTIONS: SchedulerOptions = {
	lookaheadSec: 0.1,
	intervalMs: 25
}

export function createScheduler(clock: RenderClock, options: Partial<SchedulerOptions> = {}): Scheduler {
	const cfg: SchedulerOptions = { ...DEFAULT_OPTIONS, ...options }

	let timerId: ReturnType<typeof setInterval> | null = null
	let wasRunningOnHide = false
	let queue: ScheduledItem[] = []

	const flush = (): void => {
		const now = clock.audioTime()
		const horizon = now + cfg.lookaheadSec

		// Keep queue sorted to guarantee deterministic execution order
		queue.sort((a, b) => a.at - b.at)

		const due: ScheduledItem[] = []
		const pending: ScheduledItem[] = []

		for (const item of queue) {
			if (item.at <= horizon) {
				due.push(item)
			} else {
				pending.push(item)
			}
		}

		queue = pending

		// Execute all due items in order
		for (const item of due) {
			item.fn(item.at)
		}
	}

	const startTimer = (): void => {
		if (clock.isOffline) {
			// Offline rendering should call flush manually from the renderer/engine
			return
		}
		if (timerId) {
			return
		}
		timerId = setInterval(flush, cfg.intervalMs)
	}

	const stopTimer = (): void => {
		if (!timerId) {
			return
		}
		clearInterval(timerId)
		timerId = null
	}

	if (typeof window !== 'undefined') {
		const handlePageHide = () => {
			if (timerId) {
				wasRunningOnHide = true
				stopTimer()
			} else {
				wasRunningOnHide = false
			}
		}

		const handlePageShow = () => {
			if (wasRunningOnHide) {
				startTimer()
				flush()
			}
		}

		window.addEventListener('pagehide', handlePageHide)
		window.addEventListener('pageshow', handlePageShow)
	}

	return {
		start(): void {
			startTimer()
		},

		stop(): void {
			stopTimer()
		},

		schedule(atTimeSec: number, fn: ScheduledFn): void {
			queue.push({ at: atTimeSec, fn })
		},

		clear(): void {
			queue = []
		}
	}
}

```

### transport/audioHooks.ts
```typescript
export interface TransportAudioHooks {
	onStep(stepIndex: number, audioTime: number): void
}

```

### transport/transportEngine.ts
```typescript
import type { RenderClock } from '../clock/renderClock'
import type { Scheduler } from '../clock/scheduler'
import type { TransportConfig, TransportState } from './types'
import type { TransportAudioHooks } from './audioHooks'
export type TransportListener = (state: TransportState) => void

export interface TransportEngine {
	start(): void
	stop(): void
	setConfig(next: TransportConfig): void
	subscribe(listener: TransportListener): () => void
	tick(): void
}

const clampInt = (value: number): number => {
	if (!Number.isFinite(value)) {
		return 0
	}
	return Math.floor(value)
}



export function createTransportEngine(
	clock: RenderClock,
	scheduler: Scheduler,
	initial: TransportConfig,
	audioHooks?: TransportAudioHooks
	): TransportEngine {
		let cfg: TransportConfig = initial

		let isPlaying = false
		let startTimeSec = 0
		let lastStep = -1
		let lastAbsoluteStep = -1

		const listeners = new Set<TransportListener>()
		const stepDurationSec = (): number => {
		const stepsPerBar = Math.max(1, cfg.gridSpec.division)
		const beatsPerBar = 4
		const beatsPerStep = beatsPerBar / stepsPerBar
		const secPerBeat = 60 / Math.max(1, cfg.bpm)
		return beatsPerStep * secPerBeat
		}
  
		const totalSteps = (): number => {
			const steps = cfg.gridSpec.bars * cfg.gridSpec.division
			return Math.max(0, clampInt(steps))
		}

		const normalizeStep = (step: number): number => {
			const steps = Math.max(totalSteps(), 1)
			return ((step % steps) + steps) % steps
		}

		const swingOffsetSec = (stepIndex: number): number => {
		const swing = cfg.swing ?? 0
		if (swing <= 0) {
			return 0
		}

		// apply swing to off-beats only
		const isOffBeat = stepIndex % 2 === 1
		if (!isOffBeat) {
			return 0
		}

		return stepDurationSec() * swing * 0.5
	}

	const emit = (): void => {
		const steps = Math.max(totalSteps(), 1)
		const normalized = ((lastStep % steps) + steps) % steps

		const state: TransportState = {
			isPlaying,
			currentStep: normalized
		}

		for (const listener of listeners) {
			listener(state)
			}
		}
    
		const computeAbsoluteStepAt = (timeSec: number): number => {
			const dur = stepDurationSec()
			const raw = (timeSec - startTimeSec) / dur
			return clampInt(raw)
		}

		let lastScheduledStep = -1

		const scheduleStepBoundary = (stepIndexAbsolute: number): void => {
			if (stepIndexAbsolute === lastScheduledStep) {
				return
			}

			const normalizedStep = normalizeStep(stepIndexAbsolute)
			lastScheduledStep = stepIndexAbsolute

			const stepTimeSec =
				startTimeSec +
				stepIndexAbsolute * stepDurationSec() +
				swingOffsetSec(normalizedStep)

			scheduler.schedule(stepTimeSec, (audioTime) => {
				audioHooks?.onStep(normalizedStep, audioTime)
			})
		}


		const advance = (): void => {
			const now = clock.audioTime()
			const currentAbsolute = computeAbsoluteStepAt(now)
			const current = normalizeStep(currentAbsolute)

			if (current !== lastStep) {
				lastStep = current
				lastAbsoluteStep = currentAbsolute
				scheduleStepBoundary(lastAbsoluteStep + 1)
				emit()
			}
		}

	return {
		start(): void {
			if (isPlaying) {
				return
			}
			isPlaying = true
			startTimeSec = clock.audioTime()
			lastStep = -1
			lastAbsoluteStep = -1
			lastScheduledStep = -1
			scheduler.clear()
			scheduler.start()
			lastAbsoluteStep = computeAbsoluteStepAt(startTimeSec)
			lastStep = normalizeStep(lastAbsoluteStep)
			emit()
			scheduleStepBoundary(lastAbsoluteStep + 1)
		},

		stop(): void {
			if (!isPlaying) {
				return
			}
			isPlaying = false
			scheduler.stop()
			scheduler.clear()
			lastStep = -1
			lastScheduledStep = -1
			emit()
		},

		setConfig(next: TransportConfig): void {
			cfg = next
			// Re-normalize immediately
			if (isPlaying) {
				// Keep phase consistent by resetting start time to "now - currentStep * dur"
				const now = clock.audioTime()
				const dur = stepDurationSec()
				const steps = Math.max(totalSteps(), 1)
				const current = ((lastStep % steps) + steps) % steps
				startTimeSec = now - lastAbsoluteStep * dur - swingOffsetSec(current)
				scheduler.clear()
				lastScheduledStep = -1
				lastAbsoluteStep = computeAbsoluteStepAt(now)
				lastStep = normalizeStep(lastAbsoluteStep)
				scheduleStepBoundary(lastAbsoluteStep + 1)
			} else {
				lastScheduledStep = -1
			}
			emit()
		},

		subscribe(listener: TransportListener): () => void {
			listeners.add(listener)
			// emit current snapshot immediately
			listener({
				isPlaying,
				currentStep: Math.max(0, lastStep)
			})
			return (): void => {
				listeners.delete(listener)
			}
		},

		tick(): void {
			if (!isPlaying) {
				return
			}
			advance()
		}
	}
}

```

### transport/types.ts
```typescript
import type { DrumPadId } from '@/types/drums'
// Update the import path below to the correct relative path where GridSpec is defined
import type { GridSpec } from '@/types/time'
// Or adjust the path as needed based on your project structure

export interface TransportState {
	readonly isPlaying: boolean
	readonly currentStep: number
}

export type StepTogglePayload = {
	barIndex: number
	stepInBar: number
	padId: DrumPadId
}

export interface TransportConfig {
	readonly bpm: number
	readonly gridSpec: GridSpec
	swing?: number
}

```

### velocity/velocityToGain.ts
```typescript
export function velocityToGain(
	velocity: number,
	minGain = 0.15
): number {
	// velocity expected in [0, 1]
	const v = Math.max(0, Math.min(1, velocity))

	// psychoacoustic-friendly curve
	const curved = v * v

	return minGain + (1 - minGain) * curved
}

```



=========================================
File: LICENSE
=========================================

MIT License

Copyright (c) 2025 Markus Tratschitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



=========================================
File: README 2.md
=========================================

# Drumcomputer


=========================================
File: README.md
=========================================

# Drumcomputer

Nuxt 4 drum machine using Vue 3 Options API + TypeScript strict, Vuetify 3 (Pug + Less), Web Audio lookahead scheduling, Web MIDI capability checks, and IndexedDB stubs for soundbanks.

![UI screenshot](assets/screenshots/Video%20Screen1766291171020.png)

## Maschine MK3 UI Parity Plan (2026-01-04)

- **No-scroll full-screen shell**: Lock the hardware wrapper to `100vh` with inner flex grids only; push any overflow (sound/FX/pattern drawers) into internal scroll areas and clamp paddings/margins so a 1080p viewport fits without page scroll.
- **Layout map (placeholders first)**: Dual displays with 8 soft buttons on top, 8 screen knobs below, 4D encoder + master/volume knob cluster and nav buttons between displays, transport cluster bottom-left, left column for mode buttons (Scene/Pattern/Events/Variation/Duplicate/Select/Mute/Solo) plus Shift, right column for touch strip + pad mode buttons (Keyboard/Chord/Step/Note Repeat), 4Ã—4 pads on the right, performance LEDs, and a small meter/pad bank indicator row.
- **Button symbols + hover hints**: Use consistent symbols and `title`/tooltip hints on every control. Proposed symbols: Play â–¶, Stop â– , Rec â—, Restart â†», Loop âŸ³, Count-In â™©, Tap Tempo â˜¼, Metronome â™¬, Follow â‡¥, Pad Bank â—ª, Duplicate â§‰, Select â˜, Mute ğŸ”‡, Solo âš¡, Scene â–¤, Pattern â–¦, Events âœ±, Variation â‰ˆ, Keyboard âŒ¨, Chords â™«, Step â—«, Note Repeat âœº, Shift â‡§, 4D encoder arrows â†•â†”, Touch Strip â‰¡.
- **Placeholder components to scaffold**: `DualDisplayPlaceholder` (dual LCD mock with soft-label text), `SoftButtonStripPlaceholder`, `ScreenKnobRingPlaceholder` (shows detents + hover hint), `FourDEncoderPlaceholder`, `TransportClusterPlaceholder`, `ModeColumnPlaceholder`, `TouchStripPlaceholder`, `PadBankIndicator`, `PerformanceMeterPlaceholder`, `OverlayHint` (hover helper for any element), and `DrawerPanelFrame` with fixed height for scroll containment.
- **Interaction & hover behavior**: Every element should expose a hover hint describing primary + shift-layer functions; knobs/buttons trigger placeholder overlays that can later be wired to real handlers. Touching/hovering a screen knob opens a selector overlay mock; encoder hover shows navigation arrows + confirm hint; transport buttons expose play/stop/reset semantics.
- **Sizing refactor plan**: Reduce outer gutters, use CSS `clamp()` for hardware widths/heights, pin pad square to max 640px with responsive shrink, align display + knob rows to match MK3 proportions, and keep drawers at a fixed height (e.g., 360px) with internal scroll so the main stage never scrolls.

## Setup

```bash
npm install
npm run dev
# QA
npm run lint
npm run typecheck
```

To override the dev or HMR port, prefix the command with the env vars you need:
```bash
PORT=3001 HMR_PORT=24679 npm run dev
```

## Use Cases

- Build and rehearse drum patterns live: tap pads, quantized record hits, and loop transport with velocity cycling and pad focus for performance.
- Arrange song ideas with scenes and pattern chains: switch patterns at bar boundaries and normalize grid specs when divisions change.
- Customize soundbanks: swap pad samples from local files, persist banks/patterns in IndexedDB/LocalStorage, and rehydrate blobs on load.
- Connect hardware: map pads and transport to MIDI notes, follow or drive MIDI clock, and probe WebMIDI/Audio input capabilities in the UI.
- Export mixes or stems: bounce the current scene chain to WAV/ZIP with deterministic FX seeds and optional per-pad stems for downstream DAWs.
- Normalize/import assets: round-trip patterns via JSON/MIDI, import/export soundbank manifests + blobs, and clamp malformed payloads.

## Features

- Lookahead Web Audio scheduler with AudioContext time, quantized live recording, and 16-pad grid sequencing.
- Default kit served from `public/samples` and auto-loaded into the audio engine; patterns persist via LocalStorage (v1 schema with normalization).
- Pinia stores for transport, patterns/scenes, session caps, and soundbanks; composables for audio, scheduler, sequencer, MIDI, sync, import/export, audio input, and IndexedDB soundbank storage (banks, samples, patterns).
- Client-only MIDI hooks with device selection, pad mapping, and MIDI clock support (master/slave) plus Ableton Link stub exposure via sync panel.
- Soundbank manager can select banks and replace pad samples (stored as blobs in IndexedDB) with lazy decoding; patterns also persisted per-bank in IDB.
- Configurable step grid divisions (1/2/4/8/16/32/64) with responsive layout for larger sequences and stable transport start/stop handling.
- Import/Export helpers for patterns, MIDI (@tonejs/midi), soundbank manifests + sample blobs, and WAV bounce via OfflineAudioContext.
- Scene chains with bar-boundary pattern switching, per-step velocity/accent cycling, and an FX chain (filter/drive/reverb) routed through the WebAudio graph.

## Control Area (MK3)

- Pinia store `stores/control.ts` owns modes, per-mode pages, soft buttons, encoder parameters, and display models; DrumMachine wires it without changing layout.
- Mode buttons fire primary and SHIFT secondary actions (e.g., CHANNELâ†’MIDI, PLUGINâ†’Instance, BROWSERâ†’Plug-in menu, FILEâ†’Save As, MACROâ†’Set). Page â—€/â–¶ steps through pages within the active mode.
- SoftButtonStrip renders 8 dynamic labels/tooltips per page and emits press events; display soft labels mirror the current soft buttons.
- DualDisplay renders contextual panels for Browser, File, Settings, Sampling, Mixer, Arranger, and info views; header shows mode + page.
- Encoders react to mousewheel on hover and arrow keys; SHIFT enables fine step. SHIFT hold is de-latched via global pointer/key listeners; knobs expose tabindex + aria-label.

## Analysis & Plan

- **Current gaps**: Pattern/scene editing UIs are not mounted on `pages/index.vue`; transport lacks full MK3 semantics; placeholder overlays for soft buttons/encoders/4D are not wired; accessibility coverage is partial.
- **To close parity**: Restore sequencer UI (StepGrid/StepCell) and mount Patterns/Export/TabPanel; bring transport to MK3 semantics (play/stop toggle, stop-reset, restart, count-in, tap tempo, follow/metronome controls, loop range adjust); add grid/loop UX and erase panels; surface channel/plug-in/macro/midi control modes with soft labels; wire selector overlays to 4D/soft buttons; ensure a11y labels and focus flows.

## Timing & Sync

- AudioContext is the sole clock authority; the lookahead scheduler, sequencer, and MIDI clock master all derive their timings from `AudioContext.currentTime`.
- A small `RenderClock` wrapper now feeds every scheduler/step planner from the shared `scheduleStep` helper so live playback and future offline renders can work off the same time basis.
- MIDI clock output follows the audio clock (scheduled via the lookahead worker); incoming MIDI clock only drives phase counters/start-stop follow and never retimes audio events.
- BPM updates are clamped and restored on sync mode/role changes to prevent drift when switching between internal and MIDI clock roles; transport BPM remains the master source.

## Workflow & UX

- Undo/redo history for pattern + scene edits (50 steps), persisted alongside scenes/pattern selection.
- Capability gates surface WebMIDI/Audio In support status directly in the UI.
- Importers normalize grid specs/velocities and soundbank manifests to handle malformed payloads more gracefully.

## Layout Notes

- Viewport locked, drawer scrolls internally.

## Browser support / limitations

- Web MIDI only over HTTPS/localhost after user permission; device lists stay empty when unsupported.
- Audio input uses `getUserMedia`; user denial disables monitoring/capture.
- AudioContext needs a user gesture before it can play in some browsers; first pad tap will resume the context.
- Background throttling can delay scheduled steps despite lookahead; keep tab focused for tight timing.

## BFCache Compatibility

- Web Audio: AudioContext is suspended on `pagehide` and resumed on `pageshow` to avoid active audio blocking BFCache restores.
- Media Input: Microphone streams and their AudioContext are stopped/closed on `pagehide`.
- MIDI: Device listeners detach on `pagehide` and reattach/refresh on `pageshow` when access is available.
- Scheduling: Lookahead intervals for sequencer/sync pause on `pagehide` and restart on `pageshow` when they were running.

## Deterministic FX & Export

- The FX chain now derives from a serializable `FxSettings` snapshot and only applies filter/drive/reverb updates via `setValueAtTime`, making the graph stable for live and rendered sessions alike.
- The convolution impulse uses the new seeded RNG helper, and the audio engine exposes `getFxSnapshot`/`setFxRandomSource` so exports can rebuild identical FX + randomness when supplied with the same seed.
- The offline WAV export now runs through the same `RenderClock` + `scheduleStep` loop as live playback, rebuilds the FX graph from the current `FxSnapshot`, and seeds the impulse response via `createSeededRandom`. `exportAudio` returns a `RenderMetadata` payload (seed, bpm, grid spec, scene/pattern chain, duration) andâ€”when `import.meta.env.DEV`â€”an optional debug timeline so the UI can attach a JSON blob alongside the WAV.
- To reproduce a bounce, pass the recorded `seed` back into `exportAudio` (or rehydrate the FX snapshot that produced it) so the same impulse response + scheduling is rebuilt; the metadata blob makes pairing the WAV with its deterministic context easy for debugging or downstream tooling.

### Export metadata UI
The Export audio card sits under the soundbank/Fx controls and invokes `exportAudio` for the current scene chain. Once the bounce finishes, the metadata panel appears below the export button and exposes the seed, BPM, grid spec, scene/pattern chain, event count, and rendered duration. Use the panel buttons to download the WAV/JSON, inspect the dev timeline (visible only in `process.dev`), or copy the seed for later replays.

### Reproducing exports with the seed
Copy the exported seed from the metadata panel (or the JSON blob) and supply it to `exportAudio(renderDuration, sampleRate, { seed: Number(seedValue) })` together with the scene's FX snapshot/grid spec, and the offline render will replay the exact same randomness, FX response, and scheduling that produced the mixdown.

## Recent Fixes / Stability & Diagrams

- PadGrid: Removed stray `button.pad-cell`; focus restore now uses stable PadCell refs to avoid runtime errors.
- TransportEngine: Scheduler is cleared/reseeded on config changes; step boundaries use absolute steps with wrap guards so tempo/division changes do not produce double/missed triggers.
- Docs: Mermaid diagrams fixed (valid IDs/arrows, GitHub-compatible).

## Feature Branch Changes (fix/padgrid-transport-scheduler-and-diagrams)

- Slot-based DrumMachine hardware with separate slots for transport, pads, and drawer; index layout slimmed down to `v-app` + slots.
- PadGrid refactor: per-cell pad refs, new keyboard navigation, and key labels introduced (currently not rendered).
- Drawer/panel stack re-ordered (Sound/FX/Patterns/Export), TransportBar styled with BPM/Division/Loop controls, global color/spacing variables and Nuxt global styles added.
- MIDI layer streamlined: mapping/learn persisted, simpler MIDI status access, layout metadata cleaned up.
- Sequencer components (`StepGrid.vue`, `StepCell.vue`) removed from the build; only Markdown stubs remain, so the UI currently renders pads/transport/FX only.

## Diagrams

- Transport timing: `diagrams/transport-engine.md`
- UI sequencer flow: `diagrams/ui-sequencer.md`
- Persistence + audio pipeline: `diagrams/persistence-and-audio.md`
- Control area mapping: `diagrams/control-area-mapping.md`

## Current UI / Editing State

- 16-pad surface shows three states (selected, currently triggered at the playhead, or playing anywhere in the pattern) and derives pad labels from the active soundbank.
- Step toggles cycle velocity levels 0.7 â†’ 1.0 â†’ 1.25 â†’ off; accents (>=1.25) are tinted in the grid, and the playhead overlay tracks the normalized step even when looping.
- Patterns + scenes are stored in LocalStorage (v2 schema with selected/active ids) and a 50-step undo/redo history guards edits; scene playback always prepares the first scene pattern before transport start or external sync start.
- Scene chains advance at pattern boundaries and honor normalized grid specs when divisions change, so transport + sequencer stay aligned.

## Soundbanks & Persistence

- A default kit seeds four kicks/snares/hihats/claps across 16 pads; if no banks exist on load the bank is saved to IndexedDB and selected automatically.
- Soundbanks, samples (blobs), and per-bank pattern copies are persisted to IndexedDB (v2 database with soundbanks/samples/patterns stores); samples are rehydrated from blobs on load.
- Replacing a pad sample infers the format from the filename, revokes old blob URLs, updates the sequencer in place, and writes both the bank metadata and the blob to IDB.
- Soundbank import/export supports manifest JSON + sample files; pad assignments are hydrated against the manifest ids so banks can round-trip with external files.

## Import/Export Surface

- Pattern JSON import/export + MIDI import/export (tonejs/midi) are wired through `useImportExport`; MIDI uses the current mapping and pulls velocity into step velocities.
- Offline export now optionally renders per-pad stems (only for pads that have a sample in the current cache) alongside the mixdown; stem file names are slugged from the scene/bank name.
- `exportAudio` auto-downloads the mixdown WAV, returns metadata + optional debug timeline, and the Export panel exposes buttons for WAV, ZIP bundle (mixdown + render-meta + stems), or individual/all stems.
- Export duration is derived from the active scene's pattern chain (bars Ã— division) so renders match the current arrangement at the time you press Export.

## Roadmap

- Stabilize transport scheduling: normalize queued step indices across loops, clear/reseed scheduler queues on config changes, and extend tests for swing + lookahead edge cases.
- Fix PadGrid focus/activation: remove the stray root button or wire it correctly, attach `ref`s to `PadCell` for focus restoration, and add keyboard-focus tests.
- Expand automated coverage: integrate component tests for `PadGrid`/`StepGrid` interactions and regression tests around transport start/stop/reconfigure flows.
- UX polish: expose scheduler/debug timelines in dev mode, improve empty-state messaging for pads without a selected bank/pad, and add ARIA labels around sequencing controls.
- Stretch: FX chain enhancements (filter/drive) and an extended sample browser with drag/drop and manifest previews.

## Code Review Findings (2026-01-04)

- `pages/index.vue`: Main slot renders a blank placeholder and mounts only transport/pads/FX; there is no scaffold for displays, soft buttons, encoder, mode clusters, touch strip, or hover hints, so MK3 parity cannot be reached without adding new slots/components.
- `components/DrumMachine.vue`: The hardware shell is fixed to a two-column transport+drawer vs. pads layout with clamped widths; adding the MK3 top displays, left/right button columns, and touch strip would currently overflow and reintroduce page scroll. Needs a size refactor and new placeholder regions.
- `components/TransportBar.vue`: Transport buttons rely solely on icons, have no hover hints/tooltips, and miss MK3 semantics (play/stop toggle, stop-reset, shift+rec count-in, restart). The dense vertical stack will not fit once displays/soft buttons are added.
- `components/PadGrid.vue`: Pads expose neither tooltips nor pad labels/LED hints in the UI. `is-empty` derives from missing pad state rather than sample presence, so freshly loaded banks render as â€œemptyâ€ even when defaults exist.
- `components/PadGrid.vue`: KEY_LABELS are hard-coded to 16 entries; any future pad bank paging or alternate pad counts will desync labels and navigation unless the labels derive from the pads prop.

## Hardware Layout & UI Reference

### PadGrid (4Ã—4)
- 16 pads in a 4Ã—4 grid (pad1â€“pad16) with distinct states for selected, triggered (current step), and playing. Each PadCell is a native button.
- Accessibility: `aria-label` per pad, `aria-rowcount`/`aria-colcount`/`aria-rowindex`/`aria-colindex`, and `tabindex` in pad order; focus refs support keyboard focus moves. The pattern indicator sits next to the grid.

### Mode Buttons (left of PadGrid)
- Vertical stack of 8 mode buttons; sized to align with pad heights and the Softbutton 4 reference line above Display 1. Buttons expose `aria-label`/`title` and keyboard focus.

### Fixed Velocity + Pad Mode (top row)
- Fixed Velocity plus PAD MODE/KEYBOARD/CHORD/STEP row aligned to the Softbutton row above Display 2 as the horizontal reference.

### Softbutton references
- Softbutton 4 above Display 1 defines the vertical alignment line for the mode column. The softbutton row above Display 2 defines the horizontal reference for Fixed Velocity and Pad Mode buttons (see `diagrams/padgrid-modus-layout.md`).

### Accessibility
- PadGrid: ARIA grid metadata, labels, and focusable buttons.
- Mode/Pad-Mode/Fixed-Velocity buttons: native button semantics with labels/titles and consistent tab order.
- Softbuttons remain labeled reference points for screen readers to understand spatial layout.

### TransportBar
- Standalone transport/pattern/step control component. Props include `bpm`, `division`/`divisions`, `loop`, `patternBars`, `presetBars`/`presetDivision`, `selectedPad`, and flags (`isPlaying`, `isRecording`, `countInEnabled`, `metronomeEnabled`, `followEnabled`, `liveEraseEnabled`).
- Events cover transport (play/stop/stop-reset/restart), tempo (`update-bpm`, `increment-bpm`, `decrement-bpm`, `tap-tempo`), grid (`update-division`, `update-pattern-bars`, `update:preset-*`), loop (`update-loop`, `nudge-loop-range`, `update-loop-start`, `update-loop-end`), metronome/follow (`toggle-metronome`, `update:metronome-volume`, `toggle-follow`), count-in (`toggle-count-in`, `update-count-in-bars`), MIDI learn, and live erase (`toggle-live-erase`, `erase-pad`, `erase-current-step`). Buttons use native semantics plus `aria-label`/`title` for a11y/tooltips.

### Diagram
- Layout visualization with reference lines for dual displays, softbutton rows, mode column, Fixed Velocity/Pad Mode row, and PadGrid: see `diagrams/padgrid-modus-layout.md`.



=========================================
File: ROADMAP.md
=========================================

# Roadmap

Umsetzungsschwerpunkt: Sequencer- und Transport-FunktionalitÃ¤t reaktivieren, Bedienbarkeit der Pads verbessern, Export- und MIDI/Sync-Flows wieder anbinden und StabilitÃ¤t mit Tests absichern. Alle Schritte bleiben Code-agnostisch, nennen aber die erwarteten BerÃ¼hrungspunkte.

## Aktueller Stand (Kurzreview)
- UI zeigt nur Pads, Transport und FX (`pages/index.vue`, `components/DrumMachine.vue`); Pattern-/Scene- und Export-Panels sind auskommentiert/entfernt.
- Sequencer-Komponenten fehlen im Build (nur Markdown-Stubs fÃ¼r `StepGrid`/`StepCell`).
- Transport-Engine hat bekannte Scheduling-Probleme (Queue-Clear bei Config-Wechseln, Normalisierung von Step-Indizes) laut README-Findings.
- PadGrid besitzt Keyboard-Navigation, aber Labels/ARIA sind rudimentÃ¤r; Fokus-Handling hÃ¤ngt an `$refs`.
- Stores/Composables fÃ¼r Patterns, Soundbanks, MIDI, Sync, Import/Export und IDB sind vorhanden und werden in `DrumMachine` bereits verkabelt.

## Ziele
- Transport stabilisieren (Lookahead/Scheduler resilient gegenÃ¼ber BPM/Grid-Wechseln).
- Pad-Bedienbarkeit und Accessibility verbessern.
- Sequencer-GUI (Pattern/Scenes) reaktivieren und mit Transport koppeln.
- Export- und Import-Flows in der OberflÃ¤che zugÃ¤nglich machen.
- MIDI/Sync- und Capability-UI sichtbar und getestet.
- Basis-QA wiederherstellen (Lint, Typecheck, Unit/Component-Tests).

## Phasen & Arbeitspakete
1) **Transport & Scheduler hÃ¤rten**
   - `domain/transport/transportEngine.ts`: Scheduler-Queues bei Config-Wechseln leeren/reseed, Step-Indizes normalisieren (Modulo aktueller Grid-LÃ¤nge), Swing/Lookahead-E2E prÃ¼fen.
   - Tests ergÃ¤nzen (Unit fÃ¼r Scheduler/Transport, ggf. Mocks fÃ¼r AudioClock).
2) **PadGrid/PadCell UX**
   - Labels/Key-Labels sichtbar machen, leere Pads kennzeichnen; ARIA-Labeling anreichern.
   - Fokus-Handling absichern (Refs pro Pad, Tastatur-Navigation testen).
   - Component-Tests (`vitest` + `@vue/test-utils`) fÃ¼r Auswahl, Trigger, Keyboard.
3) **Sequencer/UI-Reaktivierung**
   - `StepGrid.vue`/`StepCell.vue` rekonstruieren oder aus Historie Ã¼bernehmen; Velocity-Cycling & Playhead-Overlay einbauen.
   - Pattern-/Scene-Panels (`PatternsPanel`, `TabPanel`) und Undo/Redo-Stores in `pages/index.vue` wieder mounten.
   - Integrations-Tests (mocha/jsdom) fÃ¼r Pattern-Edit, Scene-Wechsel an Taktgrenzen.
4) **Export/Import & FX**
   - ExportPanel montieren; Buttons fÃ¼r WAV/ZIP/Stems an `useImportExport`/`exportAudio` anbinden; Seed/Metadata-Anzeige sicherstellen.
   - FX-Panel gegen `FxSnapshot`/Seeded RNG prÃ¼fen; ggf. Debug-Timeline nur in DEV.
   - Smoke-Test fÃ¼r `exportAudio` (OfflineAudioContext mocken) und Download-Trigger.
5) **MIDI/Sync-OberflÃ¤che**
   - Panels fÃ¼r MIDI-Mapping, MIDI-Clock/Link (falls vorhanden) einhÃ¤ngen; Capability-Gates anzeigen.
   - Tests fÃ¼r Mapping-Persistenz und Clock-Rollen (master/slave) an Transport-Hooks.
6) **Persistenz & Soundbanks**
   - IDB-Stubs fÃ¼r Soundbanks/Samples/Patterns (v2) durch manuelle QA: Laden, Austauschen von Samples, Import/Export von Manifests.
   - Fallbacks/Fehlermeldungen fÃ¼r fehlende Berechtigungen oder ungÃ¼ltige Dateien.
7) **QA & Hardening**
   - Lint/Typecheck fixen, Component/Unit-Suites stabilisieren.
   - E2E-light: Manuelle Checkliste (AudioContext-Gate, BFCache pagehide/pageshow, Keyboard/Screenreader, Offline-Export).
   - Cleanup: `dist/`-Artefakte entfernen bevor gebaut wird; README aktualisieren nach UI-Restore.

## Test- und Validierungsplan
- `npm run lint`, `npm run typecheck`, `npm run test:components`, gezielte Mocha-Spezifikationen fÃ¼r Sequencer/Transport.
- Manuelle Matrix: Chrome/Firefox (HTTPS/localhost), MIDI unterstÃ¼tzt/nicht unterstÃ¼tzt, AudioContext-Gate (erste User-Geste), BFCache-Resume.
- Export-Replay: Seed aus Metadata zurÃ¼ckspielen und Render-Konsistenz prÃ¼fen.

## Risiken & GegenmaÃŸnahmen
- **AudioContext/MIDI Berechtigungen**: UI-Gates und klare Prompts, Fallback auf interne Clock.
- **Scheduler-Drift bei Config-Wechseln**: Testabdeckung fÃ¼r Loop-Wrap + Swing; Clear/Reseed sicherstellen.
- **UI-Scope-Creep**: Panels schrittweise mounten (Transport/Pads â†’ Sequencer â†’ Export/MIDI), jeweils Regressionstests vor dem nÃ¤chsten Schritt.
- **Persistenz-Migrationen**: IDB-Versionierung prÃ¼fen, defensives Normalisieren von geladenen Patterns/Soundbanks.

## Offene Fragen
- Sollen Sequencer-Komponenten aus einer frÃ¼heren Revision Ã¼bernommen werden oder neu gebaut?
- Welche Browser-Zielmatrix ist verpflichtend (insb. Safari/Mobile)?
- Bedarf es einer vereinfachten Export-Pipeline (nur Mixdown) fÃ¼r MVP?



=========================================
File: StepCell.md
=========================================

```vue
<template lang="pug">
  client-only(tag="div")
    button.step-cell(
      type="button",
      :class="cellClasses",
      :aria-pressed="isActive",
      @click="onToggle",
      @pointerdown="onPointerDown",
      @pointermove="onPointerMove",
      @pointerup="onPointerUp",
      @pointercancel="onPointerCancel",
      )
      span.step-tag {{ displayLabel }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'StepCell',

  props: {
    isAccent: {
      type: Boolean,
      required: false,
      default: false
    },
    isActive: {
      type: Boolean,
      required: false,
      default: false
    },
    isCurrent: {
      type: Boolean,
      required: false,
      default: false
    },
    displayLabel: {
      type: String,
      required: false,
      default: ''
    }
  },

    emits: [
    'cell:toggle',
    'cell:pointerdown',
    'cell:pointermove',
    'cell:pointerup',
    'cell:pointercancel'
  ],
  
  computed: {
    cellClasses(): Record<string, boolean> {
      return {
        'is-active': this.isActive,
        'is-accent': this.isAccent,
        'is-current': this.isCurrent
      }
    }
  },
  methods: {
    onToggle(): void {
      this.$emit('cell:toggle')
    },
    onPointerDown(event: PointerEvent): void {
      if (event.currentTarget instanceof HTMLElement) {
        event.currentTarget.setPointerCapture(event.pointerId)
      }
      this.$emit('cell:pointerdown', event)
    },
    onPointerMove(event: PointerEvent): void {
      this.$emit('cell:pointermove', event)
    },
    onPointerUp(event: PointerEvent): void {
      this.$emit('cell:pointerup', event)
    },
    onPointerCancel(event: PointerEvent): void {
      this.$emit('cell:pointercancel', event)
    }
  }
})
</script>

<style lang="less" scoped>
@import '@/styles/variables.less';
.step-cell {
  border: none;
  border-radius: @radius-s;
  background: fade(@color-accent-primary, 15%);
  color: @color-text-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: @font-size-xs;
  padding: @space-xs 0;
  transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
  position: relative;
  cursor: pointer;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  z-index: 1;

  &:not(.is-active):hover {
    background: fade(@color-accent-primary, 25%);
  }

  &:active {
    transform: scale(0.97);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px fade(@color-accent-primary, 60%);
  }

  &.is-active {
    background: fade(@color-accent-primary, 15%);
  }

  &.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 25%),
      fade(@color-accent-warning, 65%)
    );
  }

  &.is-active.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 35%),
      fade(@color-accent-primary, 35%)
    );
  }

  &.is-current {
    box-shadow: inset 0 0 0 2px fade(@color-accent-primary, 90%);
  }

  &.is-accent.is-current {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
    animation: accent-scan-pulse 160ms ease-out 1;
  }
}

.step-tag {
  font-size: @font-size-xs;
  letter-spacing: @letter-spacing-tight;
}

@keyframes accent-scan-pulse {
  from {
    transform: scale(1.02);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 95%),
      0 0 16px fade(@color-accent-warning, 38%);
  }
  to {
    transform: scale(1);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
  }
}
</style>
```


=========================================
File: StepGrid.md
=========================================

```vue
<template lang="pug">
  client-only(tag="div")
    .step-grid-shell(
      role="grid"
      :aria-label="stepGridLabel"
      :aria-colcount="totalSteps"
      tabindex="0"
      @keydown="onKeydown"
      ref="shell"
    )
      .step-row(role="row")
        StepCell(
          v-for="stepIndex in totalSteps"
          :key="stepIndex"
          :display-label="String(stepIndex)"
          :is-active="isActive(stepIndex - 1)"
          :is-accent="isAccent(stepIndex - 1)"
          :is-current="isCurrent(stepIndex - 1)"
          :class="{ 'is-pattern-start': isPatternStart(stepIndex - 1) }"
          role="gridcell"
          :aria-label="cellAriaLabel(stepIndex - 1)"
          :aria-selected="isActive(stepIndex - 1)"
          @cell:toggle="emitToggle(stepIndex - 1)"
          @cell:pointerdown="onCellPointerDown(stepIndex - 1, $event)"
          @cell:pointermove="onCellPointerMove($event)"
          @cell:pointerup="onCellPointerUp($event)"
          @cell:pointercancel="onCellPointerCancel($event)"
        )
        div.pattern-boundary(
          v-for="boundary in patternBoundaries"
          :key="boundary"
          :style="boundaryStyle(boundary)"
        )
        PlayheadOverlay(
          v-if="totalSteps > 0"
          :current-step="currentStepNormalized"
          :total-steps="totalSteps"
          :is-playing="isPlaying"
        )
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import StepCell from './StepCell.vue'
import PlayheadOverlay from './PlayheadOverlay.vue'
import type { GridSpec } from '@/types/time'
import type { DrumPadId, StepGrid } from '@/types/drums'
import { ACCENT_STEP_VELOCITY, clampVelocity } from '@/domain/velocity'

export default defineComponent({
  name: 'StepGrid',
  components: {
    StepCell,
    PlayheadOverlay
  },
  props: {
    gridSpec: { type: Object as () => GridSpec, required: true },
    steps: { type: Object as () => StepGrid, required: true },
    patternChain: {
      type: Array as () => Array<{ id: string; bars: number }> | null,
      default: null
    },
    selectedPad: { type: String as () => DrumPadId | null, default: null },
    currentStep: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true }
  },
  emits: ['step:toggle', 'playhead:scrub', 'step:velocity'],
  data() {
    return {
      dragState: null as null | {
        pointerId: number
        startY: number
        startVelocity: number
        stepIndex: number
      }
    }
  },
  computed: {
    totalSteps(): number {
      return Math.max(0, this.gridSpec.bars * this.gridSpec.division)
    },
    currentStepNormalized(): number {
      const steps = Math.max(this.totalSteps, 1)
      return ((this.currentStep % steps) + steps) % steps
    },
    stepGridLabel(): string {
      return this.selectedPad ? `Steps for ${this.selectedPad}` : 'Step grid'
    },
    patternBoundaries(): number[] {
      if (!this.patternChain || this.patternChain.length === 0) {
        return []
      }

      const boundaries: number[] = []
      const stepsPerBar = this.gridSpec.division
      let cumulative = 0

      this.patternChain.forEach((entry, index) => {
        cumulative += entry.bars * stepsPerBar
        if (index === this.patternChain!.length - 1) {
          return
        }
        if (cumulative < this.totalSteps) {
          boundaries.push(cumulative)
        }
      })

      return boundaries
    }
  },
  methods: {
    focusGrid(): void {
      const el = this.$refs.shell as HTMLElement | undefined
      el?.focus()
    },
    resolveStepPosition(index: number): { barIndex: number; stepInBar: number } {
      const barIndex = Math.floor(index / this.gridSpec.division)
      const stepInBar = index % this.gridSpec.division
      return { barIndex, stepInBar }
    },

    emitToggle(index: number): void {
      if (!this.selectedPad) {
        return
      }

      const { barIndex, stepInBar } = this.resolveStepPosition(index)

      this.$emit('step:toggle', {
        barIndex,
        stepInBar,
        padId: this.selectedPad
      })
    },

    velocityAt(index: number): number | null {
      if (!this.selectedPad) {
        return null
      }

      const { barIndex, stepInBar } = this.resolveStepPosition(index)

      return (
        this.steps[barIndex]?.[stepInBar]?.[this.selectedPad]?.velocity?.value ??
        null
      )
    },

    isActive(index: number): boolean {
      return this.velocityAt(index) !== null
    },

    isAccent(index: number): boolean {
      const velocity = this.velocityAt(index)
      const ACCENT_EPSILON = 0.01

      return (
        velocity !== null &&
        velocity >= ACCENT_STEP_VELOCITY - ACCENT_EPSILON
      )
    },

    isCurrent(index: number): boolean {
      return index === this.currentStepNormalized
    },

    onKeydown(event: KeyboardEvent): void {
      if (this.totalSteps <= 0) {
        return
      }

      const isArrowLeft = event.key === 'ArrowLeft'
      const isArrowRight = event.key === 'ArrowRight'

      if (!isArrowLeft && !isArrowRight) {
        return
      }

      event.preventDefault()

      const stepDelta = event.shiftKey ? this.gridSpec.division : 1
      const delta = isArrowLeft ? -stepDelta : stepDelta
      const steps = this.totalSteps
      const nextStep =
        ((this.currentStepNormalized + delta) % steps + steps) % steps

      this.$emit('playhead:scrub', { stepIndex: nextStep })
    },

    emitVelocity(index: number, velocity: number): void {
      if (!this.selectedPad) {
        return
      }
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      this.$emit('step:velocity', {
        barIndex,
        stepInBar,
        padId: this.selectedPad,
        velocity
      })
    },

    onCellPointerDown(index: number, event: PointerEvent): void {
      if (!this.selectedPad) {
        return
      }
      const startVelocity = this.velocityAt(index)
      if (startVelocity === null) {
        return
      }

      this.dragState = {
        pointerId: event.pointerId,
        startY: event.clientY,
        startVelocity,
        stepIndex: index
      }
    },

    onCellPointerMove(event: PointerEvent): void {
      if (!this.dragState || event.pointerId !== this.dragState.pointerId) {
        return
      }
      const deltaY = this.dragState.startY - event.clientY
      const VELOCITY_PER_PIXEL = 0.006
      const nextVelocity = clampVelocity(
        this.dragState.startVelocity + deltaY * VELOCITY_PER_PIXEL
      )
      this.emitVelocity(this.dragState.stepIndex, nextVelocity)
    },

    onCellPointerUp(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },

    onCellPointerCancel(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },

    cellAriaLabel(index: number): string {
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      const stepNumber = stepInBar + 1
      const barNumber = barIndex + 1
      const activeState = this.isActive(index) ? 'active' : 'inactive'
      return `Bar ${barNumber}, step ${stepNumber}, ${activeState}`
    },

    isPatternStart(index: number): boolean {
      if (!this.patternChain || this.patternChain.length === 0) {
        return false
      }
      if (index === 0) {
        return true
      }
      return this.patternBoundaries.includes(index)
    },

    boundaryStyle(startIndex: number): Record<string, string> {
      const leftPercent =
        this.totalSteps > 0 ? (startIndex / this.totalSteps) * 100 : 0
      return {
        left: `${leftPercent}%`
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.step-grid-shell {
  margin-top: 0;
  padding: 10px;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  position: relative;
  height: 100%;
  max-height: 96px;
  overflow: visible;
}

.step-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
  gap: 8px;
  position: relative;
  overflow: visible;

  >.playhead-overlay {
    pointer-events: none;
    z-index: 0;
  }

  >.step-cell {
    z-index: 1;
  }

  >.step-cell:nth-child(4n + 1) {
    border-left: 2px solid rgba(255, 255, 255, 0.12);
    padding-left: 12px;
  }

  >.step-cell.is-pattern-start {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-primary, 45%),
      0 0 10px fade(@color-accent-primary, 16%);
  }
}

.pattern-boundary {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  margin-left: -1px;
  background: linear-gradient(
    to bottom,
    fade(@color-accent-primary, 0%) 0%,
    fade(@color-accent-primary, 28%) 45%,
    fade(@color-accent-primary, 8%) 100%
  );
  pointer-events: none;
  z-index: 0;
}

@media (max-height: 820px) {
  .step-grid-shell {
    max-height: 88px;
    padding: 8px;
  }
}

@media (max-width: 640px) {
  .step-grid-shell {
    padding: 8px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(44px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 44px;
    padding: 10px 0;
    font-size: @font-size-xs;
  }
}

@media (max-width: 480px) {
  .step-grid-shell {
    padding: 6px;
    max-height: 80px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(48px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 48px;
    padding: 12px 0;
  }
}
</style>
```


=========================================
File: alleDateien.md
=========================================

# Dateien mit <style>-Block

- app.vue
- components/DrumMachine.vue
- components/PadCell.vue
- components/PadGrid.vue
- components/PlayheadOverlay.vue
- components/StepGrid.vue
- components/TabPanel.vue
- components/TransportBar.vue
- components/panels/ExportPanel.vue
- components/panels/FxPanel.vue
- components/panels/PatternsPanel.vue
- components/panels/SoundPanel.vue
- layouts/default.vue


  div(style="color:white; padding:20px;")
  .drumshell
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    .hardware-top
      TransportBar(
        :bpm="bpm"
        :isPlaying="isPlaying"
        :loop="transport.loop"
        :division="gridSpec.division"
        :divisions="divisions"
        @play="start"
        @stop="stop"
        @bpm:update="updateBpm"
        @loop:update="setLoop"
        @division:update="setDivision"
      )

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    .main-shell
      .pads-panel
        PadGrid(
          :pads="pads"
          :selected-pad="selectedPadId"
          :pad-states="padStates"
          @pad:down="handlePad"
          @pad:select="selectPad"
        )

      .sequencer-panel
        StepGrid(
          :grid-spec="gridSpec"
          :steps="pattern.steps"
          :selected-pad="selectedPadId"
          :current-step="currentStep"
          :is-playing="isPlaying"
          @step:toggle="toggleStep"
        )

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DRAWER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    .drawer-wrapper
      .drawer-scroll
        TabPanel(v-model="drawerTab")
          template(#sound)
            SoundPanel(
              :banks="banks"
              :selected-bank-id="soundbanks.selectedBankId"
              @bank:select="selectBank"
              @pad:replace="replacePadSample"
            )

          template(#fx)
            FxPanel(
              :fxSettings="sequencer.fxSettings"
              @fx:update="updateFx"
            )

          template(#patterns)
            PatternsPanel(
              :patterns="patterns.patterns"
              :selected-pattern-id="patterns.selectedPatternId"
              :scenes="patterns.scenes"
              :active-scene-id="patterns.activeSceneId"
              @pattern:add="addPattern"
              @pattern:select="selectPattern"
              @pattern:rename="renamePattern"
              @pattern:undo="undoPattern"
              @pattern:redo="redoPattern"
              @scene:add="addScene"
              @scene:update="updateScene"
              @scene:select="selectScene"
            )

          template(#export)
            ExportPanel(
              :isExporting="isExporting"
              :exportError="exportError"
              :exportMetadata="exportMetadata"
              :audioBlob="exportAudioBlob"
              :hasZipArtifacts="hasZipArtifacts"
              :stemEntries="stemEntries"
              @export="exportBounce"
              @download:mixdown="downloadMixdown"
              @download:zip="downloadZip"
              @download:stem="downloadStem"
              @download:stems="downloadAllStems"
            )



=========================================
File: app.vue
=========================================

<template>
  <NuxtLayout>
  </NuxtLayout>
</template>

<style lang="less">
@import '@/styles/variables.less';

html,
body,
#__nuxt {
  height: 100%;
  margin:0;
}

body {
  overflow: hidden;
}
.v-application {
  height: 100%;
  background: @color-bg-root;
}
</style>



=========================================
File: audio/engine/play/playStep.ts
=========================================

// Plays an AudioBuffer at a scheduled AudioContext time with a fixed gain stage.
export function playStepAt(
  ctx: AudioContext,
  buffer: AudioBuffer,
  atTime: number,
  gainValue = 1
): void {
  const source = ctx.createBufferSource()
  const gain = ctx.createGain()

  gain.gain.value = gainValue

  source.buffer = buffer
  source.connect(gain).connect(ctx.destination)

  source.start(atTime)
}



=========================================
File: audio/engine/stepResolver.ts
=========================================

import type { StepGrid, DrumPadId } from '../../types/drums'
import type { GridSpec } from '../../types/time'

export interface StepNote {
  buffer: AudioBuffer
  velocity: number
}

export function createStepNoteResolver(
  steps: StepGrid,
  gridSpec: GridSpec,
  buffersByPad: Record<DrumPadId, AudioBuffer>
): (stepIndex: number) => StepNote[] {
  return (stepIndex: number): StepNote[] => {
    const result: StepNote[] = []

    const barIndex = Math.floor(stepIndex / gridSpec.division)
    const stepInBar = stepIndex % gridSpec.division

    const step = steps[barIndex]?.[stepInBar]
    if (!step) {
      return result
    }

    ; (Object.entries(step) as [DrumPadId, { velocity: { value: number } }][])
      .forEach(([padId, note]) => {
        const buffer = buffersByPad[padId]
        if (!buffer) {
          return
        }

        result.push({
          buffer,
          velocity: note.velocity.value
        })
      })

    return result
  }
}



=========================================
File: audio/engine/transportAudioHooks.ts
=========================================

import { velocityToGain } from '../../domain/velocity/velocityToGain'

export function createTransportAudioHooks(
  ctx: AudioContext,
  getStepNotes: (stepIndex: number) => Array<{
    buffer: AudioBuffer
    velocity: number
  }>
) {
  return {
    onStep(stepIndex: number, audioTime: number): void {
      const notes = getStepNotes(stepIndex)

      for (const note of notes) {
        const gainValue = velocityToGain(note.velocity)

        const source = ctx.createBufferSource()
        const gain = ctx.createGain()

        gain.gain.value = gainValue

        source.buffer = note.buffer
        source.connect(gain).connect(ctx.destination)
        source.start(audioTime)
      }
    }
  }
}



=========================================
File: audio/fxGraph.ts
=========================================

import type { FxSettings } from '@/types/audio'
import type { RandomSource } from '@/utils/seededRandom'

export interface FxGraphNodes {
  fxInput: GainNode
  driveNode: WaveShaperNode
  filterNode: BiquadFilterNode
  dryGain: GainNode
  wetGain: GainNode
  reverbNode: ConvolverNode
  connected: boolean
}

export const createFxGraph = (ctx: BaseAudioContext): FxGraphNodes => ({
  fxInput: ctx.createGain(),
  driveNode: ctx.createWaveShaper(),
  filterNode: (() => {
    const node = ctx.createBiquadFilter()
    node.type = 'lowpass'
    return node
  })(),
  dryGain: ctx.createGain(),
  wetGain: ctx.createGain(),
  reverbNode: ctx.createConvolver(),
  connected: false
})

export const connectFxGraph = (graph: FxGraphNodes, masterGain: GainNode) => {
  if (graph.connected) return
  graph.fxInput.connect(graph.driveNode)
  graph.driveNode.connect(graph.filterNode)
  graph.filterNode.connect(graph.dryGain)
  graph.filterNode.connect(graph.reverbNode)
  graph.reverbNode.connect(graph.wetGain)
  graph.dryGain.connect(masterGain)
  graph.wetGain.connect(masterGain)
  graph.connected = true
}

export const updateFxGraph = (ctx: BaseAudioContext, graph: FxGraphNodes, snapshot: FxSettings, rng: RandomSource) => {
  const now = ctx.currentTime
  const frequencyValue = snapshot.filter.enabled ? snapshot.filter.frequency : ctx.sampleRate / 2
  graph.filterNode.frequency.setValueAtTime(frequencyValue, now)
  graph.filterNode.Q.setValueAtTime(snapshot.filter.q, now)

  const amount = snapshot.drive.enabled ? snapshot.drive.amount : 0
  graph.driveNode.curve = createDriveCurve(amount)

  const mix = snapshot.reverb.enabled ? snapshot.reverb.mix : 0
  graph.dryGain.gain.setValueAtTime(Math.max(0, 1 - mix), now)
  graph.wetGain.gain.setValueAtTime(Math.max(0, Math.min(1, mix)), now)

  if (snapshot.reverb.enabled) {
    if (!graph.reverbNode.buffer) {
      graph.reverbNode.buffer = createImpulseResponse(ctx, rng)
    }
  } else if (graph.reverbNode.buffer) {
    graph.reverbNode.buffer = null
  }
}

const createDriveCurve = (amount: number) => {
  const k = Math.max(0, amount) * 50 + 1
  const samples = 1024
  const curve = new Float32Array(samples)
  for (let i = 0; i < samples; i += 1) {
    const x = (i * 2) / samples - 1
    curve[i] = ((1 + k) * x) / (1 + k * Math.abs(x))
  }
  return curve
}

const createImpulseResponse = (ctx: BaseAudioContext, rng: RandomSource, duration = 1.2, decay = 2.5) => {
  const length = Math.max(1, Math.floor(ctx.sampleRate * duration))
  const impulse = ctx.createBuffer(2, length, ctx.sampleRate)
  for (let channel = 0; channel < impulse.numberOfChannels; channel += 1) {
    const channelData = impulse.getChannelData(channel)
    for (let i = 0; i < length; i += 1) {
      channelData[i] = (rng() * 2 - 1) * Math.pow(1 - i / length, decay)
    }
  }
  return impulse
}



=========================================
File: components/DrumMachine.vue
=========================================

<template>
    <div class="hardware-stage">
      <div class="device-hardware" aria-label="Maschine MK3 layout placeholder">
        <div class="top-row">
          <div class="control-stack">
            <div class="control-area">
              <div class="control-fixed" aria-label="Fixed control buttons">
                <div class="control-btn-grid" aria-label="Control buttons">
                  <button
                    class="control-btn r1 c1"
                    type="button"
                    :class="{ active: isActiveMode('CHANNEL') }"
                    :title="modeTooltip('CHANNEL', 'CHANNEL', 'MIDI')"
                    :aria-label="modeTooltip('CHANNEL', 'CHANNEL', 'MIDI')"
                    @click="handleModePress('CHANNEL', 'CHANNEL_MIDI')"
                  >
                    <span class="control-btn__main">CHANNEL</span>
                    <span class="control-btn__sub">MIDI</span>
                  </button>

                  <button
                    class="control-btn r1 c2"
                    type="button"
                    :class="{ active: isActiveMode('PLUGIN') }"
                    :title="modeTooltip('PLUGIN', 'PLUG-IN', 'Instance')"
                    :aria-label="modeTooltip('PLUGIN', 'PLUG-IN', 'Instance')"
                    @click="handleModePress('PLUGIN', 'PLUGIN_INSTANCE')"
                  >
                    <span class="control-btn__main">PLUG-IN</span>
                    <span class="control-btn__sub">Instance</span>
                  </button>

                  <button
                    class="control-btn r2 c1"
                    type="button"
                    :class="{ active: isActiveMode('ARRANGER') }"
                    :title="modeTooltip('ARRANGER', 'ARRANGER')"
                    :aria-label="modeTooltip('ARRANGER', 'ARRANGER')"
                    @click="handleModePress('ARRANGER')"
                  >
                    <span class="control-btn__main">ARRANGER</span>
                  </button>

                  <button
                    class="control-btn r2 c2"
                    type="button"
                    :class="{ active: isActiveMode('MIXER') }"
                    :title="modeTooltip('MIXER', 'MIXER')"
                    :aria-label="modeTooltip('MIXER', 'MIXER')"
                    @click="handleModePress('MIXER')"
                  >
                    <span class="control-btn__main">MIXER</span>
                  </button>

                  <button
                    class="control-btn r3 c1"
                    type="button"
                    :class="{ active: isActiveMode('BROWSER') }"
                    :title="modeTooltip('BROWSER', 'BROWSER', '+Plug-In')"
                    :aria-label="modeTooltip('BROWSER', 'BROWSER', '+Plug-In')"
                    @click="handleModePress('BROWSER', 'BROWSER_PLUGIN_MENU')"
                  >
                    <span class="control-btn__main">BROWSER</span>
                    <span class="control-btn__sub">+Plug-In</span>
                  </button>

                  <button
                    class="control-btn r3 c2"
                    type="button"
                    :class="{ active: isActiveMode('SAMPLING') }"
                    :title="modeTooltip('SAMPLING', 'SAMPLING')"
                    :aria-label="modeTooltip('SAMPLING', 'SAMPLING')"
                    @click="handleModePress('SAMPLING')"
                  >
                    <span class="control-btn__main">SAMPLING</span>
                  </button>

                  <button
                    class="control-btn control-btn--icon r4 c1"
                    type="button"
                    aria-label="Page backwards"
                    :title="pageButtonTitle('prev')"
                    @click="prevPage"
                  >
                    <span class="control-btn__main">â—€</span>
                  </button>

                  <button
                    class="control-btn control-btn--icon r4 c2"
                    type="button"
                    aria-label="Page forwards"
                    :title="pageButtonTitle('next')"
                    @click="nextPage"
                  >
                    <span class="control-btn__main">â–¶</span>
                  </button>

                  <button
                    class="control-btn r5 c1"
                    type="button"
                    :class="{ active: isActiveMode('FILE') }"
                    :title="modeTooltip('FILE', 'FILE', 'Save')"
                    :aria-label="modeTooltip('FILE', 'FILE', 'Save')"
                    @click="handleModePress('FILE', 'FILE_SAVE')"
                  >
                    <span class="control-btn__main">FILE</span>
                    <span class="control-btn__sub">Save</span>
                  </button>

                  <button
                    class="control-btn r5 c2"
                    type="button"
                    :class="{ active: isActiveMode('SETTINGS') }"
                    :title="modeTooltip('SETTINGS', 'SETTINGS')"
                    :aria-label="modeTooltip('SETTINGS', 'SETTINGS')"
                    @click="handleModePress('SETTINGS')"
                  >
                    <span class="control-btn__main">SETTINGS</span>
                  </button>

                  <button
                    class="control-btn r6 c1"
                    type="button"
                    :class="{ active: isActiveMode('AUTO') }"
                    :title="modeTooltip('AUTO', 'AUTO')"
                    :aria-label="modeTooltip('AUTO', 'AUTO')"
                    @click="handleModePress('AUTO')"
                  >
                    <span class="control-btn__main">AUTO</span>
                  </button>

                  <button
                    class="control-btn r6 c2"
                    type="button"
                    :class="{ active: isActiveMode('MACRO') }"
                    :title="modeTooltip('MACRO', 'MACRO', 'Set')"
                    :aria-label="modeTooltip('MACRO', 'MACRO', 'Set')"
                    @click="handleModePress('MACRO', 'MACRO_SET')"
                  >
                    <span class="control-btn__main">MACRO</span>
                    <span class="control-btn__sub">Set</span>
                  </button>
                </div>
              </div>
              <div class="control-core">
                <div class="soft-row">
                  <div class="soft-row-grid">
                    <SoftButtonStrip
                      :buttons="activeSoftButtons"
                      :shift-held="shiftHeld"
                      @press="pressSoftButton"
                    />
                  </div>
                </div>
                <div class="display-block">
                  <div class="display-grid">
                    <DualDisplay
                      :left-model="leftDisplayModel"
                      :right-model="rightDisplayModel"
                      :mode-title="activeMode"
                      :page-label="pageLabel"
                      :param-slots-left="paramSlotsLeft"
                      :param-slots-right="paramSlotsRight"
                    />
                  </div>
                  <div class="display-param-labels" aria-hidden="true">
                    <span class="param-label" :title="softLabels[0]">{{ softLabels[0] }}</span>
                    <span class="param-label" :title="softLabels[1]">{{ softLabels[1] }}</span>
                    <span class="param-label" :title="softLabels[2]">{{ softLabels[2] }}</span>
                    <span class="param-label" :title="softLabels[3]">{{ softLabels[3] }}</span>
                    <span class="param-label" :title="softLabels[4]">{{ softLabels[4] }}</span>
                    <span class="param-label" :title="softLabels[5]">{{ softLabels[5] }}</span>
                    <span class="param-label" :title="softLabels[6]">{{ softLabels[6] }}</span>
                    <span class="param-label" :title="softLabels[7]">{{ softLabels[7] }}</span>
                  </div>
                </div>
                <div class="knob-row" aria-label="8 encoders">
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 1: ${getParamName(0)}`"
                    @wheel.prevent="onKnobWheel(0, $event)"
                    @keydown="onKnobKey(0, $event)"
                  ></div>
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 2: ${getParamName(1)}`"
                    @wheel.prevent="onKnobWheel(1, $event)"
                    @keydown="onKnobKey(1, $event)"
                  ></div>
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 3: ${getParamName(2)}`"
                    @wheel.prevent="onKnobWheel(2, $event)"
                    @keydown="onKnobKey(2, $event)"
                  ></div>
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 4: ${getParamName(3)}`"
                    @wheel.prevent="onKnobWheel(3, $event)"
                    @keydown="onKnobKey(3, $event)"
                  ></div>
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 5: ${getParamName(4)}`"
                    @wheel.prevent="onKnobWheel(4, $event)"
                    @keydown="onKnobKey(4, $event)"
                  ></div>
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 6: ${getParamName(5)}`"
                    @wheel.prevent="onKnobWheel(5, $event)"
                    @keydown="onKnobKey(5, $event)"
                  ></div>
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 7: ${getParamName(6)}`"
                    @wheel.prevent="onKnobWheel(6, $event)"
                    @keydown="onKnobKey(6, $event)"
                  ></div>
                  <div
                    class="knob"
                    role="presentation"
                    tabindex="0"
                    :aria-label="`Encoder 8: ${getParamName(7)}`"
                    @wheel.prevent="onKnobWheel(7, $event)"
                    @keydown="onKnobKey(7, $event)"
                  ></div>
                </div>
              </div>
            </div>
            <div class="edit-area">
              <div class="encoder-slot">
                <FourDEncoderPlaceholder class="four-d-encoder" />
              </div>
              <div class="quick-edit-buttons" aria-label="Quick edit controls">
                <button class="quick-edit-btn control-btn" type="button">
                  <span class="control-btn__main">VOLUME</span>
                  <span class="control-btn__sub">Velocity</span>
                </button>
                <button class="quick-edit-btn control-btn" type="button">
                  <span class="control-btn__main">SWING</span>
                  <span class="control-btn__sub">Position</span>
                </button>
                <button class="quick-edit-btn control-btn" type="button">
                  <span class="control-btn__main">TEMPO</span>
                  <span class="control-btn__sub">Tune</span>
                </button>
              </div>
            </div>
            <div class="performance-vert">
              <button class="control-btn" type="button">
                <span class="control-btn__main">NOTE REPEAT</span>
                <span class="control-btn__sub">Arp</span>
              </button>
              <div class="performance-vert__spacer" aria-hidden="true"></div>
              <button class="control-btn" type="button">
                <span class="control-btn__main">LOCK</span>
                <span class="control-btn__sub">Ext Lock</span>
              </button>
            </div>

            <div class="performance-block">
              <div class="performance-btn-row">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PITCH</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">MOD</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PERFORMANCE</span>
                  <span class="control-btn__sub">Fx Select</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">NOTES</span>
                </button>
              </div>
              <div class="smart-strip" aria-hidden="true"></div>
              <div class="group-area">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">A</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">B</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">C</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">D</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">E</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">F</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">G</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">H</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="bottom-row">
          <div class="left-column">
            <div class="transport-area" title="Transport area (MK3-style)" aria-label="Transport area (MK3-style)">
              <div class="transport-grid">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">RESTART</span>
                  <span class="control-btn__sub">Loop</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">ERASE</span>
                  <span class="control-btn__sub">Replace</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">TAP</span>
                  <span class="control-btn__sub">Metro</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">FOLLOW</span>
                  <span class="control-btn__sub">Grid</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PLAY</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">REC</span>
                  <span class="control-btn__sub">Count In</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">STOP</span>
                </button>
                <button
                  class="control-btn"
                  type="button"
                  :class="{ active: shiftHeld }"
                  :title="shiftHeld ? 'SHIFT (held)' : 'SHIFT (hold for secondary actions)'"
                  aria-label="Hold to access secondary controls"
                  :aria-pressed="shiftHeld"
                  @pointerdown="onShiftDown"
                  @pointerup="onShiftUp"
                  @pointercancel="onShiftUp"
                  @pointerleave="onShiftUpIfPressed"
                >
                  <div class="shift-label">SHIFT</div>
                </button>
              </div>
            </div>
          </div>

          <div class="right-column">
            <div class="pad-top-buttons" aria-label="Pad top buttons">
              <button class="control-btn" type="button">
                <span class="control-btn__main">FIXED VELOCITY</span>
                <span class="control-btn__sub">16 Vel</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">PAD MODE</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">KEYBOARD</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">CHORDS</span>
              </button>
              <button class="control-btn" type="button">
                <span class="control-btn__main">STEP</span>
              </button>
            </div>
            <div class="pads-and-strip">
              <div class="mode-buttons" aria-label="Mode buttons">
                <button class="control-btn" type="button">
                  <span class="control-btn__main">SCENE</span>
                  <span class="control-btn__sub">Section</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">PATTERN</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">EVENTS</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">VARIATION</span>
                  <span class="control-btn__sub">Navigate</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">DUPLICATE</span>
                  <span class="control-btn__sub">Double</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">SELECT</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">SOLO</span>
                </button>
                <button class="control-btn" type="button">
                  <span class="control-btn__main">MUTE</span>
                  <span class="control-btn__sub">Choke</span>
                </button>
              </div>
              <div class="pads-column">
                <div class="pads-stack" title="Pad grid with bank indicators">
                  <div class="pads-square">
                    <slot name="pads" :props="padsSlotProps" />
                  </div>
                  <div class="pad-grid-indicator">
                    <span
                      v-for="i in gridCount"
                      :key="i"
                      :class="['indicator-dot', { active: currentGridIndex === i - 1 }]"
                      :aria-label="`Pad Bank ${i}`"
                      :title="`Pad Bank ${i}`"
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
    </div>
  </div>
</template>




<script lang="ts">
import { defineComponent } from 'vue'
import { saveAs } from 'file-saver'
import { DEFAULT_GRID_SPEC, GRID_DIVISIONS, normalizeGridSpec } from '@/domain/timing'
// Hosts the drum machine hardware layout and wires transport, pads, drawer panels, persistence, MIDI, sync, and export flows.
import { useTransportStore } from '@/stores/transport'
import { usePatternsStore } from '@/stores/patterns'
import { useSoundbanksStore } from '@/stores/soundbanks'
import { useSessionStore } from '@/stores/session'
import { useControlStore, type ControlMode } from '@/stores/control'
import { useSequencer } from '@/composables/useSequencer'
import { useSync } from '@/composables/useSync.client'
import { useMidi } from '@/composables/useMidi.client'
import { usePatternStorage } from '@/composables/usePatternStorage.client'
import { useSoundbankStorage } from '@/composables/useSoundbankStorage.client'
import { useImportExport } from '@/composables/useImportExport.client'
import { useCapabilities } from '@/composables/useCapabilities.client'
import { useMidiLearn } from '@/composables/useMidiLearn'
import TransportBar from './TransportBar.vue'
import PadGrid from './PadGrid.vue'
import TabPanel from './TabPanel.vue'
import SoundPanel from './panels/SoundPanel.vue'
import FxPanel from './panels/FxPanel.vue'
import PatternsPanel from './panels/PatternsPanel.vue'
import ExportPanel from './panels/ExportPanel.vue'
import { createZip, type ZipEntry } from '@/utils/zip'
import type { DrumPadId, Scene } from '@/types/drums'
import type { GridSpec, TimeDivision } from '@/types/time'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import type { RenderEvent, RenderMetadata } from '@/types/render'
import type { StepGrid } from '@/types/drums'
import DualDisplay from './control/DualDisplay.vue'
import SoftButtonStrip from './control/SoftButtonStrip.vue'
import FourDEncoderPlaceholder from './placeholders/FourDEncoderPlaceholder.vue'
import ModeColumnPlaceholder from './placeholders/ModeColumnPlaceholder.vue'
import TouchStripPlaceholder from './placeholders/TouchStripPlaceholder.vue'

const slugify = (value: string): string => {
  const cleaned = value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
  return cleaned || 'drum-session'
}

type StemFiles = Partial<
  Record<
    DrumPadId,
    {
      fileName: string
      blob: Blob
    }
  >
>

type StemEntry = {
  padId: DrumPadId
  label: string
  fileName: string
}

type PadState = {
  label: string
  isTriggered: boolean
  isPlaying: boolean
}

const VISIBLE_DIVISIONS: TimeDivision[] = GRID_DIVISIONS.filter((value) => value <= 16)

const collectPlayingPads = (steps: StepGrid): Set<DrumPadId> => {
  const set = new Set<DrumPadId>()

  Object.values(steps).forEach((bar) => {
    Object.values(bar).forEach((step) => {
      Object.keys(step).forEach((padId) => {
        set.add(padId as DrumPadId)
      })
    })
  })

  return set
}

export default defineComponent({
  name: 'DrumMachine',
  components: {
    TransportBar,
    PadGrid,
    TabPanel,
    SoundPanel,
    FxPanel,
    PatternsPanel,
    ExportPanel,
    DualDisplay,
    SoftButtonStrip,
    FourDEncoderPlaceholder,
    ModeColumnPlaceholder,
    TouchStripPlaceholder
  },
  // ModeColumnPlaceholder currently unused; consider removing or wiring into the layout.
  data() {
    const transport = useTransportStore()
    const patterns = usePatternsStore()
    const soundbanks = useSoundbanksStore()
    const session = useSessionStore()
    const control = useControlStore()
    const capabilitiesProbe = useCapabilities()
    session.setCapabilities(capabilitiesProbe.capabilities.value)

    const importExport = useImportExport()
    const midi = useMidi()
    const midiLearn = useMidiLearn(midi)
    const sequencer = useSequencer({
      getPattern: () => patterns.currentPattern,
      onPatternBoundary: () => patterns.advanceScenePlayback()
    })
    const handleExternalStart = () => {
      if (!transport.isPlaying) {
        patterns.prepareScenePlayback()
        void sequencer.start().catch((error) => {
          console.error('Failed to start sequencer from external sync', error)
        })
      }
    }
    const handleExternalStop = () => {
      if (transport.isPlaying) {
        sequencer.stop()
      }
    }
    const sync = useSync('internal', {
      midi,
      getAudioTime: () => sequencer.getAudioTime(),
      onExternalStart: handleExternalStart,
      onExternalStop: handleExternalStop
    })
    const patternStorage = usePatternStorage()
    const soundbankStorage = useSoundbankStorage()

    const pads: DrumPadId[] = [
      'pad1',
      'pad2',
      'pad3',
      'pad4',
      'pad5',
      'pad6',
      'pad7',
      'pad8',
      'pad9',
      'pad10',
      'pad11',
      'pad12',
      'pad13',
      'pad14',
      'pad15',
      'pad16'
    ]
    const divisions: TimeDivision[] = [...VISIBLE_DIVISIONS]
    const defaultBank: Soundbank = {
      id: 'default-kit',
      name: 'Default Kit',
      createdAt: Date.now(),
      updatedAt: Date.now(),
      pads: {
        pad1: { id: 'kick', name: 'Kick', url: '/samples/kick.wav', format: 'wav' },
        pad5: { id: 'kick-2', name: 'Kick 2', url: '/samples/kick.wav', format: 'wav' },
        pad9: { id: 'kick-3', name: 'Kick 3', url: '/samples/kick.wav', format: 'wav' },
        pad13: { id: 'kick-4', name: 'Kick 4', url: '/samples/kick.wav', format: 'wav' },
        pad2: { id: 'snare', name: 'Snare', url: '/samples/snare.wav', format: 'wav' },
        pad6: { id: 'snare-2', name: 'Snare 2', url: '/samples/snare.wav', format: 'wav' },
        pad10: { id: 'snare-3', name: 'Snare 3', url: '/samples/snare.wav', format: 'wav' },
        pad14: { id: 'snare-4', name: 'Snare 4', url: '/samples/snare.wav', format: 'wav' },
        pad3: { id: 'hihat', name: 'Hi-Hat', url: '/samples/hihat.wav', format: 'wav' },
        pad7: { id: 'hihat-2', name: 'Hi-Hat 2', url: '/samples/hihat.wav', format: 'wav' },
        pad11: { id: 'hihat-3', name: 'Hi-Hat 3', url: '/samples/hihat.wav', format: 'wav' },
        pad15: { id: 'hihat-4', name: 'Hi-Hat 4', url: '/samples/hihat.wav', format: 'wav' },
        pad4: { id: 'clap', name: 'Clap', url: '/samples/clap.wav', format: 'wav' },
        pad8: { id: 'clap-2', name: 'Clap 2', url: '/samples/clap.wav', format: 'wav' },
        pad12: { id: 'clap-3', name: 'Clap 3', url: '/samples/clap.wav', format: 'wav' },
        pad16: { id: 'clap-4', name: 'Clap 4', url: '/samples/clap.wav', format: 'wav' }
      }
    }

    if (soundbanks.banks.length === 0) {
      soundbanks.setBanks([defaultBank])
    }

    return {
      transport,
      patterns,
      soundbanks,
      session,
      control,
      sequencer,
      sync,
      midi,
      midiLearn,
      patternStorage,
      soundbankStorage,
      pads,
      divisions,
      defaultBank,
      unwatchers: [] as Array<() => void>,
      exportMetadata: null as RenderMetadata | null,
      exportAudioBlob: null as Blob | null,
      exportTimeline: undefined as RenderEvent[] | undefined,
      exportStems: null as StemFiles | null,
      isExporting: false,
      exportError: null as string | null,
      exportAudioFn: importExport.exportAudio,
      selectedPadId: 'pad1' as DrumPadId,
      currentGridIndex: 0,
      padsPerGrid: 16,
      drawerTab: 'sound',
      countInTimer: null as number | null,
      tapTimestamps: [] as number[],
      liveEraseEnabled: false,
      presetBars: patterns.currentPattern?.gridSpec?.bars ?? DEFAULT_GRID_SPEC.bars,
      presetDivision: patterns.currentPattern?.gridSpec?.division ?? DEFAULT_GRID_SPEC.division,
      channelTarget: 'sound' as 'sound' | 'group' | 'master',
      midiMode: false,
      shiftPointerActive: false
    }
  },


computed: {
  activeMode(): ControlMode {
    return this.control.modeTitle as ControlMode
  },

  shiftHeld(): boolean {
    return this.control.shiftHeld
  },

  pageLabel(): string {
    return this.control.pageLabel
  },

  activeSoftButtons() {
    return this.control.activeSoftButtons
  },

  softLabels(): string[] {
    return this.control.softLabels
  },

  leftDisplayModel() {
    return this.control.leftModel
  },

  rightDisplayModel() {
    return this.control.rightModel
  },

  paramSlotsLeft() {
    return this.control.paramSlotsLeft
  },

  paramSlotsRight() {
    return this.control.paramSlotsRight
  },

  encoderParams() {
    return this.control.activeParams
  },

  gridSpec() {
    return this.patterns.currentPattern?.gridSpec ?? { ...DEFAULT_GRID_SPEC }
  },

  gridCount(): number {
    return Math.ceil(this.pads.length / this.padsPerGrid)
  },

  activePadGrid(): DrumPadId[] {
    const start = this.currentGridIndex * this.padsPerGrid
    return this.pads.slice(start, start + this.padsPerGrid)
  },

  pattern() {
    return (
      this.patterns.currentPattern ?? {
        id: 'pattern-1',
        name: 'Pattern 1',
        gridSpec: { ...DEFAULT_GRID_SPEC },
        steps: {}
      }
    )
  },

  currentStep() {
    return this.transport.currentStep
  },

  totalSteps(): number {
    return Math.max(1, this.gridSpec.bars * this.gridSpec.division)
  },

  patternChainEntries() {
    const chain = this.patterns.currentScene?.patternIds ?? []
    if (!Array.isArray(chain) || chain.length === 0) {
      return null
    }
    return chain
      .map((patternId) => {
        const entry = this.patterns.patterns.find((pattern) => pattern.id === patternId)
        if (!entry) return null
        return { id: patternId, bars: entry.gridSpec?.bars ?? this.gridSpec.bars }
      })
      .filter(Boolean) as Array<{ id: string; bars: number }> | null
  },

  bpm() {
    return this.transport.bpm
  },

  isPlaying() {
    return this.transport.isPlaying
  },

  midiInputs() {
    return this.midi.inputs
  },

  midiOutputs() {
    return this.midi.outputs
  },

  banks() {
    return this.soundbanks.banks
  },

  stemEntries(): StemEntry[] {
    if (!this.exportStems) return []
    const bankPads = this.soundbanks.currentBank?.pads ?? {}

    return Object.entries(this.exportStems).map(([padId, entry]) => ({
      padId: padId as DrumPadId,
      label: bankPads[padId as DrumPadId]?.name ?? padId,
      fileName: entry.fileName
    }))
  },

  syncState() {
    return this.sync.state
  },

  capabilities() {
    return this.session.capabilities
  }, 

  hasZipArtifacts(): boolean {
    return Boolean(this.exportMetadata && this.exportAudioBlob)
  },
  
  midiLearnLabel(): string {
    return (
      this.midiLearn.learningLabel ??
      this.midiLearn.status ??
      'Listening for MIDI...'
    )
  },
  
  padStates() {
    const bankPads = this.soundbanks.currentBank?.pads ?? {}
    const result = {} as Record<DrumPadId, PadState>

    const stepsPerPattern = Math.max(
      1,
      this.gridSpec.bars * this.gridSpec.division
    )

    const normalizedStep =
      ((this.currentStep % stepsPerPattern) + stepsPerPattern) %
      stepsPerPattern

    const barIndex = Math.floor(normalizedStep / this.gridSpec.division)
    const stepIndex = normalizedStep % this.gridSpec.division

    const currentRow =
      this.pattern.steps[barIndex]?.[stepIndex] ?? {}

    const triggered = new Set<DrumPadId>(
      Object.keys(currentRow) as DrumPadId[]
    )

    const playingPads = collectPlayingPads(this.pattern.steps)
    const visiblePads = this.activePadGrid
    visiblePads.forEach((pad) => {
      result[pad] = {
        label: bankPads[pad]?.name ?? pad.toUpperCase(),
        isTriggered: triggered.has(pad),
        isPlaying: this.isPlaying && playingPads.has(pad)
      }
    })

    return result
  },

  mainSlotProps() {
    return {
      stepGridProps: {
        gridSpec: this.gridSpec,
        steps: this.pattern.steps,
        patternChain: this.patternChainEntries,
        selectedPad: this.selectedPadId as DrumPadId | null,
        currentStep: this.currentStep,
        isPlaying: this.isPlaying,
        followEnabled: this.transport.followEnabled,
        loopStart: this.transport.loopStart,
        loopEnd: this.transport.loopEnd,
        'onStep:toggle': this.toggleStep,
        'onPlayhead:scrub': this.scrubPlayhead,
        'onStep:velocity': this.updateStepVelocity
      }
    }
  },
  

  transportSlotProps() {
    return {
      transportProps: {
        bpm: this.bpm,
        isPlaying: this.isPlaying,
        loop: this.transport.loop,
        division: this.gridSpec.division,
        divisions: this.divisions,
        isMidiLearning: this.midiLearn.isLearning,
        isRecording: this.transport.isRecording,
        countInEnabled: this.transport.countInEnabled,
        countInBars: this.transport.countInBars,
        metronomeEnabled: this.transport.metronomeEnabled,
        followEnabled: this.transport.followEnabled,
        patternBars: this.gridSpec.bars,
        loopStart: this.transport.loopStart,
        loopEnd: this.transport.loopEnd,
        totalSteps: this.totalSteps,
        selectedPad: this.selectedPadId,
        liveEraseEnabled: this.liveEraseEnabled,
        metronomeVolume: this.transport.metronomeVolume,
        presetBars: this.presetBars,
        presetDivision: this.presetDivision
        ,
        onPlay: this.start,
        onStop: this.stop,
        onStopReset: this.resetPlayhead,
        onRestart: this.restartLoop,
        onToggleRecord: this.toggleRecord,
        onToggleCountIn: this.toggleCountIn,
        onUpdateCountInBars: this.setCountInBars,
        onTapTempo: this.tapTempo,
        onToggleMetronome: this.toggleMetronome,
        onToggleFollow: this.toggleFollow,
        onUpdatePatternBars: this.setPatternBars,
        onNudgeLoopRange: this.nudgeLoopRange,
        onUpdateLoopStart: this.updateLoopStart,
        onUpdateLoopEnd: this.updateLoopEnd,
        'onUpdate:metronomeVolume': this.setMetronomeVolume,
        onToggleLiveErase: this.toggleLiveErase,
        onErasePad: this.eraseSelectedPad,
        onEraseCurrentStep: this.eraseSelectedPadAtCurrentStep,
        'onUpdate:presetBars': this.setPresetBars,
        'onUpdate:presetDivision': this.setPresetDivision,
        onApplyPatternPreset: this.applyPatternPreset,
        onUpdateBpm: this.updateBpm,
        onIncrementBpm: this.incrementBpm,
        onDecrementBpm: this.decrementBpm,
        onUpdateDivision: this.setDivision,
        onUpdateLoop: this.setLoop,
        onToggleMidiLearn: this.toggleMidiLearn
      },
      transportListeners: {
        play: this.start,
        stop: this.stop,
        'stop-reset': this.resetPlayhead,
        restart: this.restartLoop,
        'toggle-record': this.toggleRecord,
        'toggle-count-in': this.toggleCountIn,
        'update-count-in-bars': this.setCountInBars,
        'tap-tempo': this.tapTempo,
        'toggle-metronome': this.toggleMetronome,
        'toggle-follow': this.toggleFollow,
        'update-pattern-bars': this.setPatternBars,
        'nudge-loop-range': this.nudgeLoopRange,
        'update-loop-start': this.updateLoopStart,
        'update-loop-end': this.updateLoopEnd,
        'update:metronome-volume': this.setMetronomeVolume,
        'toggle-live-erase': this.toggleLiveErase,
        'erase-pad': this.eraseSelectedPad,
        'erase-current-step': this.eraseSelectedPadAtCurrentStep,
        'update:preset-bars': this.setPresetBars,
        'update:preset-division': this.setPresetDivision,
        'apply-pattern-preset': this.applyPatternPreset,
        'update-bpm': this.updateBpm,
        'increment-bpm': this.incrementBpm,
        'decrement-bpm': this.decrementBpm,
        'update-division': this.setDivision,
        'update-loop': this.setLoop,
        'toggle-midi-learn': this.toggleMidiLearn
      },
      midiLearnLabel: this.midiLearnLabel
    }
  },

  padsSlotProps() {
    return {
      padGridProps: {
        pads: this.activePadGrid,
        padStates: this.padStates,
        selectedPad: this.selectedPadId as DrumPadId | null,
        'onPad:down': this.handlePad,
        'onPad:select': this.selectPad
      }
    }
  },

  drawerSlotProps() {
    return {
      drawerTab: this.drawerTab,
      onUpdateDrawerTab: (value: string) => {
        this.drawerTab = value
      },
      soundProps: {
        banks: this.banks,
        selectedBankId: this.soundbanks.selectedBankId,
        'onBank:select': this.selectBank,
        'onPad:replace': this.replacePadSample
      },
      fxProps: {
        fxSettings: (this.sequencer.fxSettings ?? {}) as FxSettings,
        'onFx:update': this.updateFx
      },
      patternsProps: {
        patterns: this.patterns.patterns,
        selectedPatternId: this.patterns.selectedPatternId,
        scenes: this.patterns.scenes,
        activeSceneId: this.patterns.activeSceneId,
        'onPattern:add': this.addPattern,
        'onPattern:select': this.selectPattern,
        'onPattern:rename': this.renamePattern,
        'onPattern:undo': this.undoPattern,
        'onPattern:redo': this.redoPattern,
        'onScene:add': this.addScene,
        'onScene:update': this.updateScene,
        'onScene:select': this.selectScene,
        'onErase:pad': this.eraseSelectedPad,
        'onErase:step': this.eraseSelectedPadAtCurrentStep
      },
      exportProps: {
        isExporting: this.isExporting,
        exportError: this.exportError,
        exportMetadata: this.exportMetadata,
        audioBlob: this.exportAudioBlob,
        hasZipArtifacts: this.hasZipArtifacts,
        stemEntries: this.stemEntries,
        onExport: this.exportBounce,
        'onDownload:mixdown': this.downloadMixdown,
        'onDownload:zip': this.downloadZip,
        'onDownload:stem': this.downloadStem,
        'onDownload:stems': this.downloadAllStems
      },
      channelProps: {
        controlTarget: this.channelTarget,
        midiMode: this.midiMode,
        'onUpdate:control-target': (value: string) => {
          this.channelTarget = value as 'sound' | 'group' | 'master'
        },
        'onUpdate:midi-mode': (value: boolean) => {
          this.midiMode = Boolean(value)
        }
      }
    }
  }
},


  mounted() {
    window.addEventListener('keydown', this.handleGridKeys)
    window.addEventListener('keydown', this.handleShiftKeyDown)
    window.addEventListener('keyup', this.handleShiftKeyUp)
    window.addEventListener('pointerup', this.handleGlobalPointerUp)
    const storedPatterns = this.patternStorage.load()
    if (storedPatterns.patterns.length > 0) {
      this.patterns.setPatterns(storedPatterns.patterns)
    }
    if (storedPatterns.scenes.length > 0) {
      this.patterns.setScenes(storedPatterns.scenes)
    }
    if (storedPatterns.selectedPatternId && this.patterns.patterns.find((pattern) => pattern.id === storedPatterns.selectedPatternId)) {
      this.patterns.selectPattern(storedPatterns.selectedPatternId)
    }
    this.patterns.selectScene(storedPatterns.activeSceneId ?? null)
    void this.initializeSoundbank()
    const persistPatterns = () =>
      this.patternStorage.save({
        patterns: this.patterns.patterns,
        scenes: this.patterns.scenes,
        selectedPatternId: this.patterns.selectedPatternId,
        activeSceneId: this.patterns.activeSceneId
      })
    const stopWatch = this.$watch(
      () => [this.patterns.patterns, this.patterns.scenes, this.patterns.selectedPatternId, this.patterns.activeSceneId],
      persistPatterns,
      { deep: true }
    )
    const stopBankPatternWatch = this.$watch(
      () => this.patterns.patterns,
      (value) => {
        const bankId = this.soundbanks.selectedBankId
        if (bankId) {
          void this.soundbankStorage.savePatterns(bankId, value)
        }
      },
      { deep: true }
    )
    const stopMidiListener = this.midi.listen((message) => {
      if (this.midiLearn.handleMessage(message)) {
        return
      }

      if (message.type === 'noteon' && typeof message.note === 'number') {
        const transportMap = this.midi.mapping?.transportMap
        const transportNote = transportMap?.play === message.note
          ? 'play'
          : transportMap?.stop === message.note
            ? 'stop'
            : transportMap?.bpmUp === message.note
              ? 'bpmUp'
              : transportMap?.bpmDown === message.note
                ? 'bpmDown'
                : null

        if (transportNote === 'play') {
          void this.start()
          return
        }
        if (transportNote === 'stop') {
          this.stop()
          return
        }
        if (transportNote === 'bpmUp') {
          this.updateBpm(this.bpm + 1)
          return
        }
        if (transportNote === 'bpmDown') {
          this.updateBpm(this.bpm - 1)
          return
        }

        const pad = this.midi.mapNoteToPad(message.note)
        if (pad) {
          this.handlePad(pad, message.velocity ?? 1)
        }
      }
    })
    this.unwatchers.push(stopWatch)
    this.unwatchers.push(stopBankPatternWatch)
    this.unwatchers.push(() => stopMidiListener?.())
  },
  beforeUnmount() {
    window.removeEventListener('keydown', this.handleGridKeys)
    window.removeEventListener('keydown', this.handleShiftKeyDown)
    window.removeEventListener('keyup', this.handleShiftKeyUp)
    window.removeEventListener('pointerup', this.handleGlobalPointerUp)
    this.clearCountInTimer()
    this.unwatchers.forEach((stop) => stop())
  },

  
  methods: {
    handleModePress(mode: ControlMode, shiftActionId?: string) {
      this.control.setMode(mode)
      if (this.shiftHeld && shiftActionId) {
        this.control.applyAction(shiftActionId, mode)
      }
    },
    isActiveMode(mode: ControlMode): boolean {
      return this.control.activeMode === mode
    },
    modeTooltip(mode: ControlMode, primary: string, secondary?: string) {
      return secondary ? `${primary} (SHIFT: ${secondary})` : primary
    },
    pageButtonTitle(direction: 'prev' | 'next') {
      return `${direction === 'prev' ? 'Previous' : 'Next'} page (${this.pageLabel})`
    },
    prevPage() {
      this.control.prevPage()
    },
    nextPage() {
      this.control.nextPage()
    },
    pressSoftButton(index: number) {
      this.control.pressSoftButton(index)
    },
    onShiftDown(event: PointerEvent) {
      event.preventDefault()
      this.shiftPointerActive = true
      this.control.setShiftHeld(true)
    },
    onShiftUp() {
      this.shiftPointerActive = false
      this.control.setShiftHeld(false)
    },
    onShiftUpIfPressed() {
      if (this.shiftPointerActive) {
        this.onShiftUp()
      }
    },
    handleGlobalPointerUp() {
      if (this.shiftPointerActive) {
        this.onShiftUp()
      }
    },
    handleShiftKeyDown(event: KeyboardEvent) {
      if (event.key === 'Shift') {
        this.control.setShiftHeld(true)
      }
    },
    handleShiftKeyUp(event: KeyboardEvent) {
      if (event.key === 'Shift') {
        this.control.setShiftHeld(false)
      }
    },
    onKnobWheel(index: number, event: WheelEvent) {
      const direction = event.deltaY < 0 ? 1 : -1
      const magnitude = Math.abs(event.deltaY)
      const step = magnitude > 60 ? 2 : 1
      this.control.turnEncoder(index, direction * step, { fine: this.shiftHeld })
    },
    onKnobKey(index: number, event: KeyboardEvent) {
      if (event.key === 'ArrowUp' || event.key === 'ArrowRight') {
        this.control.turnEncoder(index, 1, { fine: this.shiftHeld })
        event.preventDefault()
      } else if (event.key === 'ArrowDown' || event.key === 'ArrowLeft') {
        this.control.turnEncoder(index, -1, { fine: this.shiftHeld })
        event.preventDefault()
      }
    },
    getParamName(index: number) {
      return this.encoderParams?.[index]?.name ?? `Encoder ${index + 1}`
    },
    addPattern(payload: { name?: string }) {
      this.patterns.addPattern(payload?.name)
    },
    selectPattern(id: string) {
      this.patterns.selectPattern(id)
    },
    renamePattern(payload: { id: string; name: string }) {
      this.patterns.renamePattern(payload.id, payload.name)
    },
    undoPattern() {
      this.patterns.undo()
    },
    redoPattern() {
      this.patterns.redo()
    },
    addScene(payload: { name?: string; patternIds?: string[] }) {
      this.patterns.addScene(payload?.name ?? 'Scene', payload?.patternIds ?? [])
    },
    updateScene(payload: { id: string; name?: string; patternIds?: string[] }) {
      const updates: Partial<Scene> = {}
      if (typeof payload.name === 'string') {
        updates.name = payload.name
      }
      if (Array.isArray(payload.patternIds)) {
        updates.patternIds = payload.patternIds
      }
      if (Object.keys(updates).length > 0) {
        this.patterns.updateScene(payload.id, updates)
      }
    },
    selectScene(id: string | null) {
      this.patterns.selectScene(id)
    },
    updateFx(settings: FxSettings) {
      this.sequencer.setFx(settings)
    },
    updateBpm(bpm: number) {
      this.transport.setBpm(bpm)
      this.sync.setBpm(bpm)
    },
    async start() {
      if (this.transport.isPlaying) return
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'play' })
      }
      this.patterns.prepareScenePlayback()
      await this.sequencer.start()
      this.sync.startTransport(this.transport.bpm)
    },
    stop() {
      if (!this.transport.isPlaying) {
        this.resetPlayhead()
        this.transport.setRecording(false)
        return
      }
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'stop' })
      }
      this.sequencer.stop()
      this.sync.stopTransport()
      this.transport.setRecording(false)
    },
    resetPlayhead() {
      this.transport.setCurrentStep(0)
    },
    restartLoop() {
      if (this.transport.isPlaying) {
        this.sequencer.stop()
        this.transport.setCurrentStep(this.transport.loopStart)
        this.patterns.prepareScenePlayback()
        void this.sequencer.start()
      } else {
        this.transport.setCurrentStep(this.transport.loopStart)
      }
    },
    toggleRecord() {
      const next = !this.transport.isRecording
      this.transport.setRecording(next)
      if (!next) {
        this.clearCountInTimer()
        return
      }
      if (!this.transport.isPlaying) {
        if (this.transport.countInEnabled) {
          this.startWithCountIn()
        } else {
          void this.start()
        }
      }
    },
    startWithCountIn() {
      this.clearCountInTimer()
      const bars = Math.max(1, this.transport.countInBars)
      const delayMs = (bars * 4 * 60 * 1000) / Math.max(1, this.bpm)
      this.countInTimer = window.setTimeout(() => {
        void this.start()
        this.transport.setRecording(true)
        this.clearCountInTimer()
      }, delayMs)
    },
    clearCountInTimer() {
      if (this.countInTimer != null) {
        window.clearTimeout(this.countInTimer)
        this.countInTimer = null
      }
    },
    toggleCountIn() {
      this.transport.setCountInEnabled(!this.transport.countInEnabled)
      if (!this.transport.countInEnabled) {
        this.clearCountInTimer()
      }
    },
    setCountInBars(value: number) {
      this.transport.setCountInBars(value ?? 1)
    },
    tapTempo() {
      const now = Date.now()
      this.tapTimestamps.push(now)
      const recent = this.tapTimestamps.slice(-4)
      this.tapTimestamps = recent
      if (recent.length < 2) return
      const intervals = []
      for (let i = 1; i < recent.length; i += 1) {
        intervals.push(recent[i] - recent[i - 1])
      }
      const avgMs = intervals.reduce((sum, val) => sum + val, 0) / intervals.length
      const bpm = Math.max(1, Math.round(60000 / avgMs))
      this.updateBpm(bpm)
    },
    toggleMetronome() {
      this.transport.setMetronomeEnabled(!this.transport.metronomeEnabled)
    },
    toggleFollow() {
      this.transport.setFollowEnabled(!this.transport.followEnabled)
    },
    setPatternBars(bars: number) {
      const normalized = Math.max(1, Math.min(8, Math.floor(bars))) as GridSpec['bars']
      const gridSpec = normalizeGridSpec({ ...this.gridSpec, bars: normalized })
      this.transport.setGridSpec(gridSpec)
      this.patterns.updateGridSpec(gridSpec)
      const total = gridSpec.bars * gridSpec.division
      this.transport.setLoopRange(0, total)
      this.resetPlayhead()
    },
    nudgeLoopRange(delta: number) {
      this.transport.nudgeLoopRange(delta)
      const clamped = Math.min(Math.max(this.transport.currentStep, this.transport.loopStart), this.transport.loopEnd - 1)
      this.transport.setCurrentStep(clamped)
    },
    updateLoopStart(value: number) {
      const nextStart = Math.max(0, Math.floor(value))
      const end = Math.max(nextStart + 1, this.transport.loopEnd)
      this.transport.setLoopRange(nextStart, end)
      const clamped = Math.min(Math.max(this.transport.currentStep, nextStart), end - 1)
      this.transport.setCurrentStep(clamped)
    },
    updateLoopEnd(value: number) {
      const total = this.totalSteps
      const nextEnd = Math.min(total, Math.max(1, Math.floor(value)))
      const start = Math.min(this.transport.loopStart, nextEnd - 1)
      this.transport.setLoopRange(start, nextEnd)
      const clamped = Math.min(Math.max(this.transport.currentStep, start), nextEnd - 1)
      this.transport.setCurrentStep(clamped)
    },
    setMetronomeVolume(value: number) {
      this.transport.setMetronomeVolume(value ?? 0.12)
    },
    setPresetBars(value: number) {
      const bars = Math.max(1, Math.min(8, Math.floor(value ?? 1))) as GridSpec['bars']
      this.presetBars = bars
    },
    setPresetDivision(value: TimeDivision | null) {
      if (value != null) {
        this.presetDivision = value
      }
    },
    applyPatternPreset() {
      const gridSpec = normalizeGridSpec({
        ...this.gridSpec,
        bars: this.presetBars,
        division: this.presetDivision
      })
      this.transport.setGridSpec(gridSpec)
      this.patterns.updateGridSpec(gridSpec)
      this.transport.setLoopRange(0, gridSpec.bars * gridSpec.division)
      this.resetPlayhead()
    },
    handleGridKeys(e: KeyboardEvent) {
      if (e.ctrlKey && !e.shiftKey) {
        const index = Number(e.key) - 1
        if (index >= 0 && index < this.gridCount) {
          e.preventDefault()
          this.selectPadGrid(index)
          return
        }
      }
      if (e.ctrlKey && e.key.toLowerCase() === 'z') {
        e.preventDefault()
        if (e.shiftKey) {
          this.redoPattern()
        } else {
          this.undoPattern()
        }
      }
    },
    async handlePad(pad: DrumPadId, velocity = 1) {
      if (this.liveEraseEnabled) {
        this.erasePadAtStep(pad, this.transport.currentStep)
        return
      }
      try {
        await this.sequencer.recordHit(pad, velocity, true)
      } catch (error) {
        console.error('Failed to trigger pad', error)
      }
      this.selectPad(pad)
    },
    selectPad(pad: DrumPadId) {
      this.selectedPadId = pad
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'pad', padId: pad })
      }
    },
    selectPadGrid(index: number) {
      if (index < 0 || index >= this.gridCount) return
      this.currentGridIndex = index
      const firstPad = this.activePadGrid[0]
      if (firstPad) {
        this.selectedPadId = firstPad
      }
    },
    toggleStep(payload: { barIndex: number; stepInBar: number; padId: DrumPadId }) {
      this.patterns.toggleStep(payload.barIndex, payload.stepInBar, payload.padId)
    },
    updateStepVelocity(payload: {
      barIndex: number
      stepInBar: number
      padId: DrumPadId
      velocity: number
    }) {
      this.patterns.setStepVelocity(
        payload.barIndex,
        payload.stepInBar,
        payload.padId,
        payload.velocity
      )
    },
    scrubPlayhead(payload: { stepIndex: number }) {
      this.transport.setCurrentStep(payload.stepIndex)
    },
    erasePadAtStep(pad: DrumPadId, stepIndex: number) {
      const stepsPerPattern = this.totalSteps
      const normalizedStep =
        ((stepIndex % stepsPerPattern) + stepsPerPattern) % stepsPerPattern
      const barIndex = Math.floor(normalizedStep / this.gridSpec.division)
      const stepInBar = normalizedStep % this.gridSpec.division
      this.patterns.eraseStepForPad(barIndex, stepInBar, pad)
    },
    eraseSelectedPad() {
      if (!this.selectedPadId) return
      this.patterns.erasePadEvents(this.selectedPadId)
    },
    eraseSelectedPadAtCurrentStep() {
      if (!this.selectedPadId) return
      this.erasePadAtStep(this.selectedPadId, this.transport.currentStep)
    },

    async requestMidi() {
      await this.midi.requestAccess()
      this.session.setCapabilities({
        supportsAudioInput: this.session.capabilities.supportsAudioInput,
        supportsWebMIDI: this.midi.supportsMidi()
      })
      if (this.midi.inputs.length > 0 && !this.midi.selectedInputId) {
        this.midi.setSelectedInput(this.midi.inputs[0]?.id ?? null)
      }
      if (this.midi.outputs.length > 0 && !this.midi.selectedOutputId) {
        this.midi.setSelectedOutput(this.midi.outputs[0]?.id ?? null)
      }
    },
    selectMidiInput(id: string) {
      this.midi.setSelectedInput(id)
    },
    selectMidiOutput(id: string) {
      this.midi.setSelectedOutput(id)
    },
    mapPadToNote(payload: { padId: DrumPadId; note: number }) {
      if (payload.note >= 0 && payload.note <= 127) {
        this.midi.setPadForNote(payload.note, payload.padId)
      }
    },
    setSyncMode(mode: string) {
      if (mode === 'internal' || mode === 'midiClock' || mode === 'abletonLink') {
        this.sync.setMode(mode)
      }
    },
    setSyncRole(role: string) {
      if (role === 'master' || role === 'slave') {
        this.sync.setRole(role)
      }
    },
    setLoop(loop: boolean) {
      this.transport.setLoop(loop)
    },
    incrementBpm() {
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'bpmUp' })
      }
      this.updateBpm(this.bpm + 1)
    },
    decrementBpm() {
      if (this.midiLearn.isLearning) {
        this.midiLearn.setTarget({ type: 'transport', action: 'bpmDown' })
      }
      this.updateBpm(this.bpm - 1)
    },
    toggleMidiLearn() {
      if (this.midiLearn.isLearning) {
        this.midiLearn.disable()
      } else {
        this.midiLearn.enable()
      }
    },
    toggleLiveErase() {
      this.liveEraseEnabled = !this.liveEraseEnabled
    },
    setDivision(division: TimeDivision) {
      const gridSpec = normalizeGridSpec({ ...this.gridSpec, division })
      this.transport.setGridSpec(gridSpec)
      this.patterns.updateGridSpec(gridSpec)
    },
    selectBank(id: string) {
      this.soundbanks.selectBank(id)
      void this.initializeSoundbank()
    },
    inferFormatFromName(name: string): SampleRef['format'] {
      const lower = name.toLowerCase()
      if (lower.endsWith('.wav')) return 'wav'
      if (lower.endsWith('.mp3')) return 'mp3'
      if (lower.endsWith('.ogg')) return 'ogg'
      if (lower.endsWith('.aac')) return 'aac'
      if (lower.endsWith('.flac')) return 'flac'
      return undefined
    },
    async replacePadSample(payload: { padId: DrumPadId; file: File }) {
      const bank = this.soundbanks.currentBank ?? this.defaultBank
      const existing = bank.pads[payload.padId]
      if (existing?.url && existing.url.startsWith('blob:')) {
        URL.revokeObjectURL(existing.url)
      }
      const sampleId = `${payload.padId}-${Date.now()}`
      const format = this.inferFormatFromName(payload.file.name) ?? 'wav'
      const sample: SampleRef = {
        id: sampleId,
        name: payload.file.name,
        format,
        blob: payload.file,
        url: URL.createObjectURL(payload.file)
      }
      const updatedBank: Soundbank = {
        ...bank,
        pads: { ...bank.pads, [payload.padId]: sample },
        updatedAt: Date.now()
      }
      this.soundbanks.upsertBank(updatedBank)
      await this.soundbankStorage.saveBank(updatedBank)
      await this.soundbankStorage.saveSample(sample as SampleRef & { blob: Blob })
      await this.sequencer.setSampleForPad(payload.padId, sample)
      await this.sequencer.applySoundbank(updatedBank)
    },
    async hydrateSamplesForBank(bank: Soundbank): Promise<Soundbank> {
      const hydratedPads: Partial<Record<DrumPadId, SampleRef>> = {}
      const entries = Object.entries(bank.pads)
      for (const [padId, sample] of entries) {
        if (!sample) continue
        let hydrated = sample
        if (!sample.blob) {
          const stored = await this.soundbankStorage.loadSample(sample.id)
          if (stored?.blob) {
            hydrated = { ...sample, blob: stored.blob }
          }
        }
        hydratedPads[padId as DrumPadId] = hydrated
      }
      return { ...bank, pads: hydratedPads }
    },
    async initializeSoundbank() {
      const storedBanks = await this.soundbankStorage.loadBanks()
      if (storedBanks.length > 0) {
        this.soundbanks.setBanks(storedBanks)
      } else if (this.soundbanks.banks.length === 0) {
        this.soundbanks.setBanks([this.defaultBank])
        await this.soundbankStorage.saveBank(this.defaultBank)
      }
      const bank = this.soundbanks.currentBank ?? this.soundbanks.banks[0] ?? this.defaultBank
      const hydratedBank = await this.hydrateSamplesForBank(bank)
      this.soundbanks.upsertBank(hydratedBank)
      const bankPatterns = await this.soundbankStorage.loadPatterns(hydratedBank.id)
      if (bankPatterns.length > 0) {
        this.patterns.setPatterns(bankPatterns)
      }
      await this.sequencer.applySoundbank(hydratedBank)
    },
    getScenePatternChain(): string[] {
      const chain = this.patterns.currentScene?.patternIds ?? []
      const filtered = chain.filter((patternId) => this.patterns.patterns.some((pattern) => pattern.id === patternId))
      if (filtered.length > 0) {
        return filtered
      }
      const fallback = this.patterns.selectedPatternId ?? this.patterns.patterns[0]?.id
      return fallback ? [fallback] : []
    },
    computeExportDuration(): number {
      const bpm = Math.max(1, this.transport.bpm)
      const chain = this.getScenePatternChain()
      const totalBars = chain.reduce((sum, patternId) => {
        const pattern = this.patterns.patterns.find((entry) => entry.id === patternId)
        return sum + (pattern?.gridSpec?.bars ?? DEFAULT_GRID_SPEC.bars)
      }, 0)
      const bars = totalBars || DEFAULT_GRID_SPEC.bars
      return (bars * 4 * 60) / bpm
    },
    async exportBounce() {
      if (this.isExporting) return
      this.isExporting = true
      this.exportError = null
      this.exportStems = null
      try {
        const result = await this.exportAudioFn(this.computeExportDuration())
        this.exportMetadata = result.metadata
        this.exportAudioBlob = result.audioBlob
        this.exportTimeline = result.debugTimeline
        this.exportStems = result.stems ?? null
      } catch (error) {
        console.error('Failed to export audio', error)
        this.exportError = 'Failed to export audio'
        this.exportStems = null
      } finally {
        this.isExporting = false
      }
    },
    downloadStem(pad: DrumPadId) {
      if (this.isExporting) return
      const entry = this.exportStems?.[pad]
      if (!entry) return
      saveAs(entry.blob, entry.fileName)
    },
    downloadMixdown() {
      if (this.isExporting) return
      if (!this.exportAudioBlob) return
      saveAs(this.exportAudioBlob, 'mixdown.wav')
    },
    downloadAllStems() {
      if (this.isExporting || !this.exportStems) return
      Object.values(this.exportStems).forEach((entry) => {
        saveAs(entry.blob, entry.fileName)
      })
    },
    async downloadZip() {
      if (this.isExporting || !this.hasZipArtifacts) return
      try {
        const metadata = this.exportMetadata
        const mixdown = this.exportAudioBlob
        if (!metadata || !mixdown) return
        const metadataBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' })
        const files = [
          { name: 'mixdown.wav', blob: mixdown },
          { name: 'render-meta.json', blob: metadataBlob }
        ]
        if (this.exportStems) {
          Object.entries(this.exportStems).forEach(([padId, entry]) => {
            files.push({ name: `stems/${padId}.wav`, blob: entry.blob })
          })
        }
        const entries: ZipEntry[] = await Promise.all(
          files.map(async (file) => ({
            name: file.name,
            data: new Uint8Array(await file.blob.arrayBuffer())
          }))
        )
        const zipped = createZip(entries)
        const songName = slugify(this.soundbanks.currentBank?.name ?? this.patterns.currentScene?.name ?? this.pattern?.name ?? 'drum-session')
        const seedSuffix = metadata.seed ?? Date.now().toString()
        saveAs(zipped, `${songName}_${seedSuffix}.zip`)
      } catch (error) {
        console.error('Failed to create ZIP archive', error)
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.device-root {
  height: 100%;
  width: 100%;
  overflow: hidden;
  background: @color-bg-root;
}

.device-stage {
  height: 100%;
  min-height: 0;

  display: grid;
  grid-template-columns: 1fr clamp(520px, 36vw, 760px);
  gap: @space-m;
  padding: @space-m;
}

.device-main {
  flex: 1 1 auto;
  min-width: 0;
  min-height: 0;
  overflow: hidden;
  background: @color-surface-1;
  border: 1px solid @color-border-1;
  border-radius: @radius-l;
}

.hardware-stage {
  --stage-pad: clamp(12px, 1.6vw, 24px);
  height: 100svh;
  min-height: 100svh;
  width: 100%;
  padding: var(--stage-pad);
  box-sizing: border-box;
  overflow: hidden;
  background: radial-gradient(130% 130% at 25% 20%, #2c313c 0%, #1a1e26 50%, #0d0f14 100%);
  display: flex;
  align-items: center;
  justify-content: center;
}

.device-hardware {
  position: relative;
  --device-w: 100%;
  --device-gap: clamp(8px, 1.2vh, 16px);
  --panel-radius: @radius-l;
  aspect-ratio: 1080 / 760;
  max-width: calc(100vw - (2 * var(--stage-pad)));
  max-height: calc(100svh - (2 * var(--stage-pad)));

  height: auto;
  margin: 0 auto;
  display: grid;
  grid-template-rows: auto 1fr;
  gap: var(--device-gap);
  background: linear-gradient(180deg, #1f232c, #151821);
  border: 1px solid fade(#3b4355, 70%);
  border-radius: var(--panel-radius);
  padding: @space-m;
  box-sizing: border-box;
  overflow: hidden;
  box-shadow:
    0 30px 62px rgba(0, 0, 0, 0.6),
    0 2px 12px rgba(0, 0, 0, 0.55),
    inset 0 1px 0 rgba(255, 255, 255, 0.08),
    inset 0 -1px 0 rgba(0, 0, 0, 0.8);
  width: min(
    calc((100svh - (2 * var(--stage-pad))) * (1080 / 760))
  );
}

.top-row {
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: auto auto;
  gap: var(--device-gap);
  align-items: start;
  min-height: 0;
}

.control-stack {
  display: grid;
  grid-template-columns: var(--control-cols, repeat(8, 1fr));
  grid-template-rows: auto auto;
  column-gap: var(--control-col-gap, @space-xs);
  row-gap: var(--device-gap);
  width: 100%;
}

.control-area {
  --control-row-h: clamp(44px, 4.2vh, 56px);
  --control-cols: repeat(8, 1fr);
  --control-col-gap: @space-xs;
  grid-column: 1 / -1;
  grid-row: 1;
  display: grid;
  grid-template-columns: clamp(210px, 18%, 280px) 1fr;
  gap: var(--device-gap);
  min-width: 0;
  min-height: 0;
  align-items: stretch;
  width: 100%;
}

.control-fixed {
  min-width: 0;
  display: flex;
  align-items: flex-start;
}

.control-btn-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: repeat(6, var(--control-row-h));
  gap: @space-xxs;
  width: 100%;
  max-width: 100%;
}

.control-btn.r1 { grid-row: 1; }
.control-btn.r2 { grid-row: 2; }
.control-btn.r3 { grid-row: 3; }
.control-btn.r4 { grid-row: 4; }
.control-btn.r5 { grid-row: 5; }
.control-btn.r6 { grid-row: 6; }
.control-btn.c1 { grid-column: 1; }
.control-btn.c2 { grid-column: 2; }

.control-btn {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid fade(#3b4355, 65%);
  background: linear-gradient(180deg, #1c2230, #121826);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
  color: rgba(255, 255, 255, 0.88);
  line-height: 1.05;
  text-align: left;
  min-height: 44px;
  max-width: 100%;
}

.control-btn__main {
  font-weight: 800;
  letter-spacing: 0.06em;
  font-size: 12px;
  text-transform: uppercase;
}

.control-btn__sub {
  margin-top: 2px;
  font-weight: 400;
  font-style: italic;
  opacity: 0.75;
  font-size: 11px;
  letter-spacing: 0.02em;
  text-transform: none;
}

.control-btn--icon {
  align-items: center;
  text-align: center;
}

.control-btn--icon .control-btn__main {
  font-size: 16px;
  letter-spacing: 0;
}

.control-core {
  display: grid;
  grid-template-rows: repeat(6, var(--control-row-h));
  gap: 0;
  min-width: 0;
  --control-cols: repeat(8, 1fr);
  --control-col-gap: @space-xs;
}

.soft-row {
  grid-row: 1;
  height: var(--control-row-h);
  min-width: 0;
  display: flex;
  align-items: center;
}

.drum-machine-shell :deep(.soft-row) {
  grid-row: 1;
  height: var(--control-row-h);
  min-width: 0;
  display: flex;
  align-items: center;
}

.soft-row-grid {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
}

.soft-row :deep(.soft-strip) {
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
  height: 100%;
  grid-column: 1 / -1;
}

.soft-row :deep(.soft-btn) {
  min-height: 100%;
}

.soft-row :deep(*) {
  height: 100%;
  min-height: 0;
  width: 100%;
}

.display-block {
  grid-row: 2 / span 4;
  position: relative;
  min-width: 0;
  min-height: 0;
  height: calc(var(--control-row-h) * 4);
  display: grid;
  align-items: stretch;
}

.display-grid {
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--device-gap);
  height: 100%;
}

.drum-machine-shell :deep(.display-grid) {
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--device-gap);
  height: 100%;
}

.display-grid :deep(.dual-display-root),
.display-grid :deep(.dual-display),
.display-grid :deep(.dual-display-placeholder) {
  height: 100%;
  min-height: 0;
  grid-column: 1 / -1;
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
  row-gap: 0;
}

.display-grid :deep(.dual-display .display) {
  grid-column: span 4;
  min-width: 0;
}

.display-grid :deep(.dual-display .display:nth-child(1)) {
  grid-column: 1 / span 4;
}

.display-grid :deep(.dual-display .display:nth-child(2)) {
  grid-column: 5 / span 4;
}

.display-param-labels {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 0 8px 6px 8px;
  display: grid;
  grid-template-columns: var(--control-cols);
  column-gap: var(--control-col-gap);
  pointer-events: none;
}

.param-label {
  justify-self: center;
  font-size: 10px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  opacity: 0.75;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.knob-row {
  grid-row: 6;
  height: var(--control-row-h);
  display: grid;
  grid-template-columns: var(--control-cols);
  align-items: center;
  gap: var(--device-gap);
  padding: 12px 8px;
  min-width: 0;
  --knob-y: 0px;
}

.knob {
  justify-self: center;
  width: var(--control-row-h);
  height: var(--control-row-h);
  transform: translateY(var(--knob-y));
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, #3a4150, #151a24 70%);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow:
    inset 0 2px 4px rgba(0,0,0,0.7),
    0 1px 0 rgba(255,255,255,0.06);
  position: relative;
}

.knob::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 50%;
  width: 2px;
  height: 38%;
  transform: translateX(-50%);
  border-radius: 2px;
  background: rgba(246, 139, 30, 0.9);
  box-shadow: 0 0 6px rgba(246, 139, 30, 0.35);
}

.edit-area {
  --edit-btn-h: clamp(34px, 4.2vh, 44px);
  --edit-row-gap: @space-xxs;
  --edit-stack-d: calc((3 * var(--edit-btn-h)) + (2 * var(--edit-row-gap)));

  /* statt grid-column: 1 / span 3; */
  grid-column: 1 / 3;     
  grid-row: 6;             
  justify-self: normal;

  --core-w: calc(100% - var(--fixed-col-w) - var(--device-gap));

  margin-left: calc(var(--fixed-col-w) - var(--device-gap));
  width: calc(var(--core-w) * 0.375); /* 3/8 = 0.375 */

  display: grid;
  grid-template-columns: 1fr auto;
  grid-template-rows: repeat(3, var(--edit-btn-h));
  column-gap: var(--control-col-gap);
  row-gap: var(--edit-row-gap);
  flex-direction: column;
  align-items: start;
  justify-items: center;
  align-self: start;
  margin-top: calc(var(--device-gap) * 0.5);
  min-height: 0;
  min-width: 0;
}

.encoder-slot {
  grid-column: 1 / 3;
  grid-row: 1 / -1;
  display: grid;
  padding-left: 30%;
  align-items: start;
  justify-content: center;
  justify-self: start;
  align-self: start;
  width: var(--edit-stack-d);
  height: var(--edit-stack-d);
}



.quick-edit-buttons {
  grid-column: 3 / -1;
  grid-row: 1;
  display: grid;
  grid-template-rows: repeat(3, var(--edit-btn-h));
  row-gap: var(--edit-row-gap);
  align-content: start;
  align-items: start;

}

.quick-edit-btn {
  min-height: var(--edit-btn-h);
  height: var(--edit-btn-h);
  width: 100%;
}

.four-d-encoder {
  position: relative;
  border-radius: 50%;
  background: radial-gradient(circle at 35% 30%, #3c4352, #121722 70%);
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow:
    inset 0 3px 6px rgba(0,0,0,0.65),
    0 2px 6px rgba(0,0,0,0.45);
}

.four-d-encoder::after {
  content: '';
  position: absolute;
  top: 6%;
  left: 50%;
  width: 3px;
  height: 30%;
  transform: translateX(-50%);
  border-radius: 2px;
  background: rgba(246, 139, 30, 0.95);
  box-shadow: 0 0 10px rgba(246, 139, 30, 0.35);
}

.bottom-row {
  display: grid;
  grid-template-columns: clamp(220px, 24%, 320px) minmax(0, 1fr);
  grid-template-areas: 'left right';
  gap: var(--device-gap);
  min-height: 0;
}

.drum-machine-shell :deep(.bottom-row) {
  display: grid;
  grid-template-columns: clamp(220px, 24%, 320px) minmax(0, 1fr);
  grid-template-areas: 'left right';
  gap: var(--device-gap);
  min-height: 0;
}

.left-column {
  grid-area: left;
  display: flex;
  flex-direction: column;
  gap: @space-s;
  min-height: 0;
}

.transport-cluster {
  background: linear-gradient(180deg, #1f2531, #141924);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  min-height: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
}

.drawer-shell {
  flex: 1 1 auto;
  min-height: 0;
  max-height: clamp(260px, 36vh, 360px);
  overflow: auto;
  background: linear-gradient(180deg, #1c202b, #10141d);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
}

.drum-machine-shell :deep(.drawer-shell) {
  flex: 1 1 auto;
  min-height: 0;
  max-height: clamp(260px, 36vh, 360px);
  overflow: auto;
  background: linear-gradient(180deg, #1c202b, #10141d);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
}

.right-column {
  grid-area: right;
  display: flex;
  flex-direction: column;
  gap: var(--device-gap);
  min-height: 0;
}

.drum-machine-shell :deep(.right-column) {
  grid-area: right;
  display: flex;
  flex-direction: column;
  gap: var(--device-gap);
  min-height: 0;
}

.pads-and-strip {
  display: grid;
  //grid-template-columns: clamp(90px, 18%, 140px) minmax(0, 1fr);
  grid-template-areas: 'strip pads';
  gap: var(--device-gap);
  align-items: end;
  width: 100%;
  min-height: 0;
}

.drum-machine-shell :deep(.pads-and-strip) {
  display: grid;
  grid-template-areas: 'strip pads';
  gap: var(--device-gap);
  align-items: end;
  width: 100%;
  min-height: 0;
}

.strip-column {
  grid-area: strip;
  align-self: end;
  justify-self: start;
  min-height: 0;
}

.pads-column {
  grid-area: pads;
  min-width: 0;
}

.pads-stack {
  display: grid;
  grid-columns: 4 / -1;
  grid-rows: 4 / -1;
  flex-direction: column;
  gap: @space-xs;
  align-items: end;
  justify-content: end;
  //width: 80%;
  min-width: 0;
  min-height: 0;
  align-self: end;
  justify-self: end;
  background: linear-gradient(180deg, #191d27, #10141d);
  border: 1px solid fade(#3b4355, 60%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
}

.drum-machine-shell :deep(.pads-stack) {
  display: grid;
  grid-columns: 4 / -1;
  grid-rows: 4 / -1;
  flex-direction: column;
  gap: @space-xs;
  align-items: end;
  justify-content: end;
  min-width: 0;
  min-height: 0;
  align-self: end;
  justify-self: end;
  background: linear-gradient(180deg, #191d27, #10141d);
  border: 1px solid fade(#3b4355, 60%);
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
}

.pads-square {
  width: 100%;
  // max-width: clamp(420px, 62%, 960px);
  aspect-ratio: 1 / 1;
  min-height: 0;
  display: flex;
}

.drum-machine-shell :deep(.pads-square) {
  width: 100%;
  aspect-ratio: 1 / 1;
  min-height: 0;
  display: flex;
}

.pads-square > * {
  flex: 1 1 auto;
  min-width: 0;
  min-height: 0;
}

.pads-square > :deep(*) {
  flex: 1 1 auto;
  min-width: 0;
  min-height: 0;
}

.device-hardware.debug-overlay::before {
  content: '';
  position: absolute;
  inset: 0;
  background: url('/img/maschine-reference.png') center / contain no-repeat;
  opacity: 0.35;
  pointer-events: none;
  z-index: 5;
}

.device-hardware.debug-grid::after {
  content: '';
  position: absolute;
  inset: 0;
  background-image:
    linear-gradient(to right, rgba(255, 255, 255, 0.15) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255, 255, 255, 0.15) 1px, transparent 1px);
  background-size: 20px 20px;
  opacity: 0.15;
  pointer-events: none;
  z-index: 6;
}

.pad-grid-indicator {
  display: flex;
  justify-content: center;
  gap: @space-xs;
  padding: @space-xxs;
  background: rgba(255, 255, 255, 0.02);
  border-radius: @radius-s;
}

.drum-machine-shell :deep(.pad-grid-indicator) {
  display: flex;
  justify-content: center;
  gap: @space-xs;
  padding: @space-xxs;
  background: rgba(255, 255, 255, 0.02);
  border-radius: @radius-s;
}

.indicator-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #1f2734;
  box-shadow: inset 0 0 4px rgba(0,0,0,0.9);
}

.indicator-dot.active {
  background: #f68b1e;
  box-shadow:
    0 0 6px fade(#f68b1e, 60%),
    0 0 12px fade(#f68b1e, 35%);
}

@media (max-width: 1200px) {
  .bottom-row {
    grid-template-columns: 320px 1fr;
  }

  .pads-square {
    width: clamp(360px, 48vw, 520px);
  }

  .drum-machine-shell :deep(.bottom-row) {
    grid-template-columns: 320px 1fr;
  }

  .drum-machine-shell :deep(.pads-square) {
    width: clamp(360px, 48vw, 520px);
  }
}

@media (max-width: 960px) {
  .device-hardware {
    grid-template-rows: auto auto 1fr;
  }

  .top-row {
    grid-template-columns: 1fr;
    gap: @space-s;
    align-items: start;
  }
  
  .control-area {
    grid-template-columns: 1fr;
  }

  .bottom-row {
    grid-template-columns: 1fr;
  }

  .right-column {
    grid-template-columns: 1fr;
  }

  .pads-and-strip {
    grid-template-columns: 1fr;
    grid-template-areas:
      'strip'
      'pads';
    justify-items: center;
    align-items: center;
  }

  .drawer-shell {
    max-height: 45vh;
  }

  .drum-machine-shell :deep(.bottom-row) {
    grid-template-columns: 1fr;
  }

  .drum-machine-shell :deep(.right-column) {
    grid-template-columns: 1fr;
  }

  .drum-machine-shell :deep(.pads-and-strip) {
    grid-template-columns: 1fr;
    grid-template-areas:
      'strip'
      'pads';
    justify-items: center;
    align-items: center;
  }

  .drum-machine-shell :deep(.drawer-shell) {
    max-height: 45vh;
  }
}

.edit-area {
  grid-column: 1 / 3;
  grid-row: 2;
}

.performance-vert {
  grid-column: 4;
  grid-row: 2;
  display: grid;
  grid-template-rows: repeat(3, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  row-gap: var(--edit-row-gap, @space-xxs);
  align-self: end;
  justify-self: stretch;
  width: 100%;
}

.performance-vert .control-btn {
  width: 100%;
  min-height: var(--edit-btn-h, clamp(34px, 4.2vh, 44px));
}

.performance-vert__spacer {
  width: 100%;
  height: 100%;
}

.performance-block {
  grid-column: 1 / span 4;
  grid-row: 3;
  display: grid;
  grid-template-rows: auto auto auto;
  row-gap: var(--edit-row-gap, @space-xxs);
  align-self: start;
  justify-self: stretch;
  width: 100%;
}

.performance-btn-row {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: @space-xxs;
}

.performance-btn-row .control-btn {
  width: 100%;
  min-height: var(--edit-btn-h, clamp(34px, 4.2vh, 44px));
}

.smart-strip {
  width: 100%;
  height: clamp(46px, 5vh, 64px);
  border-radius: @radius-m;
  background: linear-gradient(90deg, #2a2f3a, #141824);
  border: 1px solid fade(#3b4355, 60%);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.group-area {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
}

.group-area .control-btn {
  width: 100%;
  min-height: var(--edit-btn-h, clamp(34px, 4.2vh, 44px));
}

.transport-area {
  background: linear-gradient(180deg, #1f2531, #141924);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  min-height: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
  width: 100%;
}

.drum-machine-shell :deep(.transport-area) {
  background: linear-gradient(180deg, #1f2531, #141924);
  border: 1px solid fade(#3b4355, 65%);
  border-radius: @radius-m;
  padding: @space-s;
  min-height: 0;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
  width: 100%;
}

.transport-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
}

.drum-machine-shell :deep(.transport-grid) {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
}

.shift-label {
  height: 14px;
  background: #fff;
  color: #000;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: 0.06em;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  border-radius: 4px;
}

.right-column {
  justify-content: flex-end;
}

.drum-machine-shell :deep(.right-column) {
  justify-content: flex-end;
}

.pads-and-strip {
  --pads-square-size: clamp(320px, 42vh, 520px);
  --pad-cell-size: calc(var(--pads-square-size) / 4);
  align-items: end;
  grid-template-columns: clamp(90px, 18%, 140px) minmax(0, 1fr);
}

.drum-machine-shell :deep(.pads-and-strip) {
  --pads-square-size: clamp(320px, 42vh, 520px);
  --pad-cell-size: calc(var(--pads-square-size) / 4);
  align-items: end;
  grid-template-columns: clamp(90px, 18%, 140px) minmax(0, 1fr);
}

.pad-top-buttons {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: @space-xxs;
  width: 100%;
  margin-bottom: @space-xs;
}

.pads-column {
  grid-area: pads;
  align-self: end;
}

.mode-buttons {
  grid-area: strip;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(8, 1fr);
  gap: @space-xxs;
  align-self: end;
  height: var(--pads-square-size);
}

.drum-machine-shell :deep(.mode-buttons) {
  grid-area: strip;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(8, 1fr);
  gap: @space-xxs;
  align-self: end;
  height: var(--pads-square-size);
}

.mode-buttons .control-btn {
  min-height: calc(var(--pad-cell-size) * 2);
}

.drum-machine-shell :deep(.mode-buttons .control-btn) {
  min-height: calc(var(--pad-cell-size) * 2);
}

.pads-stack {
  align-self: end;
}

.drum-machine-shell :deep(.pads-stack) {
  align-self: end;
}

.pads-square {
  max-width: var(--pads-square-size);
  aspect-ratio: 1 / 1;
}

.drum-machine-shell :deep(.pads-square) {
  max-width: var(--pads-square-size);
  aspect-ratio: 1 / 1;
}

.pad-grid-indicator {
  overflow: visible;
}

.drum-machine-shell :deep(.pad-grid-indicator) {
  overflow: visible;
}

.drawer-shell :deep([data-tab='fx']),
.drawer-shell :deep(.fx-panel) {
  display: none !important;
}

</style>



=========================================
File: components/FxPopup.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .fx-popup
      .fx-popup-header
        .fx-title {{ effectLabel }}
        .fx-context {{ contextLabel }}
        button.fx-close(@click="$emit('close')") âœ•
      .fx-popup-body
        FxPanel(
          :fx-settings="fxSettings"
          @fx:update="$emit('fx:update', $event)"
        )
</template>

<script lang="ts">
export default {
  name: 'FxPopup'
}
</script>

<style lang="less" scoped>
@import '@/styles/variables.less';

.fx-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: min(720px, 92vw);
  max-height: 92vh;
  display: flex;
  flex-direction: column;
  background: @color-surface-2;080b10;
  border: 1px solid @color-border-2;
  @radius-xl: 20px;
  z-index: 2000;
}

.fx-popup-header {
  flex: 0 0 auto;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);

  .fx-title {
    font-weight: 600;
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }

  .fx-context {
    margin-left: auto;
    font-size: 0.75rem;
    opacity: 0.6;
  }

  .fx-close {
    background: transparent;
    border: none;
    color: inherit;
    font-size: 1.2rem;
    cursor: pointer;
  }
}

.fx-popup-body {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}
</style>


=========================================
File: components/MidiPanel.vue
=========================================

<template lang="pug">
v-card
  v-card-title MIDI
  v-card-text
    p(v-if="!supports") Web MIDI not supported in this browser.
    template(v-else)
      v-btn(color="primary" @click="$emit('request')") Request Access
      v-select(:items="devices" item-title="name" item-value="id" label="MIDI Inputs")
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { MidiDeviceInfo } from '~/types/midi'

export default defineComponent({
  name: 'MidiPanel',
  props: {
    devices: { type: Array as () => MidiDeviceInfo[], required: true },
    supports: { type: Boolean, required: true }
  },
  emits: ['request']
})
</script>



=========================================
File: components/PadCell.vue
=========================================

<template lang="pug">
  button.pad-cell(
    type="button"
    :class="padClasses"
    :title="padHint"
    :aria-label="padHint"
    :style="padStyle"
    @pointerdown.prevent="handleActivate"
    @click.prevent="handleActivate"
    @keydown.enter.prevent="handleActivate"
    @keydown.space.prevent="handleActivate"
    :aria-pressed="isSelected"
  )
    span.pad-label {{ label }}
    span.pad-key(v-if="keyLabel") {{ keyLabel }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { DrumPadId } from '@/types/drums'
// Represents a single drum pad cell, emitting pad hits and selection while reflecting trigger/play states.

export default defineComponent({
  name: 'PadCell',
  props: {
    padId: { type: String as () => DrumPadId, required: true },
    label: { type: String, required: true },
    isSelected: { type: Boolean, default: false },
    isTriggered: { type: Boolean, default: false },
    isPlaying: { type: Boolean, default: false },
    isEmpty: { type: Boolean, default: false },
    keyLabel: { type: String, default: null },
    padColor: { type: String, default: '#12c8ff' }
  },
  emits: ['pad:down', 'pad:select'],
  computed: {
    padClasses(): Record<string, boolean> {
      return {
        'is-selected': this.isSelected,
        'is-triggered': this.isTriggered,
        'is-playing': this.isPlaying,
        'is-empty': this.isEmpty
      }
    },

    padHint(): string {
      const key = this.keyLabel ? ` (${this.keyLabel})` : ''
      return `${this.label}${key} â€“ click or press to trigger/select`
    },

    padStyle(): Record<string, string> {
      return {
        '--pad-color-base': this.padColor
      }
    }
  },
  methods: {
    handleActivate() {
      this.$emit('pad:down', this.padId)
      this.$emit('pad:select', this.padId)
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.pad-cell {
  width: 100%;
  height: 100%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  color: @color-text-primary;
  background: linear-gradient(
    180deg,
    color-mix(in srgb, var(--pad-color-base, #12c8ff) 80%, #ffffff 20%),
    color-mix(in srgb, var(--pad-color-base, #12c8ff) 85%, #000000 15%)
  );
  border: 1px solid #2c3342;
  border-radius: @radius-s;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.08),
    0 6px 14px rgba(0,0,0,0.45);
}

.pad-cell.is-empty {
  background-color: #f2f1e8;
  border-color: #d6d4c8;
}

.pad-cell.is-selected {
  border-color: @color-border-3;

  box-shadow:
    0 0 0 2px fade(@color-border-3, 25%),
    @shadow-box;
}

.pad-cell.is-triggered {
  background-color: ~"color-mix(
    in srgb,
    @color-surface-1 calc(100% - (var(--pad-velocity) * 60%)),
    #000000
  )";
}

.pad-cell.is-triggered .pad-label {
  opacity: 0.85;
}

.pad-cell:not(.is-empty).is-triggered::after {
  box-shadow: 0 0
    calc(10px * var(--pad-velocity))
    fade(@color-accent-primary, 40%);
}

.pad-cell.is-triggered:not(.is-playing) {
  background: linear-gradient(
    180deg,
    fade(@color-text-primary, 90%),
    fade(@color-text-primary, 65%)
  );
}

.pad-cell:active {
  transform: translateY(1px);
  box-shadow:
    inset 0 3px 6px rgba(0,0,0,0.8);
}

.pad-label {
  font-weight: 600;
  letter-spacing: 0.04em;
  color: #fefefe;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

.pad-cell.is-playing {
  background: linear-gradient(
    180deg,
    fade(@color-accent-primary, 90%),
    fade(@color-accent-primary, 55%)
  );

  box-shadow:
    0 0 calc(18px * var(--pad-velocity))
      fade(@color-accent-primary, 70%),
    @shadow-box;
}

.pad-key {
  position: absolute;
  bottom: @space-xs;
  left: @space-xs;
  font-size: @font-size-xs;
  opacity: 0;
  pointer-events: none;
}

.pad-grid:focus-visible .pad-key {
  opacity: 0.35;
}
</style>



=========================================
File: components/PadGrid 2.vue
=========================================

<template lang="pug">
v-card
  v-card-title Pads
  v-card-text
    .pad-grid
      v-btn(v-for="pad in pads" :key="pad" color="primary" block @click="$emit('pad:down', pad)") {{ pad }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { DrumPadId } from '~/types/drums'

export default defineComponent({
  name: 'PadGrid',
  props: {
    pads: { type: Array as () => DrumPadId[], required: true }
  },
  emits: ['pad:down']
})
</script>



=========================================
File: components/PadGrid.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .pad-grid(
      role="grid"
      tabindex="0"
      aria-label="Pad grid"
      :aria-rowcount="4"
      :aria-colcount="4"
      @keydown.arrow-up.prevent="moveSelection(-4)"
      @keydown.arrow-down.prevent="moveSelection(4)"
      @keydown.arrow-left.prevent="moveSelection(-1)"
      @keydown.arrow-right.prevent="moveSelection(1)"
      @keydown.home.prevent="selectIndex(0)"
      @keydown.end.prevent="selectIndex(pads.length - 1)"
      @keydown.page-up.prevent="selectRow(0)"
      @keydown.page-down.prevent="selectRow(3)"
      :style="velocityStyle"
    )
      PadCell(
        v-for="(pad, index) in pads"
        :key="pad"
        :ref="setPadRef(pad)"
        :pad-id="pad"
        :label="padLabel(pad)"
        :is-selected="selectedPad === pad"
        :is-focusable="selectedPad === pad"
        :is-triggered="padStates[pad]?.isTriggered ?? false"
        :is-playing="padStates[pad]?.isPlaying ?? false"
        :is-empty="padIsEmpty(pad)"
        :key-label="keyLabels[index]"
        :pad-color="padColors[index] ?? padColors[0]"
        role="gridcell"
        :aria-label="padAriaLabel(pad)"
        :aria-rowindex="Math.floor(index / 4) + 1"
        :aria-colindex="(index % 4) + 1"
        @pad:down="$emit('pad:down', $event)"
        @pad:select="$emit('pad:select', $event)"
      )
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import PadCell from './PadCell.vue'
import type { DrumPadId } from '@/types/drums'
// Renders a 4x4 pad grid with keyboard navigation and selection, delegating interactions to PadCell instances.

const KEY_LABELS = [
  'Q','W','E','R',
  'A','S','D','F',
  'Z','X','C','V',
  '1','2','3','4'
]

type PadState = {
  label: string
  isTriggered: boolean
  isPlaying: boolean
}

export default defineComponent({
  name: 'PadGrid',
  components: { 
    PadCell,
    
    },

  props: {
    pads: { type: Array as () => DrumPadId[], required: true },
    selectedPad: { type: String as () => DrumPadId | null, default: null },
    velocity: { type: Number, default: 1 },
    padStates: {
      type: Object as () => Partial<Record<DrumPadId, PadState>>,
      default: () => ({})
    },
    padColors: {
      type: Array as () => string[],
      default: () => [
        '#12c8ff','#00d5ff','#00c3ff','#00b4ff',
        '#ffb840','#ff9f30','#ffb43c','#ff9c2a',
        '#ff3a3a','#ff4f4f','#ffd13a','#ffbc2a',
        '#46e3ff','#38d4ff','#2cc5ff','#20baff'
      ]
    }
  },

  emits: ['pad:down', 'pad:select'],

  data() {
    return {
      internalPadRefs: {} as Record<DrumPadId, InstanceType<typeof PadCell> | undefined>
    }
  },

  computed: {
    velocityStyle(): Record<string, string> {
      const clamped = Math.min(1, Math.max(0, this.velocity))
      return { '--pad-velocity': clamped.toString() }
    },

    keyLabels(): string[] {
      return KEY_LABELS
    },
    
    padRefs(): Record<DrumPadId, InstanceType<typeof PadCell> | undefined> {
      return this.internalPadRefs
    }
  },

  watch: {
    selectedPad(newPad: DrumPadId | null) {
      if (!newPad) return
      this.$nextTick(() => {
        const ref = this.padRefs[newPad]
        ref?.$el?.focus?.()
      })
    }
  },

  mounted() {
    if (this.pads.length !== this.keyLabels.length) {
      console.warn(
        `[PadGrid] pads (${this.pads.length}) â‰  keyLabels (${this.keyLabels.length})`
      )
    }
  },

  methods: {
    setPadRef(pad: DrumPadId) {
      return (el: InstanceType<typeof PadCell> | null) => {
        if (el) {
          this.internalPadRefs[pad] = el
        } else {
          delete this.internalPadRefs[pad]
        }
      }
    },

    padLabel(pad: DrumPadId): string {
      return this.padStates[pad]?.label ?? pad.toUpperCase()
    },

    padAriaLabel(pad: DrumPadId): string {
      const label = this.padLabel(pad)
      return `${label} pad`
    },

    padIsEmpty(pad: DrumPadId): boolean {
      return !this.padStates[pad]?.label
    },

    handlePadDown(pad: DrumPadId, velocity: number) {
      this.$emit('pad:down', pad, velocity)
    },

    handlePadSelect(pad: DrumPadId) {
      this.$emit('pad:select', pad)
    },

    selectIndex(index: number) {
      if (index < 0 || index >= this.pads.length) return
      this.$emit('pad:select', this.pads[index])
    },

    selectRow(row: number) {
      const columns = 4
      const index = row * columns
      if (index < this.pads.length) {
        this.$emit('pad:select', this.pads[index])
      }
    },

    moveSelection(offset: number) {
      if (!this.selectedPad) return

      const index = this.pads.indexOf(this.selectedPad)
      if (index === -1) return

      const columns = 4
      let nextIndex = index + offset

      if (offset === -1 && index % columns === 0) {
        nextIndex = index + (columns - 1)
      }

      if (offset === 1 && (index + 1) % columns === 0) {
        nextIndex = index - (columns - 1)
      }

      if (nextIndex < 0 || nextIndex >= this.pads.length) return
      this.$emit('pad:select', this.pads[nextIndex])
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.pad-grid {
  display: grid;
  grid-template-rows: repeat(4, minmax(0, 1fr));
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: @space-s;
  width:100%;
  height:100%;
  background: @color-surface-2;
  padding: @space-m;
  box-sizing: border-box;
  border-radius: @radius-l;
  border: 1px solid @color-border-2;

}

.pad-grid:focus-visible {
  outline: @outline-focus;
  outline-offset: @outline-focus-offset;
  border-color: #00f8ff;
}
.pad-cell.is-selected {
  border-color: @color-accent-primary;
  outline: 2px dashed #00f8ff;
  outline-offset: 3px;
}
.pad-cell:focus-visible:not(.is-selected) {
  outline: @outline-focus;
  outline-offset: @outline-focus-offset;
  box-shadow: 0 0 calc(12px * var(--pad-velocity)) ~"rgba(0, 255, 255, calc(0.2 + 0.6 * var(--pad-velocity)))";
  box-shadow: 0 0 calc(12px * var(--pad-velocity)) fade(@color-accent-primary, 60%);
}

</style>



=========================================
File: components/PlayheadOverlay.vue
=========================================

<template lang="pug">
  div.playhead-overlay(
    v-if="totalSteps > 0"
    :style="overlayStyle"
    :class="{ 'is-playing': isPlaying }"
  )
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { CSSProperties } from 'vue'

export default defineComponent({
  name: 'PlayheadOverlay',
  // Visual overlay that positions a playhead indicator across a step grid based on current playback state.
  props: {
    currentStep: { type: Number, required: true },
    totalSteps: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true }
  },
  computed: {
    safeTotalSteps(): number {
      return Math.max(this.totalSteps, 1)
    },
    clampedStep(): number {
      const maxIndex = this.safeTotalSteps - 1
      return Math.min(Math.max(0, this.currentStep), maxIndex)
    },
    stepWidthPercent(): number {
      return 100 / this.safeTotalSteps
    },
    overlayStyle(): CSSProperties {
      return {
        '--step-count': `${this.safeTotalSteps}`,
        '--step-index': `${this.clampedStep}`
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.playhead-overlay {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  --grid-gap: 8px;
  --step-count: 1;
  --step-index: 0;
  width: calc(
    (100% - (var(--grid-gap) * (var(--step-count) - 1))) / var(--step-count)
  );
  left: calc(
    var(--step-index) *
      (
        (100% - (var(--grid-gap) * (var(--step-count) - 1))) / var(--step-count) +
          var(--grid-gap)
      )
  );
  background: transparent;
  pointer-events: none;
  border-radius: @radius-xs;
  box-shadow:
    inset 0 0 0 1px fade(@color-accent-primary, 28%),
    inset 0 0 0 2px fade(@color-accent-primary, 12%);
  opacity: 0.97;
  transition: none;

  &.is-playing {
    transition: left 120ms linear;
  }

  &::before {
    content: '';
    position: absolute;
    top: 10%;
    bottom: 10%;
    left: 0;
    right: 0;
    margin: auto;
    background: linear-gradient(
      90deg,
      fade(@color-accent-primary, 0%) 0%,
      fade(@color-accent-primary, 28%) 45%,
      fade(@color-accent-primary, 46%) 50%,
      fade(@color-accent-primary, 28%) 55%,
      fade(@color-accent-primary, 0%) 100%
    );
    box-shadow:
      0 0 10px fade(@color-accent-primary, 30%),
      0 0 18px fade(@color-accent-primary, 16%),
      inset 0 0 8px fade(@color-accent-primary, 20%);
  }
}
</style>



=========================================
File: components/SampleBrowser.vue
=========================================

<template lang="pug">
v-card
  v-card-title Samples
  v-card-text
    p Add custom sample support here.
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'SampleBrowser'
})
</script>



=========================================
File: components/SoundbankManager.vue
=========================================

<template lang="pug">
v-card
  v-card-title Soundbanks
  v-card-text
    v-list
      v-list-item(v-for="bank in banks" :key="bank.id")
        v-list-item-title {{ bank.name }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { Soundbank } from '~/types/audio'

export default defineComponent({
  name: 'SoundbankManager',
  props: {
    banks: { type: Array as () => Soundbank[], required: true }
  }
})
</script>



=========================================
File: components/StepCell.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    button.step-cell(
      type="button"
      :class="cellClasses"
      :aria-pressed="isActive"
      @click="onToggle"
      @pointerdown="onPointerDown"
      @pointermove="onPointerMove"
      @pointerup="onPointerUp"
      @pointercancel="onPointerCancel"
    )
      span.step-tag {{ displayLabel }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'StepCell',
  props: {
    isAccent: { type: Boolean, default: false },
    isActive: { type: Boolean, default: false },
    isCurrent: { type: Boolean, default: false },
    displayLabel: { type: String, default: '' }
  },
  emits: [
    'cell:toggle',
    'cell:pointerdown',
    'cell:pointermove',
    'cell:pointerup',
    'cell:pointercancel'
  ],
  computed: {
    cellClasses(): Record<string, boolean> {
      return {
        'is-active': this.isActive,
        'is-accent': this.isAccent,
        'is-current': this.isCurrent
      }
    }
  },
  methods: {
    onToggle(): void {
      this.$emit('cell:toggle')
    },
    onPointerDown(event: PointerEvent): void {
      if (event.currentTarget instanceof HTMLElement) {
        event.currentTarget.setPointerCapture(event.pointerId)
      }
      this.$emit('cell:pointerdown', event)
    },
    onPointerMove(event: PointerEvent): void {
      this.$emit('cell:pointermove', event)
    },
    onPointerUp(event: PointerEvent): void {
      this.$emit('cell:pointerup', event)
    },
    onPointerCancel(event: PointerEvent): void {
      this.$emit('cell:pointercancel', event)
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.step-cell {
  border: none;
  border-radius: @radius-s;
  background: fade(@color-accent-primary, 15%);
  color: @color-text-primary;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: @font-size-xs;
  padding: @space-xs 0;
  transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
  position: relative;
  cursor: pointer;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  z-index: 1;

  &:not(.is-active):hover {
    background: fade(@color-accent-primary, 25%);
  }

  &:active {
    transform: scale(0.97);
  }

  &:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px fade(@color-accent-primary, 60%);
  }

  &.is-active {
    background: fade(@color-accent-primary, 15%);
  }

  &.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 25%),
      fade(@color-accent-warning, 65%)
    );
  }

  &.is-active.is-accent {
    background: linear-gradient(
      135deg,
      fade(@color-accent-warning, 35%),
      fade(@color-accent-primary, 35%)
    );
  }

  &.is-current {
    box-shadow: inset 0 0 0 2px fade(@color-accent-primary, 90%);
  }

  &.is-accent.is-current {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
    animation: accent-scan-pulse 160ms ease-out 1;
  }
}

.step-tag {
  font-size: @font-size-xs;
  letter-spacing: @letter-spacing-tight;
}

@keyframes accent-scan-pulse {
  from {
    transform: scale(1.02);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 95%),
      0 0 16px fade(@color-accent-warning, 38%);
  }
  to {
    transform: scale(1);
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-warning, 85%),
      0 0 12px fade(@color-accent-warning, 32%);
  }
}
</style>



=========================================
File: components/StepGrid 2.vue
=========================================

<template lang="pug">
v-card
  v-card-title Step Grid
  v-card-text
    .step-grid
      .step-row(v-for="pad in padOrder" :key="pad")
        v-btn(
          v-for="stepIndex in totalSteps"
          :key="`${pad}-${stepIndex}`"
          :color="buttonColor(pad, stepIndex - 1)"
          size="small"
          @click="toggle(pad, stepIndex - 1)"
        ) {{ stepIndex }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { GridSpec } from '~/types/time'
import type { DrumPadId, StepGrid } from '~/types/drums'

export default defineComponent({
  name: 'StepGrid',
  props: {
    gridSpec: { type: Object as () => GridSpec, required: true },
    steps: { type: Object as () => StepGrid, required: true },
    currentStep: { type: Number, required: true }
  },
  emits: ['step:toggle'],
  data() {
    const padOrder: DrumPadId[] = [
      'pad1',
      'pad2',
      'pad3',
      'pad4',
      'pad5',
      'pad6',
      'pad7',
      'pad8',
      'pad9',
      'pad10',
      'pad11',
      'pad12',
      'pad13',
      'pad14',
      'pad15',
      'pad16'
    ]

    return {
      padOrder
    }
  },
  computed: {
    totalSteps(): number {
      return this.gridSpec.bars * this.gridSpec.division
    }
  },
  methods: {
    isActive(padId: DrumPadId, stepIndex: number) {
      const barIndex = Math.floor(stepIndex / this.gridSpec.division)
      const stepInBar = stepIndex % this.gridSpec.division
      return Boolean(this.steps[barIndex]?.[stepInBar]?.[padId])
    },
    isCurrent(stepIndex: number) {
      return this.currentStep === stepIndex
    },
    buttonColor(padId: DrumPadId, stepIndex: number) {
      if (this.isActive(padId, stepIndex)) {
        return this.isCurrent(stepIndex) ? 'deep-purple-accent-3' : 'primary'
      }
      return this.isCurrent(stepIndex) ? 'info' : 'grey'
    },
    toggle(padId: DrumPadId, stepIndex: number) {
      const barIndex = Math.floor(stepIndex / this.gridSpec.division)
      const stepInBar = stepIndex % this.gridSpec.division
      this.$emit('step:toggle', { barIndex, stepInBar, padId })
    }
  }
})
</script>



=========================================
File: components/StepGrid.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .step-grid-shell(
      role="grid"
      :aria-label="stepGridLabel"
      :aria-colcount="totalSteps"
      tabindex="0"
      @keydown="onKeydown"
      ref="shell"
    )
      .step-row(role="row")
        StepCell(
          v-for="stepIndex in totalSteps"
          :key="stepIndex"
          :display-label="String(stepIndex)"
          :is-active="isActive(stepIndex - 1)"
          :is-accent="isAccent(stepIndex - 1)"
          :is-current="isCurrent(stepIndex - 1)"
          :class="{ 'is-pattern-start': isPatternStart(stepIndex - 1) }"
          role="gridcell"
          :aria-label="cellAriaLabel(stepIndex - 1)"
          :aria-selected="isActive(stepIndex - 1)"
          @cell:toggle="emitToggle(stepIndex - 1)"
          @cell:pointerdown="onCellPointerDown(stepIndex - 1, $event)"
          @cell:pointermove="onCellPointerMove($event)"
          @cell:pointerup="onCellPointerUp($event)"
          @cell:pointercancel="onCellPointerCancel($event)"
        )
        div.pattern-boundary(
          v-for="boundary in patternBoundaries"
          :key="boundary"
          :style="boundaryStyle(boundary)"
        )
      PlayheadOverlay(
        v-if="totalSteps > 0"
        :current-step="currentStepNormalized"
        :total-steps="totalSteps"
        :is-playing="isPlaying"
      )
      div.loop-overlay(:style="loopStyle" aria-hidden="true")
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import StepCell from './StepCell.vue'
import PlayheadOverlay from './PlayheadOverlay.vue'
import type { GridSpec } from '@/types/time'
import type { DrumPadId, StepGrid } from '@/types/drums'
import { ACCENT_STEP_VELOCITY, clampVelocity } from '@/domain/velocity'

export default defineComponent({
  name: 'StepGrid',
  components: {
    StepCell,
    PlayheadOverlay
  },
  props: {
    gridSpec: { type: Object as () => GridSpec, required: true },
    steps: { type: Object as () => StepGrid, required: true },
    patternChain: {
      type: Array as () => Array<{ id: string; bars: number }> | null,
      default: null
    },
    selectedPad: { type: String as () => DrumPadId | null, default: null },
    currentStep: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true },
    followEnabled: { type: Boolean, default: true },
    loopStart: { type: Number, default: 0 },
    loopEnd: { type: Number, default: 1 }
  },
  emits: ['step:toggle', 'playhead:scrub', 'step:velocity'],
  data() {
    return {
      dragState: null as null | {
        pointerId: number
        startY: number
        startVelocity: number
        stepIndex: number
      }
    }
  },
  computed: {
    totalSteps(): number {
      return Math.max(0, this.gridSpec.bars * this.gridSpec.division)
    },
    currentStepNormalized(): number {
      const steps = Math.max(this.totalSteps, 1)
      return ((this.currentStep % steps) + steps) % steps
    },
    stepGridLabel(): string {
      return this.selectedPad ? `Steps for ${this.selectedPad}` : 'Step grid'
    },
    patternBoundaries(): number[] {
      if (!this.patternChain || this.patternChain.length === 0) {
        return []
      }

      const boundaries: number[] = []
      const stepsPerBar = this.gridSpec.division
      let cumulative = 0

      this.patternChain.forEach((entry, index) => {
        cumulative += entry.bars * stepsPerBar
        if (index === this.patternChain!.length - 1) {
          return
        }
        if (cumulative < this.totalSteps) {
          boundaries.push(cumulative)
        }
      })

      return boundaries
    },
    loopStyle(): Record<string, string> {
      const total = Math.max(1, this.totalSteps)
      const clampedStart = Math.max(0, Math.min(this.loopStart, total - 1))
      const clampedEnd = Math.max(clampedStart + 1, Math.min(this.loopEnd, total))
      const left = (clampedStart / total) * 100
      const width = ((clampedEnd - clampedStart) / total) * 100
      return { left: `${left}%`, width: `${width}%` }
    }
  },
  methods: {
    focusGrid(): void {
      const el = this.$refs.shell as HTMLElement | undefined
      el?.focus()
    },
    resolveStepPosition(index: number): { barIndex: number; stepInBar: number } {
      const barIndex = Math.floor(index / this.gridSpec.division)
      const stepInBar = index % this.gridSpec.division
      return { barIndex, stepInBar }
    },
    emitToggle(index: number): void {
      if (!this.selectedPad) {
        return
      }
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      this.$emit('step:toggle', {
        barIndex,
        stepInBar,
        padId: this.selectedPad
      })
    },
    velocityAt(index: number): number | null {
      if (!this.selectedPad) {
        return null
      }

      const { barIndex, stepInBar } = this.resolveStepPosition(index)

      return (
        this.steps[barIndex]?.[stepInBar]?.[this.selectedPad]?.velocity?.value ??
        null
      )
    },
    isActive(index: number): boolean {
      return this.velocityAt(index) !== null
    },
    isAccent(index: number): boolean {
      const velocity = this.velocityAt(index)
      const ACCENT_EPSILON = 0.01

      return (
        velocity !== null &&
        velocity >= ACCENT_STEP_VELOCITY - ACCENT_EPSILON
      )
    },
    isCurrent(index: number): boolean {
      return this.followEnabled && index === this.currentStepNormalized
    },
    onKeydown(event: KeyboardEvent): void {
      if (this.totalSteps <= 0) {
        return
      }

      const isArrowLeft = event.key === 'ArrowLeft'
      const isArrowRight = event.key === 'ArrowRight'

      if (!isArrowLeft && !isArrowRight) {
        return
      }

      event.preventDefault()

      const stepDelta = event.shiftKey ? this.gridSpec.division : 1
      const delta = isArrowLeft ? -stepDelta : stepDelta
      const steps = this.totalSteps
      const nextStep =
        ((this.currentStepNormalized + delta) % steps + steps) % steps

      this.$emit('playhead:scrub', { stepIndex: nextStep })
    },
    emitVelocity(index: number, velocity: number): void {
      if (!this.selectedPad) {
        return
      }
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      this.$emit('step:velocity', {
        barIndex,
        stepInBar,
        padId: this.selectedPad,
        velocity
      })
    },
    onCellPointerDown(index: number, event: PointerEvent): void {
      if (!this.selectedPad) {
        return
      }
      const startVelocity = this.velocityAt(index)
      if (startVelocity === null) {
        return
      }

      this.dragState = {
        pointerId: event.pointerId,
        startY: event.clientY,
        startVelocity,
        stepIndex: index
      }
    },
    onCellPointerMove(event: PointerEvent): void {
      if (!this.dragState || event.pointerId !== this.dragState.pointerId) {
        return
      }
      const deltaY = this.dragState.startY - event.clientY
      const VELOCITY_PER_PIXEL = 0.006
      const nextVelocity = clampVelocity(
        this.dragState.startVelocity + deltaY * VELOCITY_PER_PIXEL
      )
      this.emitVelocity(this.dragState.stepIndex, nextVelocity)
    },
    onCellPointerUp(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },
    onCellPointerCancel(event: PointerEvent): void {
      if (this.dragState && event.pointerId === this.dragState.pointerId) {
        this.dragState = null
      }
    },
    cellAriaLabel(index: number): string {
      const { barIndex, stepInBar } = this.resolveStepPosition(index)
      const stepNumber = stepInBar + 1
      const barNumber = barIndex + 1
      const activeState = this.isActive(index) ? 'active' : 'inactive'
      return `Bar ${barNumber}, step ${stepNumber}, ${activeState}`
    },
    isPatternStart(index: number): boolean {
      if (!this.patternChain || this.patternChain.length === 0) {
        return false
      }
      if (index === 0) {
        return true
      }
      return this.patternBoundaries.includes(index)
    },
    boundaryStyle(startIndex: number): Record<string, string> {
      const leftPercent =
        this.totalSteps > 0 ? (startIndex / this.totalSteps) * 100 : 0
      return {
        left: `${leftPercent}%`
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.step-grid-shell {
  margin-top: 0;
  padding: 10px;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  position: relative;
  height: 100%;
  max-height: 96px;
  overflow: visible;
}

.step-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
  gap: 8px;
  position: relative;
  overflow: visible;

  > .playhead-overlay {
    pointer-events: none;
    z-index: 0;
  }

  > .step-cell {
    z-index: 1;
  }

  > .step-cell:nth-child(4n + 1) {
    border-left: 2px solid rgba(255, 255, 255, 0.12);
    padding-left: 12px;
  }

  > .step-cell.is-pattern-start {
    box-shadow:
      inset 0 0 0 2px fade(@color-accent-primary, 45%),
      0 0 10px fade(@color-accent-primary, 16%);
  }
}

.pattern-boundary {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 2px;
  margin-left: -1px;
  background: linear-gradient(
    to bottom,
    fade(@color-accent-primary, 0%) 0%,
    fade(@color-accent-primary, 28%) 45%,
    fade(@color-accent-primary, 8%) 100%
  );
  pointer-events: none;
  z-index: 0;
}

.loop-overlay {
  position: absolute;
  top: 0;
  bottom: 0;
  background: fade(@color-accent-primary, 12%);
  border-left: 2px solid fade(@color-accent-primary, 35%);
  border-right: 2px solid fade(@color-accent-primary, 35%);
  pointer-events: none;
  z-index: 0;
}

@media (max-height: 820px) {
  .step-grid-shell {
    max-height: 88px;
    padding: 8px;
  }
}

@media (max-width: 640px) {
  .step-grid-shell {
    padding: 8px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(44px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 44px;
    padding: 10px 0;
    font-size: @font-size-xs;
  }
}

@media (max-width: 480px) {
  .step-grid-shell {
    padding: 6px;
    max-height: 80px;
  }

  .step-row {
    gap: 6px;
    grid-template-columns: repeat(auto-fit, minmax(48px, 1fr));
  }

  .step-row > .step-cell {
    min-height: 48px;
    padding: 12px 0;
  }
}
</style>



=========================================
File: components/SyncPanel.vue
=========================================

<template lang="pug">
v-card
  v-card-title Sync
  v-card-text
    v-select(:items="modes" v-model="mode" label="Mode")
    v-select(:items="roles" v-model="role" label="Role")
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { SyncState } from '~/types/sync'

export default defineComponent({
  name: 'SyncPanel',
  props: {
    syncState: { type: Object as () => SyncState, required: true }
  },
  emits: ['mode', 'role'],
  data() {
    return {
      modes: ['internal', 'midiClock', 'abletonLink'],
      roles: ['master', 'slave'],
      mode: this.syncState.mode,
      role: this.syncState.role
    }
  },
  watch: {
    mode(value: string) {
      this.$emit('mode', value)
    },
    role(value: string) {
      this.$emit('role', value)
    }
  }
})
</script>



=========================================
File: components/TabPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .drawer-shell
      v-tabs(
        v-model="internalTab"
        density="comfortable"
        variant="text"
        class="drawer-tabs"
      )
        v-tab(v-for="tab in tabs" :key="tab.value" :value="tab.value") {{ tab.label }}
      v-tabs-window(v-model="internalTab" class="drawer-window")
        v-tabs-window-item(value="sound")
          slot(name="sound")
        v-tabs-window-item(value="fx")
          slot(name="fx")
        v-tabs-window-item(value="patterns")
          slot(name="patterns")
        v-tabs-window-item(value="export")
          slot(name="export")
</template>

<script lang="ts">
import { defineComponent } from 'vue'

const tabs = [
  { label: 'Sound', value: 'sound' },
  { label: 'FX', value: 'fx' },
  { label: 'Patterns', value: 'patterns' },
  { label: 'Export', value: 'export' },
  { label: 'Channel', value: 'channel' }
]

export default defineComponent({
  name: 'TabPanel',
  // Drawer tab container that switches between sound, FX, patterns, and export slots.
  props: {
    modelValue: { type: String, default: 'sound' }
  },
  emits: ['update:modelValue'],
  computed: {
    internalTab: {
      get(): string {
        return this.modelValue
      },
      set(value: string) {
        this.$emit('update:modelValue', value)
      }
    },
    tabs() {
      return tabs
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.drawer-shell {
  margin-top: 24px;
  @radius-xl: 20px;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  padding: 0;
  display: flex;
  flex-direction: column;
  height: 100%;

  .drawer-tabs {
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    background: @color-surface-2;
    flex: 0 0 56px;
  }

  .drawer-window {
    background: @color-surface-2;
    border-radius: 0 0 16px 16px;
    padding: 16px;
    flex: 1 1 auto;
    overflow-y: auto;
    max-height: calc(100% - 56px);
  }
}

@media (max-height: 780px) {
  .drawer-shell {
    margin-top: 16px;
  }
}
</style>



=========================================
File: components/TransportBar 2.vue
=========================================

<template lang="pug">
v-card
  v-card-title Transport
  v-card-text
    v-row(align="center")
      v-col(cols="12" md="4")
        v-btn(color="primary" @click="$emit('play')" :disabled="isPlaying") Play
        v-btn(color="secondary" class="ml-2" @click="$emit('stop')" :disabled="!isPlaying") Stop
      v-col(cols="12" md="4")
        v-text-field(label="BPM" type="number" :model-value="bpm" @update:model-value="onBpm" min="40" max="240")
      v-col(cols="12" md="4")
        v-switch(label="Loop" color="primary" :model-value="loop" @update:model-value="onLoop")
    v-row
      v-col(cols="12" md="6")
        v-select(
          label="Division"
          :items="divisionItems"
          item-title="title"
          item-value="value"
          :model-value="division"
          @update:model-value="onDivision"
          hide-details
        )
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { TimeDivision } from '~/types/time'

export default defineComponent({
  name: 'TransportBar',
  props: {
    bpm: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true },
    loop: { type: Boolean, required: true },
    division: { type: Number as () => TimeDivision, required: true },
    divisions: { type: Array as () => TimeDivision[], required: true }
  },
  emits: ['play', 'stop', 'bpm:update', 'loop:update', 'division:update'],
  computed: {
    divisionItems(): Array<{ title: string; value: TimeDivision }> {
      return this.divisions.map((value) => ({
        title: `1/${value}`,
        value
      }))
    }
  },
  methods: {
    onBpm(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('bpm:update', numeric)
      }
    },
    onLoop(value: boolean) {
      this.$emit('loop:update', value)
    },
    onDivision(value: TimeDivision | null) {
      if (value) {
        this.$emit('division:update', value)
      }
    }
  }
})
</script>



=========================================
File: components/TransportBar.vue
=========================================

<template lang="pug">
client-only(tag="div")
  .transport-bar
    .transport-grid
      button.control-btn(type="button")
        span.control-btn__main RESTART
        span.control-btn__sub Loop
      button.control-btn(type="button")
        span.control-btn__main ERASE
        span.control-btn__sub Replace
      button.control-btn(type="button")
        span.control-btn__main TAP
        span.control-btn__sub Metro
      button.control-btn(type="button")
        span.control-btn__main FOLLOW
        span.control-btn__sub Grid
      button.control-btn(type="button")
        span.control-btn__main PLAY
      button.control-btn(type="button")
        span.control-btn__main REC
        span.control-btn__sub Count In
      button.control-btn(type="button")
        span.control-btn__main STOP
      button.control-btn(type="button")
        .shift-label SHIFT
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { TimeDivision } from '@/types/time'

export default defineComponent({
  name: 'TransportBar',
  // Provides playback controls plus BPM, division, loop, and MIDI learn toggles for the drum machine.
  props: {
    bpm: { type: Number, required: true },
    isPlaying: { type: Boolean, required: true },
    loop: { type: Boolean, required: true },
    division: { type: Number as () => TimeDivision, required: true },
    divisions: { type: Array as () => TimeDivision[], required: true },
    isMidiLearning: { type: Boolean, default: false },
    isRecording: { type: Boolean, default: false },
    countInEnabled: { type: Boolean, default: false },
    countInBars: { type: Number, default: 1 },
    metronomeEnabled: { type: Boolean, default: false },
    followEnabled: { type: Boolean, default: true },
    patternBars: { type: Number, default: 1 },
    loopStart: { type: Number, default: 0 },
    loopEnd: { type: Number, default: 1 },
    totalSteps: { type: Number, default: 1 },
    selectedPad: { type: String, default: null },
    liveEraseEnabled: { type: Boolean, default: false },
    metronomeVolume: { type: Number, default: 0.12 },
    presetBars: { type: Number, default: 1 },
    presetDivision: { type: Number, default: 4 }
  },

  emits: [
    'play',
    'stop',
    'stop-reset',
    'restart',
    'toggle-record',
    'update-bpm',
    'increment-bpm',
    'decrement-bpm',
    'update-loop',
    'update-division',
    'toggle-midi-learn',
    'toggle-count-in',
    'update-count-in-bars',
    'tap-tempo',
    'toggle-metronome',
    'toggle-follow',
    'update-pattern-bars',
    'nudge-loop-range',
    'update-loop-start',
    'update-loop-end',
    'update:metronome-volume',
    'toggle-live-erase',
    'erase-pad',
    'erase-current-step',
    'update:preset-bars',
    'update:preset-division',
    'apply-pattern-preset'
  ],

  computed: {
    divisionItems(): Array<{ title: string; value: TimeDivision }> {
      return this.divisions.map((value) => ({ title: `1/${value}`, value }))
    }
  },

  methods: {
    onBpm(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-bpm', numeric)
      }
    },
    onDivision(value: TimeDivision | null) {
      if (value != null) {
        this.$emit('update-division', value)
      }
    },
    toggleLoop() {
      this.$emit('update-loop', !this.loop)
    },
    onCountInBars(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-count-in-bars', numeric)
      }
    },
    onPatternBars(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-pattern-bars', numeric)
      }
    },
    onLoopStart(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-loop-start', numeric)
      }
    },
    onLoopEnd(value: number | string) {
      const numeric = Number(value)
      if (!Number.isNaN(numeric)) {
        this.$emit('update-loop-end', numeric)
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.transport-bar {
  width: 100%;
  display: flex;
  flex-direction: column;
  background: @color-surface-1;
  border: 1px solid @color-border-1;
  border-radius: @radius-m;
  padding: @space-s;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), inset 0 -2px 6px rgba(0,0,0,0.65);
}

.transport-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(2, var(--edit-btn-h, clamp(34px, 4.2vh, 44px)));
  gap: @space-xxs;
  width: 100%;
}

.control-btn {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid fade(#3b4355, 65%);
  background: linear-gradient(180deg, #1c2230, #121826);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
  color: rgba(255, 255, 255, 0.88);
  line-height: 1.05;
  text-align: left;
  min-height: 44px;
  max-width: 50%;
}

.control-btn__main {
  font-weight: 800;
  letter-spacing: 0.06em;
  font-size: 12px;
  text-transform: uppercase;
}

.control-btn__sub {
  margin-top: 2px;
  font-weight: 400;
  font-style: italic;
  opacity: 0.75;
  font-size: 11px;
  letter-spacing: 0.02em;
  text-transform: none;
}

.shift-label {
  height: 14px;
  background: #fff;
  color: #000;
  font-weight: 800;
  font-size: 12px;
  letter-spacing: 0.06em;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  border-radius: 4px;
}
</style>



=========================================
File: components/control/DualDisplay.vue
=========================================

<template>
  <div class="dual-display dual-display-root" :title="`${modeTitle} â€¢ ${pageLabel}`">
    <div class="display left">
      <div class="display-header">
        <div class="display-title">{{ modeTitle }}</div>
        <div class="display-subtitle">{{ pageLabel }}</div>
      </div>
      <div class="display-body">
        <div class="panel" :class="panelClass(leftModel)">
          <template v-if="leftModel.view === 'BROWSER'">
            <div class="panel-header">{{ leftModel.title || 'Browser' }}</div>
            <input
              v-model="browserQuery"
              type="search"
              class="browser-search"
              placeholder="Search presets or samples"
              aria-label="Browser search"
            />
            <ul class="item-list">
              <li
                v-for="item in filteredItems(leftModel)"
                :key="item.title"
                :class="{ active: item.active }"
              >
                <div class="item-title">{{ item.title }}</div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
          </template>
          <template v-else-if="leftModel.view === 'FILE'">
            <div class="panel-header">{{ leftModel.title || 'Files' }}</div>
            <ul class="item-list">
              <li v-for="item in leftModel.items" :key="item.title">
                <div class="item-title">{{ item.title }}</div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="leftModel.summary" class="panel-hint">{{ leftModel.summary }}</div>
          </template>
          <template v-else-if="leftModel.view === 'SAMPLING'">
            <div class="panel-header">{{ leftModel.title || 'Sampling' }}</div>
            <ul class="item-list">
              <li v-for="item in leftModel.items" :key="item.title">
                <div class="item-title">{{ item.title }}</div>
                <div class="item-subtitle">{{ item.value || item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="leftModel.summary" class="panel-hint">{{ leftModel.summary }}</div>
          </template>
          <template v-else-if="leftModel.view === 'MIXER' || leftModel.view === 'ARRANGER' || leftModel.view === 'SETTINGS' || leftModel.view === 'INFO'">
            <div class="panel-header">{{ leftModel.title || 'Details' }}</div>
            <ul class="item-list">
              <li v-for="item in leftModel.items" :key="item.title" :class="{ active: item.active }">
                <div class="item-title">
                  {{ item.title }}
                  <span v-if="item.value" class="item-value">{{ item.value }}</span>
                </div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="leftModel.summary" class="panel-hint">{{ leftModel.summary }}</div>
          </template>
          <template v-else>
            <div class="panel-header">{{ leftModel.title || 'Display L' }}</div>
            <div class="panel-hint">{{ leftModel.summary || 'Ready' }}</div>
          </template>
        </div>
        <div class="param-slots">
          <div
            v-for="(param, index) in paramSlotsLeft"
            :key="param.id || index"
            class="param-slot"
          >
            <div class="param-name">{{ param.name }}</div>
            <div class="param-value">{{ formatParam(param.value, param) }}</div>
          </div>
        </div>
      </div>
    </div>
    <div class="display right">
      <div class="display-header">
        <div class="display-title">{{ rightModel.title || 'Display R' }}</div>
        <div class="display-subtitle">{{ rightModel.summary || modeTitle }}</div>
      </div>
      <div class="display-body">
        <div class="panel" :class="panelClass(rightModel)">
          <template v-if="rightModel.view === 'BROWSER'">
            <div class="panel-header">{{ rightModel.title || 'Results' }}</div>
            <ul class="item-list">
              <li v-for="item in filteredItems(rightModel)" :key="item.title" :class="{ active: item.active }">
                <div class="item-title">{{ item.title }}</div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="rightModel.summary" class="panel-hint">{{ rightModel.summary }}</div>
          </template>
          <template v-else-if="rightModel.view === 'MIXER' || rightModel.view === 'ARRANGER' || rightModel.view === 'SETTINGS' || rightModel.view === 'INFO' || rightModel.view === 'FILE'">
            <div class="panel-header">{{ rightModel.title || 'Details' }}</div>
            <ul class="item-list">
              <li v-for="item in rightModel.items" :key="item.title" :class="{ active: item.active }">
                <div class="item-title">
                  {{ item.title }}
                  <span v-if="item.value" class="item-value">{{ item.value }}</span>
                </div>
                <div class="item-subtitle">{{ item.subtitle }}</div>
              </li>
            </ul>
            <div v-if="rightModel.summary" class="panel-hint">{{ rightModel.summary }}</div>
          </template>
          <template v-else-if="rightModel.view === 'SAMPLING'">
            <div class="panel-header">{{ rightModel.title || 'Sampling' }}</div>
            <div class="panel-hint">{{ rightModel.summary || 'Set slice or record' }}</div>
          </template>
          <template v-else>
            <div class="panel-header">{{ rightModel.title || 'Display R' }}</div>
            <div class="panel-hint">{{ rightModel.summary || 'Ready' }}</div>
          </template>
        </div>
        <div class="param-slots">
          <div
            v-for="(param, index) in paramSlotsRight"
            :key="param.id || index"
            class="param-slot"
          >
            <div class="param-name">{{ param.name }}</div>
            <div class="param-value">{{ formatParam(param.value, param) }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, type PropType } from 'vue'

type ListItem = {
  title: string
  subtitle?: string
  active?: boolean
  value?: string
}

type DisplayPanelModel = {
  view: string
  title?: string
  summary?: string
  items?: ListItem[]
}

type ParamSlot = {
  id: string
  name: string
  value: number
  format?: string
}

export default defineComponent({
  name: 'DualDisplay',
  props: {
    leftModel: {
      type: Object as PropType<DisplayPanelModel>,
      required: true
    },
    rightModel: {
      type: Object as PropType<DisplayPanelModel>,
      required: true
    },
    modeTitle: {
      type: String,
      default: ''
    },
    pageLabel: {
      type: String,
      default: ''
    },
    paramSlotsLeft: {
      type: Array as PropType<ParamSlot[]>,
      default: () => []
    },
    paramSlotsRight: {
      type: Array as PropType<ParamSlot[]>,
      default: () => []
    }
  },
  data() {
    return {
      browserQuery: ''
    }
  },
  methods: {
    formatParam(value: number, param: ParamSlot) {
      if (param.format) {
        return `${value}${param.format}`
      }
      return typeof value === 'number' ? Math.round(value * 100) / 100 : value
    },
    panelClass(model: DisplayPanelModel) {
      return `panel-${(model.view || 'empty').toString().toLowerCase()}`
    },
    filteredItems(model: DisplayPanelModel) {
      if (!model?.items || !Array.isArray(model.items)) return []
      if (!this.browserQuery) return model.items
      const query = this.browserQuery.toLowerCase()
      return model.items.filter((item) => {
        return (
          item.title?.toLowerCase().includes(query) ||
          item.subtitle?.toLowerCase().includes(query)
        )
      })
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.dual-display {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: @space-s;
}

.display {
  border-radius: @radius-s;
  background: linear-gradient(180deg, #0f141d, #0b0f16);
  border: 1px solid #2c3545;
  box-shadow:
    inset 0 0 18px rgba(0, 0, 0, 0.65),
    0 8px 28px rgba(0, 0, 0, 0.65);
  color: #9fd4ff;
  min-height: 108px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.display-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: @space-xs;
  font-size: @font-size-s;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: @space-xs @space-s;
  color: #cfe9ff;
  border-bottom: 1px solid fade(#cfe9ff, 10%);
}

.display-title {
  font-weight: 600;
}

.display-subtitle {
  font-size: @font-size-xs;
  opacity: 0.8;
}

.display-body {
  flex: 1 1 auto;
  padding: @space-s;
  font-size: @font-size-s;
  opacity: 0.9;
  color: #8fc2ff;
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: @space-s;
}

.panel {
  background: linear-gradient(180deg, #131925, #0d111a);
  border: 1px solid #1e2634;
  border-radius: @radius-xs;
  padding: @space-xs;
  box-shadow: inset 0 0 8px rgba(0,0,0,0.35);
}

.panel-header {
  font-size: @font-size-s;
  font-weight: 600;
  margin-bottom: @space-xxs;
}

.panel-hint {
  margin-top: @space-xxs;
  font-size: @font-size-xs;
  color: #b6d5ff;
  opacity: 0.8;
}

.browser-search {
  width: 100%;
  background: #0b1017;
  border: 1px solid #1f2a3a;
  border-radius: @radius-xs;
  padding: @space-xxs @space-xs;
  color: #cfe9ff;
  margin-bottom: @space-xxs;
  font-size: @font-size-s;
}

.item-list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.item-list li {
  padding: 6px 8px;
  border-radius: 6px;
  border: 1px solid transparent;
  background: rgba(255, 255, 255, 0.02);
}

.item-list li.active {
  border-color: #3f73ff;
  background: rgba(63, 115, 255, 0.12);
}

.item-title {
  display: flex;
  justify-content: space-between;
  font-weight: 600;
  color: #cfe9ff;
}

.item-subtitle {
  font-size: @font-size-xs;
  opacity: 0.8;
}

.item-value {
  font-size: @font-size-xs;
  color: #8fc2ff;
}

.param-slots {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: @space-xxs;
}

.param-slot {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid #1f2a3a;
  border-radius: @radius-xs;
  padding: 6px 8px;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.param-name {
  font-size: @font-size-xs;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: #cfe9ff;
}

.param-value {
  font-size: @font-size-s;
  color: #8fc2ff;
}
</style>



=========================================
File: components/control/SoftButtonStrip.vue
=========================================

<template>
  <div class="soft-strip">
    <button
      v-for="(btn, index) in normalizedButtons"
      :key="index"
      class="soft-btn"
      type="button"
      :title="buttonTitle(btn, index)"
      :aria-label="buttonTitle(btn, index)"
      :disabled="!btn.enabled"
      @click="$emit('press', index)"
    >
      <span class="symbol">{{ index + 1 }}</span>
      <span class="label">{{ btn.label }}</span>
    </button>
  </div>
</template>

<script lang="ts">
import { defineComponent, type PropType } from 'vue'

type SoftButtonModel = {
  label: string
  actionId: string
  enabled: boolean
  shiftLabel?: string | undefined
  description?: string | undefined
}

const normalizeButtons = (buttons: SoftButtonModel[]): SoftButtonModel[] => {
  const normalized = buttons.map((btn) => ({
    label: btn.label ?? '',
    actionId: btn.actionId ?? 'noop',
    enabled: btn.enabled !== false,
    shiftLabel: btn.shiftLabel ?? undefined,
    description: btn.description ?? undefined
  }))
  while (normalized.length < 8) {
    normalized.push({
      label: '',
      actionId: 'noop',
      enabled: false,
      shiftLabel: undefined,
      description: undefined
    })
  }
  return normalized.slice(0, 8)
}

export default defineComponent({
  name: 'SoftButtonStrip',
  props: {
    buttons: {
      type: Array as PropType<SoftButtonModel[]>,
      default: () => []
    },
    shiftHeld: {
      type: Boolean,
      default: false
    }
  },
  emits: ['press'],
  computed: {
    normalizedButtons(): SoftButtonModel[] {
      return normalizeButtons(this.buttons ?? [])
    }
  },
  methods: {
    buttonTitle(btn: SoftButtonModel, index: number) {
      const label = btn.label || `Soft ${index + 1}`
      if (btn.shiftLabel) {
        return this.shiftHeld ? `${label} (${btn.shiftLabel})` : `${label} (SHIFT: ${btn.shiftLabel})`
      }
      return label
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.soft-strip {
  display: grid;
  grid-template-columns: repeat(8, minmax(0, 1fr));
  gap: @space-xs;
}

.soft-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  padding: @space-xxs @space-xs;
  border: 1px solid #3a3f49;
  border-radius: 6px;
  background: linear-gradient(180deg, #cfd2d8, #9ea3ab);
  color: #1c1f24;
  font-size: @font-size-xs;
  cursor: pointer;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.6),
    inset 0 -1px 0 rgba(0,0,0,0.25);
}

.soft-btn:disabled {
  opacity: 0.55;
  cursor: not-allowed;
}

.soft-btn:hover:enabled {
  background: linear-gradient(180deg, #ffffff, #c7ccd4);
  border-color: #ffffff;
  box-shadow:
    0 0 8px fade(#ffffff, 35%),
    inset 0 1px 0 rgba(255,255,255,0.9);
}

.symbol {
  font-size: @font-size-s;
  line-height: 1;
}

.label {
  font-size: @font-size-xs;
  line-height: 1.1;
  opacity: 0.8;
}
</style>



=========================================
File: components/panels/ChannelPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Channel & MIDI
      .panel-body
        v-select(
          label="Control target"
          dense
          :items="controlTargets"
          item-title="title"
          item-value="value"
          :model-value="controlTarget"
          @update:model-value="$emit('update:control-target', $event)"
          hide-details
        )
        v-switch(
          label="MIDI Mode (Shift+Channel)"
          dense
          :model-value="midiMode"
          @update:model-value="$emit('update:midi-mode', $event)"
        )
        p.helper Soft labels/knobs are contextual; this panel is a stub for Channel Properties.
</template>

<script lang="ts">
import { defineComponent } from 'vue'

const controlTargets = [
  { title: 'Sound', value: 'sound' },
  { title: 'Group', value: 'group' },
  { title: 'Master', value: 'master' }
]

export default defineComponent({
  name: 'ChannelPanel',
  props: {
    controlTarget: { type: String, default: 'sound' },
    midiMode: { type: Boolean, default: false }
  },
  emits: ['update:control-target', 'update:midi-mode'],
  computed: {
    controlTargets() {
      return controlTargets
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #8bd1ff;
    margin-bottom: 12px;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .helper {
    font-size: 0.75rem;
    opacity: 0.8;
    letter-spacing: 0.06em;
  }
}
</style>



=========================================
File: components/panels/ExportPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Export
      .panel-body
        v-btn(
          color="primary"
          block
          :loading="isExporting"
          :disabled="isExporting"
          @click="$emit('export')"
        ) Export mixdown
        v-alert(
          v-if="exportError"
          type="error"
          dense
          class="mt-2"
        ) {{ exportError }}
        .metadata-grid
          .metadata-row
            span.label Seed
            span.value {{ metadata?.seed ?? 'â€”' }}
          .metadata-row
            span.label BPM
            span.value {{ metadata?.bpm ?? 'â€”' }}
          .metadata-row
            span.label Duration
            span.value {{ formattedDuration }}
          .metadata-row
            span.label Grid
            span.value {{ gridLabel }}
        v-btn(
          color="secondary"
          block
          :disabled="!audioBlob || isExporting"
          class="mt-2"
          @click="$emit('download:mixdown')"
        ) Download WAV
        v-btn(
          color="secondary"
          block
          :disabled="!hasZipArtifacts || isExporting"
          class="mt-2"
          variant="outlined"
          @click="$emit('download:zip')"
        ) Download ZIP bundle
        v-divider(class="my-3")
        .stem-header(v-if="stemEntries.length > 0")
          span Stem exports
          v-btn(text small class="ml-auto" :disabled="isExporting" @click="$emit('download:stems')") Download all
        v-list(v-if="stemEntries.length > 0" density="compact")
          v-list-item(v-for="stem in stemEntries" :key="stem.padId")
            v-list-item-title {{ stem.label }}
            v-list-item-subtitle {{ stem.fileName }}
            template(#append)
              v-btn(text small :disabled="isExporting" @click="$emit('download:stem', stem.padId)") Download
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { DrumPadId } from '@/types/drums'
import type { RenderMetadata } from '@/types/render'

type StemEntry = {
  padId: DrumPadId
  label: string
  fileName: string
}

export default defineComponent({
  name: 'ExportPanel',
  // Panel that triggers audio export and lists metadata plus downloadable mixdown and stems.
  props: {
    isExporting: { type: Boolean, required: true },
    exportError: { type: String, default: null },
    exportMetadata: { type: Object as () => RenderMetadata | null, default: null },
    audioBlob: { type: Object as () => Blob | null, default: null },
    hasZipArtifacts: { type: Boolean, required: true },
    stemEntries: {
      type: Array as () => StemEntry[],
      default: () => []
    }
  },
  emits: ['export', 'download:mixdown', 'download:zip', 'download:stem', 'download:stems'],
  computed: {
    metadata() {
      return this.exportMetadata
    },
    gridLabel(): string {
      const spec = this.exportMetadata?.gridSpec
      if (!spec) return 'â€”'
      return `${spec.bars} bar${spec.bars === 1 ? '' : 's'} â€¢ 1/${spec.division}`
    },
    formattedDuration(): string {
      const duration = this.exportMetadata?.durationSec
      if (typeof duration !== 'number') return 'â€”'
      return `${duration.toFixed(2)}s`
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #fe9b8b;
    margin-bottom: 10px;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .metadata-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 6px 10px;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: rgba(255, 255, 255, 0.7);
  }

  .metadata-row {
    display: contents;
  }

  .metadata-row .label {
    font-weight: 600;
  }

  .stem-header {
    display: flex;
    align-items: center;
    font-size: 0.75rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }
}
</style>



=========================================
File: components/panels/FxPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
    .panel-header FX
      v-expansion-panels(
        v-model="activeSlot"
        accordion
        class="fx-panels"
      )
        v-expansion-panel(value="filter")
          v-expansion-panel-title Filter
          v-expansion-panel-text
            v-switch(
              label="Enabled"
              dense
              :model-value="localFx.filter.enabled"
              @update:model-value="toggleFilter"
            )
            v-slider(
              dense
              v-if="localFx.filter.enabled"
              label="Cutoff"
              hide-details
              min="200"
              max="18000"
              step="50"
              thumb-label
              :model-value="localFx.filter.frequency"
              @update:model-value="setFilterFreq"
            )
            v-slider(
              dense
              v-if="localFx.filter.enabled"
              label="Resonance (Q)"
              hide-details
              min="0.1"
              max="12"
              step="0.1"
              thumb-label
              :model-value="localFx.filter.q"
              @update:model-value="setFilterQ"
            )
        v-expansion-panel(value="drive")
          v-expansion-panel-title Drive
          v-expansion-panel-text
            v-switch(
              label="Enabled"
              dense
              :model-value="localFx.drive.enabled"
              @update:model-value="toggleDrive"
            )
            v-slider(
              dense
              v-if="localFx.drive.enabled"
              label="Amount"
              hide-details
              min="0"
              max="1"
              step="0.05"
              thumb-label
              :model-value="localFx.drive.amount"
              @update:model-value="setDriveAmount"
            )
        v-expansion-panel(value="reverb")
          v-expansion-panel-title Reverb
          v-expansion-panel-text
            v-switch(
              label="Enabled"
              dense
              :model-value="localFx.reverb.enabled"
              @update:model-value="toggleReverb"
            )
            v-slider(
              dense
              v-if="localFx.reverb.enabled"
              label="Mix"
              hide-details
              min="0"
              max="0.6"
              step="0.02"
              thumb-label
              :model-value="localFx.reverb.mix"
              @update:model-value="setReverbMix"
            )
        v-expansion-panel(value="routing")
          v-expansion-panel-title Routing
          v-expansion-panel-text
            p Subtle master shaping slot. No additional controls yet.
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { FxSettings } from '@/types/audio'

export default defineComponent({
  name: 'FxPanel',
  props: {
    fxSettings: { type: Object as () => FxSettings, required: true }
  },
  emits: ['fx:update'],
  data() {
    return {
      activeSlot: 'filter',
      localFx: { ...this.fxSettings }
    }
  },
  watch: {
    fxSettings: {
      deep: true,
      handler(value: FxSettings) {
        this.localFx = {
          ...value,
          filter: { ...value.filter },
          drive: { ...value.drive },
          reverb: { ...value.reverb }
        }
      }
    }
  },
  methods: {
    emitFx() {
      this.$emit('fx:update', {
        filter: { ...this.localFx.filter },
        drive: { ...this.localFx.drive },
        reverb: { ...this.localFx.reverb }
      })
    },
    toggleFilter(enabled: boolean) {
      this.localFx.filter.enabled = enabled
      this.emitFx()
    },
    setFilterFreq(value: number) {
      this.localFx.filter.frequency = value
      this.emitFx()
    },
    setFilterQ(value: number) {
      this.localFx.filter.q = value
      this.emitFx()
    },
    toggleDrive(enabled: boolean) {
      this.localFx.drive.enabled = enabled
      this.emitFx()
    },
    setDriveAmount(value: number) {
      this.localFx.drive.amount = value
      this.emitFx()
    },
    toggleReverb(enabled: boolean) {
      this.localFx.reverb.enabled = enabled
      this.emitFx()
    },
    setReverbMix(value: number) {
      this.localFx.reverb.mix = value
      this.emitFx()
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 12px;
  color: #f5f7fb;

  .panel-header {
    text-transform: uppercase;
    letter-spacing: 0.2em;
    font-size: 0.8rem;
    color: #ffc952;
    margin-bottom: 8px;
  }

  .fx-panels {
    background: transparent;
    border: none;

    .v-expansion-panel {
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      transition: border 0.3s ease;

      &:last-child {
        border-bottom: none;
      }
    }

    .v-expansion-panel-title {
      font-weight: 600;
      letter-spacing: 0.3em;
      text-transform: uppercase;
    }

    .v-expansion-panel-text {
      padding: 8px 0 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
  }
}

.fx-popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: min(720px, 92vw);
  max-height: 92vh;
  display: flex;
  flex-direction: column;
  background: @color-surface-2;
  border: 1px solid @color-border-2;
  @radius-xl: 20px;
  z-index: 2000;
}


</style>



=========================================
File: components/panels/PatternsPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Patterns
      .panel-body
        v-row
          v-col(cols="12" md="6")
            v-select(
              label="Current Pattern"
              dense
              :items="patternItems"
              item-title="title"
              item-value="value"
              :model-value="selectedPatternId"
              @update:model-value="handlePatternSelect"
              hide-details
            )
            v-text-field(
              label="Rename Pattern"
              dense
              :model-value="renameValue"
              :placeholder="currentPattern?.name || 'Pattern'"
              @update:model-value="updateRenameValue"
              @change="submitRename"
              hide-details
            )
            v-text-field(
              label="New Pattern Name"
              dense
              :model-value="newPatternName"
              @update:model-value="setNewPatternName"
              hide-details
            )
            v-btn(
              color="primary"
              block
              class="mt-1"
              @click="addPattern"
            ) Add Pattern
            v-row(class="mt-2" dense)
              v-col(cols="6")
                v-btn(
                  color="secondary"
                  block
                  @click="emitPatternUndo"
                ) Undo
              v-col(cols="6")
                v-btn(
                  color="secondary"
                  block
                  variant="outlined"
                  @click="emitPatternRedo"
                ) Redo
          v-col(cols="12" md="6")
            v-select(
              label="Active Scene"
              dense
              :items="sceneItems"
              item-title="title"
              item-value="value"
              :model-value="activeSceneId"
              @update:model-value="selectScene"
              hide-details
              clearable
            )
            v-text-field(
              label="Scene Name"
              dense
              :model-value="sceneName"
              @update:model-value="updateSceneName"
              @change="emitSceneUpdate"
              hide-details
            )
            v-combobox(
              label="Pattern Chain"
              dense
              clearable
              multiple
              chips
              :items="patternItems"
              item-title="title"
              item-value="value"
              :model-value="scenePatternIds"
              @update:model-value="setScenePatternIds"
              hide-details
            )
            v-btn(
              color="secondary"
              block
              class="mt-1"
              @click="addScene"
            ) Add Scene
        v-row(class="mt-2" dense)
          v-col(cols="6")
            v-btn(
              color="error"
              block
              variant="tonal"
              @click="$emit('erase:pad')"
            ) Erase selected pad
          v-col(cols="6")
            v-btn(
              color="error"
              block
              variant="outlined"
              @click="$emit('erase:step')"
            ) Erase selected pad @ step
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { Pattern, Scene } from '@/types/drums'

export default defineComponent({
  name: 'PatternsPanel',
  // Panel for selecting, naming, undoing, and organizing patterns and scenes.
  props: {
    patterns: { type: Array as () => Pattern[], required: true },
    selectedPatternId: { type: String, required: false },
    scenes: { type: Array as () => Scene[], required: true },
    activeSceneId: { type: String as () => string | null, default: null }
  },
  emits: ['pattern:add', 'pattern:select', 'pattern:rename', 'pattern:undo', 'pattern:redo', 'scene:add', 'scene:update', 'scene:select', 'erase:pad', 'erase:step'],
  data() {
    return {
      newPatternName: '',
      renameValue: '',
      sceneName: '',
      scenePatternIds: [] as string[]
    }
  },
  computed: {
    patternItems(): Array<{ title: string; value: string }> {
      return this.patterns.map((pattern) => ({ title: pattern.name, value: pattern.id }))
    },
    sceneItems(): Array<{ title: string; value: string | null }> {
      return [{ title: 'None', value: null }, ...this.scenes.map((scene) => ({ title: scene.name, value: scene.id }))]
    },
    currentScene(): Scene | null {
      return this.scenes.find((scene) => scene.id === this.activeSceneId) ?? null
    },
    currentPattern(): Pattern | null {
      return this.patterns.find((pattern) => pattern.id === this.selectedPatternId) ?? null
    }
  },
  watch: {
    currentScene: {
      immediate: true,
      handler(scene: Scene | null) {
        this.sceneName = scene?.name ?? ''
        this.scenePatternIds = [...(scene?.patternIds ?? [])]
      }
    },
    currentPattern: {
      immediate: true,
      handler(pattern: Pattern | null) {
        this.renameValue = pattern?.name ?? ''
      }
    }
  },
  methods: {
    addPattern() {
      this.$emit('pattern:add', { name: this.newPatternName.trim() || undefined })
      this.newPatternName = ''
    },
    handlePatternSelect(id: string | null) {
      if (id) this.$emit('pattern:select', id)
    },
    emitPatternUndo() {
      this.$emit('pattern:undo')
    },
    emitPatternRedo() {
      this.$emit('pattern:redo')
    },
    updateRenameValue(value: string) {
      this.renameValue = value
    },
    setNewPatternName(value: string) {
      this.newPatternName = value
    },
    submitRename() {
      if (this.currentPattern && this.renameValue.trim().length > 0) {
        this.$emit('pattern:rename', { id: this.currentPattern.id, name: this.renameValue.trim() })
      }
    },
    selectScene(id: string | null) {
      this.$emit('scene:select', id)
    },
    updateSceneName(value: string) {
      this.sceneName = value
      this.emitSceneUpdate()
    },
    setScenePatternIds(value: string[]) {
      this.scenePatternIds = value
      this.emitSceneUpdate()
    },
    emitSceneUpdate() {
      if (this.currentScene) {
        this.$emit('scene:update', {
          id: this.currentScene.id,
          name: this.sceneName.trim() || this.currentScene.name,
          patternIds: this.scenePatternIds
        })
      }
    },
    addScene() {
      this.$emit('scene:add', { name: this.sceneName.trim() || 'Scene', patternIds: this.scenePatternIds })
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: #9d7eff;
    margin-bottom: 12px;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
}
</style>



=========================================
File: components/panels/SoundPanel.vue
=========================================

<template lang="pug">
  client-only(tag="div")
    .panel-shell
      .panel-header Sound
      .panel-body
        v-select(
          label="Bank"
          dense
          :items="bankItems"
          item-title="title"
          item-value="value"
          :model-value="selectedBankId"
          @update:model-value="selectBank"
          hide-details
        )
        v-select(
          label="Pad"
          dense
          :items="padItems"
          item-title="title"
          item-value="value"
          v-model="padTarget"
          hide-details
        )
        p.current-sample Label: {{ currentSampleLabel }}
        input(
          ref="fileInput"
          type="file"
          accept="audio/*"
          class="d-none"
          @change="onFileChange"
        )
        v-btn(color="primary" class="mt-3" block @click="triggerFile") Replace sample
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import type { Soundbank } from '@/types/audio'
import type { DrumPadId } from '@/types/drums'

export default defineComponent({
  name: 'SoundPanel',
  props: {
    banks: { type: Array as () => Soundbank[], required: true },
    selectedBankId: { type: String, default: null }
  },
  emits: ['bank:select', 'pad:replace'],
  data() {
    return {
      padTarget: 'pad1' as DrumPadId
    }
  },
  computed: {
    bankItems(): Array<{ title: string; value: string }> {
      return this.banks.map((bank) => ({ title: bank.name, value: bank.id }))
    },
    padItems(): Array<{ title: string; value: DrumPadId }> {
      return Array.from({ length: 16 }, (_, index) => {
        const id = `pad${index + 1}` as DrumPadId
        return { title: id.toUpperCase(), value: id }
      })
    },
    currentSampleLabel(): string {
      const bank = this.banks.find((entry) => entry.id === this.selectedBankId)
      const sample = bank?.pads?.[this.padTarget]
      return sample?.name ?? 'Default'
    }
  },
  methods: {
    selectBank(value: string) {
      this.$emit('bank:select', value)
    },
    triggerFile() {
      const input = this.$refs.fileInput as HTMLInputElement | undefined
      input?.click()
    },
    onFileChange(event: Event) {
      const input = event.target as HTMLInputElement | null
      const files = input?.files
      if (!files || files.length === 0) return
      const file = files[0]
      this.$emit('pad:replace', { padId: this.padTarget, file })
      if (input) {
        input.value = ''
      }
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.panel-shell {
  border: 1px solid @color-border-2;
  border-radius: @radius-l;
  background: @color-surface-2;
  padding: 16px;
  color: #f5f7fb;

  .panel-header {
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    margin-bottom: 12px;
    color: #62e3ff;
  }

  .panel-body {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .current-sample {
    font-size: 0.75rem;
    opacity: 0.85;
    letter-spacing: 0.08em;
  }
}
</style>



=========================================
File: components/placeholders/DualDisplayPlaceholder.vue
=========================================

<template>
  <div class="dual-display" title="Dual displays with contextual soft labels">
    <div class="display left">
      <div class="display-header">Display L</div>
      <div class="display-body">Status / lists / presets</div>
    </div>
    <div class="display right">
      <div class="display-header">Display R</div>
      <div class="display-body">Params / meters / browser</div>
    </div>
  </div>
</template>

<style scoped lang="less">
@import '@/styles/variables.less';

.dual-display {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: @space-s;
}

.display {
  border-radius: @radius-s;
  background: linear-gradient(180deg, #0f141d, #0b0f16);
  border: 1px solid #2c3545;
  box-shadow:
    inset 0 0 18px rgba(0, 0, 0, 0.65),
    0 8px 28px rgba(0, 0, 0, 0.65);
  color: #9fd4ff;
  min-height: 108px;
  display: flex;
  flex-direction: column;
}

.display-header {
  font-size: @font-size-s;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  padding: @space-xs @space-s;
  color: #cfe9ff;
}

.display-body {
  flex: 1 1 auto;
  padding: @space-s;
  font-size: @font-size-s;
  opacity: 0.9;
  color: #8fc2ff;
}
</style>



=========================================
File: components/placeholders/FourDEncoderPlaceholder.vue
=========================================

<template>
  <div class="encoder" title="4D encoder: tilt â†•â†”, turn to browse, press to confirm">
    <div class="encoder-cap">âº</div>
    <div class="encoder-arrows">â†• â†”</div>
    <div class="encoder-label">Push to confirm</div>
  </div>
</template>

<style scoped lang="less">
@import '@/styles/variables.less';

.encoder {
  align-self: stretch;
  min-width: 120px;
  padding: @space-s @space-m;
  border-radius: @radius-m;
  background: linear-gradient(180deg, #181c26, #0f121a);
  border: 1px solid #2d3542;
  color: @color-text-primary;
  display: grid;
  place-items: center;
  gap: @space-xs;
  text-align: center;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.04),
    0 4px 12px rgba(0,0,0,0.4);
}

.encoder-cap {
  font-size: 24px;
  color: #f68b1e;
}

.encoder-arrows {
  letter-spacing: 0.25em;
}

.encoder-label {
  font-size: @font-size-xs;
  opacity: 0.85;
}
</style>



=========================================
File: components/placeholders/ModeColumnPlaceholder.vue
=========================================

<template>
  <div class="mode-column" title="Mode column with shift-layer hints">
    <button
      v-for="mode in modes"
      :key="mode.label"
      class="mode-btn"
      type="button"
      :title="mode.hint"
      :aria-label="mode.hint"
    >
      <span class="symbol">{{ mode.symbol }}</span>
      <span class="text">{{ mode.label }}</span>
    </button>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

type ModeButton = {
  label: string
  symbol: string
  hint: string
}

const DEFAULT_MODES: ModeButton[] = [
  { label: 'Scene', symbol: '', hint: 'Scene mode (hold to pin); Shift: Scene grid alt' },
  { label: 'Pattern', symbol: '', hint: 'Pattern mode (hold to pin); Shift: Duplicate pattern' },
  { label: 'Events', symbol: '', hint: 'Events/step mode; Shift: Clear events' },
  { label: 'Variation', symbol: '', hint: 'Variation/randomize; Shift: Humanize' },
  { label: 'Duplicate', symbol: '', hint: 'Duplicate selection; Shift: Copy to new slot' },
  { label: 'Select', symbol: '', hint: 'Select pad/group; Shift: Group select' },
  { label: 'Solo', symbol: '', hint: 'Solo (momentary/pin); Shift: Mute layer' },
  { label: 'Mute', symbol: '', hint: 'Mute (momentary/pin); Shift: Solo layer' },
  { label: 'Shift', symbol: 'â‡§', hint: 'Hold for secondary functions' }
]

export default defineComponent({
  name: 'ModeColumnPlaceholder',
  props: {
    modes: {
      type: Array as () => ModeButton[],
      default: () => DEFAULT_MODES
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.mode-column {
  display: flex;
  flex-direction: column;
  gap: @space-xs;
}

.mode-btn {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: @space-xs;
  padding: @space-xs @space-s;
  border: 1px solid #2f3645;
  border-radius: @radius-s;
  background: linear-gradient(180deg, #191e29, #111520);
  color: @color-text-primary;
  font-size: @font-size-xs;
  cursor: default;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
}

.mode-btn:hover {
  border-color: #f68b1e;
  background: linear-gradient(180deg, #222836, #161a25);
  box-shadow:
    0 0 8px fade(#f68b1e, 30%),
    inset 0 1px 0 rgba(255,255,255,0.06);
}

.symbol {
  font-size: @font-size-s;
  color: #f68b1e;
}

.text {
  flex: 1 1 auto;
  text-align: left;
}
</style>



=========================================
File: components/placeholders/ScreenKnobRingPlaceholder.vue
=========================================

<template>
  <div class="knob-ring" title="Screen knobs with selector overlays">
    <div
      v-for="knob in knobs"
      :key="knob.label"
      class="knob"
      :title="knob.hint"
      :aria-label="knob.hint"
    >
      <div class="knob-cap">â—¯</div>
      <div class="knob-label">{{ knob.label }}</div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

type Knob = {
  label: string
  hint: string
}

const DEFAULT_KNOBS: Knob[] = [
  { label: 'Volume', hint: 'Volume (screen knob 1)' },
  { label: 'Swing', hint: 'Swing (screen knob 2)' },
  { label: 'Tempo', hint: 'Tempo (screen knob 3)' },
  { label: 'Lock', hint: 'Lock (screen knob 4)' },
  { label: 'Group', hint: 'Group selector (screen knob 5)' },
  { label: 'Pattern', hint: 'Pattern param (screen knob 6)' },
  { label: 'Pad Mode', hint: 'Pad mode (screen knob 7)' },
  { label: 'Keyboard', hint: 'Keyboard/step (screen knob 8)' }
]

export default defineComponent({
  name: 'ScreenKnobRingPlaceholder',
  props: {
    knobs: {
      type: Array as () => Knob[],
      default: () => DEFAULT_KNOBS
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.knob-ring {
  display: grid;
  grid-template-columns: repeat(8, minmax(0, 1fr));
  gap: @space-s;
}

.knob {
  background: linear-gradient(180deg, #171c27, #0f131c);
  border: 1px solid #2f3644;
  border-radius: @radius-s;
  padding: @space-xs;
  text-align: center;
  color: @color-text-primary;
  font-size: @font-size-xs;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.04);
}

.knob:hover {
  border-color: #f68b1e;
  box-shadow:
    0 0 8px fade(#f68b1e, 35%),
    inset 0 1px 0 rgba(255,255,255,0.07);
}

.knob-cap {
  font-size: 18px;
  line-height: 1.1;
}

.knob-label {
  opacity: 0.8;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
</style>



=========================================
File: components/placeholders/SoftButtonStripPlaceholder.vue
=========================================

<template>
  <div class="soft-strip">
    <button
      v-for="btn in buttons"
      :key="btn.symbol"
      class="soft-btn"
      type="button"
      :title="btn.hint"
      :aria-label="btn.hint"
    >
      <span class="symbol">{{ btn.symbol }}</span>
      <span class="label">{{ btn.label }}</span>
    </button>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

type SoftButton = {
  symbol: string
  label: string
  hint: string
}

const DEFAULT_BUTTONS: SoftButton[] = [
  { symbol: '', label: '', hint: 'Soft button 1 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 2 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 3 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 4 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 5 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 6 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 7 (contextual)' },
  { symbol: '', label: '', hint: 'Soft button 8 (contextual)' }
]

export default defineComponent({
  name: 'SoftButtonStripPlaceholder',
  props: {
    buttons: {
      type: Array as () => SoftButton[],
      default: () => DEFAULT_BUTTONS
    }
  }
})
</script>

<style scoped lang="less">
@import '@/styles/variables.less';

.soft-strip {
  display: grid;
  grid-template-columns: repeat(8, minmax(0, 1fr));
  gap: @space-xs;
}

.soft-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2px;
  padding: @space-xxs @space-xs;
  border: 1px solid #3a3f49;
  border-radius: 6px;
  background: linear-gradient(180deg, #cfd2d8, #9ea3ab);
  color: #1c1f24;
  font-size: @font-size-xs;
  cursor: default;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.6),
    inset 0 -1px 0 rgba(0,0,0,0.25);
}

.soft-btn:hover {
  background: linear-gradient(180deg, #ffffff, #c7ccd4);
  border-color: #ffffff;
  box-shadow:
    0 0 8px fade(#ffffff, 35%),
    inset 0 1px 0 rgba(255,255,255,0.9);
}

.symbol {
  font-size: @font-size-s;
  line-height: 1;
}

.label {
  font-size: @font-size-xs;
  line-height: 1.1;
  opacity: 0.8;
}
</style>



=========================================
File: components/placeholders/TouchStripPlaceholder.vue
=========================================

<template>
  <div class="touch-strip" title="Touch strip for performance / pitch / mod">
    <div class="strip-track">
      <div class="strip-indicator" />
    </div>
    <div class="strip-label">Touch Strip â‰¡</div>
  </div>
</template>

<style scoped lang="less">
@import '@/styles/variables.less';

.touch-strip {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: @space-xs;
  width: 100%;
}

.strip-track {
  width: 20px;
  flex: 1 1 0;
  min-height: 160px;
  border-radius: @radius-m;
  background: linear-gradient(180deg, #1b2130, #0e121b);
  border: 1px solid #2c3443;
  position: relative;
  display: flex;
  align-items: center;
  box-shadow: inset 0 0 12px rgba(0,0,0,0.6);
}

.strip-indicator {
  width: 100%;
  height: 14%;
  border-radius: @radius-s;
  background: fade(#f68b1e, 35%);
  box-shadow: 0 0 10px fade(#f68b1e, 45%);
}

.strip-label {
  font-size: @font-size-xs;
  color: fade(@color-text-secondary, 80%);
}
</style>



=========================================
File: composables/useAudioEngine.client 2.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import type { DrumPadId } from '~/types/drums'
import type { SampleRef, Soundbank } from '~/types/audio'

interface TriggerRequest {
  padId: DrumPadId
  when: number
  velocity?: number
}

export function useAudioEngine() {
  const audioContext = ref<AudioContext | null>(null)
  const masterGain = ref<GainNode | null>(null)
  const sampleCache = ref<Map<DrumPadId, AudioBuffer>>(new Map())

  const ensureContext = () => {
    if (!audioContext.value) {
      const context = new AudioContext()
      const gain = context.createGain()
      gain.gain.value = 0.8
      gain.connect(context.destination)
      audioContext.value = context
      masterGain.value = gain
    }
    if (audioContext.value.state === 'suspended') {
      void audioContext.value.resume()
    }
    return audioContext.value as AudioContext
  }

  const decodeSample = async (sample: SampleRef): Promise<AudioBuffer | null> => {
    const ctx = ensureContext()
    if (!sample.url) {
      return sample.buffer ?? null
    }
    const response = await fetch(sample.url)
    const arrayBuffer = await response.arrayBuffer()
    const buffer = await ctx.decodeAudioData(arrayBuffer)
    return buffer
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    const buffer = sample.buffer ?? (await decodeSample(sample))
    if (buffer) {
      sampleCache.value.set(padId, buffer)
    }
  }

  const applySoundbank = async (bank: Soundbank) => {
    const entries = Object.entries(bank.pads)
    await Promise.all(
      entries.map(async ([padId, sample]) => {
        if (sample) {
          await setSampleForPad(padId as DrumPadId, sample)
        }
      })
    )
  }

  const trigger = async ({ padId, when, velocity = 1 }: TriggerRequest) => {
    const ctx = ensureContext()
    const buffer = sampleCache.value.get(padId) ?? null
    if (!buffer) {
      return
    }
    const source = ctx.createBufferSource()
    source.buffer = buffer
    const gain = ctx.createGain()
    gain.gain.value = velocity
    source.connect(gain)
    gain.connect(masterGain.value ?? ctx.destination)
    source.start(when)
  }

  onBeforeUnmount(() => {
    audioContext.value?.close()
    sampleCache.value.clear()
  })

  return {
    audioContext,
    masterGain,
    sampleCache,
    ensureContext,
    decodeSample,
    applySoundbank,
    setSampleForPad,
    trigger
  }
}



=========================================
File: composables/useAudioEngine.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import type { DrumPadId } from '@/types/drums'
import type { FxSettings, SampleRef, Soundbank } from '@/types/audio'
import { createSeededRandom, type RandomSource } from '@/utils/seededRandom'
import { createFxGraph, connectFxGraph, updateFxGraph, type FxGraphNodes } from '@/audio/fxGraph'

interface TriggerRequest {
  padId: DrumPadId
  when: number
  velocity?: number
}

const cloneFxSettings = (settings: FxSettings): FxSettings => ({
  filter: { ...settings.filter },
  drive: { ...settings.drive },
  reverb: { ...settings.reverb }
})

const createAudioEngineInstance = () => {
  const audioContext = ref<AudioContext | null>(null)
  const masterGain = ref<GainNode | null>(null)
  const sampleCache = ref<Map<DrumPadId, AudioBuffer>>(new Map())
  const fxSettings = ref<FxSettings>({
    filter: { enabled: true, frequency: 12000, q: 0.7 },
    drive: { enabled: false, amount: 0.25 },
    reverb: { enabled: false, mix: 0.15 }
  })
  const fxSnapshot = ref<FxSettings>(cloneFxSettings(fxSettings.value))
  const fxGraph = ref<FxGraphNodes | null>(null)
  let randomSource: RandomSource = createSeededRandom(0)
  let wasRunningOnHide = false
  let handlePageHide: (() => void) | null = null
  let handlePageShow: (() => void) | null = null

  const syncFxSnapshot = () => {
    fxSnapshot.value = cloneFxSettings(fxSettings.value)
    return fxSnapshot.value
  }

  const ensureFxGraph = (ctx: BaseAudioContext, snapshot: FxSettings) => {
    if (!masterGain.value) {
      return
    }
    if (!fxGraph.value) {
      fxGraph.value = createFxGraph(ctx)
      connectFxGraph(fxGraph.value, masterGain.value)
    }
    updateFxGraph(ctx, fxGraph.value, snapshot, randomSource)
  }

  const ensureContext = () => {
    if (!audioContext.value) {
      const context = new AudioContext()
      const gain = context.createGain()
      gain.gain.value = 0.8
      gain.connect(context.destination)
      audioContext.value = context
      masterGain.value = gain
    }
    ensureFxGraph(audioContext.value as BaseAudioContext, fxSnapshot.value)
    return audioContext.value as AudioContext
  }

  const resumeContext = async () => {
    const ctx = ensureContext()
    if (ctx.state === 'suspended') {
      await ctx.resume()
    }
    return ctx
  }

  const getFxSnapshot = () => cloneFxSettings(fxSnapshot.value)

  const setFxRandomSource = (source: RandomSource) => {
    randomSource = source
    if (fxGraph.value?.reverbNode) {
      fxGraph.value.reverbNode.buffer = null
    }
    if (audioContext.value) {
      ensureFxGraph(audioContext.value, fxSnapshot.value)
    }
  }

  const decodeSample = async (sample: SampleRef): Promise<AudioBuffer | null> => {
    const ctx = ensureContext()
    if (sample.buffer) {
      return sample.buffer
    }
    if (sample.blob) {
      const arrayBuffer = await sample.blob.arrayBuffer()
      return ctx.decodeAudioData(arrayBuffer.slice(0))
    }
    if (sample.url) {
      const response = await fetch(sample.url)
      const arrayBuffer = await response.arrayBuffer()
      return ctx.decodeAudioData(arrayBuffer)
    }
    return null
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    const buffer = sample.buffer ?? (await decodeSample(sample))
    if (buffer) {
      sampleCache.value.set(padId, buffer)
    }
  }

  const applySoundbank = async (bank: Soundbank) => {
    const entries = Object.entries(bank.pads)
    await Promise.all(
      entries.map(async ([padId, sample]) => {
        if (sample) {
          await setSampleForPad(padId as DrumPadId, sample)
        }
      })
    )
  }

  const setFx = (partial: Partial<FxSettings>) => {
    fxSettings.value = {
      filter: { ...fxSettings.value.filter, ...(partial.filter ?? {}) },
      drive: { ...fxSettings.value.drive, ...(partial.drive ?? {}) },
      reverb: { ...fxSettings.value.reverb, ...(partial.reverb ?? {}) }
    }
    const snapshot = syncFxSnapshot()
    const ctx = ensureContext()
    ensureFxGraph(ctx, snapshot)
  }

  const trigger = async ({ padId, when, velocity = 1 }: TriggerRequest) => {
    const ctx = ensureContext()
    const buffer = sampleCache.value.get(padId) ?? null
    if (!buffer) {
      return
    }
    const source = ctx.createBufferSource()
    source.buffer = buffer
    const gain = ctx.createGain()
    gain.gain.value = velocity
    source.connect(gain)
    if (fxGraph.value) {
      gain.connect(fxGraph.value.fxInput)
    } else {
      gain.connect(masterGain.value ?? ctx.destination)
    }
    source.start(when)
  }

  const triggerClick = async (when: number, accented = false, volume = 0.12) => {
    const ctx = ensureContext()
    const osc = ctx.createOscillator()
    const gain = ctx.createGain()
    osc.type = 'square'
    osc.frequency.value = accented ? 2200 : 1600
    const base = Math.max(0, Math.min(1, volume))
    gain.gain.setValueAtTime((accented ? 1.4 : 1) * base, when)
    gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.06)
    osc.connect(gain)
    gain.connect(masterGain.value ?? ctx.destination)
    osc.start(when)
    osc.stop(when + 0.08)
  }

  if (typeof window !== 'undefined') {
    handlePageHide = () => {
      if (audioContext.value) {
        wasRunningOnHide = audioContext.value.state === 'running'
        void audioContext.value.suspend().catch(() => undefined)
      }
    }

    handlePageShow = () => {
      if (wasRunningOnHide && audioContext.value) {
        void audioContext.value.resume().catch(() => undefined)
      }
      wasRunningOnHide = false
    }

    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)
  }

  onBeforeUnmount(() => {
    if (handlePageHide) {
      window.removeEventListener('pagehide', handlePageHide)
    }
    if (handlePageShow) {
      window.removeEventListener('pageshow', handlePageShow)
    }
    audioContext.value?.close()
    sampleCache.value.clear()
  })

  return {
    audioContext,
    masterGain,
    sampleCache,
    fxSettings,
    ensureContext,
    resumeContext,
    decodeSample,
    applySoundbank,
    setFx,
    setSampleForPad,
    trigger,
    triggerClick,
    getFxSnapshot,
    setFxRandomSource
  }
}

let audioEngineInstance: ReturnType<typeof createAudioEngineInstance> | null = null

export function useAudioEngine() {
  if (!audioEngineInstance) {
    audioEngineInstance = createAudioEngineInstance()
  }
  return audioEngineInstance
}



=========================================
File: composables/useAudioInput.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'

export interface AudioInputState {
  stream?: MediaStream
  error?: string
}

export function useAudioInput() {
  const state = ref<AudioInputState>({})
  const sourceNode = ref<MediaStreamAudioSourceNode | null>(null)
  const audioContext = ref<AudioContext | null>(null)
  let handlePageHide: (() => void) | null = null

  const requestMic = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const context = new AudioContext()
      sourceNode.value = context.createMediaStreamSource(stream)
      audioContext.value = context
      state.value = { stream }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'microphone request failed'
      state.value = { error: message }
    }
  }

  const stop = () => {
    state.value.stream?.getTracks().forEach((track) => track.stop())
    void audioContext.value?.close()
    audioContext.value = null
    state.value = {}
  }

  if (typeof window !== 'undefined') {
    handlePageHide = () => {
      stop()
      sourceNode.value = null
    }
    window.addEventListener('pagehide', handlePageHide)
  }

  onBeforeUnmount(() => {
    if (handlePageHide) {
      window.removeEventListener('pagehide', handlePageHide)
    }
    stop()
    sourceNode.value = null
  })

  return {
    state,
    sourceNode,
    requestMic,
    stop
  }
}



=========================================
File: composables/useCapabilities.client.ts
=========================================

import { ref } from 'vue'

export interface Capabilities {
  supportsWebMIDI: boolean
  supportsAudioInput: boolean
}

export function useCapabilities() {
  const capabilities = ref<Capabilities>({ supportsWebMIDI: false, supportsAudioInput: false })

  const evaluate = () => {
    capabilities.value = {
      supportsWebMIDI: typeof navigator !== 'undefined' && 'requestMIDIAccess' in navigator,
      supportsAudioInput: typeof navigator !== 'undefined' && Boolean(navigator.mediaDevices?.getUserMedia)
    }
  }

  evaluate()

  return {
    capabilities,
    evaluate
  }
}



=========================================
File: composables/useImportExport.client 2.ts
=========================================

import { saveAs } from 'file-saver'
import type { Pattern } from '~/types/drums'
import type { MidiFileData } from '~/types/midi'

const encoderHeader = 'Drumcomputer Pattern Export'

export function useImportExport() {
  const exportPattern = (pattern: Pattern) => {
    const blob = new Blob([JSON.stringify(pattern, null, 2)], { type: 'application/json' })
    saveAs(blob, `${pattern.name}.json`)
  }

  const importPattern = async (file: File): Promise<Pattern> => {
    const text = await file.text()
    const parsed = JSON.parse(text) as Pattern
    return parsed
  }

  const exportMidi = (data: MidiFileData) => {
    const blob = new Blob([encoderHeader, JSON.stringify(data)], { type: 'application/json' })
    saveAs(blob, 'sequence.mid.json')
  }

  const exportAudio = (buffer: ArrayBuffer) => {
    const blob = new Blob([buffer], { type: 'audio/wav' })
    saveAs(blob, 'mixdown.wav')
  }

  return {
    exportPattern,
    importPattern,
    exportMidi,
    exportAudio
  }
}



=========================================
File: composables/useImportExport.client.ts
=========================================

import { ref } from 'vue'
import { saveAs } from 'file-saver'
import { Midi as MidiType } from '@tonejs/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import { clampVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock } from '@/domain/clock/renderClock'
import { createFxGraph, connectFxGraph, updateFxGraph } from '@/audio/fxGraph'
import { useAudioEngine } from './useAudioEngine.client'
import { usePatternsStore } from '@/stores/patterns'
import { useTransportStore } from '@/stores/transport'
import { createSeededRandom } from '@/utils/seededRandom'
import type { ScheduledTask } from './useScheduler'
import { scheduleStep } from './useSequencer'
import type { ScheduleStepOptions, ScheduledStep } from './useSequencer'
import type { GridSpec } from '@/types/time'
import type { MidiFileData, MidiMapping } from '@/types/midi'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { RenderMetadata, RenderEvent } from '@/types/render'
import type { DrumPadId, Pattern } from '@/types/drums'

const Midi = MidiType
const encoderHeader = 'Drumcomputer Pattern Export'

const audioBufferToWav = (buffer: AudioBuffer) => {
  const numOfChan = buffer.numberOfChannels
  const length = buffer.length * numOfChan * 2 + 44
  const result = new ArrayBuffer(length)
  const view = new DataView(result)
  let offset = 0

  const writeString = (str: string) => {
    for (let i = 0; i < str.length; i += 1) {
      view.setUint8(offset + i, str.charCodeAt(i))
    }
    offset += str.length
  }

  const setUint16 = (data: number) => {
    view.setUint16(offset, data, true)
    offset += 2
  }

  const setUint32 = (data: number) => {
    view.setUint32(offset, data, true)
    offset += 4
  }

  writeString('RIFF')
  setUint32(length - 8)
  writeString('WAVE')
  writeString('fmt ')
  setUint32(16)
  setUint16(1)
  setUint16(numOfChan)
  setUint32(buffer.sampleRate)
  setUint32(buffer.sampleRate * numOfChan * 2)
  setUint16(numOfChan * 2)
  setUint16(16)
  writeString('data')
  setUint32(length - offset - 4)

  const channels: Float32Array[] = []
  for (let i = 0; i < numOfChan; i += 1) {
    channels.push(buffer.getChannelData(i))
  }

  while (offset < length) {
    for (let i = 0; i < numOfChan; i += 1) {
      const channel = channels[i]
      if (!channel) {
        offset += 2
        continue
      }
      const sampleIndex = Math.floor((offset - 44) / (2 * numOfChan))
      const rawSample = channel[sampleIndex] ?? 0
      const sample = Math.max(-1, Math.min(1, rawSample))
      view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true)
      offset += 2
    }
  }
  return result
}

const normalizePattern = (pattern: Pattern): Pattern => {
  const gridSpec: GridSpec = normalizeGridSpec(pattern.gridSpec)
  const steps: Pattern['steps'] = {}
  Object.entries(pattern.steps ?? {}).forEach(([barKey, barValue]) => {
    const barIndex = Number(barKey)
    if (Number.isNaN(barIndex)) return
    const normalizedBar: Record<number, Partial<Record<DrumPadId, { velocity?: { value: number } }>>> = {}
    Object.entries(barValue ?? {}).forEach(([stepKey, stepValue]) => {
      const stepInBar = Number(stepKey)
      if (Number.isNaN(stepInBar)) return
      const normalizedRow: Partial<Record<DrumPadId, { velocity?: { value: number } }>> = {}
      Object.entries(stepValue ?? {}).forEach(([padId, cell]) => {
        if (!cell) return
        normalizedRow[padId as DrumPadId] = {
          velocity: { value: clampVelocity(cell.velocity?.value ?? DEFAULT_STEP_VELOCITY) }
        }
      })
      if (Object.keys(normalizedRow).length > 0) {
        normalizedBar[stepInBar] = normalizedRow
      }
    })
    if (Object.keys(normalizedBar).length > 0) {
      steps[barIndex] = normalizedBar
    }
  })
  return {
    ...pattern,
    gridSpec,
    steps
  }
}

const patternFromMidi = (midi: MidiType, mapping: MidiMapping): Pattern => {
  const gridSpec: GridSpec = { bars: 1, division: 16 }
  const steps: Pattern['steps'] = {}
  const track = midi.tracks[0]
  if (!track) {
    return normalizePattern({
      id: 'imported-pattern',
      name: 'Imported Pattern',
      gridSpec,
      steps
    })
  }
  const ticksPerBeat = midi.header.ppq
  const stepTicks = (ticksPerBeat * 4) / gridSpec.division
  const notes = track.notes ?? []
  interface Note {
    midi: number
    ticks: number
    velocity?: number
  }

  interface Steps {
    [barIndex: number]: {
      [stepInBar: number]: Partial<Record<DrumPadId, { velocity?: { value: number } }>>
    }
  }

  notes.forEach((note: Note) => {
    const stepIndex: number = Math.round(note.ticks / stepTicks)
    const barIndex: number = Math.floor(stepIndex / gridSpec.division)
    const stepInBar: number = stepIndex % gridSpec.division
    const pad: DrumPadId | undefined = mapping.noteMap[note.midi]
    if (!pad) return
    const bar: Steps[number] = steps[barIndex] ?? {}
    const row: Steps[number][number] = bar[stepInBar] ?? {}
    const velocity: number = typeof note.velocity === 'number' ? note.velocity : DEFAULT_STEP_VELOCITY
    row[pad] = { velocity: { value: clampVelocity(velocity) } }
    bar[stepInBar] = row
    steps[barIndex] = bar
  })
  return normalizePattern({
    id: 'imported-pattern',
    name: track.name ?? 'Imported Pattern',
    gridSpec,
    steps
  })
}

export function useImportExport() {
  const exportPattern = (pattern: Pattern) => {
    const normalized = normalizePattern(pattern)
    const blob = new Blob([JSON.stringify(normalized, null, 2)], { type: 'application/json' })
    saveAs(blob, `${normalized.name}.json`)
  }

  const importPattern = async (file: File): Promise<Pattern> => {
    try {
      const text = await file.text()
      const parsed = JSON.parse(text) as Pattern
      return normalizePattern(parsed)
    } catch (error) {
      console.error('Failed to import pattern', error)
      return {
        id: `imported-${Date.now()}`,
        name: file.name,
        gridSpec: { bars: 1, division: 16 },
        steps: {}
      }
    }
  }

  const exportMidi = (pattern: Pattern, bpm: number, mapping: MidiMapping = defaultMidiMapping()) => {
    if (typeof Midi === 'undefined') {
      console.error('MIDI export is not available: Midi is undefined.')
      return
    }
    const midi = new Midi()
    midi.header.setTempo(bpm)
    const track = midi.addTrack()
    const ticksPerBeat = midi.header.ppq
    const stepTicks = (ticksPerBeat * 4) / pattern.gridSpec.division
    const totalSteps = pattern.gridSpec.bars * pattern.gridSpec.division
    for (let i = 0; i < totalSteps; i += 1) {
      const barIndex = Math.floor(i / pattern.gridSpec.division)
      const stepInBar = i % pattern.gridSpec.division
      const row = pattern.steps[barIndex]?.[stepInBar]
      if (!row) continue
      Object.entries(row).forEach(([padId, cell]) => {
        const drumPad = padId as DrumPadId
        const note = mapping.noteMapInverse?.[drumPad] ?? Object.entries(mapping.noteMap).find(([, pad]) => pad === drumPad)?.[0]
        if (typeof note !== 'string' && typeof note !== 'number') return
        const midiNote = typeof note === 'string' ? Number(note) : note
        if (typeof midiNote !== 'number') return
        track.addNote({
          midi: midiNote,
          time: (i * stepTicks) / ticksPerBeat,
          duration: stepTicks / ticksPerBeat,
          velocity: cell?.velocity?.value ?? 1
        })
      })
    }
    const midiArray = midi.toArray()
    const midiBuffer = midiArray.buffer as ArrayBuffer
    const blob = new Blob([midiBuffer], { type: 'audio/midi' })
    saveAs(blob, `${pattern.name}.mid`)
  }

  const importMidi = async (file: File, mapping: MidiMapping = defaultMidiMapping()): Promise<Pattern> => {
    if (typeof Midi === 'undefined') {
      console.error('MIDI import is not available: Midi is undefined.')
      return {
        id: `imported-${Date.now()}`,
        name: file.name,
        gridSpec: { bars: 1, division: 16 },
        steps: {}
      }
    }
    const buffer = await file.arrayBuffer()
    const midi = new Midi(buffer)
    return patternFromMidi(midi, mapping)
  }

  const createScenePlaybackTracker = (patternsStore: ReturnType<typeof usePatternsStore>) => {
    const scene = patternsStore.currentScene
    const patternList = scene?.patternIds ?? []
    const fallbackPattern: Pattern = patternsStore.patterns[0] ?? {
      id: 'pattern-1',
      name: 'Pattern 1',
      gridSpec: { ...DEFAULT_GRID_SPEC },
      steps: {}
    }
    let currentPatternId = patternList[0] ?? patternsStore.selectedPatternId ?? fallbackPattern.id
    let scenePosition = patternList.length > 1 ? 1 : 0
    const resolvePattern = (id: string) => patternsStore.patterns.find((pattern: Pattern) => pattern.id === id) ?? fallbackPattern
    const getPattern = () => resolvePattern(currentPatternId)
    const advancePattern = () => {
      if (!scene || patternList.length === 0) {
        return getPattern()
      }
      const nextId = patternList[scenePosition % patternList.length]
      scenePosition = (scenePosition + 1) % patternList.length
      if (nextId) {
        currentPatternId = nextId
      }
      return getPattern()
    }
    const initialPattern = getPattern()
    const patternChain = patternList.length > 0 ? [...patternList] : [patternsStore.selectedPatternId ?? initialPattern.id]
    return {
      sceneId: scene?.id ?? null,
      patternChain,
      initialPatternId: initialPattern.id,
      getPattern,
      advancePattern
    }
  }

  const createOfflineScheduler = (limit: number, updateClock: (time: number) => void) => {
    const tasks: ScheduledTask[] = []
    return {
      schedule(task: ScheduledTask) {
        tasks.push(task)
        tasks.sort((a, b) => a.when - b.when)
      },
      run() {
        while (tasks.length > 0) {
          const next = tasks[0]
          if (!next || next.when > limit) break
          tasks.shift()
          updateClock(next.when)
          next.callback()
        }
      }
    }
  }

  const hashSnapshot = (payload: string) => {
    let hash = 0
    for (let i = 0; i < payload.length; i += 1) {
      hash = Math.imul(31, hash) + payload.charCodeAt(i)
      hash >>>= 0
    }
    return hash.toString(36)
  }

  type StemExportFiles = Partial<Record<DrumPadId, { fileName: string; blob: Blob }>>

  type ExportAudioResult = {
    audioBlob: Blob
    metadata: RenderMetadata
    debugTimeline?: RenderEvent[]
    stems?: StemExportFiles
  }

  const slugifyName = (value: string) => {
    const cleaned = value
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '')
    return cleaned || 'session'
  }

  const collectPadIdsFromPatternChain = (patternChain: string[], patternList: Pattern[]): DrumPadId[] => {
    const padSet = new Set<DrumPadId>()
    patternChain.forEach((patternId) => {
      const pattern = patternList.find((entry) => entry.id === patternId)
      if (!pattern) return
      Object.values(pattern.steps ?? {}).forEach((bar) => {
        Object.values(bar ?? {}).forEach((stepRow) => {
          Object.keys(stepRow ?? {}).forEach((padId) => {
            padSet.add(padId as DrumPadId)
          })
        })
      })
    })
    return Array.from(padSet)
  }

  const exportAudio = async (
    renderDurationSec: number,
    sampleRate = 44100,
    options: { seed?: number; stems?: boolean } = {}
  ): Promise<ExportAudioResult> => {
    const transport = useTransportStore()
    const patterns = usePatternsStore()
    const audio = useAudioEngine()
    const duration = Math.max(0, renderDurationSec)
    const frameCount = Math.max(1, Math.ceil(duration * sampleRate))
    const seedValue = options.seed ?? Date.now()
    const fxSnapshot = audio.getFxSnapshot()
    const shouldDebug = import.meta.env?.DEV ?? false
    const baseSampleCache = new Map(audio.sampleCache.value)

    const metadataTracker = createScenePlaybackTracker(patterns)
    const metadataPattern = metadataTracker.getPattern()
    const initialGridSpec = normalizeGridSpec(metadataPattern.gridSpec ?? transport.gridSpec)
    const metadata: RenderMetadata = {
      seed: String(seedValue),
      bpm: transport.bpm,
      gridSpec: initialGridSpec,
      sceneId: metadataTracker.sceneId,
      patternChain: metadataTracker.patternChain,
      initialPatternId: metadataTracker.initialPatternId,
      durationSec: duration
    }

    const songSlug = slugifyName(patterns.currentScene?.name ?? metadataPattern.name ?? 'drum-session')
    const candidatePadIds = collectPadIdsFromPatternChain(metadataTracker.patternChain, patterns.patterns)
    const stemPadIds = options.stems
      ? candidatePadIds.filter((padId) => baseSampleCache.has(padId))
      : []

    const renderPass = async (soloPadId?: DrumPadId, collectDebug = false) => {
      const context = new OfflineAudioContext(2, frameCount, sampleRate)
      const masterGainNode = context.createGain()
      masterGainNode.gain.value = 0.8
      masterGainNode.connect(context.destination)
      const fxGraph = createFxGraph(context)
      connectFxGraph(fxGraph, masterGainNode)

      const rng = createSeededRandom(seedValue)
      updateFxGraph(context, fxGraph, fxSnapshot, rng)

      const sampleCache = new Map(baseSampleCache)
      const shouldCollectDebugEvents = shouldDebug && collectDebug
      const debugEvents: RenderEvent[] = []

      const offlineEngine = {
        trigger({ padId, when, velocity = 1 }: { padId: DrumPadId; when: number; velocity?: number }) {
          if (soloPadId && padId !== soloPadId) return
          const buffer = sampleCache.get(padId)
          if (!buffer) return
          const source = context.createBufferSource()
          source.buffer = buffer
          const gainNode = context.createGain()
          gainNode.gain.value = velocity
          source.connect(gainNode)
          gainNode.connect(fxGraph.fxInput)
          source.start(when)
          if (shouldCollectDebugEvents) {
            debugEvents.push({ time: when, padId, velocity })
          }
        }
      }

      let simulatedTime = 0
      const baseClock = createRenderClock(context, true)
      const renderClock: ScheduleStepOptions['clock'] = {
        ctx: baseClock.ctx,
        isOffline: true,
        now: () => simulatedTime,
        audioTime: () => baseClock.audioTime()
      }

      const offlineScheduler = createOfflineScheduler(duration, (time) => {
        simulatedTime = time
      })

      const tracker = createScenePlaybackTracker(patterns)
      const initialPatternForRender = tracker.getPattern()
      const renderGridSpec = normalizeGridSpec(initialPatternForRender.gridSpec ?? transport.gridSpec)
      const currentStep = ref(0)
      const pendingSteps = ref<ScheduledStep[]>([])
      const offlineTransportBase = {
        loop: transport.loop,
        bpm: transport.bpm,
        gridSpec: renderGridSpec,
        setCurrentStep: () => { },
        setGridSpec(gridSpec: GridSpec) {
          offlineTransportBase.gridSpec = normalizeGridSpec(gridSpec)
        }
      }
      const offlineTransport = offlineTransportBase as unknown as ScheduleStepOptions['transport']

      const stepOptions: ScheduleStepOptions = {
        clock: renderClock,
        scheduler: offlineScheduler,
        audio: offlineEngine as ScheduleStepOptions['audio'],
        transport: offlineTransport,
        getPattern: () => tracker.getPattern(),
        currentStep,
        pendingSteps,
        onPatternBoundary: () => {
          const nextPattern = tracker.advancePattern()
          offlineTransport.setGridSpec(nextPattern.gridSpec)
          return nextPattern
        }
      }

      scheduleStep(stepOptions, 0)
      offlineScheduler.run()
      simulatedTime = duration

      const rendered = await context.startRendering()
      return {
        audioBuffer: rendered,
        debugEvents: shouldCollectDebugEvents ? debugEvents : undefined
      }
    }

    const mixdownResult = await renderPass(undefined, true)
    const mixdownBlob = new Blob([audioBufferToWav(mixdownResult.audioBuffer)], { type: 'audio/wav' })
    saveAs(mixdownBlob, 'mixdown.wav')

    if (shouldDebug) {
      const events = mixdownResult.debugEvents ?? []
      const snapshotHash = hashSnapshot(JSON.stringify(fxSnapshot))
      console.info(
        'Offline export',
        `seed=${seedValue}`,
        `snapshot=${snapshotHash}`,
        `events=${events.length}`,
        `duration=${duration.toFixed(2)}`
      )
      if (events.length === 0) {
        console.warn('Offline export scheduled zero events; verify the active pattern/scene contains steps')
      }
    }

    const stemFiles: StemExportFiles = {}
    for (const padId of stemPadIds) {
      const stemResult = await renderPass(padId)
      const stemBlob = new Blob([audioBufferToWav(stemResult.audioBuffer)], { type: 'audio/wav' })
      const fileName = `${songSlug}_${padId}.wav`
      stemFiles[padId] = { fileName, blob: stemBlob }
    }

    const result: ExportAudioResult = {
      audioBlob: mixdownBlob,
      metadata
    }
    if (shouldDebug && mixdownResult.debugEvents) {
      result.debugTimeline = mixdownResult.debugEvents
    }
    if (Object.keys(stemFiles).length > 0) {
      result.stems = stemFiles
    }
    return result
  }

  const exportSoundbank = (bank: Soundbank, samples: SampleRef[]) => {
    const padEntries = Object.entries(bank.pads).reduce<Record<string, { id: string; name: string; format?: SampleRef['format'] }>>((acc, [padId, sample]) => {
      if (sample) {
        acc[padId] = { id: sample.id, name: sample.name, format: sample.format }
      }
      return acc
    }, {})
    const manifest = {
      bank: { ...bank, pads: padEntries },
      samples: samples.map((sample) => {
        const entry: { id: string; name: string; format?: SampleRef['format'] } = {
          id: sample.id,
          name: sample.name
        }
        if (sample.format) {
          entry.format = sample.format
        }
        return entry
      })
    }
    saveAs(new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' }), `${bank.name}-manifest.json`)
    samples.forEach((sample) => {
      if (sample.blob) {
        saveAs(sample.blob, sample.name)
      }
    })
  }

  const importSoundbank = async (manifestFile: File, sampleFiles: File[]): Promise<{ bank: Soundbank; samples: SampleRef[] }> => {
    try {
      const manifestText = await manifestFile.text()
      const parsed = JSON.parse(manifestText) as { bank: Soundbank; samples: Array<Pick<SampleRef, 'id' | 'name' | 'format'>> }
      const sampleMap = new Map(sampleFiles.map((file) => [file.name, file]))
      const hydratedSamples: SampleRef[] = parsed.samples.map((sample) => {
        const blob = sampleMap.get(sample.name)
        if (blob) {
          return { ...sample, blob }
        }
        return { ...sample }
      })
      const padAssignments: Partial<Record<string, SampleRef>> = {}
      Object.entries(parsed.bank.pads ?? {}).forEach(([padId, sampleInfo]) => {
        const found = hydratedSamples.find((sample) => sample.id === (sampleInfo as SampleRef).id)
        if (found) {
          padAssignments[padId] = found
        }
      })
      const hydratedBank: Soundbank = { ...parsed.bank, pads: padAssignments }
      return { bank: hydratedBank, samples: hydratedSamples }
    } catch (error) {
      console.error('Failed to import soundbank', error)
      return {
        bank: { id: 'invalid-bank', name: manifestFile.name, pads: {}, createdAt: Date.now(), updatedAt: Date.now() },
        samples: []
      }
    }
  }

  const exportMidiData = (data: MidiFileData) => {
    const blob = new Blob([encoderHeader, JSON.stringify(data)], { type: 'application/json' })
    saveAs(blob, 'sequence.mid.json')
  }

  return {
    exportPattern,
    importPattern,
    exportMidi,
    importMidi,
    exportMidiData,
    exportAudio,
    exportSoundbank,
    importSoundbank
  }
}



=========================================
File: composables/useMidi.client 2.ts
=========================================

import { ref } from 'vue'
import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '~/types/midi'
import { defaultMidiMapping } from '~/domain/midiMapping'

export function useMidi() {
  const access = ref<MIDIAccess | null>(null)
  const inputs = ref<MidiDeviceInfo[]>([])
  const outputs = ref<MidiDeviceInfo[]>([])
  const mapping = ref<MidiMapping>(defaultMidiMapping())

  const supportsMidi = () => typeof navigator !== 'undefined' && Boolean((navigator as Navigator).requestMIDIAccess)

  const refreshDevices = () => {
    if (!access.value) return
    inputs.value = Array.from(access.value.inputs.values()).map((device: MIDIInput) => ({
      id: device.id,
      name: device.name ?? 'MIDI In',
      type: 'input'
    }))
    outputs.value = Array.from(access.value.outputs.values()).map((device: MIDIOutput) => ({
      id: device.id,
      name: device.name ?? 'MIDI Out',
      type: 'output'
    }))
  }

  const requestAccess = async () => {
    if (!supportsMidi()) {
      return
    }
    access.value = await (navigator as Navigator).requestMIDIAccess({ sysex: false })
    refreshDevices()
  }

  const listen = (cb: (message: MidiMessage) => void) => {
    access.value?.inputs.forEach((input: MIDIInput) => {
      input.onmidimessage = (event: MIDIMessageEvent) => {
        if (!event.data || event.data.length < 3) return
        const status = event.data[0]
        const data1 = event.data[1]
        const data2 = event.data[2]
        if (status === undefined || data1 === undefined || data2 === undefined) return

        const type = status & 0xf0
        if (type === 0x90 && data2 > 0) {
          cb({ type: 'noteon', note: data1, velocity: data2 / 127 })
        } else if (type === 0x80 || (type === 0x90 && data2 === 0)) {
          cb({ type: 'noteoff', note: data1, velocity: data2 / 127 })
        } else if (status === 0xf8) {
          cb({ type: 'clock' })
        } else if (status === 0xfa) {
          cb({ type: 'start' })
        } else if (status === 0xfc) {
          cb({ type: 'stop' })
        }
      }
    })
  }

  const send = (deviceId: string, message: MidiMessage) => {
    const output = access.value?.outputs.get(deviceId)
    if (!output) return
    switch (message.type) {
      case 'noteon':
        output.send([0x90, message.note ?? 0, Math.floor((message.velocity ?? 1) * 127)])
        break
      case 'noteoff':
        output.send([0x80, message.note ?? 0, 0])
        break
      case 'start':
        output.send([0xfa])
        break
      case 'stop':
        output.send([0xfc])
        break
      case 'clock':
        output.send([0xf8])
        break
      default:
        break
    }
  }

  const mapNoteToPad = (note: number) => mapping.value.noteMap[note]

  return {
    access,
    inputs,
    outputs,
    mapping,
    supportsMidi,
    requestAccess,
    refreshDevices,
    listen,
    send,
    mapNoteToPad
  }
}



=========================================
File: composables/useMidi.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import type { MidiDeviceInfo, MidiMapping, MidiMessage } from '@/types/midi'
import { defaultMidiMapping } from '@/domain/midiMapping'

export function useMidi() {
  const access = ref<MIDIAccess | null>(null)
  const inputs = ref<MidiDeviceInfo[]>([])
  const outputs = ref<MidiDeviceInfo[]>([])
  const mapping = ref<MidiMapping>(defaultMidiMapping())
  const selectedInputId = ref<string | null>(null)
  const selectedOutputId = ref<string | null>(null)
  const listeners = ref<Set<(message: MidiMessage) => void>>(new Set())
  let handlePageHide: (() => void) | null = null
  let handlePageShow: (() => void) | null = null

  const supportsMidi = () => typeof navigator !== 'undefined' && Boolean((navigator as Navigator).requestMIDIAccess)

  const refreshDevices = () => {
    if (!access.value) return
    inputs.value = Array.from(access.value.inputs.values()).map((device: MIDIInput) => ({
      id: device.id,
      name: device.name ?? 'MIDI In',
      type: 'input'
    }))
    outputs.value = Array.from(access.value.outputs.values()).map((device: MIDIOutput) => ({
      id: device.id,
      name: device.name ?? 'MIDI Out',
      type: 'output'
    }))
  }

  const requestAccess = async () => {
    if (!supportsMidi()) {
      return
    }
    access.value = await (navigator as Navigator).requestMIDIAccess({ sysex: false })
    refreshDevices()
    if (access.value) {
      access.value.onstatechange = () => {
        refreshDevices()
        attachSelectedInput()
      }
    }
  }

  const handleMidiMessage = (event: MIDIMessageEvent) => {
    if (!event.data || event.data.length < 1) return
    const status = event.data[0]
    const data1 = event.data[1]
    const data2 = event.data[2]
    if (status === undefined) return
    const type = status & 0xf0
    const hasNoteData = typeof data1 === 'number' && typeof data2 === 'number'
    const message: MidiMessage | null =
      type === 0x90 && hasNoteData && data2 > 0
        ? { type: 'noteon', note: data1, velocity: data2 / 127 }
        : type === 0x80 && hasNoteData
          ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
          : type === 0x90 && hasNoteData && data2 === 0
            ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
            : status === 0xf8
              ? { type: 'clock' }
              : status === 0xfa
                ? { type: 'start' }
                : status === 0xfc
                  ? { type: 'stop' }
                  : null
    if (!message) return
    listeners.value.forEach((cb) => cb(message))
  }

  const detachInputs = () => {
    access.value?.inputs.forEach((input) => {
      input.onmidimessage = null
    })
  }

  const attachSelectedInput = () => {
    detachInputs()
    if (!selectedInputId.value) return
    const input = access.value?.inputs.get(selectedInputId.value)
    if (input) {
      input.onmidimessage = handleMidiMessage
    }
  }

  const listen = (cb: (message: MidiMessage) => void) => {
    listeners.value.add(cb)
    attachSelectedInput()
    return () => listeners.value.delete(cb)
  }

  const send = (deviceId: string, message: MidiMessage) => {
    const output = access.value?.outputs.get(deviceId)
    if (!output) return
    switch (message.type) {
      case 'noteon':
        output.send([0x90, message.note ?? 0, Math.floor((message.velocity ?? 1) * 127)])
        break
      case 'noteoff':
        output.send([0x80, message.note ?? 0, 0])
        break
      case 'start':
        output.send([0xfa])
        break
      case 'stop':
        output.send([0xfc])
        break
      case 'clock':
        output.send([0xf8])
        break
      default:
        break
    }
  }

  const sendClockTick = () => {
    if (selectedOutputId.value) {
      send(selectedOutputId.value, { type: 'clock' })
    }
  }

  const sendStart = () => {
    if (selectedOutputId.value) {
      send(selectedOutputId.value, { type: 'start' })
    }
  }

  const sendStop = () => {
    if (selectedOutputId.value) {
      send(selectedOutputId.value, { type: 'stop' })
    }
  }

  const setSelectedInput = (id: string | null) => {
    selectedInputId.value = id
    attachSelectedInput()
  }

  const setSelectedOutput = (id: string | null) => {
    selectedOutputId.value = id
  }

  const mapNoteToPad = (note: number) => mapping.value.noteMap[note]
  const setPadForNote = (note: number, padId: MidiMapping['noteMap'][number]) => {
    if (padId) {
      mapping.value.noteMap[note] = padId
    } else {
      delete mapping.value.noteMap[note]
    }
  }

  if (typeof window !== 'undefined') {
    handlePageHide = () => {
      detachInputs()
      if (access.value) {
        access.value.onstatechange = null
      }
    }
    handlePageShow = () => {
      if (access.value) {
        refreshDevices()
        attachSelectedInput()
        access.value.onstatechange = () => {
          refreshDevices()
          attachSelectedInput()
        }
      }
    }
    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)
  }

  onBeforeUnmount(() => {
    if (handlePageHide) {
      window.removeEventListener('pagehide', handlePageHide)
    }
    if (handlePageShow) {
      window.removeEventListener('pageshow', handlePageShow)
    }
    detachInputs()
    if (access.value) {
      access.value.onstatechange = null
    }
  })

  return {
    access,
    inputs,
    outputs,
    mapping,
    selectedInputId,
    selectedOutputId,
    supportsMidi,
    requestAccess,
    refreshDevices,
    listen,
    send,
    sendClockTick,
    sendStart,
    sendStop,
    mapNoteToPad,
    setPadForNote,
    setMapping: (next: MidiMapping) => {
      mapping.value = next
    },
    setSelectedInput,
    setSelectedOutput
  }
}



=========================================
File: composables/useMidiLearn.ts
=========================================

import { computed, onBeforeUnmount, ref } from 'vue'
import { defaultMidiMapping } from '@/domain/midiMapping'
import type { MidiMessage, MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

type LearnTarget =
  | { type: 'pad'; padId: DrumPadId }
  | { type: 'transport'; action: 'play' | 'stop' | 'bpmUp' | 'bpmDown' }

const STORAGE_KEY = 'drumcomputer:midi-mapping'

const loadMapping = (): MidiMapping => {
  if (typeof localStorage === 'undefined') return defaultMidiMapping()
  try {
    const raw = localStorage.getItem(STORAGE_KEY)
    if (!raw) return defaultMidiMapping()
    const parsed = JSON.parse(raw) as MidiMapping
    return {
      noteMap: parsed.noteMap ?? {},
      noteMapInverse: parsed.noteMapInverse ?? {},
      transportMap: parsed.transportMap ?? {}
    }
  } catch {
    return defaultMidiMapping()
  }
}

const persistMapping = (mapping: MidiMapping) => {
  if (typeof localStorage === 'undefined') return
  const payload: MidiMapping = {
    noteMap: mapping.noteMap ?? {},
    noteMapInverse: mapping.noteMapInverse ?? {},
    transportMap: mapping.transportMap ?? {}
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(payload))
}

export function useMidiLearn(midi: {
  mapping: { value: MidiMapping }
  setPadForNote: (note: number, padId: DrumPadId | undefined) => void
  mapNoteToPad: (note: number) => DrumPadId | undefined
  listen: (cb: (message: MidiMessage) => void) => () => void
}) {
  // Manages MIDI learn flow for pads and transport actions with persistence to localStorage.
  const isLearning = ref(false)
  const target = ref<LearnTarget | null>(null)
  const status = ref<string | null>(null)
  let unsubscribe: (() => void) | null = null

  midi.mapping.value = loadMapping()

  const learningLabel = computed(() => {
    if (!isLearning.value || !target.value) return null
    if (target.value.type === 'pad') {
      return `Learning: ${target.value.padId}`
    }
    return `Learning: ${target.value.action}`
  })

  const clear = () => {
    target.value = null
    status.value = null
  }

  const midiListen = (cb: (message: MidiMessage) => void) => {
    return midi.listen ? midi.listen(cb) : () => undefined
  }

  const disable = () => {
    isLearning.value = false
    if (unsubscribe) {
      unsubscribe()
      unsubscribe = null
    }
    clear()
  }

  const enable = () => {
    if (isLearning.value) return
    isLearning.value = true
    unsubscribe = midiListen(handleMessage)
  }

  const setTarget = (next: LearnTarget | null) => {
    target.value = next
    status.value = null
  }

  const setTransportMapping = (
    action: 'play' | 'stop' | 'bpmUp' | 'bpmDown',
    note: number
  ) => {
    midi.mapping.value.transportMap = midi.mapping.value.transportMap ?? {}
    midi.mapping.value.transportMap[action] = note
    persistMapping(midi.mapping.value)
  }

  const handlePadMapping = (note: number, padId: DrumPadId) => {
    if (midi.mapping.value.noteMapInverse?.[padId] !== undefined) {
      const prevNote = midi.mapping.value.noteMapInverse?.[padId]
      if (typeof prevNote === 'number') {
        delete midi.mapping.value.noteMap[prevNote]
      }
    }
    midi.mapping.value.noteMapInverse = midi.mapping.value.noteMapInverse ?? {}
    midi.mapping.value.noteMapInverse[padId] = note
    midi.mapping.value.noteMap[note] = padId
    midi.setPadForNote(note, padId)
    persistMapping(midi.mapping.value)
  }

  const handleMessage = (message: MidiMessage): boolean => {
    if (!isLearning.value || !target.value) return false
    if (message.type !== 'noteon' || typeof message.note !== 'number') {
      return false
    }

    if (target.value.type === 'pad') {
      handlePadMapping(message.note, target.value.padId)
      status.value = `Mapped ${target.value.padId} to note ${message.note}`
    } else {
      setTransportMapping(target.value.action, message.note)
      status.value = `Mapped ${target.value.action} to note ${message.note}`
    }

    clear()
    return true
  }

  onBeforeUnmount(() => {
    disable()
  })

  return {
    isLearning,
    target,
    status,
    learningLabel,
    enable,
    disable,
    setTarget,
    handleMessage,
    loadMapping,
    persistMapping
  }
}



=========================================
File: composables/usePatternStorage.client.ts
=========================================

import { ref } from 'vue'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import type { Pattern, Scene } from '@/types/drums'

const STORAGE_KEY = 'drum-machine/patterns'
const STORAGE_VERSION = 'v2'

interface StoredPatternsV1 {
  version: typeof STORAGE_VERSION
  savedAt: number
  patterns: Pattern[]
}

interface StoredPatternsV2 {
  version: typeof STORAGE_VERSION
  savedAt: number
  patterns: Pattern[]
  scenes: Scene[]
  selectedPatternId: string
  activeSceneId: string | null
}

type StoredPayload = StoredPatternsV1 | StoredPatternsV2

interface StoredState {
  patterns: Pattern[]
  scenes: Scene[]
  selectedPatternId: string
  activeSceneId: string | null
}

const ensurePatternShape = (pattern: Pattern | Partial<Pattern>, index: number): Pattern => {
  return {
    id: pattern?.id ?? `pattern-${index + 1}`,
    name: pattern?.name ?? `Pattern ${index + 1}`,
    gridSpec: normalizeGridSpec(pattern?.gridSpec ?? DEFAULT_GRID_SPEC),
    steps: pattern?.steps ?? {}
  }
}

export function usePatternStorage() {
  const lastSavedAt = ref<number | null>(null)

  const save = (payload: StoredState) => {
    if (typeof window === 'undefined') return
    const normalizedPatterns = payload.patterns.map((pattern, index) => ensurePatternShape(pattern, index))
    const stored: StoredPatternsV2 = {
      version: STORAGE_VERSION,
      savedAt: Date.now(),
      patterns: normalizedPatterns,
      scenes: payload.scenes ?? [],
      selectedPatternId: payload.selectedPatternId,
      activeSceneId: payload.activeSceneId ?? null
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(stored))
    lastSavedAt.value = stored.savedAt
  }

  const load = (): StoredState => {
    if (typeof window === 'undefined') {
      return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null }
    }
    const raw = localStorage.getItem(STORAGE_KEY)
    if (!raw) {
      return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null }
    }
    try {
      const parsed = JSON.parse(raw) as Partial<StoredPayload>
      const version = parsed.version
      const basePatterns = Array.isArray(parsed.patterns)
        ? parsed.patterns.map((pattern, index) => ensurePatternShape(pattern, index))
        : []
      const baseState: StoredState = {
        patterns: basePatterns,
        scenes: [],
        selectedPatternId: basePatterns[0]?.id ?? 'pattern-1',
        activeSceneId: null
      }
      if (version === 'v2') {
        const parsedV2 = parsed as Partial<StoredPatternsV2>
        if (typeof parsedV2.savedAt === 'number') {
          lastSavedAt.value = parsedV2.savedAt
        }
        return {
          patterns: basePatterns,
          scenes: Array.isArray(parsedV2.scenes) ? parsedV2.scenes : [],
          selectedPatternId: parsedV2.selectedPatternId ?? baseState.selectedPatternId,
          activeSceneId: parsedV2.activeSceneId ?? null
        }
      }
      if (typeof (parsed as Partial<StoredPatternsV1>).savedAt === 'number') {
        lastSavedAt.value = (parsed as Partial<StoredPatternsV1>).savedAt ?? null
      }
      return baseState
    } catch (error) {
      console.error('Failed to parse patterns from LocalStorage', error)
      return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null }
    }
  }

  const clear = () => {
    if (typeof window === 'undefined') return
    localStorage.removeItem(STORAGE_KEY)
  }

  return {
    save,
    load,
    clear,
    lastSavedAt
  }
}



=========================================
File: composables/useScheduler.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'

export interface SchedulerConfig {
  lookahead: number
  scheduleAheadSec: number
  getTime: () => number
}

export interface ScheduledTask {
  when: number
  callback: () => void
}

export function useScheduler(config: SchedulerConfig) {
  const tasks = ref<ScheduledTask[]>([])
  const intervalId = ref<number | null>(null)
  let wasRunningOnHide = false

  const tick = () => {
    const now = config.getTime()
    const windowLimit = now + config.scheduleAheadSec
    const ready = tasks.value.filter((task) => task.when <= windowLimit)
    tasks.value = tasks.value.filter((task) => task.when > windowLimit)
    ready.forEach((task) => task.callback())
  }

  const start = () => {
    if (intervalId.value !== null) return
    intervalId.value = window.setInterval(tick, config.lookahead)
  }

  const stop = () => {
    if (intervalId.value !== null) {
      clearInterval(intervalId.value)
      intervalId.value = null
    }
  }

  const schedule = (task: ScheduledTask) => {
    tasks.value.push(task)
  }

  const clear = () => {
    tasks.value = []
  }

  if (typeof window !== 'undefined') {
    const handlePageHide = () => {
      if (intervalId.value !== null) {
        wasRunningOnHide = true
        stop()
      } else {
        wasRunningOnHide = false
      }
    }

    const handlePageShow = () => {
      if (wasRunningOnHide) {
        start()
        tick()
      }
    }

    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)

    onBeforeUnmount(() => {
      stop()
      window.removeEventListener('pagehide', handlePageHide)
      window.removeEventListener('pageshow', handlePageShow)
    })
  } else {
    onBeforeUnmount(stop)
  }

  return {
    start,
    stop,
    clear,
    tick,
    schedule
  }
}



=========================================
File: composables/useSequencer 2.ts
=========================================

import { ref } from 'vue'
import { quantizeToStep } from '~/domain/quantize'
import { normalizeGridSpec, secondsPerStep } from '~/domain/timing'
import type { DrumPadId, Pattern } from '~/types/drums'
import type { SampleRef, Soundbank } from '~/types/audio'
import type { GridSpec, StepAddress } from '~/types/time'
import { useTransportStore } from '~/stores/transport'
import { useScheduler } from './useScheduler'
import { useAudioEngine } from './useAudioEngine.client'

interface SequencerOptions {
  getPattern: () => Pattern
  lookahead?: number
  scheduleAheadSec?: number
}

interface ScheduledStep {
  when: number
  stepAddress: StepAddress
}

export function useSequencer(options: SequencerOptions) {
  const transport = useTransportStore()
  const audio = useAudioEngine()
  const scheduler = useScheduler({
    lookahead: options.lookahead ?? 25,
    scheduleAheadSec: options.scheduleAheadSec ?? 0.1,
    getTime: () => audio.ensureContext().currentTime
  })

  const currentStep = ref(0)
  const isRecording = ref(false)
  const pendingSteps = ref<ScheduledStep[]>([])
  let loopStartTime = 0

  const totalStepsForGrid = (gridSpec: GridSpec) => gridSpec.bars * gridSpec.division

  const scheduleStep = (when: number) => {
    const pattern = options.getPattern()
    const totalSteps = totalStepsForGrid(pattern.gridSpec)
    const stepIndex = currentStep.value % totalSteps
    const barIndex = Math.floor(stepIndex / pattern.gridSpec.division)
    const stepInBar = stepIndex % pattern.gridSpec.division
    pendingSteps.value.push({ when, stepAddress: { barIndex, stepInBar } })
    scheduler.schedule({
      when,
      callback: () => {
        playStep(pattern, when, { barIndex, stepInBar })
        currentStep.value = (currentStep.value + 1) % totalSteps
        transport.setCurrentStep(currentStep.value)
        if (transport.loop) {
          const stepDuration = secondsPerStep(transport.bpm, pattern.gridSpec.division)
          scheduleStep(when + stepDuration)
        }
      }
    })
  }

  const playStep = (pattern: Pattern, when: number, step: StepAddress) => {
    const bar = pattern.steps[step.barIndex]
    const stepRow = bar?.[step.stepInBar]
    if (!stepRow) return
    Object.entries(stepRow).forEach(([padId, cell]) => {
      audio.trigger({ padId: padId as DrumPadId, when, velocity: cell?.velocity?.value ?? 1 })
    })
  }

  const start = () => {
    if (transport.isPlaying) return
    const ctx = audio.ensureContext()
    const pattern = options.getPattern()
    const gridSpec = normalizeGridSpec(pattern.gridSpec)
    pattern.gridSpec = gridSpec
    transport.setGridSpec(gridSpec)
    loopStartTime = ctx.currentTime
    currentStep.value = 0
    pendingSteps.value = []
    transport.setCurrentStep(0)
    transport.setPlaying(true)
    scheduler.clear()
    scheduleStep(loopStartTime)
    scheduler.start()
    scheduler.tick()
  }

  const stop = () => {
    transport.setPlaying(false)
    scheduler.stop()
    scheduler.clear()
    pendingSteps.value = []
    currentStep.value = 0
    transport.setCurrentStep(0)
    loopStartTime = 0
  }

  const toggleStep = (barIndex: number, stepInBar: number, padId: DrumPadId) => {
    const pattern = options.getPattern()
    const bar = pattern.steps[barIndex] ?? {}
    const stepRow = bar[stepInBar] ?? {}
    const updated = { ...stepRow }
    if (updated[padId]) {
      delete updated[padId]
    } else {
      updated[padId] = { velocity: { value: 1 } }
    }
    pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
  }

  const recordHit = (padId: DrumPadId, velocity = 1, quantize = true) => {
    const pattern = options.getPattern()
    const ctx = audio.ensureContext()
    const gridSpec = pattern.gridSpec
    const stepDuration = secondsPerStep(transport.bpm, gridSpec.division)
    const anchor = transport.isPlaying ? loopStartTime : ctx.currentTime
    if (!transport.isPlaying) {
      loopStartTime = anchor
    }
    const sinceStart = ctx.currentTime - anchor
    const step = quantize
      ? quantizeToStep(sinceStart, stepDuration, gridSpec.bars, gridSpec.division)
      : {
          barIndex: Math.floor(currentStep.value / gridSpec.division),
          stepInBar: currentStep.value % gridSpec.division
        }
    toggleStep(step.barIndex, step.stepInBar, padId)
    audio.trigger({ padId, when: ctx.currentTime, velocity })
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    await audio.setSampleForPad(padId, sample)
  }

  const applySoundbank = async (bank: Soundbank) => {
    await audio.applySoundbank(bank)
  }

  return {
    currentStep,
    isRecording,
    pendingSteps,
    start,
    stop,
    toggleStep,
    recordHit,
    setSampleForPad,
    applySoundbank
  }
}



=========================================
File: composables/useSequencer.ts
=========================================

import { ref, type Ref } from 'vue'
import { quantizeToStep } from '@/domain/quantize'
import { normalizeGridSpec, secondsPerStep } from '@/domain/timing'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { SampleRef, Soundbank } from '@/types/audio'
import type { GridSpec, StepAddress } from '@/types/time'
import { useTransportStore } from '@/stores/transport'
import { useScheduler, type ScheduledTask } from './useScheduler'
import { useAudioEngine } from './useAudioEngine.client'
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'
import { createRenderClock, type RenderClock } from '@/domain/clock/renderClock'

interface SequencerOptions {
  getPattern: () => Pattern
  lookahead?: number
  scheduleAheadSec?: number
  onPatternBoundary?: () => Pattern | void
}

interface SchedulerLike {
  schedule: (task: ScheduledTask) => void
}

export interface ScheduledStep {
  when: number
  stepAddress: StepAddress
}

const totalStepsForGrid = (gridSpec: GridSpec) => gridSpec.bars * gridSpec.division

export interface ScheduleStepOptions {
  clock: RenderClock
  scheduler: SchedulerLike
  audio: ReturnType<typeof useAudioEngine>
  transport: ReturnType<typeof useTransportStore>
  getPattern: () => Pattern
  currentStep: Ref<number>
  pendingSteps: Ref<ScheduledStep[]>
  onPatternBoundary?: () => Pattern | void
}

export function scheduleStep(options: ScheduleStepOptions, when: number) {
  const pattern = options.getPattern()
  const totalSteps = totalStepsForGrid(pattern.gridSpec)
  const loopStart = Math.min(
    Math.max(0, options.transport.loopStart),
    Math.max(0, totalSteps - 1)
  )
  const loopEnd = Math.min(
    Math.max(loopStart + 1, options.transport.loopEnd),
    totalSteps
  )
  const loopLength = Math.max(1, loopEnd - loopStart)
  const stepIndex =
    loopStart +
    (((options.currentStep.value - loopStart) % loopLength) + loopLength) %
      loopLength
  const barIndex = Math.floor(stepIndex / pattern.gridSpec.division)
  const stepInBar = stepIndex % pattern.gridSpec.division
  const scheduledWhen = Math.max(when, options.clock.now())
  options.pendingSteps.value.push({ when: scheduledWhen, stepAddress: { barIndex, stepInBar } })

  options.scheduler.schedule({
    when: scheduledWhen,
    callback: () => {
      const bar = pattern.steps[barIndex]
      const stepRow = bar?.[stepInBar]
      if (stepRow) {
        Object.entries(stepRow).forEach(([padId, cell]) => {
          options.audio.trigger({
            padId: padId as DrumPadId,
            when: scheduledWhen,
            velocity: cell?.velocity?.value ?? 1
          })
        })
      }

      const rawNext = options.currentStep.value + 1
      const nextStepInLoop =
        loopStart + (((rawNext - loopStart) % loopLength) + loopLength) % loopLength
      const isPatternBoundary = nextStepInLoop === 0

      if (options.transport.metronomeEnabled) {
        const isQuarter =
          pattern.gridSpec.division % 4 === 0
            ? stepInBar % (pattern.gridSpec.division / 4) === 0
            : stepInBar === 0
        if (isQuarter) {
          void options.audio.triggerClick(
            scheduledWhen,
            isPatternBoundary,
            options.transport.metronomeVolume
          )
        }
      }

      let nextPattern = pattern
      if (isPatternBoundary && options.onPatternBoundary) {
        const candidate = options.onPatternBoundary()
        if (candidate) {
          nextPattern = candidate
          options.transport.setGridSpec(nextPattern.gridSpec)
        } else {
          nextPattern = options.getPattern()
        }
      }

      options.currentStep.value = nextStepInLoop
      options.transport.setCurrentStep(options.currentStep.value)

      if (options.transport.loop) {
        const stepDuration = secondsPerStep(options.transport.bpm, nextPattern.gridSpec.division)
        scheduleStep(options, scheduledWhen + stepDuration)
      }
    }
  })
}

export function useSequencer(options: SequencerOptions) {
  const transport = useTransportStore()
  const audio = useAudioEngine()
  let renderClock: RenderClock | null = null
  const scheduler = useScheduler({
    lookahead: options.lookahead ?? 25,
    scheduleAheadSec: options.scheduleAheadSec ?? 0.1,
    getTime: () => renderClock?.now() ?? 0
  })

  const currentStep = ref(0)
  const isRecording = ref(false)
  const pendingSteps = ref<ScheduledStep[]>([])
  let loopStartTime = 0

  const boundaryCallback = options.onPatternBoundary ?? (() => undefined)
  const buildStepOptions = (clock: RenderClock): ScheduleStepOptions => ({
    clock,
    scheduler,
    audio,
    transport,
    getPattern: options.getPattern,
    currentStep,
    pendingSteps,
    onPatternBoundary: boundaryCallback
  })

  const start = async () => {
    if (transport.isPlaying) return
    const ctx = await audio.resumeContext()
    renderClock = createRenderClock(ctx)
    const pattern = options.getPattern()
    const gridSpec = normalizeGridSpec(pattern.gridSpec)
    pattern.gridSpec = gridSpec
    transport.setGridSpec(gridSpec)
    loopStartTime = renderClock.now()
    currentStep.value = Math.max(0, transport.loopStart)
    pendingSteps.value = []
    transport.setCurrentStep(currentStep.value)
    transport.setPlaying(true)
    scheduler.clear()
    const stepOptions = buildStepOptions(renderClock)
    scheduleStep(stepOptions, loopStartTime)
    scheduler.start()
    scheduler.tick()
  }

  const stop = () => {
    transport.setPlaying(false)
    scheduler.stop()
    scheduler.clear()
    pendingSteps.value = []
    currentStep.value = Math.max(0, transport.loopStart)
    transport.setCurrentStep(currentStep.value)
    loopStartTime = 0
    renderClock = null
  }

  const toggleStep = (barIndex: number, stepInBar: number, padId: DrumPadId) => {
    const pattern = options.getPattern()
    const bar = pattern.steps[barIndex] ?? {}
    const stepRow = bar[stepInBar] ?? {}
    const updated = { ...stepRow }
    const nextVelocity = cycleVelocity(updated[padId]?.velocity?.value)
    if (nextVelocity === null) {
      delete updated[padId]
    } else {
      updated[padId] = { velocity: { value: clampVelocity(nextVelocity) } }
    }
    pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
  }

  const setStepVelocity = (barIndex: number, stepInBar: number, padId: DrumPadId, velocity: number) => {
    const pattern = options.getPattern()
    const bar = pattern.steps[barIndex] ?? {}
    const stepRow = bar[stepInBar] ?? {}
    const updated = { ...stepRow, [padId]: { velocity: { value: clampVelocity(velocity || DEFAULT_STEP_VELOCITY) } } }
    pattern.steps[barIndex] = { ...bar, [stepInBar]: updated }
  }

  const recordHit = async (padId: DrumPadId, velocity = 1, quantize = true) => {
    const pattern = options.getPattern()
    const ctx = await audio.resumeContext()
    const gridSpec = pattern.gridSpec
    const stepDuration = secondsPerStep(transport.bpm, gridSpec.division)
    const resolvedVelocity = clampVelocity(velocity)
    const anchor = transport.isPlaying ? loopStartTime : ctx.currentTime
    if (!transport.isPlaying) {
      loopStartTime = anchor
    }
    const sinceStart = ctx.currentTime - anchor
    const step = quantize
      ? quantizeToStep(sinceStart, stepDuration, gridSpec.bars, gridSpec.division)
      : {
          barIndex: Math.floor(currentStep.value / gridSpec.division),
          stepInBar: currentStep.value % gridSpec.division
        }
    setStepVelocity(step.barIndex, step.stepInBar, padId, resolvedVelocity)
    audio.trigger({ padId, when: ctx.currentTime, velocity: resolvedVelocity })
  }

  const setSampleForPad = async (padId: DrumPadId, sample: SampleRef) => {
    await audio.setSampleForPad(padId, sample)
  }

  const applySoundbank = async (bank: Soundbank) => {
    await audio.applySoundbank(bank)
  }

  const getAudioTime = () => renderClock?.now() ?? audio.ensureContext().currentTime

  return {
    currentStep,
    isRecording,
    pendingSteps,
    start,
    stop,
    toggleStep,
    setStepVelocity,
    recordHit,
    fxSettings: audio.fxSettings,
    setFx: audio.setFx,
    setSampleForPad,
    applySoundbank,
    getAudioTime
  }
}



=========================================
File: composables/useSoundbankStorage.client.ts
=========================================

import { ref } from 'vue'
import type { DrumPadId, Pattern } from '@/types/drums'
import type { Soundbank, SampleRef } from '@/types/audio'

const DB_NAME = 'drum-machine-db'
const DB_VERSION = 2

interface StoredSampleRecord {
  id: string
  name: string
  format?: string
  blob: Blob
}

interface StoredPatternRecord {
  id: string
  bankId: string
  pattern: Pattern
}

const stripNonSerializableSample = (sample?: SampleRef): SampleRef | undefined => {
  if (!sample) return undefined
  const sanitized: SampleRef = {
    id: sample.id,
    name: sample.name
  }
  if (sample.url !== undefined) {
    sanitized.url = sample.url
  }
  if (sample.format !== undefined) {
    sanitized.format = sample.format
  }
  return sanitized
}

const serializeSoundbank = (bank: Soundbank): Soundbank => {
  const pads: Partial<Record<DrumPadId, SampleRef>> = {}
  Object.entries(bank.pads).forEach(([padId, sample]) => {
    const sanitized = stripNonSerializableSample(sample)
    if (sanitized) {
      pads[padId as DrumPadId] = sanitized
    }
  })
  return {
    id: bank.id,
    name: bank.name,
    createdAt: bank.createdAt,
    updatedAt: bank.updatedAt,
    pads
  }
}

export function useSoundbankStorage() {
  const dbRef = ref<IDBDatabase | null>(null)

  const open = (): Promise<IDBDatabase> => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION)
      request.onupgradeneeded = () => {
        const db = request.result
        if (!db.objectStoreNames.contains('soundbanks')) {
          db.createObjectStore('soundbanks', { keyPath: 'id' })
        }
        if (!db.objectStoreNames.contains('samples')) {
          db.createObjectStore('samples', { keyPath: 'id' })
        }
        if (!db.objectStoreNames.contains('patterns')) {
          const store = db.createObjectStore('patterns', { keyPath: 'id' })
          store.createIndex('bankId', 'bankId', { unique: false })
        }
      }
      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        dbRef.value = request.result
        resolve(request.result)
      }
    })
  }

  const ensureDb = async () => {
    if (dbRef.value) return dbRef.value
    return open()
  }

  const saveBank = async (bank: Soundbank) => {
    const db = await ensureDb()
    return new Promise<void>((resolve, reject) => {
      const tx = db.transaction(['soundbanks'], 'readwrite')
      tx.objectStore('soundbanks').put(serializeSoundbank(bank))
      tx.oncomplete = () => resolve()
      tx.onerror = () => reject(tx.error)
    })
  }

  const saveSample = async (sample: SampleRef & { blob: Blob }) => {
    const db = await ensureDb()
    return new Promise<void>((resolve, reject) => {
      const tx = db.transaction(['samples'], 'readwrite')
      const record: StoredSampleRecord = { id: sample.id, name: sample.name, blob: sample.blob }
      if (sample.format) {
        record.format = sample.format
      }
      tx.objectStore('samples').put(record)
      tx.oncomplete = () => resolve()
      tx.onerror = () => reject(tx.error)
    })
  }

  const loadBanks = async (): Promise<Soundbank[]> => {
    const db = await ensureDb()
    return new Promise((resolve, reject) => {
      const tx = db.transaction(['soundbanks'], 'readonly')
      const request = tx.objectStore('soundbanks').getAll()
      request.onsuccess = () => resolve((request.result as Soundbank[]) ?? [])
      request.onerror = () => reject(request.error)
    })
  }

  const loadSample = async (sampleId: string): Promise<SampleRef | null> => {
    const db = await ensureDb()
    return new Promise((resolve, reject) => {
      const tx = db.transaction(['samples'], 'readonly')
      const request = tx.objectStore('samples').get(sampleId)
      request.onsuccess = () => {
        const result = request.result as StoredSampleRecord | undefined
        if (!result) {
          resolve(null)
          return
        }
        const restored: SampleRef = { id: result.id, name: result.name, blob: result.blob }
        const format = result.format as SampleRef['format'] | undefined
        if (format) {
          restored.format = format
        }
        resolve(restored)
      }
      request.onerror = () => reject(request.error)
    })
  }

  const savePatterns = async (bankId: string, patterns: Pattern[]) => {
    const db = await ensureDb()
    return new Promise<void>((resolve, reject) => {
      const tx = db.transaction(['patterns'], 'readwrite')
      patterns.forEach((pattern) => {
        const record: StoredPatternRecord = { id: `${bankId}:${pattern.id}`, bankId, pattern }
        tx.objectStore('patterns').put(record)
      })
      tx.oncomplete = () => resolve()
      tx.onerror = () => reject(tx.error)
    })
  }

  const loadPatterns = async (bankId: string): Promise<Pattern[]> => {
    const db = await ensureDb()
    return new Promise((resolve, reject) => {
      const tx = db.transaction(['patterns'], 'readonly')
      const index = tx.objectStore('patterns').index('bankId')
      const request = index.getAll(bankId)
      request.onsuccess = () => {
        const records = (request.result as StoredPatternRecord[] | undefined) ?? []
        resolve(records.map((record) => record.pattern))
      }
      request.onerror = () => reject(request.error)
    })
  }

  return {
    saveBank,
    saveSample,
    loadBanks,
    loadSample,
    savePatterns,
    loadPatterns
  }
}



=========================================
File: composables/useSync.client 2.ts
=========================================

import { ref } from 'vue'
import type { SyncMode, SyncRole, SyncState } from '~/types/sync'

export function useSync(initialMode: SyncMode = 'internal') {
  const state = ref<SyncState>({ bpm: 120, phase: 0, isPlaying: false, mode: initialMode, role: 'master' })

  const setMode = (mode: SyncMode) => {
    state.value.mode = mode
  }

  const setRole = (role: SyncRole) => {
    state.value.role = role
  }

  const setPlaying = (isPlaying: boolean) => {
    state.value.isPlaying = isPlaying
  }

  const setBpm = (bpm: number) => {
    state.value.bpm = bpm
  }

  const tick = (phase: number) => {
    state.value.phase = phase
  }

  return {
    state,
    setMode,
    setRole,
    setPlaying,
    setBpm,
    tick
  }
}



=========================================
File: composables/useSync.client.ts
=========================================

import { onBeforeUnmount, ref } from 'vue'
import { useScheduler } from './useScheduler'
import type { ClockAuthority, SyncMode, SyncRole, SyncState } from '@/types/sync'
import type { MidiMessage } from '@/types/midi'

interface SyncDeps {
  midi?: {
    listen: (cb: (message: MidiMessage) => void) => () => void
    sendClockTick: () => void
    sendStart: () => void
    sendStop: () => void
    selectedOutputId: { value: string | null }
  }
  getAudioTime?: () => number
  onExternalStart?: () => void
  onExternalStop?: () => void
}

const MIDI_CLOCKS_PER_QUARTER = 24
const CLOCK_AUTHORITY: ClockAuthority = 'audioContext'

export function useSync(initialMode: SyncMode = 'internal', deps?: SyncDeps) {
  // Coordinates transport sync between audio clock and MIDI clock roles (master/slave), handling clock ticks and start/stop events.
  const state = ref<SyncState>({
    bpm: 120,
    phase: 0,
    isPlaying: false,
    mode: initialMode,
    role: 'master',
    linkAvailable: false,
    clockAuthority: CLOCK_AUTHORITY,
    bpmSource: 'transport'
  })
  const scheduler = deps?.getAudioTime
    ? useScheduler({
      lookahead: 25,
      scheduleAheadSec: 0.05,
      getTime: deps.getAudioTime
    })
    : null
  const lastStableBpm = ref(state.value.bpm)
  let nextClockAt: number | null = null
  let midiUnsubscribe: (() => void) | null = null

  const secondsPerClockTick = () => 60 / (state.value.bpm * MIDI_CLOCKS_PER_QUARTER)

  const resetPhase = () => {
    state.value.phase = 0
  }

  const stopClock = () => {
    scheduler?.stop()
    scheduler?.clear()
    nextClockAt = null
    deps?.midi?.sendStop()
  }

  const tick = () => {
    state.value.phase = (state.value.phase + 1) % MIDI_CLOCKS_PER_QUARTER
  }

  const scheduleClockTick = () => {
    if (!scheduler || nextClockAt === null) return
    scheduler.schedule({
      when: nextClockAt,
      callback: () => {
        deps?.midi?.sendClockTick()
        tick()
        if (nextClockAt !== null) {
          nextClockAt = nextClockAt + secondsPerClockTick()
          scheduleClockTick()
        }
      }
    })
  }

  const startClock = () => {
    stopClock()
    if (state.value.mode !== 'midiClock' || state.value.role !== 'master') return
    if (!deps?.midi?.selectedOutputId.value) return
    if (!deps?.getAudioTime || !scheduler) return
    const now = deps.getAudioTime()
    nextClockAt = now + secondsPerClockTick()
    deps.midi.sendStart()
    scheduleClockTick()
    scheduler.start()
    scheduler.tick()
  }

  const setMode = (mode: SyncMode) => {
    state.value.mode = mode
    state.value.bpm = lastStableBpm.value
    stopClock()
    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
      startClock()
    }
  }

  const setRole = (role: SyncRole) => {
    state.value.role = role
    state.value.bpm = lastStableBpm.value
    stopClock()
    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
      startClock()
    }
  }

  const setPlaying = (isPlaying: boolean) => {
    state.value.isPlaying = isPlaying
    if (isPlaying) {
      startClock()
    } else {
      stopClock()
    }
  }

  const setBpm = (bpm: number) => {
    state.value.bpm = Math.max(20, Math.min(300, bpm))
    lastStableBpm.value = state.value.bpm
    if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
      startClock()
    }
  }

  const handleMidiMessage = (message: MidiMessage) => {
    if (state.value.mode !== 'midiClock' || state.value.role !== 'slave') return
    if (message.type === 'start') {
      state.value.isPlaying = true
      resetPhase()
      deps?.onExternalStart?.()
    } else if (message.type === 'stop') {
      state.value.isPlaying = false
      resetPhase()
      deps?.onExternalStop?.()
    } else if (message.type === 'clock') {
      tick()
    }
  }

  const startTransport = (bpm: number) => {
    setBpm(bpm)
    setPlaying(true)
  }

  const stopTransport = () => {
    setPlaying(false)
  }

  if (deps?.midi) {
    midiUnsubscribe = deps.midi.listen(handleMidiMessage)
  }

  onBeforeUnmount(() => {
    stopClock()
    midiUnsubscribe?.()
  })

  return {
    state,
    setMode,
    setRole,
    setPlaying,
    setBpm,
    startTransport,
    stopTransport
  }
}



=========================================
File: config/pwa.ts
=========================================

export const pwaConfig = {
  registerType: 'autoUpdate',
  manifest: {
    name: 'Drumcomputer',
    short_name: 'Drumcomputer',
    theme_color: '#121212',
    background_color: '#121212',
    display: 'standalone'
  },
  workbox: {
    globPatterns: ['**/*.{js,css,html,png,svg,ico}']
  }
}



=========================================
File: control-review.md
=========================================

# Control-Bereich Review: Offene Punkte und Empfehlungen

## Ãœbersicht
Der Control-Bereich der MASCHINE MK3 bietet Zugriff auf alle Parameter des gewÃ¤hlten Modus und enthÃ¤lt fest zugeordnete Buttons fÃ¼r Browser, Arranger, Mixer, Sample-Editor, File, Settings, Auto, Macro sowie dynamische Softbuttons und Drehregler. Die Hardware-Logik und UI-Struktur sind in der Codebasis teilweise abgebildet, jedoch fehlen noch einige zentrale Funktionen und UI-Elemente.

---

## Fehlende Implementierungen & offene Punkte

### 1. Modus- und Control-Buttons
- **CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, FILE, SETTINGS, AUTO, MACRO:**
  - Es fehlen dedizierte Komponenten/Buttons fÃ¼r diese Funktionen im Control-Bereich.
  - SHIFT-Funktionen (z.B. SHIFT+CHANNEL fÃ¼r MIDI, SHIFT+PLUG-IN fÃ¼r Instance) sind nicht als UI-Elemente oder Logik abgebildet.
  - Die Zuordnung und das visuelle Layout dieser Buttons gemÃ¤ÃŸ Hardware-Referenz sind nicht vollstÃ¤ndig umgesetzt.

### 2. Softbuttons & Displays
- **Softbuttons 1-8 Ã¼ber den Displays:**
  - Die dynamische Anpassung der Softbutton-Funktionen je nach Modus ist nicht vollstÃ¤ndig implementiert.
  - Die Anzeige der jeweiligen Aktion unter jedem Button im Display fehlt.
  - Die Verbindung zwischen Softbuttons und den Displays (z.B. Anzeige der Parameter, dynamische Labels) ist nicht klar dokumentiert und technisch nicht vollstÃ¤ndig umgesetzt.

### 3. Drehregler
- **Drehregler 1-8:**
  - Die Steuerung der im Display angezeigten Parameter Ã¼ber die Drehregler ist nicht als UI/Logik vorhanden.
  - Die Verbindung zwischen Regler und Parameter (z.B. Mapping, Value-Feedback) fehlt.

### 4. Page-Buttons
- **Page-Buttons:**
  - Die Funktion zum Wechseln von Parameter-Pages ist nicht als UI-Element oder Logik abgebildet.
  - Die Anzeige und Navigation zwischen Pages fehlt.

### 5. File- und Settings-Buttons
- **FILE, SETTINGS:**
  - Schnellzugriff auf Dateioperationen und Einstellungen (Metronom, Count-in) ist nicht als Button oder Panel vorhanden.
  - SHIFT-Funktionen (z.B. Save) fehlen.

### 6. Auto- und Macro-Buttons
- **AUTO, MACRO:**
  - Modulations- und Macro-Funktionen sind nicht als UI-Elemente oder Logik abgebildet.
  - SHIFT-Funktionen (z.B. Festsetzen, Macro-Set) fehlen.

### 7. Sampling-Button
- **SAMPLING:**
  - Der direkte Zugriff auf den Sample-Editor ist nicht als Button oder Panel vorhanden.

### 8. Browser-Button
- **BROWSER:**
  - Der Browser-Zugriff ist nicht als Button oder Panel implementiert.
  - SHIFT-Funktion fÃ¼r Plug-in-MenÃ¼ fehlt.

### 9. Arranger- und Mixer-Button
- **ARRANGER, MIXER:**
  - Zugriff auf Arranger- und Mixer-Views ist nicht als Button oder Panel vorhanden.

### 10. Accessibility & Dokumentation
- **ARIA, Tabindex, Fokussteuerung:**
  - FÃ¼r die neuen Control-Buttons und Panels mÃ¼ssen Accessibility-Attribute ergÃ¤nzt werden.
- **Dokumentation:**
  - Die Zuordnung und Logik der Control-Buttons, Softbuttons und Drehregler muss in README.md und als Diagramm dokumentiert werden.

---

## Empfehlungen zur Fertigstellung der Control-Sektion
1. **Komponenten fÃ¼r alle Control-Buttons und deren SHIFT-Funktionen erstellen** (CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, FILE, SETTINGS, AUTO, MACRO).
2. **Softbutton-Logik dynamisch an Modus koppeln** und Anzeige der jeweiligen Aktion im Display ergÃ¤nzen.
3. **Drehregler-UI und Parameter-Mapping implementieren** (inkl. Value-Feedback im Display).
4. **Page-Button-Komponente und Page-Navigation ergÃ¤nzen**.
5. **Panels fÃ¼r File, Settings, Sampling, Browser, Arranger, Mixer erstellen** und Buttons verknÃ¼pfen.
6. **Accessibility fÃ¼r alle neuen UI-Elemente sicherstellen**.
7. **README.md und Diagramm im diagrams-Ordner aktualisieren**: Hardware-Referenz, UI-Logik, Button-Zuordnung, Regler-Mapping.

---

## Schnellreferenz: MASCHINE MK3 Control-Bereich
- **Buttons:** CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, FILE, SETTINGS, AUTO, MACRO, Softbuttons 1-8
- **Displays:** Anzeige von Parametern, dynamischen Labels, Value-Feedback
- **Drehregler:** Steuerung der Parameter im Display
- **Page-Buttons:** Navigation zwischen Parameter-Pages

---

**Fazit:**
Die Control-Sektion ist in der Codebasis noch nicht vollstÃ¤ndig umgesetzt. Es fehlen zentrale UI-Komponenten, Logik fÃ¼r dynamische Softbuttons, Regler-Mapping, Page-Navigation und Panels fÃ¼r die wichtigsten Control-Funktionen. Die Hardware-Referenz und UI-Logik mÃ¼ssen in README.md und als Diagramm dokumentiert werden.

---

**Siehe MASCHINE MK3 Benutzerhandbuch S. 51â€“53 fÃ¼r vollstÃ¤ndige Hardware-Referenz.**



=========================================
File: diagrams/class-diagram.md
=========================================

# Core Components Class Diagram

```mermaid
classDiagram
  class DrumMachine {
    +start()
    +stop()
    +updateBpm(bpm)
    +setDivision(div)
    +selectPad(padId)
    +exportBounce()
  }

  class TransportBar {
    +play()
    +stop()
    +updateBpm(bpm)
    +updateDivision(div)
    +toggleLoop()
    +toggleMidiLearn()
  }

  class PadGrid {
    +pads: DrumPadId[]
    +padStates: PadState map
    +selectPad(padId)
    +triggerPad(padId, velocity)
  }

  class PatternsPanel {
    +addPattern(name)
    +renamePattern(id, name)
    +undo()
    +redo()
    +addScene(name, patternIds)
    +selectScene(id)
  }

  class ExportPanel {
    +export()
    +downloadMixdown()
    +downloadZip()
    +downloadStem(padId)
  }

  class TransportStore {
    +bpm
    +isPlaying
    +gridSpec
    +setBpm(bpm)
    +setGridSpec(spec)
    +setLoop(loop)
  }

  class PatternsStore {
    +patterns
    +scenes
    +toggleStep(bar, step, pad)
    +setStepVelocity(...)
    +updateGridSpec(spec)
    +prepareScenePlayback()
    +advanceScenePlayback()
  }

  class SoundbanksStore {
    +banks
    +currentBank
    +upsertBank(bank)
    +selectBank(id)
  }

  class Sequencer {
    +start()
    +stop()
    +recordHit(pad, velocity, quantize)
    +applySoundbank(bank)
    +setFx(settings)
  }

  DrumMachine --> TransportBar : renders
  DrumMachine --> PadGrid : renders
  DrumMachine --> PatternsPanel : renders (drawer)
  DrumMachine --> ExportPanel : renders (drawer)
  DrumMachine --> Sequencer : drives playback/record
  DrumMachine --> TransportStore : reads/writes transport state
  DrumMachine --> PatternsStore : reads/writes patterns/scenes
  DrumMachine --> SoundbanksStore : reads/writes soundbanks
  Sequencer --> PatternsStore : reads steps
  Sequencer --> SoundbanksStore : uses pad samples
  TransportBar --> TransportStore : updates BPM/division/loop/play
  PadGrid --> Sequencer : record hits
  ExportPanel --> DrumMachine : triggers export/download flows
```

## Maschine MK3 UI placeholders (no-scroll shell)

```mermaid
classDiagram
  class DualDisplayPlaceholder {
    +leftText: string
    +rightText: string
    +softButtonLabels[8]: string
  }

  class SoftButtonStripPlaceholder {
    +buttons[8]: {symbol, hint}
    +onHoverHint()
  }

  class ScreenKnobRingPlaceholder {
    +knobs[8]: {label, value, hint}
    +selectorOverlay()
  }

  class FourDEncoderPlaceholder {
    +navigate(direction)
    +confirm()
    +hoverHint()
  }

  class TransportClusterPlaceholder {
    +playStop()
    +stopReset()
    +record()
    +restart()
    +tapTempo()
    +hoverHint()
  }

  class ModeColumnPlaceholder {
    +scene/pattern/events/variation
    +duplicate/select/mute/solo
    +shift()
    +hoverHint()
  }

  class TouchStripPlaceholder {
    +stripPosition
    +aftertouchMode
    +hoverHint()
  }

  DrumMachine --> DualDisplayPlaceholder : top displays
  DualDisplayPlaceholder --> SoftButtonStripPlaceholder : labels above displays
  DualDisplayPlaceholder --> ScreenKnobRingPlaceholder : knobs below displays
  DrumMachine --> FourDEncoderPlaceholder : nav + confirm
  DrumMachine --> ModeColumnPlaceholder : left cluster
  DrumMachine --> TransportClusterPlaceholder : transport cluster
  DrumMachine --> TouchStripPlaceholder : right/performance column
  DrumMachine --> PadGrid : pad matrix (right)
```

All placeholder components must expose hover hints (tooltips/titles) so every control mirrors the MK3 guidance even before full functionality is wired. Widths/heights should use `clamp()` to keep the entire shell inside 100vh without page scroll.



=========================================
File: diagrams/control-area-mapping.md
=========================================

# Control-Area Mapping (MK3)

| Mode | Pages | Encoders (1â€“8) | Soft Buttons (1â€“8) | Displays (L / R) |
| --- | --- | --- | --- | --- |
| CHANNEL | Levels | Sound Vol, Sound Pan, Send A, Send B, Group Vol, Group Pan, Master Comp, Limiter | Sound, Group, Master, Input, Route, Solo, Mute, Monitor | Channel meters / Group + Master meters |
| PLUGIN | Plug-in | Cutoff, Resonance, Attack, Release, Drive, Mix, Stereo, Output | Instance/Swap, Preset, Bypass, Enable, Param, Macro, Browse, Remove | Plug-in chain / Instance meta |
| ARRANGER | Scenes | Scene Bars, Repeat, Section, Swing, Vel Mod, Humanize, Shift, Accent | Scenes, Sections, Duplicate, Length, Follow, Loop, Grid, Clear | Scenes list / Layout overview |
| MIXER | Mix | Kick, Snare, Hat, Perc, Bus Comp, Saturate, Send A, Send B | Levels, Pan, Sends, FX, Group, Master, Cue, Meters | Channel strip / Sends & FX |
| BROWSER | Library, Recent | Filter, Cutoff, Res, Rate, Depth, Space, Tone, Volume (Recent: Preview controls) | Search/Plug-in Menu, Type, Tag, Favorites, Prehear/Stop, Load, Replace, Clear | Categories with search / Results & preview |
| SAMPLING | Sampling | Start, End, Snap, Silence, Attack, Hold, Release, Gain | Record, Edit, Slice, Detect, Normalize, Fade, Apply, Discard | Waveform info / Sampling actions |
| FILE | Files | Mixdown, Stems, Normalize, Dither, Rate, Bit Depth, Loop, Count-in | New, Open, Save/Save As, Export, Audio, MIDI, Bounce, Close | File ops / Export options |
| SETTINGS | Settings | Metro Vol, Count-In, Swing, Quantize, Theme, Latency, Buffer, Safe Mode | Metronome, Count-In, Quantize, MIDI, Audio, Theme, Safe, Reset | System toggles / Audio & MIDI device info |
| AUTO | Automation | Lane, Smooth, Scale, Quantize, Protect, Loop, Snap, Depth | Write, Read, Latch, Touch, Erase, Arm, Hold, Clear | Automation mode / Status flags |
| MACRO | Macro | Macro 1â€“8 | Assign, Clear, Hold, Latch, Morph, Set/Shift Set, Store, Recall | Macro sets / Morph target |

- Page â—€/â–¶ cycles pages per mode (clamped). SHIFT + mode triggers secondary action (e.g., CHANNELâ†’MIDI, PLUGINâ†’Instance, BROWSERâ†’Plug-in menu, FILEâ†’Save As, MACROâ†’Set).
- Encoders support mouse wheel on hover and ArrowUp/Down/Left/Right keys; SHIFT performs fine steps.



=========================================
File: diagrams/padgrid-modus-layout.md
=========================================

# PadGrid & Modus-Layout

Das Schema zeigt, wie PadGrid, Modus-Spalte und die oberen Buttonreihen an den Softbutton-Referenzlinien ausgerichtet sind. DisplayÂ 1 (links) und DisplayÂ 2 (rechts) bilden die obere Achse; die Softbuttons darÃ¼ber liefern die vertikale Referenz (SoftbuttonÂ 4 Ã¼ber DisplayÂ 1) fÃ¼r die Modus-Spalte und die horizontale Referenz (Softbuttons Ã¼ber DisplayÂ 2) fÃ¼r die Fixed-Velocity/Pad-Mode-Zeile.

```mermaid
flowchart TB
  %% Softbuttons + Referenzen
  subgraph soft["Softbuttons 1â€“8 (oben)"]
    direction LR
    sb1["SB1"]:::softbtn
    sb2["SB2"]:::softbtn
    sb3["SB3"]:::softbtn
    sb4["SB4\nVertikale Referenzlinie"]:::ref
    sb5["SB5"]:::softbtn
    sb6["SB6"]:::softbtn
    sb7["SB7"]:::softbtn
    sb8["SB8"]:::softbtn
  end

  %% Displays
  subgraph displays["Dual Displays"]
    direction LR
    disp1["Display 1 (links)"]:::display
    disp2["Display 2 (rechts)"]:::display
  end

  %% Referenzlinien
  refV["Ausrichtung Modus-Spalte\n(Vertikale Linie SB4)"]:::ref
  refH["Horizontale Referenz:\nSoftbuttons Ã¼ber Display 2"]:::ref

  %% Upper buttons (Fixed Velocity + Pad Modes)
  upperRow["Fixed Velocity  |  PAD MODE  |  KEYBOARD  |  CHORD  |  STEP"]:::upper

  %% Main surface
  subgraph surface["BedienoberflÃ¤che (schematisch)"]
    direction LR
    subgraph modes["Modus-Buttons (links)\n8 StÃ¼ck, je 2 Pad-HÃ¶hen\nAusrichtung: Linie SB4"]
      m1["Mode 1"]:::mode
      m2["Mode 2"]:::mode
      m3["Mode 3"]:::mode
      m4["Mode 4"]:::mode
      m5["Mode 5"]:::mode
      m6["Mode 6"]:::mode
      m7["Mode 7"]:::mode
      m8["Mode 8"]:::mode
    end

    subgraph pads["PadGrid 4Ã—4 (rechts)\npad1â€“pad16\nStates: selected / triggered / playing\nPattern Indicator"]
      pgrid["4Ã—4 Pads"]:::pads
      pind["Pattern Indicator"]:::pads
    end
  end

  %% Relations
  soft --> displays
  sb4 -. Vertikale Referenz .- refV
  refV -. Linie .- modes
  soft -. Marker .- refH
  refH --> upperRow
  upperRow --> modes
  upperRow --> pads
  modes --> pads
  displays --> upperRow

  classDef softbtn fill:#1f2430,stroke:#6a7da8,color:#e4ecff;
  classDef display fill:#0f141f,stroke:#4d5a78,color:#d8e3ff;
  classDef pads fill:#1a1f2b,stroke:#f6a821,color:#ffeac2;
  classDef mode fill:#131722,stroke:#56b2e5,color:#d9f2ff;
  classDef upper fill:#1c2230,stroke:#8ac6ff,color:#e7f4ff;
  classDef ref stroke-dasharray: 4 2,stroke:#ff7f11,color:#ff7f11,fill:#fff2e6;
```

**Legende**
- Softbuttons 1â€“8 bilden die obere Linie; SoftbuttonÂ 4 markiert die vertikale Referenz der Modus-Spalte.
- DisplayÂ 1 sitzt links, DisplayÂ 2 rechts; die Softbuttons Ã¼ber DisplayÂ 2 definieren die horizontale Referenz fÃ¼r Fixed Velocity + PAD MODEâ€¦STEP.
- Modus-Buttons stehen links vom PadGrid, sind eine Spalte breit und jeweils 2 Pad-HÃ¶hen hoch (8 StÃ¼ck).
- Fixed Velocity plus die Reihe PAD MODE bis STEP liegt oberhalb der Modus-Spalte und orientiert sich an der Softbutton-Linie von DisplayÂ 2.
- PadGrid ist 4Ã—4 (pad1â€“pad16) mit ZustÃ¤nden selected/triggered/playing und einem Pattern Indicator im Bereich des Grids.



=========================================
File: diagrams/persistence-and-audio.md
=========================================

# Persistence and Audio Flow

```mermaid
  flowchart TB
    UI[UI_and_Stores] -->|save patterns/scenes| LocalStorage
    UI -->|manage banks/samples| IndexedDB
    DefaultKit[DefaultKitLoader] --> IndexedDB
    ImportExport[ImportExportHelpers] -->|manifests + blobs| IndexedDB
    IndexedDB -->|rehydrate blobs| AudioEngine[AudioEngine+FX]
    AudioEngine -->|decode| AudioCache[AudioBufferCache]
    TransportEngine -->|onStep schedule| AudioEngine
    AudioEngine -->|mixdown/stems + metadata| Exporter[OfflineExport]
    Exporter -->|WAV + JSON| Downloader[DownloadHelpers]
```

## MK3 UI overlays hooked to persistence/audio (placeholders)

```mermaid
flowchart LR
  ScreenKnobs["Screen Knobs 1-8\n(hint + selector overlay)"] -->|grid length/div/swing| TransportStore
  ScreenKnobs -->|pad params| PatternsStore
  SoftButtons["Soft Buttons 1-8\n(symbol + hover hint)"] -->|scene/pattern select| PatternsStore
  ModeButtons["Mode Column\n(Scene/Pattern/Events/Variation/Duplicate/Select/Mute/Solo)"] --> PatternsStore
  TouchStrip["Touch Strip â‰¡\n(performance macro placeholder)"] --> AudioEngine
  Displays["Dual Displays\n(render metadata + presets)"] --> ImportExport
  TransportCluster["Transport Cluster\n(play/stop/rec/restart)"] --> TransportEngine
```

- All hardware placeholders must show hover hints describing what they write to (transport store, patterns store, audio engine) and list both primary + shift-layer actions.
- Keep overlays lightweight and clipped inside the 100vh hardware shell; any deeper lists (e.g., selector values) should scroll inside the display mock, not the page.



=========================================
File: diagrams/transport-engine.md
=========================================

# Transport Engine Timing (English)

```mermaid
sequenceDiagram
    participant UI as UI/Stores
    participant Transport as TransportEngine
    participant Clock as RenderClock
    participant Scheduler as StepScheduler
    participant Hooks as AudioHooks
    participant Subs as Subscribers

    UI->>Transport: start()
    Transport->>Clock: audioTime()
    Transport->>Transport: set startTimeSec + lastStep
    Transport->>Scheduler: clear()
    Transport->>Scheduler: start()
    Transport->>Scheduler: schedule(nextBoundary)
    Scheduler-->>Hooks: onStep(stepIndex, audioTime)
    Hooks-->>Subs: audio pipeline elsewhere

    loop tick
        UI->>Transport: tick()
        Transport->>Clock: audioTime()
        Transport->>Transport: compute currentStep
        Transport->>Scheduler: schedule(step+1, swing)
        Transport-->>Subs: emit isPlaying + currentStep
    end

    UI->>Transport: setConfig(bpm/division/swing)
    Transport->>Clock: audioTime()
    Transport->>Transport: recompute startTimeSec (phase)
    Note over Transport,Scheduler: clear/reseed to avoid stale queued steps

    UI->>Transport: stop()
    Transport->>Scheduler: stop()
    Transport->>Scheduler: clear()
    Transport-->>Subs: emit stopped
```

## MK3 transport mapping (placeholders + hover hints)

```mermaid
stateDiagram-v2
    [*] --> Stopped
    Stopped --> Playing: Play â–¶
    Playing --> Stopped: Play/Stop â– 
    Stopped --> CountingIn: Shift+Rec (Count-In â™©)
    CountingIn --> Recording: Count-in done
    Playing --> Recording: Rec â—
    Recording --> Playing: Rec â— (toggle)
    Stopped --> Stopped: Stop â–  (reset playhead)
    Playing --> Stopped: Stop â–  (reset)
    Playing --> Playing: Restart â†» (jump to step 0)
```

- Transport cluster placeholder should expose hover hints for primary + shift: Play â–¶ (toggle), Stop â–  (press twice = reset), Rec â— (hold = Pattern Preset length), Restart â†» (shift+stop), Tap â˜¼, Loop âŸ³, Metronome â™¬, Count-In â™©, Follow â‡¥.
- Ensure the transport row stays within the left column and never forces a page scroll; stack controls into two compact rows with icons + labels so it fits under the dual displays.



=========================================
File: diagrams/ui-sequencer.md
=========================================

# UI Sequencer Flow

```mermaid
flowchart LR
    TransportBar["TransportBar.vue"]
    TransportStore["Transport / Session Stores"]
    StepGrid["StepGrid.vue"]
    PadGrid["PadGrid.vue"]
    SequencerStore["Patterns / Scenes Store"]
    TransportEngine["Transport Engine"]
    AudioEngine["Audio Engine<br/>+ FX"]

    TransportBar -->|"play Â· stop Â· bpm Â· division"| TransportStore
    TransportStore -->|"isPlaying Â· currentStep Â· gridSpec"| StepGrid

    PadGrid -->|"pad select / pad down"| SequencerStore
    SequencerStore -->|"steps for selected pad"| StepGrid
    StepGrid -->|"step toggle"| SequencerStore

    TransportStore -->|"tick / schedule"| TransportEngine
    TransportEngine -->|"onStep hook"| AudioEngine
    AudioEngine -->|"pad state (trigger / playing)"| PadGrid
```

## MK3 surface + hover hints

```mermaid
flowchart TB
  Displays["Dual Displays\n(soft labels + status bars)"]
  SoftButtons["Soft Buttons 1-8\n(symbol + hint tooltip)"]
  ScreenKnobs["8 Screen Knobs\n(selector overlay on hover/touch)"]
  Encoder["4D Encoder + Push\n(nav arrows â†•â†” + confirm)"]
  Modes["Mode Column\n(Scene/Pattern/Events/Variation/Duplicate/Select/Mute/Solo + Shift)"]
  Transport["Transport Cluster\n(Play â–¶ / Stop â–  / Rec â— / Restart â†» / Loop âŸ³ / Tap â˜¼)"]
  TouchStrip["Touch Strip â‰¡\n(perform/aftertouch placeholder)"]
  Pads["Pad Grid 4Ã—4\n(labels + key legends + hover hint)"]

  Displays --- SoftButtons
  Displays --- ScreenKnobs
  ScreenKnobs --> Encoder
  SoftButtons --> Displays
  Modes --> Pads
  Transport --> Pads
  TouchStrip --> Pads
  Pads --> Displays
```

- Fit everything inside a `100vh` stage: displays + buttons at top, pad square anchored bottom-right, transport + mode columns on the left, touch strip on the right. Only drawers scroll internally.
- Hover hints must show both the primary and shift-layer action (e.g., â€œMUTE (hold to momentary) / SHIFT: SOLOâ€), and selector overlays appear when hovering a screen knob to mimic MK3 lists.



=========================================
File: diagrams/use-cases.md
=========================================

# Sequence Diagrams for the documented Use Cases

## Live pattern building
```mermaid
sequenceDiagram
  participant User
  participant PadGrid
  participant DrumMachine
  participant Sequencer
  participant PatternsStore
  participant TransportStore

  User->>PadGrid: tap pad (velocity)
  PadGrid->>DrumMachine: pad:down(padId, velocity)
  DrumMachine->>Sequencer: recordHit(padId, velocity, quantized=true)
  Sequencer->>PatternsStore: toggleStep/current pattern
  DrumMachine->>TransportStore: ensure transport running/looping
  DrumMachine-->>User: updated pad state + playhead feedback
```

## Scene and pattern chaining
```mermaid
sequenceDiagram
  participant User
  participant PatternsPanel
  participant DrumMachine
  participant PatternsStore
  participant Sequencer
  participant TransportStore

  User->>PatternsPanel: set scene pattern chain
  PatternsPanel->>DrumMachine: scene:update(patternIds)
  DrumMachine->>PatternsStore: updateScene(...)
  User->>TransportStore: start transport
  TransportStore-->>DrumMachine: isPlaying=true
  DrumMachine->>Sequencer: start()
  Sequencer->>PatternsStore: prepareScenePlayback()
  Sequencer-->>PatternsStore: advanceScenePlayback() at bar boundary
```

## Soundbank customization and persistence
```mermaid
sequenceDiagram
  participant User
  participant SoundPanel
  participant DrumMachine
  participant SoundbanksStore
  participant SoundbankStorage
  participant Sequencer

  User->>SoundPanel: upload sample for pad
  SoundPanel->>DrumMachine: replacePadSample(padId, file)
  DrumMachine->>SoundbanksStore: upsertBank(updatedBank)
  DrumMachine->>SoundbankStorage: saveBank/saveSample
  DrumMachine->>Sequencer: setSampleForPad/applySoundbank
  DrumMachine-->>User: updated pad label + sound
```

## MIDI/hardware integration
```mermaid
sequenceDiagram
  participant User
  participant TransportBar
  participant DrumMachine
  participant Midi
  participant MidiLearn
  participant Sequencer
  participant TransportStore

  User->>TransportBar: toggle MIDI learn
  TransportBar->>DrumMachine: toggleMidiLearn()
  MidiLearn-->>User: awaiting pad/transport mapping
  Midi-->>MidiLearn: noteOn(message)
  MidiLearn->>Midi: setPadForNote / set transport mapping
  User->>TransportStore: start via mapped note
  TransportStore-->>DrumMachine: isPlaying=true
  DrumMachine->>Sequencer: start()
  Midi->>ExternalClock: send/start/stop (if master)
```

## Export mixes and stems
```mermaid
sequenceDiagram
  participant User
  participant ExportPanel
  participant DrumMachine
  participant ImportExport
  participant Sequencer

  User->>ExportPanel: click Export mixdown
  ExportPanel->>DrumMachine: export()
  DrumMachine->>ImportExport: exportAudio(duration)
  ImportExport->>Sequencer: render scene chain via RenderClock
  ImportExport-->>DrumMachine: {audioBlob, metadata, stems}
  DrumMachine-->>ExportPanel: metadata + download actions
  User->>ExportPanel: download WAV/ZIP/stems
```

## Import and normalization
```mermaid
sequenceDiagram
  participant User
  participant ImportUI
  participant DrumMachine
  participant ImportExport
  participant PatternsStore
  participant SoundbanksStore

  User->>ImportUI: select pattern JSON / MIDI / soundbank bundle
  ImportUI->>DrumMachine: import request
  DrumMachine->>ImportExport: parse/normalize payload
  ImportExport->>PatternsStore: setPatterns / updateGridSpec normalized
  ImportExport->>SoundbanksStore: upsertBank + samples
  DrumMachine-->>User: normalized patterns/soundbanks ready to play
```

## MK3 hardware-style navigation & hover hints
```mermaid
sequenceDiagram
  participant User
  participant Displays as DualDisplays+SoftButtons
  participant ScreenKnobs
  participant Encoder as 4DEncoder
  participant Transport as TransportCluster
  participant Modes as ModeColumn
  participant Pads

  User->>Displays: hover soft button (see hint + symbol)
  User->>ScreenKnobs: hover knob (opens selector overlay with values)
  ScreenKnobs->>Encoder: nudge/confirm selection
  Modes-->>Pads: change pad mode (mute/solo/select)
  Transport-->>Pads: play/stop/rec/restart toggles
  User->>Pads: tap pad (see pad label + hover legend)
  Displays-->>User: status update (no page scroll)
```

- Keep all interactions inside the hardware viewport; drawers and selector overlays scroll internally while the page remains locked.
- Hover hints should list both primary and shift-layer actions to mirror the MK3 printed labels.



=========================================
File: domain/clock/renderClock.ts
=========================================

export interface RenderClock {
  readonly ctx: BaseAudioContext

  /**
   * Indicates whether the clock is used for offline rendering.
   * Offline clocks must not rely on real-time scheduling.
   */
  readonly isOffline: boolean

  /**
   * Current audio time in seconds.
   * This is always based on the underlying AudioContext.
   */
  audioTime(): number

  /**
   * Alias for audioTime(), for compatibility.
   */
  now(): number
}

export function createRenderClock(


  ctx: BaseAudioContext,
  isOffline = false
): RenderClock {
  return {
    ctx,
    isOffline,
    audioTime: () => ctx.currentTime,
    now: () => ctx.currentTime
  }
}



=========================================
File: domain/clock/scheduler.ts
=========================================

import type { RenderClock } from './renderClock'

export type ScheduledFn = (audioTime: number) => void

export interface SchedulerOptions {
  readonly lookaheadSec: number
  readonly intervalMs: number
}

export interface Scheduler {
  start(): void
  stop(): void
  schedule(atTimeSec: number, fn: ScheduledFn): void
  clear(): void
}

interface ScheduledItem {
  at: number
  fn: ScheduledFn
}

// Lookahead scheduler that batches callbacks scheduled within a horizon relative to the audio clock.
const DEFAULT_OPTIONS: SchedulerOptions = {
  lookaheadSec: 0.1,
  intervalMs: 25
}

export function createScheduler(clock: RenderClock, options: Partial<SchedulerOptions> = {}): Scheduler {
  const cfg: SchedulerOptions = { ...DEFAULT_OPTIONS, ...options }

  let timerId: ReturnType<typeof setInterval> | null = null
  let wasRunningOnHide = false
  let queue: ScheduledItem[] = []

  const flush = (): void => {
    const now = clock.audioTime()
    const horizon = now + cfg.lookaheadSec

    queue.sort((a, b) => a.at - b.at)

    const due: ScheduledItem[] = []
    const pending: ScheduledItem[] = []

    for (const item of queue) {
      if (item.at <= horizon) {
        due.push(item)
      } else {
        pending.push(item)
      }
    }

    queue = pending

    for (const item of due) {
      item.fn(item.at)
    }
  }

  const startTimer = (): void => {
    if (clock.isOffline) {
      return
    }
    if (timerId) {
      return
    }
    timerId = setInterval(flush, cfg.intervalMs)
  }

  const stopTimer = (): void => {
    if (!timerId) {
      return
    }
    clearInterval(timerId)
    timerId = null
  }

  if (typeof window !== 'undefined') {
    const handlePageHide = () => {
      if (timerId) {
        wasRunningOnHide = true
        stopTimer()
      } else {
        wasRunningOnHide = false
      }
    }

    const handlePageShow = () => {
      if (wasRunningOnHide) {
        startTimer()
        flush()
      }
    }

    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)
  }

  return {
    start(): void {
      startTimer()
    },

    stop(): void {
      stopTimer()
    },

    schedule(atTimeSec: number, fn: ScheduledFn): void {
      queue.push({ at: atTimeSec, fn })
    },

    clear(): void {
      queue = []
    }
  }
}



=========================================
File: domain/midiMapping.ts
=========================================

import type { MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

const defaultPads: DrumPadId[] = [
  'pad1',
  'pad2',
  'pad3',
  'pad4',
  'pad5',
  'pad6',
  'pad7',
  'pad8',
  'pad9',
  'pad10',
  'pad11',
  'pad12',
  'pad13',
  'pad14',
  'pad15',
  'pad16'
]

export function defaultMidiMapping(): MidiMapping {
  const noteMap: Partial<Record<number, DrumPadId>> = {}
  const noteMapInverse: Partial<Record<DrumPadId, number>> = {}
  defaultPads.forEach((padId, index) => {
    const note = 36 + index
    noteMap[note] = padId
    noteMapInverse[padId] = note
  })
  return { noteMap, noteMapInverse, transportMap: {} }
}



=========================================
File: domain/quantize.ts
=========================================

import type { StepAddress } from '@/types/time'

export function quantizeToStep(time: number, secondsPerStep: number, bars: number, division: number): StepAddress {
  const totalSteps = bars * division
  const stepIndex = Math.max(0, Math.min(totalSteps - 1, Math.round(time / secondsPerStep)))
  return {
    barIndex: Math.floor(stepIndex / division),
    stepInBar: stepIndex % division
  }
}



=========================================
File: domain/timing.ts
=========================================

import type { GridSpec, TimeDivision } from '@/types/time'

export const GRID_DIVISIONS: readonly TimeDivision[] = [1, 2, 4, 8, 16, 32, 64] as const
export const DEFAULT_GRID_SPEC: GridSpec = { bars: 1, division: 16 }

export function secondsPerStep(bpm: number, division: number): number {
  return (60 / bpm) * (4 / division)
}

export function stepsPerBar(gridSpec: GridSpec): number {
  return gridSpec.division
}

export function normalizeGridSpec(gridSpec?: Partial<GridSpec>): GridSpec {
  const division = GRID_DIVISIONS.includes((gridSpec?.division ?? DEFAULT_GRID_SPEC.division) as TimeDivision)
    ? (gridSpec?.division as TimeDivision)
    : DEFAULT_GRID_SPEC.division
  const bars: GridSpec['bars'] =
    gridSpec?.bars === 1 || gridSpec?.bars === 2 || gridSpec?.bars === 4 || gridSpec?.bars === 8
      ? gridSpec.bars
      : DEFAULT_GRID_SPEC.bars

  return { bars, division }
}



=========================================
File: domain/transport/audioHooks.ts
=========================================

export interface TransportAudioHooks {
  onStep(stepIndex: number, audioTime: number): void
}



=========================================
File: domain/transport/transportEngine.ts
=========================================

import type { RenderClock } from '../clock/renderClock'
import type { Scheduler } from '../clock/scheduler'
import type { TransportConfig, TransportState } from './types'
import type { TransportAudioHooks } from './audioHooks'
export type TransportListener = (state: TransportState) => void

// Transport engine that schedules step boundaries against the audio clock, emitting normalized transport state.
export interface TransportEngine {
  start(): void
  stop(): void
  setConfig(next: TransportConfig): void
  subscribe(listener: TransportListener): () => void
  tick(): void
}

const clampInt = (value: number): number => {
  if (!Number.isFinite(value)) {
    return 0
  }
  return Math.floor(value)
}



export function createTransportEngine(
  clock: RenderClock,
  scheduler: Scheduler,
  initial: TransportConfig,
  audioHooks?: TransportAudioHooks
  ): TransportEngine {
    let cfg: TransportConfig = initial

    let isPlaying = false
    let startTimeSec = 0
    let lastStep = -1
    let lastAbsoluteStep = -1

    const listeners = new Set<TransportListener>()
    const stepDurationSec = (): number => {
    const stepsPerBar = Math.max(1, cfg.gridSpec.division)
    const beatsPerBar = 4
    const beatsPerStep = beatsPerBar / stepsPerBar
    const secPerBeat = 60 / Math.max(1, cfg.bpm)
    return beatsPerStep * secPerBeat
    }
  
    const totalSteps = (): number => {
      const steps = cfg.gridSpec.bars * cfg.gridSpec.division
      return Math.max(0, clampInt(steps))
    }

    const normalizeStep = (step: number): number => {
      const steps = Math.max(totalSteps(), 1)
      return ((step % steps) + steps) % steps
    }

    const swingOffsetSec = (stepIndex: number): number => {
    const swing = cfg.swing ?? 0
    if (swing <= 0) {
      return 0
    }

    const isOffBeat = stepIndex % 2 === 1
    if (!isOffBeat) {
      return 0
    }

    return stepDurationSec() * swing * 0.5
  }

  const emit = (): void => {
    const steps = Math.max(totalSteps(), 1)
    const normalized = ((lastStep % steps) + steps) % steps

    const state: TransportState = {
      isPlaying,
      currentStep: normalized
    }

    for (const listener of listeners) {
      listener(state)
      }
    }
    
    const computeAbsoluteStepAt = (timeSec: number): number => {
      const dur = stepDurationSec()
      const raw = (timeSec - startTimeSec) / dur
      return clampInt(raw)
    }

    let lastScheduledStep = -1

    const scheduleStepBoundary = (stepIndexAbsolute: number): void => {
      if (stepIndexAbsolute === lastScheduledStep) {
        return
      }

      const normalizedStep = normalizeStep(stepIndexAbsolute)
      lastScheduledStep = stepIndexAbsolute

      const stepTimeSec =
        startTimeSec +
        stepIndexAbsolute * stepDurationSec() +
        swingOffsetSec(normalizedStep)

      scheduler.schedule(stepTimeSec, (audioTime) => {
        audioHooks?.onStep(normalizedStep, audioTime)
      })
    }


    const advance = (): void => {
      const now = clock.audioTime()
      const currentAbsolute = computeAbsoluteStepAt(now)
      const current = normalizeStep(currentAbsolute)

      if (current !== lastStep) {
        lastStep = current
        lastAbsoluteStep = currentAbsolute
        scheduleStepBoundary(lastAbsoluteStep + 1)
        emit()
      }
    }

  return {
    start(): void {
      if (isPlaying) {
        return
      }
      isPlaying = true
      startTimeSec = clock.audioTime()
      lastStep = -1
      lastAbsoluteStep = -1
      lastScheduledStep = -1
      scheduler.clear()
      scheduler.start()
      lastAbsoluteStep = computeAbsoluteStepAt(startTimeSec)
      lastStep = normalizeStep(lastAbsoluteStep)
      emit()
      scheduleStepBoundary(lastAbsoluteStep + 1)
    },

    stop(): void {
      if (!isPlaying) {
        return
      }
      isPlaying = false
      scheduler.stop()
      scheduler.clear()
      lastStep = -1
      lastScheduledStep = -1
      emit()
    },

    setConfig(next: TransportConfig): void {
      cfg = next
      if (isPlaying) {
        const now = clock.audioTime()
        const dur = stepDurationSec()
        const steps = Math.max(totalSteps(), 1)
        const current = ((lastStep % steps) + steps) % steps
        startTimeSec = now - lastAbsoluteStep * dur - swingOffsetSec(current)
        scheduler.clear()
        lastScheduledStep = -1
        lastAbsoluteStep = computeAbsoluteStepAt(now)
        lastStep = normalizeStep(lastAbsoluteStep)
        scheduleStepBoundary(lastAbsoluteStep + 1)
      } else {
        lastScheduledStep = -1
      }
      emit()
    },

    subscribe(listener: TransportListener): () => void {
      listeners.add(listener)
      listener({
        isPlaying,
        currentStep: Math.max(0, lastStep)
      })
      return (): void => {
        listeners.delete(listener)
      }
    },

    tick(): void {
      if (!isPlaying) {
        return
      }
      advance()
    }
  }
}



=========================================
File: domain/transport/types.ts
=========================================

import type { DrumPadId } from '@/types/drums'
import type { GridSpec } from '@/types/time'

// Shared transport domain types for playback and grid configuration.

export interface TransportState {
  readonly isPlaying: boolean
  readonly currentStep: number
}

export type StepTogglePayload = {
  barIndex: number
  stepInBar: number
  padId: DrumPadId
}

export interface TransportConfig {
  readonly bpm: number
  readonly gridSpec: GridSpec
  swing?: number
}



=========================================
File: domain/validators.ts
=========================================

import { GRID_DIVISIONS } from './timing'
import type { GridSpec } from '../types/time'

export function isValidGridSpec(gridSpec: GridSpec): boolean {
  return gridSpec.bars >= 1 && gridSpec.bars <= 8 && GRID_DIVISIONS.includes(gridSpec.division)
}



=========================================
File: domain/velocity/velocityToGain.ts
=========================================

// Converts a normalized velocity value to a gain multiplier using a simple curve.
export function velocityToGain(
  velocity: number,
  minGain = 0.15
): number {
  const v = Math.max(0, Math.min(1, velocity))

  const curved = v * v

  return minGain + (1 - minGain) * curved
}



=========================================
File: domain/velocity.ts
=========================================

export const STEP_VELOCITY_LEVELS = [0.7, 1, 1.25] as const
export const DEFAULT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[0]
export const ACCENT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[STEP_VELOCITY_LEVELS.length - 1]!

const EPSILON = 0.001

const matchesLevel = (value: number, level: number) => Math.abs(value - level) < EPSILON

export function clampVelocity(value?: number): number {
  const resolved = typeof value === 'number' ? value : DEFAULT_STEP_VELOCITY
  const clamped = Math.max(STEP_VELOCITY_LEVELS[0], Math.min(ACCENT_STEP_VELOCITY, resolved))
  const closest = STEP_VELOCITY_LEVELS.find((level) => matchesLevel(clamped, level))
  return closest ?? clamped
}

export function cycleVelocity(current?: number): number | null {
  if (typeof current !== 'number') {
    return DEFAULT_STEP_VELOCITY
  }
  const index = STEP_VELOCITY_LEVELS.findIndex((level) => matchesLevel(current, level))
  if (index === -1) {
    return DEFAULT_STEP_VELOCITY
  }
  const nextIndex = index + 1
  if (nextIndex >= STEP_VELOCITY_LEVELS.length) {
    return null
  }
  const nextValue = STEP_VELOCITY_LEVELS[nextIndex]
  if (typeof nextValue !== 'number') {
    return null
  }
  return nextValue
}

export function velocityToIntensity(value?: number): number {
  if (!value) return 0
  return Math.min(1, value / ACCENT_STEP_VELOCITY)
}



=========================================
File: eslint.config.cjs
=========================================

const { FlatCompat } = require('@eslint/eslintrc')
const js = require('@eslint/js')

const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all
})

module.exports = [
  ...compat.config(require('./.eslintrc.cjs')),
  {
    ignores: ['eslint.config.cjs', '.eslintrc.cjs']
  }
]



=========================================
File: eslint.config.js
=========================================

import js from '@eslint/js'
import tseslint from '@typescript-eslint/eslint-plugin'
import tsParser from '@typescript-eslint/parser'
import vue from 'eslint-plugin-vue'
import vueParser from 'vue-eslint-parser'
import globals from 'globals'

export default [{
    ignores: ['node_modules', '.nuxt', '.output', 'dist', 'coverage']
  },
  {
    files: ['**/*.{ts,tsx,js,jsx,vue}'],
    languageOptions: {
      parser: vueParser,
      parserOptions: {
        parser: tsParser,
        ecmaVersion: 'latest',
        sourceType: 'module',
        extraFileExtensions: ['.vue']
      },
      globals: {
        ...globals.browser,
        ...globals.es2021,
        ...globals.node,
        defineNuxtPlugin: 'readonly'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      vue
    },
    rules: {
      ...js.configs.recommended.rules,
      ...tseslint.configs.recommended.rules,
      ...vue.configs['vue3-recommended'].rules,
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-empty-object-type': 'off'
    },
  },

  // ğŸ”¹ âœ… Tests (Mocha)
  {
    files: ['**/*.spec.ts', '**/*.d.ts'],
    languageOptions: {
      globals: {
        ...globals.mocha
      }
    }
  }
]


=========================================
File: functionsList.json
=========================================

{
  "missing_functions": [
    "Play/Stop Toggle (Transport)",
    "Stop + Reset Playhead (Transport)",
    "Record Toggle und Count-In (Transport)",
    "Pattern Preset Mode (Pattern-LÃ¤nge vor Aufnahme)",
    "Restart Loop Range (Transport)",
    "Loop On/Off und Loop-Range-Verschiebung/Endpunkt-Anpassung",
    "Tap Tempo (Transport)",
    "Metronom Toggle",
    "Follow Toggle (Display folgt Playhead)",
    "Grid Mode (Perform/Arrange/Step/Nudge Grid)",
    "Live-Erase (Events wÃ¤hrend Playback lÃ¶schen)",
    "Erase All Events for Pad (Shortcut)",
    "Erase Automation for Parameter",
    "Remove Sound/Group Slot (Reset)",
    "Channel Properties (Control Mode)",
    "MIDI Mode Umschaltung (SHIFT + CHANNEL)",
    "Pad/Group-LED-Feedback (Farben, Choke, Create)",
    "Soft Button/Knob Kontextsteuerung (Overlays, Selector-Listen)",
    "Mode-Pinning und Shift-Layer-Handling (UI/Logik)",
    "Undo/Redo-Logik fÃ¼r Pattern/Scene-Edits (History)"
  ],
  "hardware_functions": [
    "Pad Input: Note On/Off, Velocity, Aftertouch, RGB-Feedback je nach Modus (Mute/Solo/Pattern/Slot)",
    "Pad Mode: Umschalten zwischen SCENE, PATTERN, PAD MODE, KEYBOARD, CHORD, STEP, ARRANGE, DUPLICATE",
    "Group Select: 2x4 Buttons, Farbkodiert, Create-Button (dim white)",
    "Transport: RESTART, ERASE, TAP, FOLLOW, PLAY, REC, STOP, SHIFT, mit Status-Feedback",
    "Performance: Note Repeat, Lock, Strip Mode, Smart Strip (Touch/Slide, LED-Bar, Strip Mode)",
    "Edit Zone: 4D-Encoder (tilt, push, turn), Quick Edit (VOLUME, SWING, TEMPO)",
    "Screen Buttons: Soft Buttons 1â€“8, kontextabhÃ¤ngige Funktion",
    "Screen Knobs: 8 Touch-Knobs, Touch blendet Werteliste ein, Push fÃ¼r Reset",
    "Displays: 2x, dynamische Overlays, Kontext-Feedback, Selector-Listen",
    "Control Zone: CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, PATTERN, SCENE, PAD MODE, EVENTS, VARIATION, DUPLICATE",
    "Pad Input Mode: FIXED VEL, PAD MODE, KEYBOARD, CHORD, STEP",
    "Global: Shift-Layer, Mode-Pinning, Undo/Redo, Kontext-Feedback, LED-Feedback, Overlay-Icons"
  ],
  "interaction_models": [
    "press: Kurzer Tastendruck (z.B. Pad, Button)",
    "press_twice: Doppelklick (z.B. Stop)",
    "hold: GedrÃ¼ckt halten (Momentary)",
    "hold_combo: GedrÃ¼ckt halten + weiteres Element",
    "shift_combo: SHIFT + Element",
    "turn: Drehen (Knob, Encoder)",
    "touch: BerÃ¼hren (Touch-Knob, Strip)",
    "slide: Fingerbewegung Ã¼ber Touch-Strip",
    "push_turn: Encoder drÃ¼cken + drehen",
    "tilt: 4D-Encoder Richtung",
    "confirm: Auswahl bestÃ¤tigen (Encoder drÃ¼cken)"
  ],
  "feedback_mechanisms": [
    "Pad RGB: Status je nach Modus (Mute/Solo/Pattern/Slot)",
    "Button LED: off/dim/bright/pinned",
    "Group Button: Farbkodiert, dim white fÃ¼r Create",
    "Soft Button/Knob: Overlay/Label im Display",
    "Selector-Listen: Overlay bei Touch auf Knob",
    "Touch Strip: LED-Bar, haptisches Feedback",
    "4D-Encoder: LED-Ring fÃ¼r Richtungen, Push-Feedback"
  ],
  "roadmap": [
    "1. Transport- und Playback-Funktionen vollstÃ¤ndig implementieren",
    "2. Pattern/Scene-Chain- und Preset-Mode-Logik entwickeln",
    "3. Loop- und Grid-Handling (inkl. Endpunkt/Range) umsetzen",
    "4. Erase- und Automation-Funktionen ergÃ¤nzen",
    "5. Channel-Properties- und MIDI-Mode-Logik bereitstellen",
    "6. Pad/Group-LED-Feedback und Soft-Button/Knob-Kontextsteuerung integrieren",
    "7. Mode-Pinning, Shift-Layer-Handling und Undo/Redo-Logik finalisieren"
  ]
}


=========================================
File: implementationPlan.json
=========================================

{
  "phases": [
    {
      "id": 1,
      "title": "Analyse & Planung",
      "description": "Analyse aller json-Dateien (uiList, functionsList, nimamk3) und Abgleich mit der aktuellen Codebasis. Identifikation aller fehlenden UI-Elemente, Funktionen und Hardware-Workflows. Erstellung einer vollstÃ¤ndigen Feature- und Task-Liste.",
      "criteria": [
        "Alle Anforderungen und LÃ¼cken sind dokumentiert",
        "Abgleich mit Hardware-Workflows und Interaktionsmodellen"
      ]
    },
    {
      "id": 2,
      "title": "Architektur & Clean Code Setup",
      "description": "Definition und Dokumentation der Architektur, Clean Code-Prinzipien, Performance-Standards und Nuxt 4-spezifischen Patterns (Options API, Pug, Less). ErgÃ¤nzung/Anpassung der Diagramme im diagrams-Ordner.",
      "criteria": [
        "README.md enthÃ¤lt Architektur- und Clean Code-Richtlinien",
        "Diagramme sind aktuell und vollstÃ¤ndig"
      ]
    },
    {
      "id": 3,
      "title": "UI/UX & Interaktions-Implementierung",
      "description": "Schrittweise Implementierung aller fehlenden UI-Elemente und Interaktionsmodelle gemÃ¤ÃŸ uiList.json und Hardware-Workflows. Fokus auf Performance, Accessibility und Options API. Jede Komponente erhÃ¤lt Pug/Less-Templates und ist in Nuxt 4 eingebunden.",
      "criteria": [
        "Alle UI-Elemente und Panels sind funktionsfÃ¤hig",
        "Accessibility und Fokussteuerung umgesetzt"
      ]
    },
    {
      "id": 4,
      "title": "Funktionale Logik & Audio/MIDI",
      "description": "Implementierung aller fehlenden Funktionen aus functionsList.json und nimamk3.json (Transport, Pattern, Erase, Undo/Redo, MIDI, LED-Feedback etc.). Performance-Optimierung und deterministische Exporte. Erweiterung/Anpassung der Stores und Composables.",
      "criteria": [
        "Alle Funktionen sind testbar und performant",
        "Audio/MIDI-Engine vollstÃ¤ndig integriert"
      ]
    },
    {
      "id": 5,
      "title": "Testing, QA & Use Cases",
      "description": "Komponententests, Unittests und End-to-End-Tests fÃ¼r alle neuen Features. ErgÃ¤nzung der README.md um alle relevanten Use Cases. Testabdeckung und Performance werden dokumentiert.",
      "criteria": [
        "Tests fÃ¼r alle neuen Features vorhanden",
        "README.md enthÃ¤lt alle Use Cases"
      ]
    },
    {
      "id": 6,
      "title": "Finalisierung & Review",
      "description": "Abschluss aller Tasks im Feature-Branch. Review mit Repository-Inhaber vor Merge. Kein Merge ohne explizite Freigabe. Abschlussdokumentation und Ãœbergabe.",
      "criteria": [
        "Alle Phasen abgeschlossen und dokumentiert",
        "Review und Freigabe durch Inhaber"
      ]
    }
  ],
  "branching": {
    "feature_branch_only": true,
    "merge_policy": "Kein Merge ohne RÃ¼cksprache mit dem Inhaber des Repositories."
  },
  "documentation": {
    "readme": "Jede Phase und alle neuen Use Cases werden in der README.md dokumentiert.",
    "diagrams": "Alle relevanten Diagramme im diagrams-Ordner werden ergÃ¤nzt/aktualisiert."
  },
  "tech_stack": {
    "framework": "Nuxt 4",
    "ui": "Vue 3 Options API, Pug, Less, Vuetify 3",
    "audio": "Web Audio API, Web MIDI API",
    "persistence": "IndexedDB, LocalStorage",
    "testing": "Vitest, Vue Test Utils"
  },
  "quality": {
    "performance": "Alle Komponenten und Funktionen werden auf Performance optimiert.",
    "clean_code": "Strikte Einhaltung von Clean Code und Architekturprinzipien."
  }
}


=========================================
File: layouts/default.vue
=========================================

<template>
  <v-app>
    <NuxtPage />
  </v-app>
</template>

<script lang="ts">
export default {
  // Provides the root Vuetify app shell for all pages.
}
</script>



=========================================
File: nimamk3.json
=========================================

{
  "schema_version": "1.0",
  "device": {
    "manufacturer": "Native Instruments",
    "model": "MASCHINE MK3",
    "scope_note": "Bericht fokussiert auf Hardware-Funktionen und deren Bedienwege. Integrierte Softwareinstrumente werden nicht als Inhalte/Presets beschrieben, Plug-in-/Channel-Navigation als Hardware-Workflow aber schon.",
    "source_documents": [
      {
        "title": "NI Tech Manuals â€“ Maschine MK3 Manual â€“ Quick reference (HTML)",
        "type": "official_html",
        "url": "https://www.native-instruments.com/ni-tech-manuals/maschine-mk3-manual/en/quick-reference"
      },
      {
        "title": "NI Tech Manuals â€“ Maschine MK3 Manual â€“ Basic concepts (HTML)",
        "type": "official_html",
        "url": "https://www.native-instruments.com/ni-tech-manuals/maschine-mk3-manual/en/basic-concepts"
      },
      {
        "title": "NI Tech Manuals â€“ Maschine Accessibility â€“ Maschine Hardware Layout (HTML)",
        "type": "official_html",
        "url": "https://www.native-instruments.com/ni-tech-manuals/maschine-accessibility/en/maschine-hardware-layout"
      },
      {
        "title": "MASCHINE MK3 Getting Started (PDF)",
        "type": "official_pdf",
        "url": "https://www.native-instruments.com/fileadmin/ni_media/downloads/manuals/maschine_276/MASCHINE_MK3_2.7.6_0518_Getting_Started_English.pdf"
      }
    ]
  },
  "reports": {
    "functions_report": {
      "report_id": "mk3_functions_v1",
      "interaction_primitives": {
        "press": "Kurzer Tastendruck",
        "press_twice": "Zweimal drÃ¼cken (Toggle/Stop)",
        "hold": "GedrÃ¼ckt halten (Momentary Mode / Aktion solange gehalten)",
        "hold_combo": "GedrÃ¼ckt halten + weiteres Element betÃ¤tigen",
        "shift_combo": "SHIFT gedrÃ¼ckt halten + Element betÃ¤tigen",
        "turn": "Drehen (Endlos/Rotary)",
        "touch": "BerÃ¼hren (Touch-Erkennung, ohne Drehen)",
        "slide": "Fingerbewegung Ã¼ber Touch-Strip",
        "push_turn": "Encoder drÃ¼cken (Push) + drehen",
        "tilt": "4D-Encoder Richtung (up/down/left/right)",
        "confirm": "Auswahl bestÃ¤tigen (Encoder drÃ¼cken)"
      },
      "global_behaviors": [
        {
          "behavior": "Shift-layer",
          "description": "Viele Hardware-Controls haben eine Zweitfunktion mit gedrÃ¼cktem SHIFT. Shift-Labels sind teilweise auf dem GerÃ¤t bzw. in Doku als [Function] angegeben.",
          "primary_control_id": "btn_shift"
        },
        {
          "behavior": "Mode pinning",
          "description": "Mehrere Modus-Tasten (z. B. MUTE/SOLO/SELECT/DUPLICATE/VARIATION/EVENTS/PATTERN/SCENE) sind standardmÃ¤ÃŸig 'momentary' (halten) und kÃ¶nnen per Mode-Button + Soft Button 1 'gepinnt' werden (bleibt aktiv).",
          "controls_involved": [
            "soft_btn_1",
            "btn_mode_mute",
            "btn_mode_solo",
            "btn_mode_select",
            "btn_mode_duplicate",
            "btn_mode_variation",
            "btn_mode_events",
            "btn_mode_pattern",
            "btn_mode_scene"
          ]
        },
        {
          "behavior": "Soft Buttons & Screen Knobs are contextual",
          "description": "Soft Buttons 1â€“8 (Ã¼ber den Displays) und Knobs 1â€“8 (unter den Displays) Ã¤ndern ihre Funktion kontextabhÃ¤ngig; Beschriftungen erscheinen im Display.",
          "controls_involved": [
            "soft_btn_1",
            "soft_btn_2",
            "soft_btn_3",
            "soft_btn_4",
            "soft_btn_5",
            "soft_btn_6",
            "soft_btn_7",
            "soft_btn_8",
            "knob_1",
            "knob_2",
            "knob_3",
            "knob_4",
            "knob_5",
            "knob_6",
            "knob_7",
            "knob_8"
          ]
        },
        {
          "behavior": "4D encoder navigation model",
          "description": "4D-Encoder: Displays navigieren per Richtungsbewegung; Listen browsen per Drehen; Parameterwert Ã¤ndern per Drehen; Auswahl bestÃ¤tigen per Druck. LEDs um den Encoder zeigen mÃ¶gliche Richtungen.",
          "controls_involved": [
            "enc_4d"
          ]
        },
        {
          "behavior": "Selector list overlay on touch",
          "description": "Bei Parametern mit Selector-Liste: BerÃ¼hren des zugehÃ¶rigen Knobs blendet eine Werteliste im Display ein; Liste bleibt solange sichtbar wie berÃ¼hrt/gedreht (verschwindet nach kurzer VerzÃ¶gerung). Nur eine Liste gleichzeitig.",
          "controls_involved": [
            "knob_1",
            "knob_2",
            "knob_3",
            "knob_4",
            "knob_5",
            "knob_6",
            "knob_7",
            "knob_8"
          ]
        }
      ],
      "functions": [
        {
          "function_id": "transport_play_stop_toggle",
          "name": "Play / Stop Toggle",
          "category": "Transport",
          "description": "Startet die Wiedergabe; erneutes DrÃ¼cken stoppt.",
          "available_via": [
            {
              "control_id": "btn_play",
              "gesture": "press"
            },
            {
              "control_id": "btn_play",
              "gesture": "press_twice",
              "effect": "stop"
            }
          ],
          "feedback": [
            "btn_play_led",
            "display_transport_state"
          ]
        },
        {
          "function_id": "transport_stop_reset",
          "name": "Stop + Reset Playhead",
          "category": "Transport",
          "description": "Stoppt; wenn bereits gestoppt, setzt die Abspielposition auf Anfang.",
          "available_via": [
            {
              "control_id": "btn_stop",
              "gesture": "press"
            }
          ],
          "feedback": [
            "btn_stop_led",
            "display_transport_state"
          ]
        },
        {
          "function_id": "transport_record",
          "name": "Record Toggle",
          "category": "Transport",
          "description": "WÃ¤hrend Playback: Aufnahme starten/stoppen.",
          "available_via": [
            {
              "control_id": "btn_rec",
              "gesture": "press"
            }
          ],
          "feedback": [
            "btn_rec_led",
            "display_record_state"
          ]
        },
        {
          "function_id": "transport_count_in_record",
          "name": "Count-In Recording",
          "category": "Transport",
          "description": "Aufnahme mit Count-In starten (bei gestoppter Wiedergabe).",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_rec",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_record_state",
            "metronome_if_enabled"
          ]
        },
        {
          "function_id": "transport_pattern_preset_mode",
          "name": "Pattern Preset Mode (LÃ¤nge vor Aufnahme wÃ¤hlen)",
          "category": "Transport",
          "description": "REC halten Ã¶ffnet Pattern Preset Mode zur Wahl der Pattern-LÃ¤nge bevor neue Patterns aufgenommen werden.",
          "available_via": [
            {
              "control_id": "btn_rec",
              "gesture": "hold"
            }
          ],
          "feedback": [
            "display_pattern_preset_ui"
          ]
        },
        {
          "function_id": "transport_restart_loop",
          "name": "Restart Loop Range",
          "category": "Transport",
          "description": "Springt sofort an den Anfang des aktuellen Loop-Bereichs.",
          "available_via": [
            {
              "control_id": "btn_restart",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_transport_state"
          ]
        },
        {
          "function_id": "transport_loop_toggle",
          "name": "Loop On/Off",
          "category": "Transport",
          "description": "Looping aktivieren/deaktivieren.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_restart",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_loop_state"
          ]
        },
        {
          "function_id": "transport_loop_move_range",
          "name": "Loop Range verschieben",
          "category": "Transport",
          "description": "Gesamten Loop entlang der Timeline verschieben.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_restart",
                  "gesture": "hold"
                },
                {
                  "control_id": "enc_4d",
                  "gesture": "turn",
                  "effect": "move_loop_range"
                }
              ]
            }
          ],
          "feedback": [
            "display_loop_controls_overlay"
          ]
        },
        {
          "function_id": "transport_loop_adjust_endpoint",
          "name": "Loop Endpunkt anpassen (Push+Turn)",
          "category": "Transport",
          "description": "Bei gehaltenem SHIFT+RESTART: 4D-Encoder drÃ¼cken+drehen, um nur den Endpunkt des Loops zu verÃ¤ndern.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_restart",
                  "gesture": "hold"
                },
                {
                  "control_id": "enc_4d",
                  "gesture": "push_turn",
                  "effect": "adjust_loop_end"
                }
              ]
            }
          ],
          "feedback": [
            "display_loop_controls_overlay"
          ]
        },
        {
          "function_id": "tap_tempo",
          "name": "Tap Tempo",
          "category": "Transport",
          "description": "Tempo durch wiederholtes Tippen setzen.",
          "available_via": [
            {
              "control_id": "btn_tap",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_tempo_value"
          ]
        },
        {
          "function_id": "metronome_toggle",
          "name": "Metronom On/Off",
          "category": "Transport",
          "description": "Metronom schnell ein/aus.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_tap",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_metronome_state"
          ]
        },
        {
          "function_id": "follow_toggle",
          "name": "Follow On/Off",
          "category": "Navigation",
          "description": "Time-related Displays folgen dem Playhead (z. B. Pattern Editor).",
          "available_via": [
            {
              "control_id": "btn_follow",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_follow_state"
          ]
        },
        {
          "function_id": "grid_mode_open",
          "name": "Grid Mode (Perform/Arrange/Step/Nudge Grid)",
          "category": "Navigation",
          "description": "Ã–ffnet Grid-Mode zur Anpassung verschiedener Grids.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_follow",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_grid_mode_ui"
          ]
        },
        {
          "function_id": "erase_events_live",
          "name": "Erase Events (Live)",
          "category": "Editing",
          "description": "WÃ¤hrend Playback: ERASE halten und Pads/Group Buttons halten, um Events on-the-fly zu lÃ¶schen.",
          "available_via": [
            {
              "control_id": "btn_erase",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_*",
                  "gesture": "hold"
                },
                {
                  "control_id": "btn_group_*",
                  "gesture": "hold"
                }
              ]
            }
          ],
          "feedback": [
            "display_event_changes",
            "pad_state_changes"
          ]
        },
        {
          "function_id": "erase_all_events_for_pad",
          "name": "Erase All Events for Pad (Shortcut)",
          "category": "Editing",
          "description": "ERASE + EVENTS + Pad lÃ¶scht alle von diesem Pad getriggerten Events im Pattern.",
          "available_via": [
            {
              "control_id": "btn_erase",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_mode_events",
                  "gesture": "hold"
                },
                {
                  "control_id": "pad_*",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_event_changes"
          ]
        },
        {
          "function_id": "erase_automation_for_parameter",
          "name": "Erase Automation for Parameter",
          "category": "Automation",
          "description": "ERASE halten und den zugehÃ¶rigen Parameter-Knob drehen, um Automation dieses Parameters zu lÃ¶schen.",
          "available_via": [
            {
              "control_id": "btn_erase",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "knob_*",
                  "gesture": "turn"
                }
              ]
            }
          ],
          "feedback": [
            "display_automation_change"
          ]
        },
        {
          "function_id": "remove_sound_or_group_slot",
          "name": "Remove Sound/Group Slot",
          "category": "Editing",
          "description": "SHIFT + ERASE + Pad/Group entfernt Sound/Group in diesem Slot (Reset).",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_erase",
                  "gesture": "hold"
                },
                {
                  "control_id": "pad_*",
                  "gesture": "press"
                }
              ]
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_erase",
                  "gesture": "hold"
                },
                {
                  "control_id": "btn_group_*",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_slot_cleared",
            "pad_or_group_led_reset"
          ]
        },
        {
          "function_id": "control_channel_properties_mode",
          "name": "Channel Properties (Control Mode)",
          "category": "Control/Views",
          "description": "CHANNEL Ã¶ffnet Control Mode und zeigt Channel Properties des selektierten Sound/Group/Master; Parameter Ã¼ber Soft Buttons und Knobs.",
          "available_via": [
            {
              "control_id": "btn_channel",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_channel_properties",
            "soft_labels_update"
          ]
        },
        {
          "function_id": "control_midi_mode",
          "name": "MIDI Mode",
          "category": "Control/Views",
          "description": "SHIFT + CHANNEL wechselt den Controller in MIDI Mode (als MIDI-Controller nutzbar).",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_channel",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_midi_mode_state"
          ]
        },
        {
          "function_id": "control_plugin_mode",
          "name": "Plug-in Control (Control Mode)",
          "category": "Control/Views",
          "description": "PLUG-IN Ã¶ffnet Control Mode und zeigt Plug-in Slots/Parameter des selektierten Sound/Group/Master; Parameter Ã¼ber Soft Buttons und Knobs.",
          "available_via": [
            {
              "control_id": "btn_plugin",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_plugin_chain",
            "soft_labels_update"
          ]
        },
        {
          "function_id": "control_instance_mode",
          "name": "Instance Mode (Maschine Plug-in Instanz wÃ¤hlen)",
          "category": "Control/Views",
          "description": "SHIFT + PLUG-IN Ã¶ffnet Instance Mode zur Wahl der zu steuernden Maschine-Plug-in-Instanz im Host.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_plugin",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_instance_select_ui"
          ]
        },
        {
          "function_id": "view_arranger",
          "name": "Arranger View",
          "category": "Control/Views",
          "description": "ARRANGER zeigt Projekt-Ãœberblick: Ideas View (Scenes/Patterns) bzw. Song View (Sections/Arrangement).",
          "available_via": [
            {
              "control_id": "btn_arranger",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_arranger_ui"
          ]
        },
        {
          "function_id": "view_mixer",
          "name": "Mixer View",
          "category": "Control/Views",
          "description": "MIXER Ã¶ffnet Mix-Ãœbersicht (Level/Pan etc. fÃ¼r Sounds/Groups).",
          "available_via": [
            {
              "control_id": "btn_mixer",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_mixer_ui"
          ]
        },
        {
          "function_id": "view_browser",
          "name": "Browser View",
          "category": "Control/Views",
          "description": "BROWSER Ã¶ffnet den Browser.",
          "available_via": [
            {
              "control_id": "btn_browser",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_browser_ui"
          ]
        },
        {
          "function_id": "browser_plugin_menu",
          "name": "Plug-in Menu via Browser (Load Plug-in in Slot)",
          "category": "Control/Views",
          "description": "SHIFT + BROWSER Ã¶ffnet Plug-in Menu zum Laden eines Plug-ins in den selektierten Plug-in Slot (ohne Inhalte/Instrumente zu spezifizieren).",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_browser",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_plugin_menu_ui"
          ]
        },
        {
          "function_id": "view_sampling_sample_editor",
          "name": "Sampling / Sample Editor View",
          "category": "Control/Views",
          "description": "SAMPLING Ã¶ffnet Sample Editor / Sampling Workflow.",
          "available_via": [
            {
              "control_id": "btn_sampling",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_sampling_ui"
          ]
        },
        {
          "function_id": "page_left_right",
          "name": "Page Navigation (Parameter Pages)",
          "category": "Control/Views",
          "description": "Parameter in Pages gruppiert; Page Left/Right wÃ¤hlt Pages (kontextabhÃ¤ngig).",
          "available_via": [
            {
              "control_id": "btn_page_left",
              "gesture": "press"
            },
            {
              "control_id": "btn_page_right",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_page_change"
          ]
        },
        {
          "function_id": "file_mode",
          "name": "File Mode (New/Save/Save As/Recent Load etc.)",
          "category": "Project",
          "description": "FILE Ã¶ffnet File Mode fÃ¼r Projektoperationen (Kopie speichern, unter anderem Namen speichern, neu, zuletzt geladene laden usw.).",
          "available_via": [
            {
              "control_id": "btn_file",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_file_mode_ui"
          ]
        },
        {
          "function_id": "quick_save",
          "name": "Quick Save",
          "category": "Project",
          "description": "SHIFT + FILE speichert aktuelle ProjektÃ¤nderungen schnell.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_file",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_save_confirmation"
          ]
        },
        {
          "function_id": "settings_mode",
          "name": "Settings (Preferences Zugriff)",
          "category": "Project",
          "description": "SETTINGS gibt Zugriff auf viele Preferences/Settings der Software.",
          "available_via": [
            {
              "control_id": "btn_settings",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_settings_ui"
          ]
        },
        {
          "function_id": "auto_write_modulation",
          "name": "Auto-write Modulation",
          "category": "Automation",
          "description": "AUTO halten und Knob(s) drehen, um Modulation/Automation fÃ¼r die entsprechenden Parameter zu schreiben.",
          "available_via": [
            {
              "control_id": "btn_auto",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "knob_*",
                  "gesture": "turn"
                }
              ]
            }
          ],
          "feedback": [
            "display_auto_write_state",
            "automation_recorded"
          ]
        },
        {
          "function_id": "auto_pin",
          "name": "Auto Mode pin/unpin",
          "category": "Automation",
          "description": "SHIFT + AUTO pinnt Auto Mode (AUTO bleibt aktiv, ohne gehalten zu werden).",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_auto",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "btn_auto_led_pinned"
          ]
        },
        {
          "function_id": "macro_view",
          "name": "Macro Controls (Channel Macros)",
          "category": "Control/Views",
          "description": "MACRO Ã¶ffnet Channel Macro Controls.",
          "available_via": [
            {
              "control_id": "btn_macro",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_macro_ui"
          ]
        },
        {
          "function_id": "macro_set_define",
          "name": "Define Macros (Set)",
          "category": "Control/Views",
          "description": "SHIFT + MACRO startet Workflow zum Definieren neuer Macros direkt am Controller.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_macro",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_macro_set_ui"
          ]
        },
        {
          "function_id": "edit_4d_navigate_lists_values_confirm",
          "name": "4D Encoder: Navigate / Browse / Adjust / Confirm",
          "category": "Editing/Navigation",
          "description": "Richtung: UI-Navigation; Drehen: Listen browsen oder Werte Ã¤ndern; DrÃ¼cken: Auswahl bestÃ¤tigen.",
          "available_via": [
            {
              "control_id": "enc_4d",
              "gesture": "tilt"
            },
            {
              "control_id": "enc_4d",
              "gesture": "turn"
            },
            {
              "control_id": "enc_4d",
              "gesture": "confirm"
            }
          ],
          "feedback": [
            "encoder_direction_leds",
            "display_focus_change"
          ]
        },
        {
          "function_id": "quick_edit_volume",
          "name": "Quick Edit: Volume (Project/Group/Sound)",
          "category": "Quick Edit",
          "description": "VOLUME aktivieren und 4D drehen: Projekt-Volume; Group halten + drehen: Group-Volume; Pad halten + drehen: Sound-Volume. SHIFT = feinere Schritte.",
          "available_via": [
            {
              "control_id": "btn_qe_volume",
              "gesture": "press"
            },
            {
              "control_id": "enc_4d",
              "gesture": "turn",
              "context": "btn_qe_volume_active"
            },
            {
              "control_id": "btn_group_*",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "enc_4d",
                  "gesture": "turn"
                }
              ],
              "context": "btn_qe_volume_active"
            },
            {
              "control_id": "pad_*",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "enc_4d",
                  "gesture": "turn"
                }
              ],
              "context": "btn_qe_volume_active"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "enc_4d",
                  "gesture": "turn"
                }
              ],
              "effect": "fine_increment"
            }
          ],
          "feedback": [
            "display_volume_value"
          ]
        },
        {
          "function_id": "quick_edit_swing",
          "name": "Quick Edit: Swing (Project/Group/Sound)",
          "category": "Quick Edit",
          "description": "SWING aktivieren und 4D drehen: Project Swing; Group/Pad halten + drehen: individueller Swing; in Step Mode entspricht SWING 'Position'.",
          "available_via": [
            {
              "control_id": "btn_qe_swing",
              "gesture": "press"
            },
            {
              "control_id": "enc_4d",
              "gesture": "turn",
              "context": "btn_qe_swing_active"
            },
            {
              "control_id": "btn_group_*",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "enc_4d",
                  "gesture": "turn"
                }
              ],
              "context": "btn_qe_swing_active"
            },
            {
              "control_id": "pad_*",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "enc_4d",
                  "gesture": "turn"
                }
              ],
              "context": "btn_qe_swing_active"
            }
          ],
          "feedback": [
            "display_swing_value"
          ]
        },
        {
          "function_id": "quick_edit_tempo_tune",
          "name": "Quick Edit: Tempo (Project) / Tune (Group/Sound)",
          "category": "Quick Edit",
          "description": "TEMPO aktivieren und 4D drehen: Project Tempo; Group/Pad halten + drehen: Tune; in Step Mode entspricht TEMPO 'Tune'.",
          "available_via": [
            {
              "control_id": "btn_qe_tempo",
              "gesture": "press"
            },
            {
              "control_id": "enc_4d",
              "gesture": "turn",
              "context": "btn_qe_tempo_active"
            },
            {
              "control_id": "btn_group_*",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "enc_4d",
                  "gesture": "turn"
                }
              ],
              "context": "btn_qe_tempo_active"
            },
            {
              "control_id": "pad_*",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "enc_4d",
                  "gesture": "turn"
                }
              ],
              "context": "btn_qe_tempo_active"
            }
          ],
          "feedback": [
            "display_tempo_or_tune_value"
          ]
        },
        {
          "function_id": "note_repeat",
          "name": "Note Repeat / Arp",
          "category": "Performance",
          "description": "NOTE REPEAT halten: in Group Mode wiederholt ausgewÃ¤hlten Sound im gewÃ¤hlten Rate; Buttons 5â€“8 wÃ¤hlen Raten, Knob 3 Ã¤ndert Rate-Wert. In Keyboard/Chord Mode: Arp Engine. SHIFT+NOTE REPEAT: Shortcut zu Keyboard Mode + Arp.",
          "available_via": [
            {
              "control_id": "btn_note_repeat",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_*",
                  "gesture": "hold"
                }
              ]
            },
            {
              "control_id": "soft_btn_5",
              "gesture": "press",
              "context": "note_repeat_active"
            },
            {
              "control_id": "soft_btn_6",
              "gesture": "press",
              "context": "note_repeat_active"
            },
            {
              "control_id": "soft_btn_7",
              "gesture": "press",
              "context": "note_repeat_active"
            },
            {
              "control_id": "soft_btn_8",
              "gesture": "press",
              "context": "note_repeat_active"
            },
            {
              "control_id": "knob_3",
              "gesture": "turn",
              "context": "note_repeat_active"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_note_repeat",
                  "gesture": "press"
                }
              ],
              "effect": "activate_arp_and_keyboard_mode"
            }
          ],
          "feedback": [
            "display_note_repeat_rates",
            "pad_trigger_feedback"
          ]
        },
        {
          "function_id": "note_repeat_pin",
          "name": "Pin Note Repeat / Arp Mode",
          "category": "Performance",
          "description": "NOTE REPEAT + Soft Button 1 pin/unpin.",
          "available_via": [
            {
              "control_id": "btn_note_repeat",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "soft_btn_1",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "btn_note_repeat_led_pinned"
          ]
        },
        {
          "function_id": "lock_snapshot_basic",
          "name": "Lock Snapshot (Create/Recall)",
          "category": "Performance",
          "description": "LOCK drÃ¼cken: Snapshot aller modulierten Parameter erstellen; nach Ã„nderungen erneut LOCK drÃ¼cken: Snapshot recall.",
          "available_via": [
            {
              "control_id": "btn_lock",
              "gesture": "press"
            }
          ],
          "feedback": [
            "btn_lock_led_dim_lit_state",
            "snapshot_state"
          ]
        },
        {
          "function_id": "lock_extended",
          "name": "Extended Lock Mode (bis zu 64 Snapshots, Pads)",
          "category": "Performance",
          "description": "SHIFT + LOCK Ã¶ffnet Extended Lock: Snapshots Ã¼ber Pads speichern/aufrufen, BÃ¤nke organisieren, Morphing konfigurieren.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_lock",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_ext_lock_ui",
            "pad_bank_feedback"
          ]
        },
        {
          "function_id": "smart_strip_pitch_mod",
          "name": "Smart Strip: Pitch/Mod",
          "category": "Performance",
          "description": "PITCH oder MOD aktivieren: Strip sendet Pitchbend bzw. Modulation an selektierten Sound. REC kann Actions als MIDI Automation aufnehmen.",
          "available_via": [
            {
              "control_id": "btn_strip_pitch",
              "gesture": "press"
            },
            {
              "control_id": "btn_strip_mod",
              "gesture": "press"
            },
            {
              "control_id": "strip_smart",
              "gesture": "slide",
              "context": "pitch_or_mod_enabled"
            },
            {
              "control_id": "btn_rec",
              "gesture": "press",
              "context": "pitch_or_mod_enabled",
              "effect": "record_automation"
            }
          ],
          "feedback": [
            "strip_led_bar",
            "automation_recorded"
          ]
        },
        {
          "function_id": "smart_strip_perform_fx",
          "name": "Smart Strip: Perform FX",
          "category": "Performance",
          "description": "PERFORM aktivieren: Strip steuert Perform FX (Group). SHIFT+PERFORM: FX Select/Load Workflow (ohne Inhalte zu listen).",
          "available_via": [
            {
              "control_id": "btn_strip_perform",
              "gesture": "press"
            },
            {
              "control_id": "strip_smart",
              "gesture": "slide",
              "context": "perform_enabled"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_strip_perform",
                  "gesture": "press"
                }
              ],
              "effect": "fx_select"
            }
          ],
          "feedback": [
            "strip_led_bar",
            "display_perform_fx_ui"
          ]
        },
        {
          "function_id": "smart_strip_notes",
          "name": "Smart Strip: Notes (Strum/Play)",
          "category": "Performance",
          "description": "NOTES aktivieren: Strip spielt Sounds/Notes/Chords abhÃ¤ngig vom Pad Input Mode; optional nur gehaltene Pads werden getriggert; unterstÃ¼tzt Slides und SprÃ¼nge (z. B. mit zwei Fingern).",
          "available_via": [
            {
              "control_id": "btn_strip_notes",
              "gesture": "press"
            },
            {
              "control_id": "strip_smart",
              "gesture": "slide",
              "context": "notes_enabled"
            }
          ],
          "feedback": [
            "strip_led_bar",
            "pad_trigger_feedback"
          ]
        },
        {
          "function_id": "group_select_create",
          "name": "Group Select / Create",
          "category": "Groups",
          "description": "Group Aâ€“H: Auswahl; leere Slots: dim white drÃ¼cken, um neuen Group zu erstellen. SHIFT + Group: andere Group Banks.",
          "available_via": [
            {
              "control_id": "btn_group_*",
              "gesture": "press"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_group_*",
                  "gesture": "press"
                }
              ],
              "effect": "select_group_bank"
            }
          ],
          "feedback": [
            "group_button_color_led",
            "pads_reflect_group_sounds"
          ]
        },
        {
          "function_id": "mode_mute",
          "name": "Mute Mode (Sounds/Groups muten)",
          "category": "Pad Modes (Left Column)",
          "description": "MUTE Mode: Pads/Group Buttons muten/unmuten Sounds/Groups; mutierte werden halb-lit dargestellt.",
          "available_via": [
            {
              "control_id": "btn_mode_mute",
              "gesture": "hold"
            },
            {
              "control_id": "btn_mode_mute",
              "gesture": "press",
              "context": "pinned_if_supported"
            }
          ],
          "feedback": [
            "pad_half_lit_state",
            "group_button_state"
          ]
        },
        {
          "function_id": "mode_solo",
          "name": "Solo Mode (Sounds/Groups solo)",
          "category": "Pad Modes (Left Column)",
          "description": "SOLO Mode: Solo eines Sounds/Groups; andere werden gedimmt.",
          "available_via": [
            {
              "control_id": "btn_mode_solo",
              "gesture": "hold"
            }
          ],
          "feedback": [
            "pad_dim_state",
            "group_button_state"
          ]
        },
        {
          "function_id": "mode_select",
          "name": "Select Mode (Sound/Events selektieren ohne zu triggern)",
          "category": "Pad Modes (Left Column)",
          "description": "SELECT Mode: Auswahl ohne Abspielen; SHIFT+SELECT+Pad selektiert alle Events dieses Pads (oder Pitch in Keyboard).",
          "available_via": [
            {
              "control_id": "btn_mode_select",
              "gesture": "hold"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_mode_select",
                  "gesture": "hold"
                },
                {
                  "control_id": "pad_*",
                  "gesture": "press"
                }
              ],
              "effect": "select_all_events_for_pad"
            }
          ],
          "feedback": [
            "display_selection_state"
          ]
        },
        {
          "function_id": "mode_duplicate",
          "name": "Duplicate Mode",
          "category": "Pad Modes (Left Column)",
          "description": "DUPLICATE Mode: dupliziert Sounds/Patterns/Groups/Scenes. SHIFT+DUPLICATE: Pattern Double Shortcut.",
          "available_via": [
            {
              "control_id": "btn_mode_duplicate",
              "gesture": "hold"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_mode_duplicate",
                  "gesture": "press"
                }
              ],
              "effect": "double_pattern"
            }
          ],
          "feedback": [
            "display_duplicate_ui"
          ]
        },
        {
          "function_id": "mode_variation",
          "name": "Variation Mode (Humanize/Random)",
          "category": "Pad Modes (Left Column)",
          "description": "VARIATION Mode: 'Humanize' und 'Random' Variationen fÃ¼r Patterns.",
          "available_via": [
            {
              "control_id": "btn_mode_variation",
              "gesture": "hold"
            }
          ],
          "feedback": [
            "display_variation_ui"
          ]
        },
        {
          "function_id": "navigate_mode",
          "name": "Navigate Mode (Software Navigation / Page Navigation)",
          "category": "Navigation",
          "description": "SHIFT+VARIATION: Navigate Mode; Submodes: Software Navigation (UI ein-/ausblenden, Zoom/Scroll) und Page Navigation (Channel/Plug-ins/Pages). Umschalten per SHIFT+VARIATION+Soft Button 2 (PAGE NAV).",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_mode_variation",
                  "gesture": "press"
                }
              ]
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_mode_variation",
                  "gesture": "hold"
                },
                {
                  "control_id": "soft_btn_2",
                  "gesture": "press"
                }
              ],
              "effect": "toggle_page_nav_submode"
            }
          ],
          "feedback": [
            "display_navigate_ui",
            "soft_labels_update"
          ]
        },
        {
          "function_id": "navigate_software_ui_controls",
          "name": "Navigate: Software Navigation â€“ UI Elemente umschalten",
          "category": "Navigation",
          "description": "In Navigate/Software Navigation: Buttons (Soft Buttons) togglen Ideas/Song/Mixer/Browser/Control Lane/Follow; Zoom/Scroll via Knobs und Pads (Shortcuts).",
          "available_via": [
            {
              "control_id": "soft_btn_2",
              "gesture": "press",
              "context": "navigate_software",
              "effect": "ideas_view"
            },
            {
              "control_id": "soft_btn_3",
              "gesture": "press",
              "context": "navigate_software",
              "effect": "song_view"
            },
            {
              "control_id": "soft_btn_4",
              "gesture": "press",
              "context": "navigate_software",
              "effect": "mixer_toggle"
            },
            {
              "control_id": "soft_btn_5",
              "gesture": "press",
              "context": "navigate_software",
              "effect": "browser_toggle"
            },
            {
              "control_id": "soft_btn_7",
              "gesture": "press",
              "context": "navigate_software",
              "effect": "control_lane_toggle"
            },
            {
              "control_id": "soft_btn_8",
              "gesture": "press",
              "context": "navigate_software",
              "effect": "follow_toggle"
            },
            {
              "control_id": "knob_1",
              "gesture": "turn",
              "context": "navigate_software_song_view",
              "effect": "timeline_zoom"
            },
            {
              "control_id": "knob_2",
              "gesture": "turn",
              "context": "navigate_software_song_view",
              "effect": "timeline_scroll"
            },
            {
              "control_id": "knob_5",
              "gesture": "turn",
              "context": "navigate_software",
              "effect": "pattern_zoom"
            },
            {
              "control_id": "knob_6",
              "gesture": "turn",
              "context": "navigate_software",
              "effect": "pattern_scroll"
            }
          ],
          "feedback": [
            "display_zoom_scroll_overlays"
          ]
        },
        {
          "function_id": "navigate_page_navigation",
          "name": "Navigate: Page Navigation â€“ Channel/Plug-ins/Pages",
          "category": "Navigation",
          "description": "In Navigate/Page Navigation: Soft Buttons 5/6 wÃ¤hlen Channel Properties oder Plug-in; Soft Buttons 7/8 wÃ¤hlen Page Bank; Pads 1â€“16 wÃ¤hlen Parameter Page; Exit: Soft Button 2 (PAGE NAV) oder Navigate verlassen.",
          "available_via": [
            {
              "control_id": "soft_btn_5",
              "gesture": "press",
              "context": "navigate_page_nav",
              "effect": "select_channel_or_plugin_prev_next"
            },
            {
              "control_id": "soft_btn_6",
              "gesture": "press",
              "context": "navigate_page_nav",
              "effect": "select_channel_or_plugin_prev_next"
            },
            {
              "control_id": "soft_btn_7",
              "gesture": "press",
              "context": "navigate_page_nav",
              "effect": "select_page_bank_prev"
            },
            {
              "control_id": "soft_btn_8",
              "gesture": "press",
              "context": "navigate_page_nav",
              "effect": "select_page_bank_next"
            },
            {
              "control_id": "pad_*",
              "gesture": "press",
              "context": "navigate_page_nav",
              "effect": "select_parameter_page"
            },
            {
              "control_id": "soft_btn_2",
              "gesture": "press",
              "context": "navigate_page_nav",
              "effect": "exit_page_nav"
            }
          ],
          "feedback": [
            "display_page_nav_ui"
          ]
        },
        {
          "function_id": "mode_events",
          "name": "Events Mode",
          "category": "Pad Modes (Left Column)",
          "description": "EVENTS Mode: Events im Pattern selektieren und Position/Pitch/Velocity/Length modifizieren; EVENTS + Pad selektiert alle Events des Pads.",
          "available_via": [
            {
              "control_id": "btn_mode_events",
              "gesture": "hold"
            },
            {
              "control_id": "btn_mode_events",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_*",
                  "gesture": "press"
                }
              ],
              "effect": "select_all_events_for_pad"
            }
          ],
          "feedback": [
            "display_events_edit_ui"
          ]
        },
        {
          "function_id": "mode_pattern",
          "name": "Pattern Mode",
          "category": "Pad Modes (Left Column)",
          "description": "PATTERN Mode: Patterns des selektierten Groups verwalten (erstellen, duplizieren, wechseln).",
          "available_via": [
            {
              "control_id": "btn_mode_pattern",
              "gesture": "hold"
            }
          ],
          "feedback": [
            "display_pattern_ui",
            "pads_show_pattern_slots"
          ]
        },
        {
          "function_id": "mode_scene_section",
          "name": "Scene Mode (Ideas) / Section Mode (Song)",
          "category": "Pad Modes (Left Column)",
          "description": "SCENE Mode in Ideas View: Scenes verwalten und live wechseln; in Song View: Section Mode fÃ¼r Arrangement (Sections erstellen, Scene zuweisen, positionieren, LÃ¤nge). SHIFT+SCENE toggelt Ideas/Song View.",
          "available_via": [
            {
              "control_id": "btn_mode_scene",
              "gesture": "hold"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_mode_scene",
                  "gesture": "press"
                }
              ],
              "effect": "toggle_ideas_song_view"
            }
          ],
          "feedback": [
            "display_scene_or_section_ui",
            "pads_show_scene_slots"
          ]
        },
        {
          "function_id": "pad_input_group_mode",
          "name": "Pad Input: Group (Pad Mode)",
          "category": "Pad Input",
          "description": "PAD MODE: Pads reprÃ¤sentieren 16 Sounds des aktuellen Groups (typisch Drums). Erneut drÃ¼cken: Parameter ausblenden, Mode bleibt aktiv. SHIFT+PAD MODE: Group Mode ohne Display-Parameter.",
          "available_via": [
            {
              "control_id": "btn_pad_mode",
              "gesture": "press"
            },
            {
              "control_id": "btn_pad_mode",
              "gesture": "press_twice",
              "effect": "hide_params_keep_mode"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_pad_mode",
                  "gesture": "press"
                }
              ],
              "effect": "activate_without_display_params"
            }
          ],
          "feedback": [
            "btn_pad_mode_led",
            "display_pad_mode_params_optional"
          ]
        },
        {
          "function_id": "pad_input_keyboard_mode",
          "name": "Pad Input: Keyboard",
          "category": "Pad Input",
          "description": "KEYBOARD: Pads spielen 16 chromatische Pitches fÃ¼r selektierten Sound; Root Note/Scale Engine Ã¼ber Displays/Buttons/Knobs. SHIFT+KEYBOARD: ohne Display-Parameter.",
          "available_via": [
            {
              "control_id": "btn_keyboard",
              "gesture": "press"
            },
            {
              "control_id": "btn_keyboard",
              "gesture": "press_twice",
              "effect": "hide_params_keep_mode"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_keyboard",
                  "gesture": "press"
                }
              ],
              "effect": "activate_without_display_params"
            }
          ],
          "feedback": [
            "btn_keyboard_led",
            "display_keyboard_params_optional"
          ]
        },
        {
          "function_id": "pad_input_chords_mode",
          "name": "Pad Input: Chords",
          "category": "Pad Input",
          "description": "CHORDS: Pads triggern Akkorde statt einzelner Noten; Parameter u. a. Ã¼ber Knobs 3â€“4. SHIFT+CHORDS: ohne Display-Parameter.",
          "available_via": [
            {
              "control_id": "btn_chords",
              "gesture": "press"
            },
            {
              "control_id": "btn_chords",
              "gesture": "press_twice",
              "effect": "hide_params_keep_mode"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_chords",
                  "gesture": "press"
                }
              ],
              "effect": "activate_without_display_params"
            }
          ],
          "feedback": [
            "btn_chords_led",
            "display_chords_params_optional"
          ]
        },
        {
          "function_id": "pad_input_step_mode",
          "name": "Pad Input: Step Sequencer",
          "category": "Pad Input",
          "description": "STEP: Pads reprÃ¤sentieren Steps; laufendes Licht zeigt Sequencer-Position; Pads setzen/entfernen Notes. SHIFT+STEP: ohne Display-Parameter.",
          "available_via": [
            {
              "control_id": "btn_step",
              "gesture": "press"
            },
            {
              "control_id": "btn_step",
              "gesture": "press_twice",
              "effect": "hide_params_keep_mode"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_step",
                  "gesture": "press"
                }
              ],
              "effect": "activate_without_display_params"
            }
          ],
          "feedback": [
            "btn_step_led",
            "pads_step_lighting"
          ]
        },
        {
          "function_id": "fixed_velocity_toggle",
          "name": "Fixed Velocity",
          "category": "Pad Input",
          "description": "FIXED VEL: Pads spielen mit fester Velocity (alle Modes).",
          "available_via": [
            {
              "control_id": "btn_fixed_vel",
              "gesture": "press"
            }
          ],
          "feedback": [
            "display_fixed_vel_state"
          ]
        },
        {
          "function_id": "vel_16_mode",
          "name": "16 Velocities (nur Group Mode)",
          "category": "Pad Input",
          "description": "SHIFT + FIXED VEL: 16 Velocities Mode (Pads = gleiche Note, verschiedene Velocity Werte).",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "btn_fixed_vel",
                  "gesture": "press"
                }
              ]
            }
          ],
          "feedback": [
            "display_16_vel_ui",
            "pads_velocity_values"
          ]
        },
        {
          "function_id": "shift_pad_undo_redo_step",
          "name": "SHIFT + Pads: Undo/Redo & Step Undo/Redo",
          "category": "Shortcuts",
          "description": "SHIFT+Pad1 Undo, SHIFT+Pad2 Redo, SHIFT+Pad3 Step Undo, SHIFT+Pad4 Step Redo.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_01",
                  "gesture": "press"
                }
              ],
              "effect": "undo"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_02",
                  "gesture": "press"
                }
              ],
              "effect": "redo"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_03",
                  "gesture": "press"
                }
              ],
              "effect": "step_undo"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_04",
                  "gesture": "press"
                }
              ],
              "effect": "step_redo"
            }
          ],
          "feedback": [
            "display_undo_redo_state"
          ]
        },
        {
          "function_id": "shift_pad_quantize_nudge_copy_paste_clear_oct_semi",
          "name": "SHIFT + Pads: Quantize/Nudge/Copy/Paste/Clear/Octave/Semitone",
          "category": "Shortcuts",
          "description": "SHIFT+Pad5 Quantize, Pad6 Quantize50%, Pad7 NudgeLeft, Pad8 NudgeRight, Pad9 Clear, Pad10 Clear Auto, Pad11 Copy, Pad12 Paste, Pad13 SemitoneDown, Pad14 SemitoneUp, Pad15 OctaveDown, Pad16 OctaveUp.",
          "available_via": [
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_05",
                  "gesture": "press"
                }
              ],
              "effect": "quantize"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_06",
                  "gesture": "press"
                }
              ],
              "effect": "quantize_50"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_07",
                  "gesture": "press"
                }
              ],
              "effect": "nudge_left"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_08",
                  "gesture": "press"
                }
              ],
              "effect": "nudge_right"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_09",
                  "gesture": "press"
                }
              ],
              "effect": "clear"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_10",
                  "gesture": "press"
                }
              ],
              "effect": "clear_auto"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_11",
                  "gesture": "press"
                }
              ],
              "effect": "copy"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_12",
                  "gesture": "press"
                }
              ],
              "effect": "paste"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_13",
                  "gesture": "press"
                }
              ],
              "effect": "semitone_down"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_14",
                  "gesture": "press"
                }
              ],
              "effect": "semitone_up"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_15",
                  "gesture": "press"
                }
              ],
              "effect": "octave_down"
            },
            {
              "control_id": "btn_shift",
              "gesture": "hold_combo",
              "with": [
                {
                  "control_id": "pad_16",
                  "gesture": "press"
                }
              ],
              "effect": "octave_up"
            }
          ],
          "feedback": [
            "display_shortcut_feedback"
          ]
        },
        {
          "function_id": "hardware_audio_interface_controls",
          "name": "Audio Interface Hardware Controls",
          "category": "Hardware I/O",
          "description": "Rear Panel: Phones Volume, Line Out Volume, Mic In Gain. (Sowie Ein-/AusgÃ¤nge: Phones, Line Out L/R, Mic In, Line In 1/2).",
          "available_via": [
            {
              "control_id": "rear_knob_phones_volume",
              "gesture": "turn"
            },
            {
              "control_id": "rear_knob_main_volume",
              "gesture": "turn"
            },
            {
              "control_id": "rear_knob_mic_gain",
              "gesture": "turn"
            }
          ],
          "feedback": [
            "analog_level_change"
          ]
        },
        {
          "function_id": "hardware_power",
          "name": "Power Button / DC In (optional)",
          "category": "Hardware I/O",
          "description": "Power Button am Rear Panel; DC In optional (USB-B ebenfalls vorhanden).",
          "available_via": [
            {
              "control_id": "rear_btn_power",
              "gesture": "press"
            }
          ],
          "feedback": [
            "device_power_state"
          ]
        }
      ],
      "coverage_notes": [
        {
          "note": "Einige SHIFT-Labels (z. B. [Replace] auf ERASE, [Choke] auf MUTE) sind als Shift-Zweitbelegung dokumentiert; spezifische Detailwirkung kann je nach Kontext/Softwarezustand variieren."
        },
        {
          "note": "Soft Buttons/Knobs sind bewusst als kontextsensitiv modelliert (GUI sollte dynamische Beschriftung/Hinting unterstÃ¼tzen)."
        }
      ]
    },
    "layout_report": {
      "report_id": "mk3_layout_v1",
      "coordinate_system": {
        "type": "normalized_rect",
        "origin": "top_left",
        "x_axis": "left_to_right",
        "y_axis": "top_to_bottom",
        "range": [
          0.0,
          1.0
        ]
      },
      "surfaces": [
        {
          "surface_id": "top_panel",
          "name": "Top Panel",
          "zones": [
            {
              "zone_id": "zone_control_buttons",
              "name": "Control Zone (2 columns Ã— 6 rows)",
              "bbox": [
                0.03,
                0.05,
                0.27,
                0.32
              ],
              "layout": {
                "type": "grid",
                "rows": 6,
                "cols": 2,
                "row_major": true
              },
              "controls": [
                {
                  "id": "btn_channel",
                  "label": "CHANNEL",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "MIDI",
                  "default_mode_behavior": "latching_control_mode"
                },
                {
                  "id": "btn_plugin",
                  "label": "PLUG-IN",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Instance",
                  "default_mode_behavior": "latching_control_mode"
                },
                {
                  "id": "btn_arranger",
                  "label": "ARRANGER",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_mixer",
                  "label": "MIXER",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_browser",
                  "label": "BROWSER",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "+Plug-In (Plug-in menu)"
                },
                {
                  "id": "btn_sampling",
                  "label": "SAMPLING",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_page_left",
                  "label": "PAGE LEFT",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_page_right",
                  "label": "PAGE RIGHT",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_file",
                  "label": "FILE",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Save"
                },
                {
                  "id": "btn_settings",
                  "label": "SETTINGS",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_auto",
                  "label": "AUTO",
                  "type": "button",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Pin/Unpin (Auto)",
                  "default_mode_behavior": "momentary_record_when_held"
                },
                {
                  "id": "btn_macro",
                  "label": "MACRO",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Set"
                }
              ]
            },
            {
              "zone_id": "zone_soft_buttons",
              "name": "Screen Button Zone (Soft Buttons 1â€“8)",
              "bbox": [
                0.29,
                0.05,
                0.97,
                0.12
              ],
              "layout": {
                "type": "row",
                "count": 8,
                "spacing": "even"
              },
              "controls": [
                {
                  "id": "soft_btn_1",
                  "label": "Button 1",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                },
                {
                  "id": "soft_btn_2",
                  "label": "Button 2",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                },
                {
                  "id": "soft_btn_3",
                  "label": "Button 3",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                },
                {
                  "id": "soft_btn_4",
                  "label": "Button 4",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                },
                {
                  "id": "soft_btn_5",
                  "label": "Button 5",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                },
                {
                  "id": "soft_btn_6",
                  "label": "Button 6",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                },
                {
                  "id": "soft_btn_7",
                  "label": "Button 7",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                },
                {
                  "id": "soft_btn_8",
                  "label": "Button 8",
                  "type": "button_soft",
                  "interaction": [
                    "press"
                  ],
                  "dynamic": true
                }
              ]
            },
            {
              "zone_id": "zone_displays",
              "name": "Displays (2x)",
              "bbox": [
                0.29,
                0.12,
                0.97,
                0.28
              ],
              "layout": {
                "type": "split",
                "parts": [
                  "left_display",
                  "right_display"
                ],
                "ratio": [
                  0.5,
                  0.5
                ]
              },
              "controls": [
                {
                  "id": "display_left",
                  "label": "Left Display",
                  "type": "display",
                  "interaction": []
                },
                {
                  "id": "display_right",
                  "label": "Right Display",
                  "type": "display",
                  "interaction": []
                }
              ]
            },
            {
              "zone_id": "zone_screen_knobs",
              "name": "Screen Knob Zone (Knobs 1â€“8, touch-sensitive)",
              "bbox": [
                0.29,
                0.28,
                0.97,
                0.37
              ],
              "layout": {
                "type": "row",
                "count": 8,
                "spacing": "even"
              },
              "controls": [
                {
                  "id": "knob_1",
                  "label": "Knob 1",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                },
                {
                  "id": "knob_2",
                  "label": "Knob 2",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                },
                {
                  "id": "knob_3",
                  "label": "Knob 3",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                },
                {
                  "id": "knob_4",
                  "label": "Knob 4",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                },
                {
                  "id": "knob_5",
                  "label": "Knob 5",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                },
                {
                  "id": "knob_6",
                  "label": "Knob 6",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                },
                {
                  "id": "knob_7",
                  "label": "Knob 7",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                },
                {
                  "id": "knob_8",
                  "label": "Knob 8",
                  "type": "rotary_knob_touch",
                  "interaction": [
                    "turn",
                    "touch"
                  ],
                  "dynamic": true
                }
              ],
              "ui_hinting": {
                "selector_list_overlay_on_touch": true,
                "zoom_scroll_overlay_icons_on_touch_knobs_5_8": true
              }
            },
            {
              "zone_id": "zone_pad_input_modes",
              "name": "Pad Input Mode Zone (5 buttons)",
              "bbox": [
                0.29,
                0.37,
                0.97,
                0.42
              ],
              "layout": {
                "type": "row",
                "count": 5,
                "spacing": "even"
              },
              "controls": [
                {
                  "id": "btn_fixed_vel",
                  "label": "FIXED VEL",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "16 Velocities"
                },
                {
                  "id": "btn_pad_mode",
                  "label": "PAD MODE",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Activate w/o params"
                },
                {
                  "id": "btn_keyboard",
                  "label": "KEYBOARD",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Activate w/o params"
                },
                {
                  "id": "btn_chords",
                  "label": "CHORDS",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Activate w/o params"
                },
                {
                  "id": "btn_step",
                  "label": "STEP",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Activate w/o params"
                }
              ]
            },
            {
              "zone_id": "zone_edit",
              "name": "Edit Zone (4D encoder + Quick Edit buttons)",
              "bbox": [
                0.03,
                0.33,
                0.45,
                0.56
              ],
              "layout": {
                "type": "freeform"
              },
              "controls": [
                {
                  "id": "enc_4d",
                  "label": "4-Directional Push Encoder",
                  "type": "encoder_4d",
                  "interaction": [
                    "turn",
                    "tilt",
                    "confirm",
                    "push_turn"
                  ],
                  "feedback": {
                    "direction_leds": true
                  }
                },
                {
                  "id": "btn_qe_volume",
                  "label": "VOLUME",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Velocity (in Step mode context)"
                },
                {
                  "id": "btn_qe_swing",
                  "label": "SWING",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Position (in Step mode context)"
                },
                {
                  "id": "btn_qe_tempo",
                  "label": "TEMPO",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Tune (in Step mode context)"
                }
              ],
              "relative_positions": [
                {
                  "control_id": "enc_4d",
                  "bbox": [
                    0.05,
                    0.38,
                    0.17,
                    0.52
                  ]
                },
                {
                  "control_id": "btn_qe_volume",
                  "bbox": [
                    0.19,
                    0.36,
                    0.28,
                    0.41
                  ]
                },
                {
                  "control_id": "btn_qe_swing",
                  "bbox": [
                    0.19,
                    0.42,
                    0.28,
                    0.47
                  ]
                },
                {
                  "control_id": "btn_qe_tempo",
                  "bbox": [
                    0.19,
                    0.48,
                    0.28,
                    0.53
                  ]
                }
              ]
            },
            {
              "zone_id": "zone_performance",
              "name": "Performance Zone (Note Repeat, Lock) + Strip Mode Buttons + Smart Strip",
              "bbox": [
                0.03,
                0.56,
                0.60,
                0.78
              ],
              "layout": {
                "type": "freeform"
              },
              "controls": [
                {
                  "id": "btn_note_repeat",
                  "label": "NOTE REPEAT",
                  "type": "button_large",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Arp"
                },
                {
                  "id": "btn_lock",
                  "label": "LOCK",
                  "type": "button_large",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Ext Lock"
                },
                {
                  "id": "btn_strip_pitch",
                  "label": "PITCH",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_strip_mod",
                  "label": "MOD",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_strip_perform",
                  "label": "PERFORM",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "FX Select"
                },
                {
                  "id": "btn_strip_notes",
                  "label": "NOTES",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "strip_smart",
                  "label": "Smart Strip",
                  "type": "touch_strip",
                  "interaction": [
                    "slide"
                  ],
                  "properties": {
                    "supports_multi_touch": true,
                    "led_bar": true
                  }
                }
              ]
            },
            {
              "zone_id": "zone_groups",
              "name": "Group Buttons Zone (2 rows Ã— 4 cols)",
              "bbox": [
                0.22,
                0.78,
                0.60,
                0.92
              ],
              "layout": {
                "type": "grid",
                "rows": 2,
                "cols": 4
              },
              "controls": [
                {
                  "id": "btn_group_a",
                  "label": "GROUP A",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                },
                {
                  "id": "btn_group_b",
                  "label": "GROUP B",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                },
                {
                  "id": "btn_group_c",
                  "label": "GROUP C",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                },
                {
                  "id": "btn_group_d",
                  "label": "GROUP D",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                },
                {
                  "id": "btn_group_e",
                  "label": "GROUP E",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                },
                {
                  "id": "btn_group_f",
                  "label": "GROUP F",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                },
                {
                  "id": "btn_group_g",
                  "label": "GROUP G",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                },
                {
                  "id": "btn_group_h",
                  "label": "GROUP H",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Bank Select"
                }
              ],
              "feedback": {
                "rgb_color_per_group": true,
                "dim_lit_for_selectable": true,
                "dim_white_for_empty_create": true
              }
            },
            {
              "zone_id": "zone_transport",
              "name": "Transport Zone (2 rows Ã— 4 cols)",
              "bbox": [
                0.03,
                0.78,
                0.22,
                0.95
              ],
              "layout": {
                "type": "grid",
                "rows": 2,
                "cols": 4
              },
              "controls": [
                {
                  "id": "btn_restart",
                  "label": "RESTART",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Loop"
                },
                {
                  "id": "btn_erase",
                  "label": "ERASE",
                  "type": "button",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Replace (label)"
                },
                {
                  "id": "btn_tap",
                  "label": "TAP",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Metronome"
                },
                {
                  "id": "btn_follow",
                  "label": "FOLLOW",
                  "type": "button",
                  "interaction": [
                    "press"
                  ],
                  "shift_label": "Grid"
                },
                {
                  "id": "btn_play",
                  "label": "PLAY",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_rec",
                  "label": "REC",
                  "type": "button",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Count In"
                },
                {
                  "id": "btn_stop",
                  "label": "STOP",
                  "type": "button",
                  "interaction": [
                    "press"
                  ]
                },
                {
                  "id": "btn_shift",
                  "label": "SHIFT",
                  "type": "button_modifier",
                  "interaction": [
                    "hold"
                  ]
                }
              ]
            },
            {
              "zone_id": "zone_mode_buttons",
              "name": "Pad Mode Zone (Mode buttons, vertical column)",
              "bbox": [
                0.60,
                0.42,
                0.70,
                0.95
              ],
              "layout": {
                "type": "column",
                "count": 8,
                "spacing": "even"
              },
              "controls": [
                {
                  "id": "btn_mode_scene",
                  "label": "SCENE",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Section",
                  "pinnable_with": "soft_btn_1"
                },
                {
                  "id": "btn_mode_pattern",
                  "label": "PATTERN",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "pinnable_with": "soft_btn_1"
                },
                {
                  "id": "btn_mode_events",
                  "label": "EVENTS",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "pinnable_with": "soft_btn_1"
                },
                {
                  "id": "btn_mode_variation",
                  "label": "VARIATION",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Navigate",
                  "pinnable_with": "soft_btn_1"
                },
                {
                  "id": "btn_mode_duplicate",
                  "label": "DUPLICATE",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Double",
                  "pinnable_with": "soft_btn_1"
                },
                {
                  "id": "btn_mode_select",
                  "label": "SELECT",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "pinnable_with": "soft_btn_1"
                },
                {
                  "id": "btn_mode_solo",
                  "label": "SOLO",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "pinnable_with": "soft_btn_1"
                },
                {
                  "id": "btn_mode_mute",
                  "label": "MUTE",
                  "type": "button_mode",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Choke (label)",
                  "pinnable_with": "soft_btn_1"
                }
              ],
              "mode_behavior": {
                "default": "momentary_hold",
                "can_pin": true,
                "pin_combo": "mode_button + soft_btn_1"
              }
            },
            {
              "zone_id": "zone_pads",
              "name": "Pad Zone (16 velocity-sensitive RGB pads, 4Ã—4)",
              "bbox": [
                0.70,
                0.45,
                0.97,
                0.95
              ],
              "layout": {
                "type": "grid",
                "rows": 4,
                "cols": 4,
                "numbering": "pad_01_bottom_left_to_pad_16_top_right"
              },
              "controls": [
                {
                  "id": "pad_01",
                  "label": "Pad 1",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Undo"
                },
                {
                  "id": "pad_02",
                  "label": "Pad 2",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Redo"
                },
                {
                  "id": "pad_03",
                  "label": "Pad 3",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Step Undo"
                },
                {
                  "id": "pad_04",
                  "label": "Pad 4",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Step Redo"
                },
                {
                  "id": "pad_05",
                  "label": "Pad 5",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Quantize"
                },
                {
                  "id": "pad_06",
                  "label": "Pad 6",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Quantize 50%"
                },
                {
                  "id": "pad_07",
                  "label": "Pad 7",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Nudge Left"
                },
                {
                  "id": "pad_08",
                  "label": "Pad 8",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Nudge Right"
                },
                {
                  "id": "pad_09",
                  "label": "Pad 9",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Clear"
                },
                {
                  "id": "pad_10",
                  "label": "Pad 10",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Clear Auto"
                },
                {
                  "id": "pad_11",
                  "label": "Pad 11",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Copy"
                },
                {
                  "id": "pad_12",
                  "label": "Pad 12",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Paste"
                },
                {
                  "id": "pad_13",
                  "label": "Pad 13",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Semitone Down"
                },
                {
                  "id": "pad_14",
                  "label": "Pad 14",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Semitone Up"
                },
                {
                  "id": "pad_15",
                  "label": "Pad 15",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Octave Down"
                },
                {
                  "id": "pad_16",
                  "label": "Pad 16",
                  "type": "pad_velocity_rgb",
                  "interaction": [
                    "press",
                    "hold"
                  ],
                  "shift_label": "Octave Up"
                }
              ],
              "feedback": {
                "rgb_color": true,
                "half_lit_state_used_for_mute": true,
                "dim_state_used_for_solo_context": true
              }
            }
          ]
        },
        {
          "surface_id": "rear_panel",
          "name": "Rear Panel",
          "layout_order_left_to_right": true,
          "controls_in_order": [
            {
              "id": "rear_knob_phones_volume",
              "label": "PHONES VOLUME",
              "type": "rotary_knob",
              "interaction": [
                "turn"
              ]
            },
            {
              "id": "rear_jack_phones",
              "label": "PHONES (1/4\" TRS)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_knob_main_volume",
              "label": "LINE OUT VOLUME",
              "type": "rotary_knob",
              "interaction": [
                "turn"
              ]
            },
            {
              "id": "rear_jack_line_out_r",
              "label": "LINE OUT R (1/4\" TRS)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_jack_line_out_l",
              "label": "LINE OUT L (1/4\" TRS)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_knob_mic_gain",
              "label": "MIC IN GAIN",
              "type": "rotary_knob",
              "interaction": [
                "turn"
              ]
            },
            {
              "id": "rear_jack_mic_in",
              "label": "MIC IN (1/4\" TRS)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_jack_line_in_2",
              "label": "LINE IN 2 (1/4\" TRS)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_jack_line_in_1",
              "label": "LINE IN 1 (1/4\" TRS)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_jack_midi_out",
              "label": "MIDI OUT (5-pin DIN)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_jack_midi_in",
              "label": "MIDI IN (5-pin DIN)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_jack_footswitch",
              "label": "FOOTSWITCH (1/4\" TRS)",
              "type": "jack",
              "interaction": []
            },
            {
              "id": "rear_port_usb_b",
              "label": "USB-B",
              "type": "port",
              "interaction": []
            },
            {
              "id": "rear_port_dc_in",
              "label": "DC IN (optional)",
              "type": "port",
              "interaction": []
            },
            {
              "id": "rear_btn_power",
              "label": "POWER",
              "type": "button_switch",
              "interaction": [
                "press"
              ]
            }
          ]
        },
        {
          "surface_id": "left_edge",
          "name": "Left Edge",
          "controls_in_order_left_to_right": true,
          "controls": [
            {
              "id": "edge_kensington_lock",
              "label": "Kensington Lock Slot",
              "type": "slot",
              "interaction": []
            }
          ]
        }
      ],
      "gui_reconstruction_hints": {
        "lighting_model": {
          "buttons": "Einfarbig (weiÃŸ) mit ZustÃ¤nden: off, dim, bright; einige Buttons zeigen 'pinned' durch dauerhaftes Leuchten.",
          "pads": "RGB (pro Pad), ZustÃ¤nde: off/dim/half/bright; Bedeutung kontextabhÃ¤ngig (Mute/Solo/Pattern Slots etc.).",
          "group_buttons": "Farbkodiert nach Group; ungenutzte Slots unlit; leer aber verfÃ¼gbar kann dim white sein (Create)."
        },
        "dynamic_labels": {
          "soft_buttons_and_knobs": "Soft Buttons 1â€“8 und Knobs 1â€“8 mÃ¼ssen im GUI kontextsensitiv beschriftet werden (wie im Display).",
          "overlays": "Beim Touch der Knobs (v. a. 5â€“8) sollten Overlay-Icons fÃ¼r Zoom/Scroll erscheinen; bei Selector-Parametern sollte eine Werteliste erscheinen."
        },
        "haptics_suggestion_for_tablet": {
          "touch_strip": "Optional haptisches Feedback bei Wert-Rasterung oder Zonen (Pitch/Notes).",
          "4d_encoder": "Simuliere 'tilt' als 4-Wege D-Pad + zentraler Push; 'turn' als Drehkranz oder virtuelles Rad."
        }
      }
    }
  }
}


=========================================
File: nuxt.config.ts
=========================================

import { defineNuxtConfig } from 'nuxt/config'

const DEFAULT_HMR_PORT = 24678
const hmrPort = Number.isInteger(Number(process.env.HMR_PORT)) && process.env.HMR_PORT
  ? Number(process.env.HMR_PORT)
  : DEFAULT_HMR_PORT

export default defineNuxtConfig({
  // Nuxt configuration for the client-only drum machine, wiring modules, styles, and Vite options.
  ssr: false,
  debug: true,
  compatibilityDate: '2024-04-03',
  devtools: {
    enabled: true,

    timeline: {
      enabled: true
    }
  },
  modules: [
    '@pinia/nuxt',
  ],


  css: ['vuetify/styles', '@/styles/globals.less'],
  typescript: {
    strict: true,
    typeCheck: false
  },
  devServer: {
    host: '0.0.0.0',
    port: 3100
  },
  nitro: {
    prerender: {
      routes: []
    }
  },
  vite: {
    server: {
      hmr: {
        port: hmrPort,
        host: '127.0.0.1'
      }
    },

    define: {
      'process.env.DEBUG': true
    },
    css: {
      preprocessorOptions: {
        less: {
          javascriptEnabled: true,
          additionalData: `@import '@/styles/variables.less';`
        }
      }
    }
  },

  pages: true,
  app: {
    head: {
      title: 'Drumcomputer',
      meta: [
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { name: 'description', content: 'Nuxt 4 Drumcomputer with WebAudio and MIDI' }
      ]
    }
  }
})



=========================================
File: package.json
=========================================

{
  "name": "drumcomputer",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "node scripts/dev.mjs",
    "build": "nuxt build",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "lint": "eslint .",
    "typecheck": "vue-tsc --noEmit",
    "build:test": "tsc -p tsconfig.test.json",
    "test:unit": "mocha --require tsx --require jsdom-global/register tests/unitTests/*.spec.ts",
    "test:components": "vitest",
    "test:watch": "mocha --watch --loader ts-node/esm --require jsdom-global/register tests/**/*.spec.ts"
  },
  "dependencies": {
    "@pinia/nuxt": "^0.5.4",
    "@tonejs/midi": "^2.0.27",
    "@vite-pwa/nuxt": "^0.10.1",
    "file-saver": "^2.0.5",
    "nuxt": "^4.2.2",
    "pinia": "^2.2.6",
    "pug": "^3.0.3",
    "vuetify": "^3.11.4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.3",
    "@types/chai": "^5.2.3",
    "@types/mocha": "^10.0.10",
    "@types/node": "^25.0.3",
    "@types/vue": "^1.0.31",
    "@types/webmidi": "^2.0.12",
    "@typescript-eslint/eslint-plugin": "^8.18.1",
    "@typescript-eslint/parser": "^8.18.1",
    "@vue/test-utils": "^2.4.6",
    "chai": "^6.2.1",
    "eslint": "^9.13.0",
    "eslint-plugin-vue": "^9.29.0",
    "jsdom": "^27.3.0",
    "jsdom-global": "^3.0.2",
    "less": "^4.2.0",
    "mocha": "^11.7.5",
    "ts-node": "^10.9.2",
    "tsx": "^4.21.0",
    "typescript": "^5.6.3",
    "vue-tsc": "^2.1.10"
  }
}


=========================================
File: pages/index.vue
=========================================

<template>
<ClientOnly>
  <DrumMachine>
    <template #main>
      <div class="main-placeholder" />
    </template>

    <template #pads="{ props }">
      <PadGrid v-bind="props.padGridProps" />
    </template>

    <template #transport="{ props }">
      <TransportBar v-bind="props.transportProps" />
    </template>

  </DrumMachine>
</ClientOnly>
</template>

<script>
import DrumMachine from '@/components/DrumMachine.vue'
import TransportBar from '@/components/TransportBar.vue'
import PadGrid from '@/components/PadGrid.vue'
import FxPanel from '@/components/panels/FxPanel.vue'

export default {
  // Composes the DrumMachine with transport, pads, and FX panels for the main page.
  components: {
    DrumMachine,
    TransportBar,
    PadGrid,
    FxPanel
  }
}
</script>

<style scoped>
.main-placeholder {
  width: 100%;
  height: 100%;
}
</style>



=========================================
File: plugins/vuetify.client.ts
=========================================

import { defineNuxtPlugin } from '#app'
import { createVuetify } from 'vuetify'
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'

export default defineNuxtPlugin((nuxtApp) => {
  const vuetify = createVuetify({
    components,
    directives,
    theme: {
      defaultTheme: 'dark',
      themes: {
        dark: {
          dark: true,
          colors: {
            background: '#0E1013',
            surface: '#12151B',
            primary: '#2EC5FF',
            secondary: '#5EE1FF',
            error: '#FF4D4D',
            info: '#2EC5FF',
            success: '#4CAF50',
            warning: '#FFC107'
          }
        }
      }
    }
  })

  nuxtApp.vueApp.use(vuetify)
})



=========================================
File: plugins/vuetify.ts
=========================================

import { createVuetify, DateInstance, DefaultsInstance, DisplayInstance, GoToInstance, IconAliases, IconSet, LocaleInstance, LocaleMessages, LocaleOptions, ThemeInstance } from 'vuetify'
import { aliases, mdi } from 'vuetify/iconsets/mdi'
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'
import { defineNuxtPlugin } from 'nuxt/app'
import { App, Ref, ShallowRef } from 'vue'

export default defineNuxtPlugin((nuxtApp: { vueApp: { use: (arg0: { install: (app: App<unknown>) => void; unmount: () => void; defaults: Ref<DefaultsInstance, DefaultsInstance>; display: DisplayInstance; theme: ThemeInstance & { install: (app: App<unknown>) => void }; icons: { defaultSet: string; aliases: Partial<IconAliases>; sets: Record<string, IconSet> }; locale: { name: string; decimalSeparator: ShallowRef<string>; messages: Ref<LocaleMessages, LocaleMessages>; current: Ref<string, string>; fallback: Ref<string, string>; t: (key: string, ...params: unknown[]) => string; n: (value: number) => string; provide: (props: LocaleOptions) => LocaleInstance; isRtl: Ref<boolean, boolean>; rtl: Ref<Record<string, boolean>, Record<string, boolean>>; rtlClasses: Ref<string, string> }; date: { options: { adapter: (new (options: { locale: unknown; formats?: unknown }) => DateInstance) | DateInstance; formats?: Record<string, unknown>; locale: Record<string, unknown> }; instance: { date: (value?: unknown) => unknown; format: (date: unknown, formatString: string) => string; toJsDate: (value: unknown) => Date; parseISO: (date: string) => unknown; toISO: (date: unknown) => string; startOfDay: (date: unknown) => unknown; endOfDay: (date: unknown) => unknown; startOfWeek: (date: unknown, firstDayOfWeek?: string | number | undefined) => unknown; endOfWeek: (date: unknown) => unknown; startOfMonth: (date: unknown) => unknown; endOfMonth: (date: unknown) => unknown; startOfYear: (date: unknown) => unknown; endOfYear: (date: unknown) => unknown; isAfter: (date: unknown, comparing: unknown) => boolean; isAfterDay: (date: unknown, comparing: unknown) => boolean; isSameDay: (date: unknown, comparing: unknown) => boolean; isSameMonth: (date: unknown, comparing: unknown) => boolean; isSameYear: (date: unknown, comparing: unknown) => boolean; isBefore: (date: unknown, comparing: unknown) => boolean; isEqual: (date: unknown, comparing: unknown) => boolean; isValid: (date: unknown) => boolean; isWithinRange: (date: unknown, range: [unknown, unknown]) => boolean; addMinutes: (date: unknown, amount: number) => unknown; addHours: (date: unknown, amount: number) => unknown; addDays: (date: unknown, amount: number) => unknown; addWeeks: (date: unknown, amount: number) => unknown; addMonths: (date: unknown, amount: number) => unknown; getYear: (date: unknown) => number; setYear: (date: unknown, year: number) => unknown; getDiff: (date: unknown, comparing: unknown, unit?: string | undefined) => number; getWeekArray: (date: unknown, firstDayOfWeek?: string | number | undefined) => unknown[][]; getWeekdays: (firstDayOfWeek?: string | number | undefined, weekdayFormat?: "long" | "narrow" | "short" | undefined) => string[]; getWeek: (date: unknown, firstDayOfWeek?: string | number | undefined, firstDayOfYear?: string | number | undefined) => number; getMonth: (date: unknown) => number; setMonth: (date: unknown, month: number) => unknown; getDate: (date: unknown) => number; setDate: (date: unknown, day: number) => unknown; getNextMonth: (date: unknown) => unknown; getPreviousMonth: (date: unknown) => unknown; getHours: (date: unknown) => number; setHours: (date: unknown, hours: number) => unknown; getMinutes: (date: unknown) => number; setMinutes: (date: unknown, minutes: number) => unknown; locale?: unknown } }; goTo: GoToInstance }) => void } }) => {
  const vuetify = createVuetify({
    components,
    directives,
    icons: {
      defaultSet: 'mdi',
      aliases,
      sets: { mdi }
    },
    theme: {
      defaultTheme: 'dark'
    }
  })

  nuxtApp.vueApp.use(vuetify)
})




=========================================
File: promptingAgentInstructions.json
=========================================

{
  "branch": "featureImplementation",
  "merge_policy": "Merge in master nur nach expliziter Freigabe durch den Inhaber.",
  "phasen": [
    {
      "missing_functions": [
        "Play/Stop Toggle (Transport)",
        "Stop + Reset Playhead (Transport)",
        "Record Toggle und Count-In (Transport)",
        "Pattern Preset Mode (Pattern-LÃ¤nge vor Aufnahme)",
        "Restart Loop Range (Transport)",
        "Loop On/Off und Loop-Range-Verschiebung/Endpunkt-Anpassung",
        "Tap Tempo (Transport)",
        "Metronom Toggle",
        "Follow Toggle (Display folgt Playhead)",
        "Grid Mode (Perform/Arrange/Step/Nudge Grid)",
        "Live-Erase (Events wÃ¤hrend Playback lÃ¶schen)",
        "Erase All Events for Pad (Shortcut)",
        "Erase Automation for Parameter",
        "Remove Sound/Group Slot (Reset)",
        "Channel Properties (Control Mode)",
        "MIDI Mode Umschaltung (SHIFT + CHANNEL)",
        "Pad/Group-LED-Feedback (Farben, Choke, Create)",
        "Soft Button/Knob Kontextsteuerung (Overlays, Selector-Listen)",
        "Mode-Pinning und Shift-Layer-Handling (UI/Logik)",
        "Undo/Redo-Logik fÃ¼r Pattern/Scene-Edits (History)"
      ],
      "hardware_functions": [
        "Pad Input: Note On/Off, Velocity, Aftertouch, RGB-Feedback je nach Modus (Mute/Solo/Pattern/Slot)",
        "Pad Mode: Umschalten zwischen SCENE, PATTERN, PAD MODE, KEYBOARD, CHORD, STEP, ARRANGE, DUPLICATE",
        "Group Select: 2x4 Buttons, Farbkodiert, Create-Button (dim white)",
        "Transport: RESTART, ERASE, TAP, FOLLOW, PLAY, REC, STOP, SHIFT, mit Status-Feedback",
        "Performance: Note Repeat, Lock, Strip Mode, Smart Strip (Touch/Slide, LED-Bar, Strip Mode)",
        "Edit Zone: 4D-Encoder (tilt, push, turn), Quick Edit (VOLUME, SWING, TEMPO)",
        "Screen Buttons: Soft Buttons 1â€“8, kontextabhÃ¤ngige Funktion",
        "Screen Knobs: 8 Touch-Knobs, Touch blendet Werteliste ein, Push fÃ¼r Reset",
        "Displays: 2x, dynamische Overlays, Kontext-Feedback, Selector-Listen",
        "Control Zone: CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, PATTERN, SCENE, PAD MODE, EVENTS, VARIATION, DUPLICATE",
        "Pad Input Mode: FIXED VEL, PAD MODE, KEYBOARD, CHORD, STEP",
        "Global: Shift-Layer, Mode-Pinning, Undo/Redo, Kontext-Feedback, LED-Feedback, Overlay-Icons"
      ],
      "interaction_models": [
        "press: Kurzer Tastendruck (z.B. Pad, Button)",
        "press_twice: Doppelklick (z.B. Stop)",
        "hold: GedrÃ¼ckt halten (Momentary)",
        "hold_combo: GedrÃ¼ckt halten + weiteres Element",
        "shift_combo: SHIFT + Element",
        "turn: Drehen (Knob, Encoder)",
        "touch: BerÃ¼hren (Touch-Knob, Strip)",
        "slide: Fingerbewegung Ã¼ber Touch-Strip",
        "push_turn: Encoder drÃ¼cken + drehen",
        "tilt: 4D-Encoder Richtung",
        "confirm: Auswahl bestÃ¤tigen (Encoder drÃ¼cken)"
      ],
      "feedback_mechanisms": [
        "Pad RGB: Status je nach Modus (Mute/Solo/Pattern/Slot)",
        "Button LED: off/dim/bright/pinned",
        "Group Button: Farbkodiert, dim white fÃ¼r Create",
        "Soft Button/Knob: Overlay/Label im Display",
        "Selector-Listen: Overlay bei Touch auf Knob",
        "Touch Strip: LED-Bar, haptisches Feedback",
        "4D-Encoder: LED-Ring fÃ¼r Richtungen, Push-Feedback"
      ],
      "roadmap": [
        "1. Transport- und Playback-Funktionen vollstÃ¤ndig implementieren",
        "2. Pattern/Scene-Chain- und Preset-Mode-Logik entwickeln",
        "3. Loop- und Grid-Handling (inkl. Endpunkt/Range) umsetzen",
        "4. Erase- und Automation-Funktionen ergÃ¤nzen",
        "5. Channel-Properties- und MIDI-Mode-Logik bereitstellen",
        "6. Pad/Group-LED-Feedback und Soft-Button/Knob-Kontextsteuerung integrieren",
        "7. Mode-Pinning, Shift-Layer-Handling und Undo/Redo-Logik finalisieren"
      ]
    }
  ],
  "dokumentation": {
    "readme": "Jede Phase und alle neuen Use Cases werden in der README.md dokumentiert.",
    "diagrams": "Alle relevanten Diagramme im diagrams-Ordner werden ergÃ¤nzt/aktualisiert."
  },
  "qualitaet": {
    "performance": "Alle Komponenten und Funktionen werden auf Performance optimiert.",
    "clean_code": "Strikte Einhaltung von Clean Code und Architekturprinzipien."
  },
  "hinweise": [
    "Es darf ausschlieÃŸlich im Branch 'featureImplementation' gearbeitet werden.",
    "Der Merge in den master-Branch erfolgt nur nach expliziter Freigabe durch den Inhaber.",
    "Alle Aufgaben sind so zu dokumentieren, dass ein Eingreifen des Inhabers erst zum Merge erforderlich ist."
  ]
}


=========================================
File: scripts/dev.mjs
=========================================

import {
  spawn
} from 'node:child_process'
import path from 'node:path'
import {
  fileURLToPath
} from 'node:url'

/**
 * __dirname for ESM
 */
const __dirname = path.dirname(fileURLToPath(
  import.meta.url))

/**
 * Project root (one level above /scripts)
 */
const rootDir = path.resolve(__dirname, '..')

/**
 * Direct entry point for Nuxt CLI (nuxi)
 * â†’ no .bin symlinks, no shebang, no shell:true
 */
const nuxtEntry = path.join(
  rootDir,
  'node_modules',
  '@nuxt',
  'cli',
  'bin',
  'nuxi.mjs'
)

/**
 * Dev parameters
 */
const host = '127.0.0.1'
const port = process.env.PORT ?? '3000'
const passThroughArgs = process.argv.slice(2)

const nuxtArgs = [
  nuxtEntry,
  'dev',
  '--host',
  host,
  '--port',
  port,
  ...passThroughArgs
]

/**
 * Spawn via explicit Node binary
 */
const runner = spawn(
  process.execPath, // garantiert der richtige Node
  nuxtArgs, {
    stdio: 'inherit',
    cwd: rootDir,
    env: {
      ...process.env
    }
  }
)

/**
 * Forward exit code cleanly
 */
runner.on('exit', (code, signal) => {
  if (typeof code === 'number') {
    process.exitCode = code
  } else if (signal) {
    process.exitCode = 1
  }
})



=========================================
File: stores/control.ts
=========================================

import { defineStore } from 'pinia'

export type ControlMode =
  | 'CHANNEL'
  | 'PLUGIN'
  | 'ARRANGER'
  | 'MIXER'
  | 'BROWSER'
  | 'SAMPLING'
  | 'FILE'
  | 'SETTINGS'
  | 'AUTO'
  | 'MACRO'

type SoftButton = {
  label: string
  actionId: string
  shiftLabel?: string | undefined
  shiftActionId?: string | undefined
  enabled: boolean
  description?: string | undefined
}

type EncoderParam = {
  id: string
  name: string
  value: number
  min: number
  max: number
  step: number
  fineStep?: number
  format?: string
  side?: 'left' | 'right'
}

type ListItem = {
  title: string
  subtitle?: string
  active?: boolean
  value?: string
  meter?: number
}

type DisplayPanelModel = {
  view:
    | 'BROWSER'
    | 'FILE'
    | 'SETTINGS'
    | 'SAMPLING'
    | 'MIXER'
    | 'ARRANGER'
    | 'INFO'
    | 'EMPTY'
  title?: string
  summary?: string
  items?: ListItem[]
  hint?: string
}

type ControlPage = {
  label: string
  softButtons: SoftButton[]
  params: EncoderParam[]
  leftModel: DisplayPanelModel
  rightModel: DisplayPanelModel
}

type PageIndexByMode = Record<ControlMode, number>

const MODES: ControlMode[] = [
  'CHANNEL',
  'PLUGIN',
  'ARRANGER',
  'MIXER',
  'BROWSER',
  'SAMPLING',
  'FILE',
  'SETTINGS',
  'AUTO',
  'MACRO'
]

const clamp = (value: number, min: number, max: number): number =>
  Math.max(min, Math.min(max, value))

const buildSoftButtons = (buttons: Partial<SoftButton>[]): SoftButton[] => {
  const defaults: SoftButton = {
    label: '',
    actionId: 'noop',
    enabled: false,
    description: undefined
  }
  const filled = buttons.map((btn) => ({
    ...defaults,
    ...btn,
    enabled: btn.enabled !== false
  }))
  while (filled.length < 8) {
    filled.push({ ...defaults })
  }
  return filled.slice(0, 8)
}

const buildParams = (params: Partial<EncoderParam>[]): EncoderParam[] => {
  const defaults: EncoderParam = {
    id: 'param',
    name: '',
    value: 0,
    min: 0,
    max: 127,
    step: 1,
    side: 'left'
  }
  const filled = params.map((param, index) => ({
    ...defaults,
    id: param.id ?? `param-${index + 1}`,
    name: param.name ?? `Param ${index + 1}`,
    ...param
  }))
  while (filled.length < 8) {
    const idx = filled.length + 1
    filled.push({ ...defaults, id: `param-${idx}`, name: `Param ${idx}`, side: idx <= 4 ? 'left' : 'right' })
  }
  return filled.slice(0, 8)
}

const browserPages: ControlPage[] = [
  {
    label: 'Library',
    softButtons: buildSoftButtons([
      { label: 'Search', actionId: 'BROWSER_SEARCH', shiftLabel: 'Plug-In Menu', shiftActionId: 'BROWSER_PLUGIN_MENU' },
      { label: 'Type', actionId: 'BROWSER_TYPE' },
      { label: 'Tag', actionId: 'BROWSER_TAG' },
      { label: 'Favorites', actionId: 'BROWSER_FAVORITES' },
      { label: 'Prehear', actionId: 'BROWSER_PREHEAR', shiftLabel: 'Stop', shiftActionId: 'BROWSER_STOP' },
      { label: 'Load', actionId: 'BROWSER_LOAD' },
      { label: 'Replace', actionId: 'BROWSER_REPLACE' },
      { label: 'Clear', actionId: 'BROWSER_CLEAR' }
    ]),
    params: buildParams([
      { id: 'filter1', name: 'Filter', value: 40, min: 0, max: 100, step: 2, format: '%' },
      { id: 'cutoff', name: 'Cutoff', value: 72, min: 0, max: 127, step: 3 },
      { id: 'res', name: 'Resonance', value: 32, min: 0, max: 127, step: 3 },
      { id: 'rate', name: 'Rate', value: 4, min: 1, max: 16, step: 1 },
      { id: 'depth', name: 'Depth', value: 25, min: 0, max: 100, step: 1, side: 'right' },
      { id: 'space', name: 'Space', value: 35, min: 0, max: 100, step: 1, side: 'right' },
      { id: 'tone', name: 'Tone', value: 64, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'volume', name: 'Volume', value: 90, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'BROWSER',
      title: 'Browser',
      summary: 'Navigate library',
      items: [
        { title: 'Drums', subtitle: 'Kits, Percussion', active: true },
        { title: 'Instruments', subtitle: 'Bass, Keys' },
        { title: 'Loops', subtitle: 'Textures' },
        { title: 'User', subtitle: 'Local content' }
      ],
      hint: 'SHIFT: Plug-in menu'
    },
    rightModel: {
      view: 'BROWSER',
      title: 'Results',
      items: [
        { title: 'Neon Kit', subtitle: 'Kit â€¢ 16 samples', active: true },
        { title: 'Marble Kit', subtitle: 'Kit â€¢ 16 samples' },
        { title: 'Dusty Breaks', subtitle: 'Loop â€¢ 92 BPM' },
        { title: 'Glass Pluck', subtitle: 'Instrument' }
      ],
      summary: 'Use Load or Replace'
    }
  },
  {
    label: 'Recent',
    softButtons: buildSoftButtons([
      { label: 'Recent', actionId: 'BROWSER_RECENT' },
      { label: 'Clear', actionId: 'BROWSER_CLEAR_RECENT' },
      { label: 'Fav', actionId: 'BROWSER_FAVORITE' },
      { label: 'Tag', actionId: 'BROWSER_TAG_RECENT' },
      { label: 'Load', actionId: 'BROWSER_LOAD_RECENT' },
      { label: 'Prehear', actionId: 'BROWSER_PREHEAR' },
      { label: 'Replace', actionId: 'BROWSER_REPLACE' },
      { label: 'Stop', actionId: 'BROWSER_STOP' }
    ]),
    params: buildParams([
      { id: 'recent-volume', name: 'Preview Vol', value: 68, min: 0, max: 127, step: 2 },
      { id: 'recent-start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
      { id: 'recent-end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
      { id: 'recent-tune', name: 'Tune', value: 64, min: 0, max: 127, step: 1 },
      { id: 'recent-form', name: 'Formant', value: 64, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'recent-pan', name: 'Pan', value: 64, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'recent-dry', name: 'Dry/Wet', value: 80, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'recent-level', name: 'Level', value: 90, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'BROWSER',
      title: 'Recent Files',
      items: [
        { title: 'Deep Snare', subtitle: 'Sample', active: true },
        { title: 'Air Hat', subtitle: 'Sample' },
        { title: 'Chop Vox', subtitle: 'Sample' },
        { title: 'Lo-fi Loop', subtitle: 'Loop â€¢ 87 BPM' }
      ]
    },
    rightModel: {
      view: 'BROWSER',
      title: 'Preview',
      summary: 'Use Prehear',
      items: [
        { title: 'Waveform', subtitle: '00:12', value: 'Fade-in' },
        { title: 'Slice Points', subtitle: 'Auto â€¢ 8' }
      ]
    }
  }
]

const channelPages: ControlPage[] = [
  {
    label: 'Levels',
    softButtons: buildSoftButtons([
      { label: 'Sound', actionId: 'CHANNEL_SOUND' },
      { label: 'Group', actionId: 'CHANNEL_GROUP' },
      { label: 'Master', actionId: 'CHANNEL_MASTER' },
      { label: 'Input', actionId: 'CHANNEL_INPUT' },
      { label: 'Route', actionId: 'CHANNEL_ROUTE' },
      { label: 'Solo', actionId: 'CHANNEL_SOLO' },
      { label: 'Mute', actionId: 'CHANNEL_MUTE' },
      { label: 'Monitor', actionId: 'CHANNEL_MONITOR' }
    ]),
    params: buildParams([
      { id: 'snd-level', name: 'Sound Vol', value: 96, min: 0, max: 127, step: 2 },
      { id: 'snd-pan', name: 'Sound Pan', value: 64, min: 0, max: 127, step: 2 },
      { id: 'snd-send-a', name: 'Send A', value: 40, min: 0, max: 127, step: 2 },
      { id: 'snd-send-b', name: 'Send B', value: 55, min: 0, max: 127, step: 2 },
      { id: 'grp-level', name: 'Group Vol', value: 88, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'grp-pan', name: 'Group Pan', value: 64, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'mst-comp', name: 'Master Comp', value: 48, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'mst-lim', name: 'Limiter', value: 38, min: 0, max: 127, step: 1, side: 'right' }
    ]),
    leftModel: {
      view: 'MIXER',
      title: 'Channel Levels',
      items: [
        { title: 'Kick', value: '-1.2 dB', meter: 0.84 },
        { title: 'Snare', value: '-3.1 dB', meter: 0.68 },
        { title: 'Hat', value: '-5.0 dB', meter: 0.54 },
        { title: 'Bass', value: '-0.4 dB', meter: 0.9 }
      ],
      summary: 'SHIFT: MIDI'
    },
    rightModel: {
      view: 'MIXER',
      title: 'Group & Master',
      items: [
        { title: 'Group A', value: '-1.0 dB', meter: 0.82 },
        { title: 'Group B', value: '-2.4 dB', meter: 0.72 },
        { title: 'Master', value: '-0.3 dB', meter: 0.96 }
      ]
    }
  }
]

const pluginPages: ControlPage[] = [
  {
    label: 'Plug-in',
    softButtons: buildSoftButtons([
      { label: 'Instance', actionId: 'PLUGIN_INSTANCE', shiftLabel: 'Swap', shiftActionId: 'PLUGIN_SWAP' },
      { label: 'Preset', actionId: 'PLUGIN_PRESET' },
      { label: 'Bypass', actionId: 'PLUGIN_BYPASS' },
      { label: 'Enable', actionId: 'PLUGIN_ENABLE' },
      { label: 'Param', actionId: 'PLUGIN_PARAM' },
      { label: 'Macro', actionId: 'PLUGIN_MACRO' },
      { label: 'Browse', actionId: 'PLUGIN_BROWSE' },
      { label: 'Remove', actionId: 'PLUGIN_REMOVE' }
    ]),
    params: buildParams([
      { id: 'cutoff', name: 'Cutoff', value: 82, min: 0, max: 127, step: 2 },
      { id: 'resonance', name: 'Resonance', value: 52, min: 0, max: 127, step: 2 },
      { id: 'attack', name: 'Attack', value: 12, min: 0, max: 127, step: 1 },
      { id: 'release', name: 'Release', value: 88, min: 0, max: 127, step: 2 },
      { id: 'drive', name: 'Drive', value: 40, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'mix', name: 'Mix', value: 90, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'width', name: 'Stereo', value: 70, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'out', name: 'Output', value: 96, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'INFO',
      title: 'Plug-In Chain',
      items: [
        { title: 'Slot 1', subtitle: 'Drum Synth', active: true },
        { title: 'Slot 2', subtitle: 'Transient Master' },
        { title: 'Slot 3', subtitle: 'Reverb' }
      ]
    },
    rightModel: {
      view: 'INFO',
      title: 'Instance',
      summary: 'SHIFT: Swap instance',
      items: [
        { title: 'Preset', subtitle: 'Neon Dust' },
        { title: 'Category', subtitle: 'Drums' },
        { title: 'Author', subtitle: 'Native Instruments' }
      ]
    }
  }
]

const arrangerPages: ControlPage[] = [
  {
    label: 'Scenes',
    softButtons: buildSoftButtons([
      { label: 'Scenes', actionId: 'ARRANGER_SCENES' },
      { label: 'Sections', actionId: 'ARRANGER_SECTIONS' },
      { label: 'Duplicate', actionId: 'ARRANGER_DUPLICATE' },
      { label: 'Length', actionId: 'ARRANGER_LENGTH' },
      { label: 'Follow', actionId: 'ARRANGER_FOLLOW' },
      { label: 'Loop', actionId: 'ARRANGER_LOOP' },
      { label: 'Grid', actionId: 'ARRANGER_GRID' },
      { label: 'Clear', actionId: 'ARRANGER_CLEAR' }
    ]),
    params: buildParams([
      { id: 'scene-length', name: 'Scene Bars', value: 4, min: 1, max: 16, step: 1 },
      { id: 'scene-repeat', name: 'Repeat', value: 2, min: 1, max: 8, step: 1 },
      { id: 'section', name: 'Section', value: 1, min: 1, max: 16, step: 1 },
      { id: 'swing', name: 'Swing', value: 8, min: 0, max: 100, step: 1 },
      { id: 'velocity', name: 'Vel Mod', value: 50, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'humanize', name: 'Humanize', value: 24, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'shift', name: 'Shift', value: 0, min: -32, max: 32, step: 1, side: 'right' },
      { id: 'accent', name: 'Accent', value: 72, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'ARRANGER',
      title: 'Scenes',
      items: [
        { title: 'Intro', subtitle: '4 bars', active: true },
        { title: 'Hook', subtitle: '8 bars' },
        { title: 'Bridge', subtitle: '4 bars' },
        { title: 'Outro', subtitle: '4 bars' }
      ],
      summary: 'Page â—€/â–¶ for parameters'
    },
    rightModel: {
      view: 'ARRANGER',
      title: 'Layout',
      items: [
        { title: 'Pattern A1', subtitle: 'Scene: Intro' },
        { title: 'Pattern B1', subtitle: 'Scene: Hook' },
        { title: 'Pattern C1', subtitle: 'Scene: Bridge' }
      ]
    }
  }
]

const mixerPages: ControlPage[] = [
  {
    label: 'Mix',
    softButtons: buildSoftButtons([
      { label: 'Levels', actionId: 'MIXER_LEVELS' },
      { label: 'Pan', actionId: 'MIXER_PAN' },
      { label: 'Sends', actionId: 'MIXER_SENDS' },
      { label: 'FX', actionId: 'MIXER_FX' },
      { label: 'Group', actionId: 'MIXER_GROUP' },
      { label: 'Master', actionId: 'MIXER_MASTER' },
      { label: 'Cue', actionId: 'MIXER_CUE' },
      { label: 'Meters', actionId: 'MIXER_METERS' }
    ]),
    params: buildParams([
      { id: 'kick-level', name: 'Kick', value: 96, min: 0, max: 127, step: 2 },
      { id: 'snare-level', name: 'Snare', value: 92, min: 0, max: 127, step: 2 },
      { id: 'hat-level', name: 'Hat', value: 88, min: 0, max: 127, step: 2 },
      { id: 'perc-level', name: 'Perc', value: 80, min: 0, max: 127, step: 2 },
      { id: 'bus-comp', name: 'Bus Comp', value: 50, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'bus-sat', name: 'Saturate', value: 36, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'send-a', name: 'Send A', value: 45, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'send-b', name: 'Send B', value: 56, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'MIXER',
      title: 'Channels',
      items: [
        { title: 'Kick', value: '-1.2 dB', meter: 0.84 },
        { title: 'Snare', value: '-3.0 dB', meter: 0.72 },
        { title: 'Hat', value: '-4.4 dB', meter: 0.62 }
      ]
    },
    rightModel: {
      view: 'MIXER',
      title: 'Sends/FX',
      items: [
        { title: 'Reverb', subtitle: 'Aux A', value: '22%' },
        { title: 'Delay', subtitle: 'Aux B', value: '18%' },
        { title: 'Sidechain', subtitle: 'Bus', value: '-14 dB' }
      ]
    }
  }
]

const samplingPages: ControlPage[] = [
  {
    label: 'Sampling',
    softButtons: buildSoftButtons([
      { label: 'Record', actionId: 'SAMPLING_RECORD' },
      { label: 'Edit', actionId: 'SAMPLING_EDIT' },
      { label: 'Slice', actionId: 'SAMPLING_SLICE' },
      { label: 'Detect', actionId: 'SAMPLING_DETECT' },
      { label: 'Normalize', actionId: 'SAMPLING_NORMALIZE' },
      { label: 'Fade', actionId: 'SAMPLING_FADE' },
      { label: 'Apply', actionId: 'SAMPLING_APPLY' },
      { label: 'Discard', actionId: 'SAMPLING_DISCARD' }
    ]),
    params: buildParams([
      { id: 'start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
      { id: 'end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
      { id: 'snap', name: 'Snap', value: 1, min: 0, max: 8, step: 1 },
      { id: 'silence', name: 'Silence', value: 6, min: 0, max: 20, step: 1 },
      { id: 'attack', name: 'Attack', value: 4, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'hold', name: 'Hold', value: 32, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'release', name: 'Release', value: 60, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'gain', name: 'Gain', value: 80, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'SAMPLING',
      title: 'Waveform',
      summary: 'Set start/end or slice',
      items: [
        { title: 'Length', value: '0:12.4' },
        { title: 'Slices', value: '8 auto' }
      ]
    },
    rightModel: {
      view: 'SAMPLING',
      title: 'Actions',
      items: [
        { title: 'Record Input', subtitle: 'Line' },
        { title: 'Monitor', subtitle: 'On' },
        { title: 'Normalize', subtitle: '-1 dB' }
      ]
    }
  }
]

const filePages: ControlPage[] = [
  {
    label: 'Files',
    softButtons: buildSoftButtons([
      { label: 'New', actionId: 'FILE_NEW' },
      { label: 'Open', actionId: 'FILE_OPEN' },
      { label: 'Save', actionId: 'FILE_SAVE', shiftLabel: 'Save As', shiftActionId: 'FILE_SAVE_AS' },
      { label: 'Export', actionId: 'FILE_EXPORT' },
      { label: 'Audio', actionId: 'FILE_EXPORT_AUDIO' },
      { label: 'MIDI', actionId: 'FILE_EXPORT_MIDI' },
      { label: 'Bounce', actionId: 'FILE_BOUNCE' },
      { label: 'Close', actionId: 'FILE_CLOSE' }
    ]),
    params: buildParams([
      { id: 'mixdown', name: 'Mixdown', value: 0, min: 0, max: 1, step: 1 },
      { id: 'stems', name: 'Stems', value: 1, min: 0, max: 1, step: 1 },
      { id: 'normalize', name: 'Normalize', value: 1, min: 0, max: 1, step: 1 },
      { id: 'dither', name: 'Dither', value: 0, min: 0, max: 1, step: 1 },
      { id: 'sample-rate', name: 'Rate', value: 48000, min: 22050, max: 96000, step: 11025, side: 'right' },
      { id: 'bit-depth', name: 'Bit', value: 24, min: 8, max: 32, step: 8, side: 'right' },
      { id: 'loop-export', name: 'Loop', value: 1, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'prepend', name: 'Count-in', value: 1, min: 0, max: 1, step: 1, side: 'right' }
    ]),
    leftModel: {
      view: 'FILE',
      title: 'File Ops',
      items: [
        { title: 'New Project', subtitle: 'Empty template' },
        { title: 'Open Recent', subtitle: 'DrumComputer_01' },
        { title: 'Save', subtitle: 'CTRL+S', active: true }
      ],
      summary: 'SHIFT: Save As'
    },
    rightModel: {
      view: 'FILE',
      title: 'Export',
      items: [
        { title: 'Audio', subtitle: 'Mixdown, Stems' },
        { title: 'MIDI', subtitle: 'All tracks' },
        { title: 'Bounce', subtitle: 'Selected pattern' }
      ],
      summary: 'Count-in & loop options'
    }
  }
]

const settingsPages: ControlPage[] = [
  {
    label: 'Settings',
    softButtons: buildSoftButtons([
      { label: 'Metronome', actionId: 'SETTINGS_METRO' },
      { label: 'Count-In', actionId: 'SETTINGS_COUNTIN' },
      { label: 'Quantize', actionId: 'SETTINGS_QUANTIZE' },
      { label: 'MIDI', actionId: 'SETTINGS_MIDI' },
      { label: 'Audio', actionId: 'SETTINGS_AUDIO' },
      { label: 'Theme', actionId: 'SETTINGS_THEME' },
      { label: 'Safe', actionId: 'SETTINGS_SAFE' },
      { label: 'Reset', actionId: 'SETTINGS_RESET' }
    ]),
    params: buildParams([
      { id: 'metro-lvl', name: 'Metro Vol', value: 72, min: 0, max: 127, step: 2 },
      { id: 'count-in', name: 'Count-In', value: 1, min: 0, max: 8, step: 1 },
      { id: 'swing', name: 'Swing', value: 8, min: 0, max: 100, step: 1 },
      { id: 'quantize', name: 'Quantize', value: 1, min: 0, max: 1, step: 1 },
      { id: 'theme', name: 'Theme', value: 0, min: 0, max: 2, step: 1, side: 'right' },
      { id: 'audio-lat', name: 'Latency', value: 5, min: 1, max: 20, step: 1, side: 'right' },
      { id: 'buffer', name: 'Buffer', value: 256, min: 64, max: 1024, step: 64, side: 'right' },
      { id: 'safety', name: 'Safe Mode', value: 1, min: 0, max: 1, step: 1, side: 'right' }
    ]),
    leftModel: {
      view: 'SETTINGS',
      title: 'System',
      items: [
        { title: 'Metronome', value: 'On' },
        { title: 'Count-In', value: '1 bar' },
        { title: 'Quantize', value: '1/16' }
      ]
    },
    rightModel: {
      view: 'SETTINGS',
      title: 'Audio/MIDI',
      items: [
        { title: 'Device', subtitle: 'Built-in Output' },
        { title: 'Buffer', subtitle: '256 samples' },
        { title: 'MIDI Input', subtitle: 'MK3 Virtual' }
      ]
    }
  }
]

const autoPages: ControlPage[] = [
  {
    label: 'Automation',
    softButtons: buildSoftButtons([
      { label: 'Write', actionId: 'AUTO_WRITE' },
      { label: 'Read', actionId: 'AUTO_READ' },
      { label: 'Latch', actionId: 'AUTO_LATCH' },
      { label: 'Touch', actionId: 'AUTO_TOUCH' },
      { label: 'Erase', actionId: 'AUTO_ERASE' },
      { label: 'Arm', actionId: 'AUTO_ARM' },
      { label: 'Hold', actionId: 'AUTO_HOLD' },
      { label: 'Clear', actionId: 'AUTO_CLEAR' }
    ]),
    params: buildParams([
      { id: 'auto-lane', name: 'Lane', value: 1, min: 1, max: 8, step: 1 },
      { id: 'auto-smooth', name: 'Smooth', value: 42, min: 0, max: 127, step: 2 },
      { id: 'auto-scale', name: 'Scale', value: 100, min: 0, max: 150, step: 5 },
      { id: 'auto-quant', name: 'Quantize', value: 1, min: 0, max: 1, step: 1 },
      { id: 'auto-protect', name: 'Protect', value: 0, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'auto-loop', name: 'Loop', value: 1, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'auto-snap', name: 'Snap', value: 1, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'auto-depth', name: 'Depth', value: 60, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'INFO',
      title: 'Automation',
      summary: 'Hold to write with encoders',
      items: [
        { title: 'Mode', value: 'Write' },
        { title: 'Lane', value: '1/8 Grid' }
      ]
    },
    rightModel: {
      view: 'INFO',
      title: 'Status',
      items: [
        { title: 'Armed', value: 'Yes' },
        { title: 'Protect', value: 'Off' },
        { title: 'Overwrite', value: 'No' }
      ]
    }
  }
]

const macroPages: ControlPage[] = [
  {
    label: 'Macro',
    softButtons: buildSoftButtons([
      { label: 'Assign', actionId: 'MACRO_ASSIGN' },
      { label: 'Clear', actionId: 'MACRO_CLEAR' },
      { label: 'Hold', actionId: 'MACRO_HOLD' },
      { label: 'Latch', actionId: 'MACRO_LATCH' },
      { label: 'Morph', actionId: 'MACRO_MORPH' },
      { label: 'Set', actionId: 'MACRO_SET', shiftLabel: 'Shift Set', shiftActionId: 'MACRO_SHIFT_SET' },
      { label: 'Store', actionId: 'MACRO_STORE' },
      { label: 'Recall', actionId: 'MACRO_RECALL' }
    ]),
    params: buildParams([
      { id: 'macro1', name: 'Macro 1', value: 40, min: 0, max: 127, step: 2 },
      { id: 'macro2', name: 'Macro 2', value: 80, min: 0, max: 127, step: 2 },
      { id: 'macro3', name: 'Macro 3', value: 64, min: 0, max: 127, step: 2 },
      { id: 'macro4', name: 'Macro 4', value: 32, min: 0, max: 127, step: 2 },
      { id: 'macro5', name: 'Macro 5', value: 20, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'macro6', name: 'Macro 6', value: 55, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'macro7', name: 'Macro 7', value: 76, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'macro8', name: 'Macro 8', value: 90, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'INFO',
      title: 'Macro Sets',
      items: [
        { title: 'Set A', subtitle: 'Live' },
        { title: 'Set B', subtitle: 'Studio', active: true },
        { title: 'Set C', subtitle: 'User' }
      ],
      summary: 'SHIFT: Macro Set'
    },
    rightModel: {
      view: 'INFO',
      title: 'Morph',
      items: [
        { title: 'Target', subtitle: 'Set B' },
        { title: 'Morph', value: '38%' }
      ]
    }
  }
]

const pagesByMode: Record<ControlMode, ControlPage[]> = {
  CHANNEL: channelPages,
  PLUGIN: pluginPages,
  ARRANGER: arrangerPages,
  MIXER: mixerPages,
  BROWSER: browserPages,
  SAMPLING: samplingPages,
  FILE: filePages,
  SETTINGS: settingsPages,
  AUTO: autoPages,
  MACRO: macroPages
}

const createInitialPageIndex = (): PageIndexByMode => {
  return MODES.reduce((acc, mode) => {
    acc[mode] = 0
    return acc
  }, {} as PageIndexByMode)
}

export const useControlStore = defineStore('control', {
  state: () => ({
    activeMode: 'BROWSER' as ControlMode,
    shiftHeld: false,
    pageIndexByMode: createInitialPageIndex(),
    pagesByMode,
    lastAction: 'Ready',
    statusFlags: {
      metronome: true,
      countIn: true,
      automationArmed: false
    }
  }),
  getters: {
    activePage(state): ControlPage {
      const pages = state.pagesByMode[state.activeMode] ?? []
      const index = state.pageIndexByMode[state.activeMode] ?? 0
      return pages[index] ?? pages[0]
    },
    pageLabel(): string {
      return this.activePage?.label ?? ''
    },
    modeTitle(state): string {
      return state.activeMode
    },
    activeSoftButtons(): SoftButton[] {
      return this.activePage?.softButtons ?? buildSoftButtons([])
    },
    softLabels(): string[] {
      return this.activeSoftButtons.map((btn) => btn.label || '')
    },
    activeParams(): EncoderParam[] {
      return this.activePage?.params ?? buildParams([])
    },
    paramSlotsLeft(): EncoderParam[] {
      return this.activeParams.filter((param) => (param.side ?? 'left') === 'left').slice(0, 4)
    },
    paramSlotsRight(): EncoderParam[] {
      return this.activeParams.filter((param) => (param.side ?? 'left') === 'right').slice(0, 4)
    },
    leftModel(): DisplayPanelModel {
      return this.activePage?.leftModel ?? { view: 'EMPTY', title: 'Empty' }
    },
    rightModel(): DisplayPanelModel {
      return this.activePage?.rightModel ?? { view: 'EMPTY', title: 'Empty' }
    }
  },
  actions: {
    setMode(mode: ControlMode) {
      this.activeMode = mode
      if (this.pageIndexByMode[mode] == null) {
        this.pageIndexByMode[mode] = 0
      }
      this.lastAction = `${mode} selected`
    },
    setShiftHeld(value: boolean) {
      this.shiftHeld = value
    },
    nextPage() {
      const pages = this.pagesByMode[this.activeMode] ?? []
      if (pages.length === 0) return
      const nextIndex = Math.min(pages.length - 1, (this.pageIndexByMode[this.activeMode] ?? 0) + 1)
      this.pageIndexByMode[this.activeMode] = nextIndex
      this.lastAction = `${this.activeMode} page: ${pages[nextIndex]?.label ?? ''}`
    },
    prevPage() {
      const pages = this.pagesByMode[this.activeMode] ?? []
      if (pages.length === 0) return
      const nextIndex = Math.max(0, (this.pageIndexByMode[this.activeMode] ?? 0) - 1)
      this.pageIndexByMode[this.activeMode] = nextIndex
      this.lastAction = `${this.activeMode} page: ${pages[nextIndex]?.label ?? ''}`
    },
    pressSoftButton(index: number) {
      const btn = this.activeSoftButtons[index]
      if (!btn || btn.enabled === false) return
      const actionId = this.shiftHeld && btn.shiftActionId ? btn.shiftActionId : btn.actionId
      this.applyAction(actionId, btn.label)
    },
    applyAction(actionId: string, label?: string) {
      switch (actionId) {
        case 'BROWSER_PLUGIN_MENU':
        case 'PLUGIN_INSTANCE':
        case 'PLUGIN_SWAP':
        case 'CHANNEL_SOUND':
        case 'CHANNEL_GROUP':
        case 'CHANNEL_MASTER':
          this.lastAction = label ? `${label} triggered` : actionId
          break
        case 'FILE_SAVE':
        case 'FILE_SAVE_AS':
          this.lastAction = 'Project saved (demo)'
          break
        case 'SETTINGS_METRO':
          this.statusFlags.metronome = !this.statusFlags.metronome
          this.lastAction = `Metronome ${this.statusFlags.metronome ? 'On' : 'Off'}`
          break
        case 'SETTINGS_COUNTIN':
          this.statusFlags.countIn = !this.statusFlags.countIn
          this.lastAction = `Count-in ${this.statusFlags.countIn ? 'On' : 'Off'}`
          break
        case 'AUTO_ARM':
          this.statusFlags.automationArmed = !this.statusFlags.automationArmed
          this.lastAction = `Automation ${this.statusFlags.automationArmed ? 'Armed' : 'Disarmed'}`
          break
        default:
          this.lastAction = label ? `${label} triggered` : actionId
      }
    },
    turnEncoder(index: number, delta: number, options?: { fine?: boolean }) {
      const page = this.activePage
      if (!page) return
      const params = page.params
      const param = params[index]
      if (!param) return
      const step = options?.fine ? param.fineStep ?? Math.max(0.25, param.step / 4) : param.step
      const nextValue = clamp(param.value + delta * step, param.min, param.max)
      param.value = nextValue
      this.lastAction = `${param.name}: ${Math.round(nextValue * 100) / 100}${param.format ? ` ${param.format}` : ''}`
    },
    turnEncoderById(id: string, delta: number, options?: { fine?: boolean }) {
      const params = this.activeParams
      const index = params.findIndex((param) => param.id === id)
      if (index >= 0) {
        this.turnEncoder(index, delta, options)
      }
    }
  }
})



=========================================
File: stores/patterns.ts
=========================================

import { defineStore } from 'pinia'
import type { DrumPadId, Pattern, Scene, StepGrid } from '@/types/drums'
import type { GridSpec } from '@/types/time'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'

// Manages patterns and scenes with undo/redo history, grid spec updates, and step velocity editing.
const createDefaultGrid = (): GridSpec => ({ ...DEFAULT_GRID_SPEC })

const createEmptyPattern = (id: string, name: string): Pattern => ({
  id,
  name,
  gridSpec: createDefaultGrid(),
  steps: {}
})

const createScene = (id: string, name: string, patternIds: string[] = []): Scene => ({
  id,
  name,
  patternIds
})

const HISTORY_LIMIT = 50

type PatternsSnapshot = {
  patterns: Pattern[]
  scenes: Scene[]
  selectedPatternId: string
  activeSceneId: string | null
}

export const usePatternsStore = defineStore('patterns', {
  state: () => ({
    patterns: [createEmptyPattern('pattern-1', 'Pattern 1')],
    scenes: [] as Scene[],
    selectedPatternId: 'pattern-1',
    activeSceneId: null as string | null,
    scenePosition: 0,
    history: [] as PatternsSnapshot[],
    historyIndex: -1,
    isRestoring: false
  }),
  getters: {
    currentPattern(state): Pattern {
      return state.patterns.find((p) => p.id === state.selectedPatternId) ?? createEmptyPattern('pattern-1', 'Pattern 1')
    },
    currentScene(state): Scene | null {
      return state.scenes.find((scene) => scene.id === state.activeSceneId) ?? null
    }
  },
  actions: {
    snapshotState(): PatternsSnapshot {
      return {
        patterns: JSON.parse(JSON.stringify(this.patterns)) as Pattern[],
        scenes: JSON.parse(JSON.stringify(this.scenes)) as Scene[],
        selectedPatternId: this.selectedPatternId,
        activeSceneId: this.activeSceneId
      }
    },
    recordHistory() {
      if (this.isRestoring) return
      const snapshot = this.snapshotState()
      this.history = this.history.slice(0, this.historyIndex + 1)
      this.history.push(snapshot)
      if (this.history.length > HISTORY_LIMIT) {
        this.history.shift()
        this.historyIndex -= 1
      }
      this.historyIndex = this.history.length - 1
    },
    restoreSnapshot(snapshot: PatternsSnapshot) {
      this.isRestoring = true
      this.patterns = snapshot.patterns.map((pattern) => ({
        ...pattern,
        gridSpec: normalizeGridSpec(pattern.gridSpec)
      }))
      this.setScenes(snapshot.scenes)
      this.selectedPatternId = snapshot.selectedPatternId
      if (!this.patterns.find((pattern) => pattern.id === this.selectedPatternId)) {
        this.selectedPatternId = this.patterns[0]?.id ?? 'pattern-1'
      }
      this.activeSceneId = snapshot.activeSceneId
      this.scenePosition = 0
      this.isRestoring = false
    },
    undo() {
      if (this.historyIndex <= 0) return
      this.historyIndex -= 1
      const snapshot = this.history[this.historyIndex]
      if (snapshot) {
        this.restoreSnapshot(snapshot)
      }
    },
    redo() {
      if (this.historyIndex >= this.history.length - 1) return
      this.historyIndex += 1
      const snapshot = this.history[this.historyIndex]
      if (snapshot) {
        this.restoreSnapshot(snapshot)
      }
    },
    selectPattern(id: string) {
      this.selectedPatternId = id
    },
    addPattern(name?: string) {
      this.recordHistory()
      const nextIndex = this.patterns.length + 1
      const id = `pattern-${Date.now()}-${nextIndex}`
      const pattern = createEmptyPattern(id, name ?? `Pattern ${nextIndex}`)
      this.patterns.push(pattern)
      this.selectedPatternId = pattern.id
    },
    renamePattern(id: string, name: string) {
      this.recordHistory()
      const pattern = this.patterns.find((entry) => entry.id === id)
      if (pattern) {
        pattern.name = name
      }
    },
    setScenes(scenes: Scene[]) {
      const allowedIds = this.patterns.map((pattern) => pattern.id)
      this.scenes = scenes.map((scene) => ({
        ...scene,
        patternIds: scene.patternIds.filter((id) => allowedIds.includes(id))
      }))
      if (this.activeSceneId && !this.scenes.find((scene) => scene.id === this.activeSceneId)) {
        this.activeSceneId = null
        this.scenePosition = 0
      }
    },
    setPatterns(patterns: Pattern[]) {
      this.patterns = patterns.length ? patterns : [createEmptyPattern('pattern-1', 'Pattern 1')]
      if (!this.patterns.find((pattern) => pattern.id === this.selectedPatternId)) {
        this.selectedPatternId = this.patterns[0]?.id ?? 'pattern-1'
      }
      const allowedIds = this.patterns.map((pattern) => pattern.id)
      this.scenes = this.scenes.map((scene) => ({
        ...scene,
        patternIds: scene.patternIds.filter((id) => allowedIds.includes(id))
      }))
      if (this.activeSceneId && !this.scenes.find((scene) => scene.id === this.activeSceneId)) {
        this.activeSceneId = null
        this.scenePosition = 0
      }
    },
    toggleStep(barIndex: number, stepInBar: number, padId: DrumPadId) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      const bar = grid[barIndex] ?? {}
      const stepRow = bar[stepInBar] ?? {}
      const updated = { ...stepRow }
      const nextVelocity = cycleVelocity(updated[padId]?.velocity?.value)
      if (nextVelocity === null) {
        delete updated[padId]
      } else {
        updated[padId] = { velocity: { value: clampVelocity(nextVelocity) } }
      }
      grid[barIndex] = { ...bar, [stepInBar]: updated }
    },
    setStepVelocity(barIndex: number, stepInBar: number, padId: DrumPadId, velocity: number) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      const bar = grid[barIndex] ?? {}
      const stepRow = bar[stepInBar] ?? {}
      const updated = { ...stepRow }
      updated[padId] = { velocity: { value: clampVelocity(velocity || DEFAULT_STEP_VELOCITY) } }
      grid[barIndex] = { ...bar, [stepInBar]: updated }
    },
    eraseStepForPad(barIndex: number, stepInBar: number, padId: DrumPadId) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      const bar = grid[barIndex] ?? {}
      const stepRow = bar[stepInBar] ?? {}
      if (stepRow && stepRow[padId]) {
        const updated = { ...stepRow }
        delete updated[padId]
        grid[barIndex] = { ...bar, [stepInBar]: updated }
      }
    },
    erasePadEvents(padId: DrumPadId) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      Object.entries(grid).forEach(([barIndex, bar]) => {
        const barIdx = Number(barIndex)
        Object.entries(bar ?? {}).forEach(([stepIndex, row]) => {
          if (row && row[padId]) {
            const updated = { ...row }
            delete updated[padId]
            grid[barIdx] = { ...(grid[barIdx] ?? {}), [Number(stepIndex)]: updated }
          }
        })
      })
    },
    eraseAutomationForPad(padId: DrumPadId) {
      // Placeholder: no automation envelope stored yet; reuse pad erase.
      this.erasePadEvents(padId)
    },
    updateGridSpec(gridSpec: GridSpec) {
      this.recordHistory()
      const pattern = this.currentPattern
      pattern.gridSpec = normalizeGridSpec(gridSpec)
    },
    addScene(name: string, patternIds: string[] = []) {
      this.recordHistory()
      const id = `scene-${Date.now()}-${this.scenes.length + 1}`
      this.scenes.push(createScene(id, name, patternIds))
      this.activeSceneId = id
      this.scenePosition = 0
    },
    updateScene(sceneId: string, updates: Partial<Scene>) {
      this.recordHistory()
      const scene = this.scenes.find((entry) => entry.id === sceneId)
      if (!scene) return
      if (updates.name) {
        scene.name = updates.name
      }
      if (updates.patternIds) {
        const allowed = this.patterns.map((pattern) => pattern.id)
        scene.patternIds = updates.patternIds.filter((id) => allowed.includes(id))
      }
    },
    selectScene(sceneId: string | null) {
      this.activeSceneId = sceneId
      this.scenePosition = 0
    },
    prepareScenePlayback() {
      this.scenePosition = 0
      const scene = this.currentScene
      if (scene && scene.patternIds.length > 0) {
        const nextId = scene.patternIds[0]
        if (nextId) {
          this.selectedPatternId = nextId
        }
        this.scenePosition = scene.patternIds.length > 1 ? 1 : 0
      }
    },
    advanceScenePlayback(): Pattern {
      const scene = this.currentScene
      if (!scene || scene.patternIds.length === 0) {
        return this.currentPattern
      }
      const nextId = scene.patternIds[this.scenePosition % scene.patternIds.length]
      this.scenePosition = (this.scenePosition + 1) % scene.patternIds.length
      if (nextId) {
        this.selectedPatternId = nextId
      }
      return this.currentPattern
    }
  }
})



=========================================
File: stores/session.ts
=========================================

import { defineStore } from 'pinia'
import type { MidiDeviceInfo } from '@/types/midi'

export const useSessionStore = defineStore('session', {
  state: () => ({
    midiInput: undefined as MidiDeviceInfo | undefined,
    midiOutput: undefined as MidiDeviceInfo | undefined,
    audioReady: false,
    capabilities: {
      supportsWebMIDI: false,
      supportsAudioInput: false
    }
  }),
  actions: {
    setMidiInput(device?: MidiDeviceInfo) {
      this.midiInput = device
    },
    setMidiOutput(device?: MidiDeviceInfo) {
      this.midiOutput = device
    },
    setAudioReady(isReady: boolean) {
      this.audioReady = isReady
    },
    setCapabilities(capabilities: { supportsWebMIDI: boolean; supportsAudioInput: boolean }) {
      this.capabilities = capabilities
    }
  }
})



=========================================
File: stores/soundbanks.ts
=========================================

import { defineStore } from 'pinia'
import type { Soundbank } from '@/types/audio'

export const useSoundbanksStore = defineStore('soundbanks', {
  state: () => ({
    banks: [] as Soundbank[],
    selectedBankId: ''
  }),
  getters: {
    currentBank(state): Soundbank | undefined {
      return state.banks.find((bank) => bank.id === state.selectedBankId)
    }
  },
  actions: {
    setBanks(banks: Soundbank[]) {
      this.banks = banks
      if (!this.selectedBankId && banks.length > 0) {
        const first = banks[0]
        if (first) {
          this.selectedBankId = first.id
        }
      }
    },
    selectBank(id: string) {
      this.selectedBankId = id
    },
    upsertBank(bank: Soundbank) {
      const index = this.banks.findIndex((b) => b.id === bank.id)
      if (index >= 0) {
        this.banks.splice(index, 1, bank)
      } else {
        this.banks.push(bank)
      }
    }
  }
})



=========================================
File: stores/transport.ts
=========================================

import { defineStore } from 'pinia'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import type { GridSpec } from '@/types/time'

export const useTransportStore = defineStore('transport', {
  state: () => ({
    bpm: 120,
    isPlaying: false,
    loop: true,
    gridSpec: { ...DEFAULT_GRID_SPEC } as GridSpec,
    currentStep: 0,
    isRecording: false,
    countInEnabled: false,
    countInBars: 1,
    metronomeEnabled: false,
    metronomeVolume: 0.12,
    followEnabled: true,
    loopStart: 0,
    loopEnd: DEFAULT_GRID_SPEC.bars * DEFAULT_GRID_SPEC.division
  }),
  actions: {
    setBpm(bpm: number) {
      this.bpm = bpm
    },
    setPlaying(isPlaying: boolean) {
      this.isPlaying = isPlaying
    },
    setGridSpec(gridSpec: GridSpec) {
      const prevTotal = this.gridSpec.bars * this.gridSpec.division
      this.gridSpec = normalizeGridSpec(gridSpec)
      const nextTotal = this.gridSpec.bars * this.gridSpec.division
      if (prevTotal > 0 && nextTotal > 0) {
        const startRatio = this.loopStart / prevTotal
        const endRatio = this.loopEnd / prevTotal
        const nextStart = Math.floor(startRatio * nextTotal)
        const nextEnd = Math.max(nextStart + 1, Math.round(endRatio * nextTotal))
        this.setLoopRange(nextStart, nextEnd)
      } else {
        this.setLoopRange(0, nextTotal)
      }
    },
    setLoop(loop: boolean) {
      this.loop = loop
    },
    setCurrentStep(step: number) {
      this.currentStep = step
    },
    setRecording(isRecording: boolean) {
      this.isRecording = isRecording
    },
    setCountInEnabled(enabled: boolean) {
      this.countInEnabled = enabled
    },
    setCountInBars(bars: number) {
      const normalized = Math.max(1, Math.floor(bars))
      this.countInBars = normalized
    },
    setMetronomeEnabled(enabled: boolean) {
      this.metronomeEnabled = enabled
    },
    setMetronomeVolume(volume: number) {
      const clamped = Math.max(0, Math.min(1, volume))
      this.metronomeVolume = clamped
    },
    setFollowEnabled(enabled: boolean) {
      this.followEnabled = enabled
    },
    setLoopRange(start: number, end: number) {
      const total = this.gridSpec.bars * this.gridSpec.division
      const clampedStart = Math.max(0, Math.min(start, total - 1))
      const clampedEnd = Math.max(clampedStart + 1, Math.min(end, total))
      this.loopStart = clampedStart
      this.loopEnd = clampedEnd
    },
    nudgeLoopRange(delta: number) {
      const length = this.loopEnd - this.loopStart
      this.setLoopRange(this.loopStart + delta, this.loopStart + delta + length)
    }
  }
})



=========================================
File: styles/drum-machine.less
=========================================

@import 'variables.less';

body {
  background: @background;
  color: #fff;
  margin: 0;
}



=========================================
File: styles/globals.less
=========================================

@import '@/styles/variables.less';

html, body, #__nuxt {
  height: 100%;
  margin: 0;
  overflow: hidden;
}

body {
  background: @color-bg-root;
}

:deep(.v-application) {
  height: 100%;
}



=========================================
File: styles/variables.less
=========================================

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Root / Background */
@color-bg-root: #121212;
@bg-cell: linear-gradient(180deg, #1b1c20, #0f1013);
/* Surfaces */
@color-surface-1: #0f1115;  /* Panels, Transport */
@color-surface-2: #0a0d12;  /* Pads, deeper layers */
@color-surface-3: #080b10;  /* Drawer / FX */

/* Borders / Divider */
@color-border-1: #1d2430;
@color-border-2: #1f2838;
@color-border-3: #f2f1e8;

/* Text */
@color-text-primary: #f5f7fb;
@color-text-secondary: rgba(245, 247, 251, 0.65);
@color-text-muted: rgba(245, 247, 251, 0.4);

/* Akzent */
@color-accent-primary: #00f8ff;
@color-accent-warning: #ffc952;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Shadows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@shadow-box: inset 0 1px 0 rgba(255,255,255,0.04), 
  inset 0 -2px 4px rgba(0,0,0,0.6);

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Spacing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@space-xxs: 2px;
@space-2xs: 4px;
@space-xs: 8px;
@space-s: 12px;
@space-m: 16px;
@space-l: 24px;
@space-xl: 32px;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Pad LEDs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@pad-led-active: @color-accent-primary;
@pad-led-selected: @color-border-3;
@pad-led-idle: @bg-cell;


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Radii â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@radius-xs: 4px;
@radius-s: 6px;
@radius-xm: 8px;
@radius-m: 12px;
@radius-l: 16px;
@radius-xl: 20px;


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Typography (Base) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@font-size-xs: 0.7rem;
@font-size-s: 0.8rem;
@font-size-m: 0.9rem;
@font-size-l: 1rem;

@letter-spacing-tight: 0.1em;
@letter-spacing-wide: 0.2em;
@letter-spacing-xwide: 0.3em;


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@outline-focus: 2px dashed @color-accent-primary;
@outline-focus-offset: 3px;



=========================================
File: styles/vuetify-overrides.less
=========================================

@import 'variables.less';

html,
body {
  height: 100%;
  min-height: 100%;
  margin: 0;
}

body {
  overflow: hidden;
}

#app,
#__nuxt,
.v-application,
.v-application--wrap {
  height: 100%;
  min-height: 100%;
  display: flex;
  flex-direction: column;
}

.v-main {
  flex: 1 1 auto;
  min-height: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.v-application {
  background-color: @background !important;
}



=========================================
File: tests/componentTests/PadCell.component.spec.ts
=========================================

import { describe, it } from 'mocha'
import { expect } from 'chai'
import { mount } from '@vue/test-utils'
import PadCell from '../components/PadCell.vue'

describe('PadCell', () => {
  it('renders label', () => {
    const wrapper = mount(PadCell, {
      props: {
        padId: 'pad1',
        label: 'Kick'
      }
    })

    expect(wrapper.text()).to.equal('Kick')
  })

  it('emits pad:down on pointerdown', async () => {
    const wrapper = mount(PadCell, {
      props: {
        padId: 'pad1',
        label: 'Kick'
      }
    })

    await wrapper.trigger('pointerdown')

    const emitted = wrapper.emitted('pad:down')

    expect(emitted).to.be.an('array')
    expect(emitted).to.have.lengthOf(1)
    if (emitted && emitted[0]) {
      expect(emitted[0][0]).to.equal('pad1')
    }
  })

  it('applies is-playing class', () => {
    const wrapper = mount(PadCell, {
      props: {
        padId: 'pad1',
        label: 'Kick',
        isPlaying: true
      }
    })

    expect(wrapper.classes()).to.include('is-playing')
  })
})



=========================================
File: tests/componentTests/PadGrid.component.spec.ts
=========================================

import { describe, it } from 'mocha'
import { expect } from 'chai'
import { mount } from '@vue/test-utils'
import PadGrid from '../components/PadGrid.vue'

describe('PadGrid', () => {
  const pads = ['pad1', 'pad2']

  it('renders PadCell components', () => {
    const wrapper = mount(PadGrid, {
      props: { pads, selectedPad: null, padStates: {} }
    })

    expect(wrapper.findAllComponents({ name: 'PadCell' }))
      .to.have.lengthOf(2)
  })

  it('emits pad:select when PadCell emits', async () => {
    const wrapper = mount(PadGrid, {
      props: { pads, selectedPad: null, padStates: {} }
    })

    await wrapper.findComponent({ name: 'PadCell' })
      .vm.$emit('pad:select', 'pad1')

    const emitted = wrapper.emitted('pad:select') as unknown[][]
    const payload = emitted
    expect(emitted).to.be.an('array')
    expect(emitted!.length).to.equal(1)
    expect(payload).to.equal('pad1')

  })

  it('passes is-selected correctly', () => {
    const wrapper = mount(PadGrid, {
      props: { pads, selectedPad: 'pad1', padStates: {} }
    })

    const cells = wrapper.findAllComponents({ name: 'PadCell' })
    expect(cells).to.have.lengthOf(2)

    expect(cells[0]!.props('isSelected')).to.equal(true)
    expect(cells[1]!.props('isSelected')).to.equal(false)
  })
})



=========================================
File: tests/unitTests/transportEngine.spec.ts
=========================================

import { describe, it, beforeEach } from 'mocha'
import { expect } from 'chai'
import { createTransportEngine } from '@/domain/transport/transportEngine'
import type { RenderClock } from '@/domain/clock/renderClock'
import type { Scheduler, ScheduledFn } from '@/domain/clock/scheduler'
import type { TransportAudioHooks } from '@/domain/transport/audioHooks'
import type { TransportConfig, TransportState } from '@/domain/transport/types'

type ScheduledCall = { at: number; fn: ScheduledFn }

const createTestClock = (
  initialTime = 0
): { clock: RenderClock; setTime: (next: number) => void } => {
  let now = initialTime

  const clock: RenderClock = {
    ctx: {} as BaseAudioContext,
    isOffline: false,
    audioTime: () => now,
    now: () => now
  }

  return {
    clock,
    setTime: (next: number) => {
      now = next
    }
  }
}

const createStubScheduler = (): {
  scheduler: Scheduler
  calls: ScheduledCall[]
  counts: () => { start: number; stop: number; clear: number }
} => {
  const calls: ScheduledCall[] = []
  let start = 0
  let stop = 0
  let clear = 0

  const scheduler: Scheduler = {
    start(): void {
      start += 1
    },
    stop(): void {
      stop += 1
    },
    schedule(atTimeSec: number, fn: ScheduledFn): void {
      calls.push({ at: atTimeSec, fn })
    },
    clear(): void {
      clear += 1
      calls.length = 0
    }
  }

  return {
    scheduler,
    calls,
    counts: () => ({ start, stop, clear })
  }
}

describe('transportEngine', () => {
  const baseConfig: TransportConfig = {
    bpm: 120,
    gridSpec: { bars: 1, division: 4 }
  }

  let states: TransportState[]

  beforeEach(() => {
    states = []
  })

  it('starts playback, emits state and schedules the first boundary', () => {
    const { clock, setTime } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)

    const unsubscribe = engine.subscribe((state) => states.push(state))
    expect(states).to.deep.equal([{ isPlaying: false, currentStep: 0 }])

    engine.start()
    setTime(0.1)

    const lastState = states[states.length - 1]
    expect(lastState).to.deep.equal({ isPlaying: true, currentStep: 0 })

    const counts = schedulerStub.counts()
    expect(counts.start).to.equal(1)
    expect(counts.clear).to.equal(1)
    expect(schedulerStub.calls).to.have.lengthOf(1)
    expect(schedulerStub.calls[0]!.at).to.be.closeTo(0.5, 0.0001)

    unsubscribe()
  })

  it('advances steps on tick and schedules subsequent boundaries', () => {
    const { clock, setTime } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)
    engine.subscribe((state) => states.push(state))

    engine.start()
    setTime(0.51)
    engine.tick()

    const lastState = states[states.length - 1]
    expect(lastState).to.deep.equal({ isPlaying: true, currentStep: 1 })
    expect(schedulerStub.calls).to.have.lengthOf(2)
    expect(schedulerStub.calls[1]!.at).to.be.closeTo(1, 0.0001)
  })

  it('stops playback, clears scheduler, and ignores further ticks', () => {
    const { clock } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)
    engine.subscribe((state) => states.push(state))

    engine.start()
    schedulerStub.calls.length = 0

    engine.stop()
    const counts = schedulerStub.counts()
    expect(counts.stop).to.equal(1)
    expect(counts.clear).to.equal(2)

    const lastState = states[states.length - 1]
    expect(lastState).to.deep.equal({ isPlaying: false, currentStep: 3 })

    engine.tick()
    expect(schedulerStub.calls).to.have.lengthOf(0)
  })

  it('keeps phase stable when the config changes during playback', () => {
    const { clock, setTime } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)
    engine.subscribe((state) => states.push(state))

    engine.start()
    setTime(0.51)
    engine.tick()

    expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 1 })

    engine.setConfig({
      bpm: 120,
      gridSpec: { bars: 1, division: 8 }
    })

    expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 1 })

    setTime(0.76)
    engine.tick()

    expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 2 })
    expect(schedulerStub.calls).to.have.lengthOf(3)
    expect(schedulerStub.calls[2]!.at).to.be.closeTo(1.01, 0.0001)
  })

  it('applies swing offset to off-beat scheduling and forwards onStep callbacks', () => {
    const { clock } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const hookCalls: Array<{ stepIndex: number; audioTime: number }> = []

    const audioHooks: TransportAudioHooks = {
      onStep(stepIndex, audioTime) {
        hookCalls.push({ stepIndex, audioTime })
      }
    }

    const engine = createTransportEngine(
      clock,
      schedulerStub.scheduler,
      {
        bpm: 120,
        gridSpec: { bars: 1, division: 4 },
        swing: 0.5
      },
      audioHooks
    )

    engine.subscribe((state) => states.push(state))
    engine.start()

    expect(schedulerStub.calls[0]!.at).to.be.closeTo(0.625, 0.0001)

    schedulerStub.calls[0]!.fn(schedulerStub.calls[0]!.at)
    expect(hookCalls).to.deep.equal([
      { stepIndex: 1, audioTime: schedulerStub.calls[0]!.at }
    ])
  })
})



=========================================
File: tsconfig.json
=========================================

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist-test",
    "module": "ESNext",
    "target": "ES2022",
    "moduleResolution": "Node",
    "types": ["node", "mocha"],
    "sourceMap": true,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "tests/**/*.ts",
    "components/**/*.vue",
    "composables/**/*.ts",
    "utils/**/*.ts",
    "stores/**/*.ts",
    "./tests/*.spec.ts",
    "./components/**/*.vue",
    "./types/**/*.d.ts"
  ]
}



=========================================
File: tsconfig.test.json
=========================================

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "dist-test",
    "module": "ESNext",
    "target": "ES2022",
    "moduleResolution": "Node",
    "types": ["node", "mocha"],
    "sourceMap": true
  },
  "include": [
    "tests/**/*.ts",
    "components/**/*.vue",
    "composables/**/*.ts",
    "utils/**/*.ts",
    "stores/**/*.ts",
    "./tests/*.spec.ts",
    "./components/**/*.vue",
    "./types/**/*.d.ts"

  ]
}



=========================================
File: types/audio.ts
=========================================

import type { DrumPadId } from './drums'

export type AudioFormat = 'wav' | 'mp3' | 'ogg' | 'aac' | 'flac'

export interface SampleRef {
  id: string
  name: string
  url?: string
  buffer?: AudioBuffer
  format?: AudioFormat
  blob?: Blob
}

export interface Soundbank {
  id: string
  name: string
  pads: Partial<Record<DrumPadId, SampleRef>>
  createdAt: number
  updatedAt: number
}

export interface AudioRouting {
  masterGain: number
}

export interface FxSettings {
  filter: {
    enabled: boolean
    frequency: number
    q: number
  }
  drive: {
    enabled: boolean
    amount: number
  }
  reverb: {
    enabled: boolean
    mix: number
  }
}



=========================================
File: types/drums.ts
=========================================

import type { GridSpec, StepAddress } from './time'

export type DrumPadId =
  | 'pad1'
  | 'pad2'
  | 'pad3'
  | 'pad4'
  | 'pad5'
  | 'pad6'
  | 'pad7'
  | 'pad8'
  | 'pad9'
  | 'pad10'
  | 'pad11'
  | 'pad12'
  | 'pad13'
  | 'pad14'
  | 'pad15'
  | 'pad16'

export interface Velocity {
  value: number
}

export interface StepCell {
  velocity?: Velocity
}

export type StepGrid = Record<number, Record<number, Partial<Record<DrumPadId, StepCell>>>>

export interface Pattern {
  id: string
  name: string
  gridSpec: GridSpec
  steps: StepGrid
}

export interface Scene {
  id: string
  name: string
  patternIds: string[]
}

export interface PadEvent {
  padId: DrumPadId
  time: number
  velocity: number
}

export interface QuantizedPadEvent extends PadEvent {
  step: StepAddress
}



=========================================
File: types/file-saver.d.ts
=========================================

declare module 'file-saver' {
  export function saveAs(data: Blob | File | string, filename?: string, options?: Record<string, unknown>): void
}



=========================================
File: types/midi.ts
=========================================

import type { DrumPadId } from './drums'

export interface MidiDeviceInfo {
  id: string
  name: string
  type: 'input' | 'output'
}

export type MidiMessageType = 'noteon' | 'noteoff' | 'clock' | 'start' | 'stop' | 'continue' | 'cc'

export interface MidiMessage {
  type: MidiMessageType
  channel?: number
  note?: number
  velocity?: number
  controller?: number
  value?: number
}

export interface MidiMapping {
  noteMap: Partial<Record<number, DrumPadId>>
  noteMapInverse?: Partial<Record<DrumPadId, number>>
  transportMap?: Partial<Record<'play' | 'stop' | 'bpmUp' | 'bpmDown', number>>
}

export interface MidiFileEvent {
  deltaTime: number
  message: MidiMessage
}

export interface MidiTrack {
  name: string
  events: MidiFileEvent[]
}

export interface MidiFileData {
  header: {
    ticksPerBeat: number
  }
  tracks: MidiTrack[]
}



=========================================
File: types/persistence.ts
=========================================

import type { Pattern, Scene } from './drums'
import type { Soundbank, SampleRef } from './audio'
import type { MidiMapping } from './midi'

export interface PersistedState {
  patterns: Pattern[]
  scenes: Scene[]
  soundbanks: Soundbank[]
  samples: SampleRef[]
  mappings: MidiMapping[]
}



=========================================
File: types/process.d.ts
=========================================

declare namespace NodeJS {
  interface Process {
    dev?: boolean
    client?: boolean
  }
}




=========================================
File: types/render.ts
=========================================

import type { DrumPadId } from './drums'
import type { GridSpec } from './time'

export interface RenderMetadata {
  seed: string
  bpm: number
  gridSpec: GridSpec
  sceneId: string | null
  patternChain: string[]
  initialPatternId: string
  durationSec: number
}

export interface RenderEvent {
  time: number
  padId: DrumPadId
  velocity: number
}



=========================================
File: types/shims-vue.d.ts
=========================================

/* eslint-disable @typescript-eslint/no-explicit-any */


declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

interface ImportMeta {
  readonly env?: Record<string, any>;
}




=========================================
File: types/sync.ts
=========================================

export type SyncMode = 'internal' | 'midiClock' | 'abletonLink'
export type SyncRole = 'master' | 'slave'
export type ClockAuthority = 'audioContext'
export type SyncBpmSource = 'transport'

export interface SyncState {
  bpm: number
  phase: number
  isPlaying: boolean
  mode: SyncMode
  role: SyncRole
  linkAvailable?: boolean
  clockAuthority: ClockAuthority
  bpmSource: SyncBpmSource
}



=========================================
File: types/time.ts
=========================================

export type TimeDivision = 1 | 2 | 4 | 8 | 16 | 32 | 64

export interface TimeSignature {
  numerator: 4
  denominator: 4
}

export interface GridSpec {
  bars: 1 | 2 | 4 | 8
  division: TimeDivision
}

export interface StepAddress {
  barIndex: number
  stepInBar: number
}



=========================================
File: uiList.json
=========================================

{
  "missing_ui_ux": [
    "Pad/Group-LED-Feedback: Visualisierung von Pad- und Group-Status (Farben, Dim/Off, Choke, Create)",
    "Soft Button Overlays: Dynamische Soft-Button-Beschriftungen und KontextmenÃ¼s Ã¼ber den Displays",
    "4D-Encoder-Navigation: UI-Elemente fÃ¼r Richtungsnavigation, Listen-Browsing, AuswahlbestÃ¤tigung (Push)",
    "Selector-Listen-Overlays: Wertelisten bei Touch/Turn von Parametern (Knobs)",
    "Mode-Pinning: UI-Feedback fÃ¼r gepinnte Modi (Mute/Solo/Select etc.)",
    "Shift-Layer-Feedback: Sichtbare Shift-Zweitbelegungen und aktiver Shift-Status",
    "Transport-Panel: Play/Stop/Record/Restart/Loop/Metronom/Follow/Count-In/Pattern-Preset/Tempo-Tap",
    "Loop-Range-UI: Visuelle Loop-Bereiche, Endpunkt-Anpassung (Push+Turn)",
    "Grid-Mode-Panel: Grid- und Nudge-Settings, Step/Arrange/Perform-Grid-Auswahl",
    "Erase-Panel: Live-Erase, Pad/Group-Event-LÃ¶schen, Automation-Erase",
    "Channel-Properties-Panel: Control-Mode fÃ¼r Sound/Group/Master, Parameter-Soft-Buttons/Knobs",
    "MIDI-Mode-Umschaltung: UI fÃ¼r Wechsel in den MIDI-Controller-Modus",
    "Pattern/Scene-Chain-UI: Pattern-LÃ¤nge, Preset-Mode, Scene- und Pattern-Management",
    "Pad-Label/Key-Label-Feedback: Sichtbare Pad-Beschriftungen, Velocity/Accent-Visualisierung",
    "Undo/Redo-UI: Sichtbare History-Steuerung fÃ¼r Pattern/Scene-Edits",
    "Accessibility: Fokussteuerung, ARIA-Labels, Tastatur-Navigation fÃ¼r alle Controls",
    "BFCache/State-Restore-Feedback: UI fÃ¼r Suspend/Resume, Audio/MIDI/Media-Input-Status",
    "Debug/Timeline-Panel: Scheduler/Playback-Timeline fÃ¼r Dev-Mode"
  ],
  "interaction_primitives": [
    "press: Kurzer Tastendruck",
    "press_twice: Zweimal drÃ¼cken (Toggle/Stop)",
    "hold: GedrÃ¼ckt halten (Momentary Mode)",
    "hold_combo: GedrÃ¼ckt halten + weiteres Element",
    "shift_combo: SHIFT gedrÃ¼ckt halten + Element",
    "turn: Drehen (Endlos/Rotary)",
    "touch: BerÃ¼hren (Touch-Erkennung)",
    "slide: Fingerbewegung Ã¼ber Touch-Strip",
    "push_turn: Encoder drÃ¼cken + drehen",
    "tilt: 4D-Encoder Richtung",
    "confirm: Auswahl bestÃ¤tigen (Encoder drÃ¼cken)"
  ],
  "global_behaviors": [
    "Shift-Layer: Viele Controls mit SHIFT-Zweitfunktion, UI muss Shift-Status und Zweitbelegung anzeigen.",
    "Mode-Pinning: Modus-Tasten (Mute/Solo/Select/...) kÃ¶nnen per Soft Button 1 gepinnt werden, UI-Feedback fÃ¼r Pin-Status.",
    "Soft Buttons & Knobs: KontextabhÃ¤ngige Beschriftung/Overlays, dynamisch im Display/GUI.",
    "4D-Encoder: Richtungsnavigation, Listen-Browsing, Push-BestÃ¤tigung, LED-Feedback fÃ¼r Richtungen.",
    "Selector-Listen: Touch auf Knob blendet Werteliste im Display ein, nur eine Liste gleichzeitig sichtbar."
  ],
  "hardware_zones": [
    "Control Zone: 2x6 Buttons (CHANNEL, PLUG-IN, ARRANGER, ...)",
    "Screen Button Zone: Soft Buttons 1â€“8 Ã¼ber den Displays",
    "Displays: 2x (links/rechts)",
    "Screen Knob Zone: 8 Touch-Knobs unter den Displays",
    "Pad Input Mode Zone: 5 Buttons (FIXED VEL, PAD MODE, ...)",
    "Edit Zone: 4D-Encoder + Quick Edit Buttons (VOLUME, SWING, TEMPO)",
    "Performance Zone: Note Repeat, Lock, Strip Mode Buttons, Smart Strip",
    "Group Buttons Zone: 2x4 Buttons (Aâ€“H)",
    "Transport Zone: 2x4 Buttons (RESTART, ERASE, TAP, FOLLOW, PLAY, REC, STOP, SHIFT)",
    "Pad Mode Zone: 8 vertikale Mode-Buttons (SCENE, PATTERN, ...)",
    "Pad Zone: 16 velocity-sensitive RGB Pads (4x4)"
  ],
  "gui_hints": [
    "Buttons: Einfarbig (weiÃŸ), ZustÃ¤nde: off, dim, bright, pinned",
    "Pads: RGB, ZustÃ¤nde: off/dim/half/bright, Kontext: Mute/Solo/Pattern/Slots",
    "Group Buttons: Farbkodiert, dim white fÃ¼r Create",
    "Soft Buttons/Knobs: KontextabhÃ¤ngige Beschriftung/Overlays",
    "Overlay-Icons fÃ¼r Zoom/Scroll bei Touch auf Knobs 5â€“8",
    "Selector-Listen-Overlay bei Touch auf Knobs",
    "Touch Strip: Optional haptisches Feedback, LED-Bar-Feedback",
    "4D-Encoder: Tilt als D-Pad, Push als BestÃ¤tigung, LED-Ring fÃ¼r Richtungen"
  ],
  "roadmap": [
    "1. Transport-Panel und alle zugehÃ¶rigen Controls vollstÃ¤ndig abbilden",
    "2. Soft-Button- und Knob-Overlays mit dynamischer Kontextsteuerung implementieren",
    "3. 4D-Encoder-Navigation und Selector-Listen-Overlays fÃ¼r Parameterwerte integrieren",
    "4. Mode-Pinning und Shift-Layer-Feedback als UI-Status visualisieren",
    "5. Loop- und Grid-Panel mit Endpunkt- und Bereichssteuerung umsetzen",
    "6. Erase- und Automation-Panel fÃ¼r Live- und gezieltes LÃ¶schen ergÃ¤nzen",
    "7. Channel-Properties-Panel und MIDI-Mode-Umschaltung bereitstellen",
    "8. Pattern/Scene-Chain-UI und Preset-Mode fÃ¼r Pattern-LÃ¤nge entwickeln",
    "9. Pad- und Group-LED-Feedback, Velocity/Accent-Visualisierung und Pad-Labels vervollstÃ¤ndigen",
    "10. Undo/Redo-UI, Accessibility und State-Restore-Feedback finalisieren",
    "11. Debug/Timeline-Panel fÃ¼r Entwickler- und QA-Zwecke integrieren"
  ]
}


=========================================
File: utils/seededRandom.ts
=========================================

export type RandomSource = () => number

export function createSeededRandom(seed: number): RandomSource {
  let value = seed >>> 0
  return () => {
    value += 0x6d2b79f5
    let t = value
    t = Math.imul(t ^ (t >>> 15), t | 1)
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296
  }
}



=========================================
File: utils/zip.ts
=========================================

// Minimal ZIP creator that writes stored entries with CRC32 checksums.
const textEncoder = new TextEncoder()

const CRC_TABLE = (() => {
  const table = new Uint32Array(256)
  for (let i = 0; i < 256; i += 1) {
    let crc = i
    for (let j = 0; j < 8; j += 1) {
      crc = crc & 1 ? 0xedb88320 ^ (crc >>> 1) : crc >>> 1
    }
    table[i] = crc >>> 0
  }
  return table
})()

const crc32 = (data: Uint8Array): number => {
  let crc = 0xffffffff
  for (let i = 0; i < data.length; i += 1) {
    const byte = data[i] ?? 0
    const tableValue = CRC_TABLE[(crc ^ byte) & 0xff] ?? 0
    crc = tableValue ^ (crc >>> 8)
  }
  return (crc ^ 0xffffffff) >>> 0
}

export type ZipEntry = {
  name: string
  data: Uint8Array
}

export const createZip = (entries: ZipEntry[]): Blob => {
  const localChunks: ArrayBuffer[] = []
  const centralChunks: ArrayBuffer[] = []

  let offset = 0
  let centralSize = 0

  for (const entry of entries) {
    const { name, data } = entry
    const crc = crc32(data)
    const nameBytes = textEncoder.encode(name)

    // Build local file header and append raw data.
    const localHeaderBuffer = new ArrayBuffer(30 + nameBytes.length)
    const localView = new DataView(localHeaderBuffer)
    localView.setUint32(0, 0x04034b50, true)
    localView.setUint16(4, 20, true)
    localView.setUint16(6, 0, true)
    localView.setUint16(8, 0, true)
    localView.setUint16(10, 0, true)
    localView.setUint16(12, 0, true)
    localView.setUint32(14, crc, true)
    localView.setUint32(18, data.length, true)
    localView.setUint32(22, data.length, true)
    localView.setUint16(26, nameBytes.length, true)
    localView.setUint16(28, 0, true)

    const localHeaderBytes = new Uint8Array(localHeaderBuffer)
    localHeaderBytes.set(nameBytes, 30)
    localChunks.push(localHeaderBuffer)
    let ab: ArrayBuffer
    if (data.buffer instanceof ArrayBuffer && !(data.buffer instanceof SharedArrayBuffer)) {
      ab = data.buffer.slice(0, data.byteLength)
    } else {
      ab = new Uint8Array(data).buffer.slice(0)
    }
    localChunks.push(ab)

    // Build central directory header for the entry.
    const centralHeaderBuffer = new ArrayBuffer(46 + nameBytes.length)
    const centralView = new DataView(centralHeaderBuffer)
    centralView.setUint32(0, 0x02014b50, true)
    centralView.setUint16(4, 20, true)
    centralView.setUint16(6, 20, true)
    centralView.setUint16(8, 0, true)
    centralView.setUint16(10, 0, true)
    centralView.setUint16(12, 0, true)
    centralView.setUint16(14, 0, true)
    centralView.setUint32(16, crc, true)
    centralView.setUint32(20, data.length, true)
    centralView.setUint32(24, data.length, true)
    centralView.setUint16(28, nameBytes.length, true)
    centralView.setUint16(30, 0, true)
    centralView.setUint16(32, 0, true)
    centralView.setUint16(34, 0, true)
    centralView.setUint16(36, 0, true)
    centralView.setUint32(38, 0, true)
    centralView.setUint32(42, offset, true)

    const centralHeaderBytes = new Uint8Array(centralHeaderBuffer)
    centralHeaderBytes.set(nameBytes, 46)
    centralChunks.push(centralHeaderBuffer)

    offset += localHeaderBytes.length + data.length
    centralSize += centralHeaderBytes.length
  }

  // Write end of central directory record.
  const endBuffer = new ArrayBuffer(22)
  const endView = new DataView(endBuffer)
  endView.setUint32(0, 0x06054b50, true)
  endView.setUint16(4, 0, true)
  endView.setUint16(6, 0, true)
  endView.setUint16(8, entries.length, true)
  endView.setUint16(10, entries.length, true)
  endView.setUint32(12, centralSize, true)
  endView.setUint32(16, offset, true)
  endView.setUint16(20, 0, true)

  const parts: ArrayBuffer[] = [
    ...localChunks,
    ...centralChunks,
    endBuffer
  ]
  return new Blob(parts, { type: 'application/zip' })
}






=========================================
File: diagrams/browser-file-system-access.md
=========================================

# Browser File System Access

```mermaid
flowchart LR
    UI[User Action] -->|requestAccess| Repo[BrowserFileSystemRepository]
    Repo --> Guard{showDirectoryPicker?}
    Guard -- No --> Fallback[MemoryFileSystemRepository]
    Guard -- Yes --> Picker[window.showDirectoryPicker]
    Picker --> DirHandle[DirectoryHandle]
    DirHandle --> Cache[Path to Handle Cache]
    Cache --> List[listDir path]
    Cache --> Stat[stat path]
    Cache --> Read[readFileBlob path]
```

- Permission denial or missing API routes back to the memory fallback.



=========================================
File: diagrams/browser-performance.md
=========================================

# Browser Performance Optimizations

```mermaid
flowchart LR
    Query[setQuery text] --> Debounce[300ms debounce]
    Debounce --> Search[search]
    Search --> Results[store results]
    Results --> Window[toDisplayModels]
    Window --> View[windowed list <=100 items]
    Search --> Cache[cache hierarchy options]
```

- Debounced search and windowed display keep large lists responsive.



=========================================
File: diagrams/browser-sorting.md
=========================================

# Browser Sorting

```mermaid
flowchart TD
    Mode[setSortMode mode] --> Sort[sortResults]
    Sort --> Library[library.results sorted]
    Sort --> Files[files.entries sorted]
    Sort --> Display[subtitle: Sorted by ...]
```

- Relevance mode preserves the original search ordering.



=========================================
File: diagrams/class-diagram.md
=========================================

# Core Components Class Diagram

```mermaid
classDiagram
  class DrumMachine {
    +start()
    +stop()
    +updateBpm(bpm)
    +setDivision(div)
    +selectPad(padId)
    +exportBounce()
  }

  class TransportBar {
    +play()
    +stop()
    +updateBpm(bpm)
    +updateDivision(div)
    +toggleLoop()
    +toggleMidiLearn()
  }

  class PadGrid {
    +pads: DrumPadId[]
    +padStates: PadState map
    +selectPad(padId)
    +triggerPad(padId, velocity)
  }

  class PatternsPanel {
    +addPattern(name)
    +renamePattern(id, name)
    +undo()
    +redo()
    +addScene(name, patternIds)
    +selectScene(id)
  }

  class ExportPanel {
    +export()
    +downloadMixdown()
    +downloadZip()
    +downloadStem(padId)
  }

  class TransportStore {
    +bpm
    +isPlaying
    +gridSpec
    +setBpm(bpm)
    +setGridSpec(spec)
    +setLoop(loop)
  }

  class PatternsStore {
    +patterns
    +scenes
    +toggleStep(bar, step, pad)
    +setStepVelocity(...)
    +updateGridSpec(spec)
    +prepareScenePlayback()
    +advanceScenePlayback()
  }

  class SoundbanksStore {
    +banks
    +currentBank
    +upsertBank(bank)
    +selectBank(id)
  }

  class Sequencer {
    +start()
    +stop()
    +recordHit(pad, velocity, quantize)
    +applySoundbank(bank)
    +setFx(settings)
  }

  DrumMachine --> TransportBar : renders
  DrumMachine --> PadGrid : renders
  DrumMachine --> PatternsPanel : renders (drawer)
  DrumMachine --> ExportPanel : renders (drawer)
  DrumMachine --> Sequencer : drives playback/record
  DrumMachine --> TransportStore : reads/writes transport state
  DrumMachine --> PatternsStore : reads/writes patterns/scenes
  DrumMachine --> SoundbanksStore : reads/writes soundbanks
  Sequencer --> PatternsStore : reads steps
  Sequencer --> SoundbanksStore : uses pad samples
  TransportBar --> TransportStore : updates BPM/division/loop/play
  PadGrid --> Sequencer : record hits
  ExportPanel --> DrumMachine : triggers export/download flows
```

## Maschine MK3 UI placeholders (no-scroll shell)

```mermaid
classDiagram
  class DualDisplayPlaceholder {
    +leftText: string
    +rightText: string
    +softButtonLabels[8]: string
  }

  class SoftButtonStripPlaceholder {
    +buttons[8]: {symbol, hint}
    +onHoverHint()
  }

  class ScreenKnobRingPlaceholder {
    +knobs[8]: {label, value, hint}
    +selectorOverlay()
  }

  class FourDEncoderPlaceholder {
    +navigate(direction)
    +confirm()
    +hoverHint()
  }

  class TransportClusterPlaceholder {
    +playStop()
    +stopReset()
    +record()
    +restart()
    +tapTempo()
    +hoverHint()
  }

  class ModeColumnPlaceholder {
    +scene/pattern/events/variation
    +duplicate/select/mute/solo
    +shift()
    +hoverHint()
  }

  class TouchStripPlaceholder {
    +stripPosition
    +aftertouchMode
    +hoverHint()
  }

  DrumMachine --> DualDisplayPlaceholder : top displays
  DualDisplayPlaceholder --> SoftButtonStripPlaceholder : labels above displays
  DualDisplayPlaceholder --> ScreenKnobRingPlaceholder : knobs below displays
  DrumMachine --> FourDEncoderPlaceholder : nav + confirm
  DrumMachine --> ModeColumnPlaceholder : left cluster
  DrumMachine --> TransportClusterPlaceholder : transport cluster
  DrumMachine --> TouchStripPlaceholder : right/performance column
  DrumMachine --> PadGrid : pad matrix (right)
```

All placeholder components must expose hover hints (tooltips/titles) so every control mirrors the MK3 guidance even before full functionality is wired. Widths/heights should use `clamp()` to keep the entire shell inside 100vh without page scroll.



=========================================
File: diagrams/control-4d-encoder-browser.md
=========================================

# Browser 4D Encoder Wiring

```mermaid
sequenceDiagram
    participant Control as ControlStore
    participant Browser as BrowserStore
    participant Encoder as use4DEncoder

    Control->>Control: setMode BROWSER or FILE
    Control->>Browser: getEncoderFields
    Control->>Encoder: init + setFields fields

    Control->>Encoder: tilt direction
    Encoder-->>Browser: update field highlight

    Control->>Encoder: turn delta
    Encoder-->>Browser: setFilter field + value

    Control->>Encoder: press
    Encoder-->>Browser: importSelected
```

- Encoder wiring is active only in BROWSER/FILE modes.



=========================================
File: diagrams/control-area-mapping.md
=========================================

# Control-Area Mapping (MK3)

| Mode | Pages | Encoders (1â€“8) | Soft Buttons (1â€“8) | Displays (L / R) |
| --- | --- | --- | --- | --- |
| CHANNEL | Levels | Sound Vol, Sound Pan, Send A, Send B, Group Vol, Group Pan, Master Comp, Limiter | Sound, Group, Master, Input, Route, Solo, Mute, Monitor | Channel meters / Group + Master meters |
| PLUGIN | Plug-in | Cutoff, Resonance, Attack, Release, Drive, Mix, Stereo, Output | Instance/Swap, Preset, Bypass, Enable, Param, Macro, Browse, Remove | Plug-in chain / Instance meta |
| ARRANGER | Scenes | Scene Bars, Repeat, Section, Swing, Vel Mod, Humanize, Shift, Accent | Scenes, Sections, Duplicate, Length, Follow, Loop, Grid, Clear | Scenes list / Layout overview |
| MIXER | Mix | Kick, Snare, Hat, Perc, Bus Comp, Saturate, Send A, Send B | Levels, Pan, Sends, FX, Group, Master, Cue, Meters | Channel strip / Sends & FX |
| BROWSER | Library, Recent | Filter, Cutoff, Res, Rate, Depth, Space, Tone, Volume (Recent: Preview controls) | Search/Plug-in Menu, Type, Tag, Favorites, Prehear/Stop, Load, Replace, Clear | Categories with search / Results & preview |
| SAMPLING | Sampling | Start, End, Snap, Silence, Attack, Hold, Release, Gain | Record, Edit, Slice, Detect, Normalize, Fade, Apply, Discard | Waveform info / Sampling actions |
| FILE | Files | Mixdown, Stems, Normalize, Dither, Rate, Bit Depth, Loop, Count-in | New, Open, Save/Save As, Export, Audio, MIDI, Bounce, Close | File ops / Export options |
| SETTINGS | Settings | Metro Vol, Count-In, Swing, Quantize, Theme, Latency, Buffer, Safe Mode | Metronome, Count-In, Quantize, MIDI, Audio, Theme, Safe, Reset | System toggles / Audio & MIDI device info |
| AUTO | Automation | Lane, Smooth, Scale, Quantize, Protect, Loop, Snap, Depth | Write, Read, Latch, Touch, Erase, Arm, Hold, Clear | Automation mode / Status flags |
| MACRO | Macro | Macro 1â€“8 | Assign, Clear, Hold, Latch, Morph, Set/Shift Set, Store, Recall | Macro sets / Morph target |

- Page â—€/â–¶ cycles pages per mode (clamped). SHIFT + mode triggers secondary action (e.g., CHANNELâ†’MIDI, PLUGINâ†’Instance, BROWSERâ†’Plug-in menu, FILEâ†’Save As, MACROâ†’Set).
- Encoders support mouse wheel on hover and ArrowUp/Down/Left/Right keys; SHIFT performs fine steps.



=========================================
File: diagrams/favorites-flow.md
=========================================

# Favorites Flow

```mermaid
flowchart LR
    UI[User Toggle] --> Browser[toggleFavorite id]
    Browser --> Repo[LibraryRepository]
    Repo --> Store[localStorage set of ids]
    Browser --> Search[search filters]
    Search --> Results[filtered items]
    Results --> Display[subtitle with star]
```

- Favorites filtering is opt-in via `filters.favorites`.



=========================================
File: diagrams/library-hierarchy.md
=========================================

# Category/Product/Bank Hierarchy

```mermaid
flowchart TD
    Import[importDirectory] --> Meta[extractMetadataFromPath]
    Meta --> Items[Library items]
    Items --> Cats[getCategories]
    Items --> Prods[getProducts category]
    Items --> Banks[getBanks product]
    Items --> Subs[getSubBanks bank]
    Cats --> Filters[applyFilters]
    Prods --> Filters
    Banks --> Filters
    Subs --> Filters
```

- Hierarchy queries are filtered by their parent selection.



=========================================
File: diagrams/library-import-progress.md
=========================================

# Library Import Progress

```mermaid
flowchart TD
    Start[importDirectory path] --> List[listDir path]
    List --> Loop{entry}
    Loop -->|dir + recursive| Recurse[importDirectory child]
    Loop -->|file| Format{supported?}
    Format -- No --> Skip[record error + continue]
    Format -- Yes --> Meta[extractMetadataFromPath]
    Meta --> Import[importFile file]
    Import --> Progress[onProgress update]
    Progress --> Loop
```

- Errors are collected and logged after the pass.



=========================================
File: diagrams/padgrid-modus-layout.md
=========================================

# PadGrid & Modus-Layout

Das Schema zeigt, wie PadGrid, Modus-Spalte und die oberen Buttonreihen an den Softbutton-Referenzlinien ausgerichtet sind. DisplayÂ 1 (links) und DisplayÂ 2 (rechts) bilden die obere Achse; die Softbuttons darÃ¼ber liefern die vertikale Referenz (SoftbuttonÂ 4 Ã¼ber DisplayÂ 1) fÃ¼r die Modus-Spalte und die horizontale Referenz (Softbuttons Ã¼ber DisplayÂ 2) fÃ¼r die Fixed-Velocity/Pad-Mode-Zeile.

```mermaid
flowchart TB
  %% Softbuttons + Referenzen
  subgraph soft["Softbuttons 1â€“8 (oben)"]
    direction LR
    sb1["SB1"]:::softbtn
    sb2["SB2"]:::softbtn
    sb3["SB3"]:::softbtn
    sb4["SB4\nVertikale Referenzlinie"]:::ref
    sb5["SB5"]:::softbtn
    sb6["SB6"]:::softbtn
    sb7["SB7"]:::softbtn
    sb8["SB8"]:::softbtn
  end

  %% Displays
  subgraph displays["Dual Displays"]
    direction LR
    disp1["Display 1 (links)"]:::display
    disp2["Display 2 (rechts)"]:::display
  end

  %% Referenzlinien
  refV["Ausrichtung Modus-Spalte\n(Vertikale Linie SB4)"]:::ref
  refH["Horizontale Referenz:\nSoftbuttons Ã¼ber Display 2"]:::ref

  %% Upper buttons (Fixed Velocity + Pad Modes)
  upperRow["Fixed Velocity  |  PAD MODE  |  KEYBOARD  |  CHORD  |  STEP"]:::upper

  %% Main surface
  subgraph surface["BedienoberflÃ¤che (schematisch)"]
    direction LR
    subgraph modes["Modus-Buttons (links)\n8 StÃ¼ck, je 2 Pad-HÃ¶hen\nAusrichtung: Linie SB4"]
      m1["Mode 1"]:::mode
      m2["Mode 2"]:::mode
      m3["Mode 3"]:::mode
      m4["Mode 4"]:::mode
      m5["Mode 5"]:::mode
      m6["Mode 6"]:::mode
      m7["Mode 7"]:::mode
      m8["Mode 8"]:::mode
    end

    subgraph pads["PadGrid 4Ã—4 (rechts)\npad1â€“pad16\nStates: selected / triggered / playing\nPattern Indicator"]
      pgrid["4Ã—4 Pads"]:::pads
      pind["Pattern Indicator"]:::pads
    end
  end

  %% Relations
  soft --> displays
  sb4 -. Vertikale Referenz .- refV
  refV -. Linie .- modes
  soft -. Marker .- refH
  refH --> upperRow
  upperRow --> modes
  upperRow --> pads
  modes --> pads
  displays --> upperRow

  classDef softbtn fill:#1f2430,stroke:#6a7da8,color:#e4ecff;
  classDef display fill:#0f141f,stroke:#4d5a78,color:#d8e3ff;
  classDef pads fill:#1a1f2b,stroke:#f6a821,color:#ffeac2;
  classDef mode fill:#131722,stroke:#56b2e5,color:#d9f2ff;
  classDef upper fill:#1c2230,stroke:#8ac6ff,color:#e7f4ff;
  classDef ref stroke-dasharray: 4 2,stroke:#ff7f11,color:#ff7f11,fill:#fff2e6;
```

**Legende**
- Softbuttons 1â€“8 bilden die obere Linie; SoftbuttonÂ 4 markiert die vertikale Referenz der Modus-Spalte.
- DisplayÂ 1 sitzt links, DisplayÂ 2 rechts; die Softbuttons Ã¼ber DisplayÂ 2 definieren die horizontale Referenz fÃ¼r Fixed Velocity + PAD MODEâ€¦STEP.
- Modus-Buttons stehen links vom PadGrid, sind eine Spalte breit und jeweils 2 Pad-HÃ¶hen hoch (8 StÃ¼ck).
- Fixed Velocity plus die Reihe PAD MODE bis STEP liegt oberhalb der Modus-Spalte und orientiert sich an der Softbutton-Linie von DisplayÂ 2.
- PadGrid ist 4Ã—4 (pad1â€“pad16) mit ZustÃ¤nden selected/triggered/playing und einem Pattern Indicator im Bereich des Grids.



=========================================
File: diagrams/persistence-and-audio.md
=========================================

# Persistence and Audio Flow

```mermaid
  flowchart TB
    UI[UI_and_Stores] -->|save patterns/scenes| LocalStorage
    UI -->|manage banks/samples| IndexedDB
    DefaultKit[DefaultKitLoader] --> IndexedDB
    ImportExport[ImportExportHelpers] -->|manifests + blobs| IndexedDB
    IndexedDB -->|rehydrate blobs| AudioEngine[AudioEngine+FX]
    AudioEngine -->|decode| AudioCache[AudioBufferCache]
    TransportEngine -->|onStep schedule| AudioEngine
    AudioEngine -->|mixdown/stems + metadata| Exporter[OfflineExport]
    Exporter -->|WAV + JSON| Downloader[DownloadHelpers]
```

## MK3 UI overlays hooked to persistence/audio (placeholders)

```mermaid
flowchart LR
  ScreenKnobs["Screen Knobs 1-8\n(hint + selector overlay)"] -->|grid length/div/swing| TransportStore
  ScreenKnobs -->|pad params| PatternsStore
  SoftButtons["Soft Buttons 1-8\n(symbol + hover hint)"] -->|scene/pattern select| PatternsStore
  ModeButtons["Mode Column\n(Scene/Pattern/Events/Variation/Duplicate/Select/Mute/Solo)"] --> PatternsStore
  TouchStrip["Touch Strip â‰¡\n(performance macro placeholder)"] --> AudioEngine
  Displays["Dual Displays\n(render metadata + presets)"] --> ImportExport
  TransportCluster["Transport Cluster\n(play/stop/rec/restart)"] --> TransportEngine
```

- All hardware placeholders must show hover hints describing what they write to (transport store, patterns store, audio engine) and list both primary + shift-layer actions.
- Keep overlays lightweight and clipped inside the 100vh hardware shell; any deeper lists (e.g., selector values) should scroll inside the display mock, not the page.



=========================================
File: diagrams/quick-browse.md
=========================================

# Quick-Browse Restore

```mermaid
sequenceDiagram
    participant Browser as BrowserStore
    participant Quick as useQuickBrowse
    participant Storage as localStorage

    Browser->>Quick: recordBrowse entry
    Quick->>Storage: write storageKey

    Browser->>Quick: getLastBrowse contextId
    Quick->>Storage: read storageKey
    Quick-->>Browser: entry
    Browser->>Browser: restoreBrowse entry
    Browser->>Browser: search + select
```

- Each context id stores a single latest entry.



=========================================
File: diagrams/recent-files.md
=========================================

# Recent Files Tracking

```mermaid
sequenceDiagram
    participant Browser as BrowserStore
    participant Recent as useRecentFiles
    participant Storage as localStorage

    Browser->>Recent: addRecent entry
    Recent->>Storage: write storageKey

    Browser->>Recent: getRecent limit
    Recent->>Storage: read storageKey
    Recent-->>Browser: entries sorted desc
```

- Recent entries are deduplicated and capped at 50.



=========================================
File: diagrams/sample-preview.md
=========================================

# Sample Preview / Prehear

```mermaid
sequenceDiagram
    participant Browser as BrowserStore
    participant Preview as useSamplePreview
    participant FS as FileSystemRepository
    participant Audio as AudioContext

    Browser->>Preview: loadAndPlay path + blob
    Preview->>FS: readFileBlob path if needed
    Preview->>Audio: decodeAudioData
    Preview->>Audio: createBufferSource
    Preview-->>Browser: state updates isPlaying + progress
    Browser->>Preview: stop
```

- Playback uses the shared AudioContext and stops automatically at end.



=========================================
File: diagrams/tag-dialog.md
=========================================

# Tag Dialog Flow

```mermaid
stateDiagram-v2
    [*] --> Closed
    Closed --> Open: openTagDialog itemId
    Open --> Open: turn encoder scroll tags
    Open --> Open: press add or remove tag
    Open --> Closed: tilt right or closeTagDialog
```

```mermaid
flowchart LR
    Import[importSelected] --> Scan[scan tags]
    Scan --> Available[availableTags]
    Available --> Display[overlay lists + checkmarks]
```

- Tag overlay uses the existing display model without new UI elements.



=========================================
File: diagrams/transport-engine.md
=========================================

# Transport Engine Timing (English)

```mermaid
sequenceDiagram
    participant UI as UI/Stores
    participant Transport as TransportEngine
    participant Clock as RenderClock
    participant Scheduler as StepScheduler
    participant Hooks as AudioHooks
    participant Subs as Subscribers

    UI->>Transport: start()
    Transport->>Clock: audioTime()
    Transport->>Transport: set startTimeSec + lastStep
    Transport->>Scheduler: clear()
    Transport->>Scheduler: start()
    Transport->>Scheduler: schedule(nextBoundary)
    Scheduler-->>Hooks: onStep(stepIndex, audioTime)
    Hooks-->>Subs: audio pipeline elsewhere

    loop tick
        UI->>Transport: tick()
        Transport->>Clock: audioTime()
        Transport->>Transport: compute currentStep
        Transport->>Scheduler: schedule(step+1, swing)
        Transport-->>Subs: emit isPlaying + currentStep
    end

    UI->>Transport: setConfig(bpm/division/swing)
    Transport->>Clock: audioTime()
    Transport->>Transport: recompute startTimeSec (phase)
    Note over Transport,Scheduler: clear/reseed to avoid stale queued steps

    UI->>Transport: stop()
    Transport->>Scheduler: stop()
    Transport->>Scheduler: clear()
    Transport-->>Subs: emit stopped
```

## MK3 transport mapping (placeholders + hover hints)

```mermaid
stateDiagram-v2
    [*] --> Stopped
    Stopped --> Playing: Play â–¶
    Playing --> Stopped: Play/Stop â– 
    Stopped --> CountingIn: Shift+Rec (Count-In â™©)
    CountingIn --> Recording: Count-in done
    Playing --> Recording: Rec â—
    Recording --> Playing: Rec â— (toggle)
    Stopped --> Stopped: Stop â–  (reset playhead)
    Playing --> Stopped: Stop â–  (reset)
    Playing --> Playing: Restart â†» (jump to step 0)
```

- Transport cluster placeholder should expose hover hints for primary + shift: Play â–¶ (toggle), Stop â–  (press twice = reset), Rec â— (hold = Pattern Preset length), Restart â†» (shift+stop), Tap â˜¼, Loop âŸ³, Metronome â™¬, Count-In â™©, Follow â‡¥.
- Ensure the transport row stays within the left column and never forces a page scroll; stack controls into two compact rows with icons + labels so it fits under the dual displays.



=========================================
File: diagrams/ui-sequencer.md
=========================================

# UI Sequencer Flow

```mermaid
flowchart LR
    TransportBar["TransportBar.vue"]
    TransportStore["Transport / Session Stores"]
    StepGrid["StepGrid.vue"]
    PadGrid["PadGrid.vue"]
    SequencerStore["Patterns / Scenes Store"]
    TransportEngine["Transport Engine"]
    AudioEngine["Audio Engine<br/>+ FX"]

    TransportBar -->|"play Â· stop Â· bpm Â· division"| TransportStore
    TransportStore -->|"isPlaying Â· currentStep Â· gridSpec"| StepGrid

    PadGrid -->|"pad select / pad down"| SequencerStore
    SequencerStore -->|"steps for selected pad"| StepGrid
    StepGrid -->|"step toggle"| SequencerStore

    TransportStore -->|"tick / schedule"| TransportEngine
    TransportEngine -->|"onStep hook"| AudioEngine
    AudioEngine -->|"pad state (trigger / playing)"| PadGrid
```

## MK3 surface + hover hints

```mermaid
flowchart TB
  Displays["Dual Displays\n(soft labels + status bars)"]
  SoftButtons["Soft Buttons 1-8\n(symbol + hint tooltip)"]
  ScreenKnobs["8 Screen Knobs\n(selector overlay on hover/touch)"]
  Encoder["4D Encoder + Push\n(nav arrows â†•â†” + confirm)"]
  Modes["Mode Column\n(Scene/Pattern/Events/Variation/Duplicate/Select/Mute/Solo + Shift)"]
  Transport["Transport Cluster\n(Play â–¶ / Stop â–  / Rec â— / Restart â†» / Loop âŸ³ / Tap â˜¼)"]
  TouchStrip["Touch Strip â‰¡\n(perform/aftertouch placeholder)"]
  Pads["Pad Grid 4Ã—4\n(labels + key legends + hover hint)"]

  Displays --- SoftButtons
  Displays --- ScreenKnobs
  ScreenKnobs --> Encoder
  SoftButtons --> Displays
  Modes --> Pads
  Transport --> Pads
  TouchStrip --> Pads
  Pads --> Displays
```

- Fit everything inside a `100vh` stage: displays + buttons at top, pad square anchored bottom-right, transport + mode columns on the left, touch strip on the right. Only drawers scroll internally.
- Hover hints must show both the primary and shift-layer action (e.g., â€œMUTE (hold to momentary) / SHIFT: SOLOâ€), and selector overlays appear when hovering a screen knob to mimic MK3 lists.



=========================================
File: diagrams/use-cases.md
=========================================

# Sequence Diagrams for the documented Use Cases

## Live pattern building
```mermaid
sequenceDiagram
  participant User
  participant PadGrid
  participant DrumMachine
  participant Sequencer
  participant PatternsStore
  participant TransportStore

  User->>PadGrid: tap pad (velocity)
  PadGrid->>DrumMachine: pad:down(padId, velocity)
  DrumMachine->>Sequencer: recordHit(padId, velocity, quantized=true)
  Sequencer->>PatternsStore: toggleStep/current pattern
  DrumMachine->>TransportStore: ensure transport running/looping
  DrumMachine-->>User: updated pad state + playhead feedback
```

## Scene and pattern chaining
```mermaid
sequenceDiagram
  participant User
  participant PatternsPanel
  participant DrumMachine
  participant PatternsStore
  participant Sequencer
  participant TransportStore

  User->>PatternsPanel: set scene pattern chain
  PatternsPanel->>DrumMachine: scene:update(patternIds)
  DrumMachine->>PatternsStore: updateScene(...)
  User->>TransportStore: start transport
  TransportStore-->>DrumMachine: isPlaying=true
  DrumMachine->>Sequencer: start()
  Sequencer->>PatternsStore: prepareScenePlayback()
  Sequencer-->>PatternsStore: advanceScenePlayback() at bar boundary
```

## Soundbank customization and persistence
```mermaid
sequenceDiagram
  participant User
  participant SoundPanel
  participant DrumMachine
  participant SoundbanksStore
  participant SoundbankStorage
  participant Sequencer

  User->>SoundPanel: upload sample for pad
  SoundPanel->>DrumMachine: replacePadSample(padId, file)
  DrumMachine->>SoundbanksStore: upsertBank(updatedBank)
  DrumMachine->>SoundbankStorage: saveBank/saveSample
  DrumMachine->>Sequencer: setSampleForPad/applySoundbank
  DrumMachine-->>User: updated pad label + sound
```

## MIDI/hardware integration
```mermaid
sequenceDiagram
  participant User
  participant TransportBar
  participant DrumMachine
  participant Midi
  participant MidiLearn
  participant Sequencer
  participant TransportStore

  User->>TransportBar: toggle MIDI learn
  TransportBar->>DrumMachine: toggleMidiLearn()
  MidiLearn-->>User: awaiting pad/transport mapping
  Midi-->>MidiLearn: noteOn(message)
  MidiLearn->>Midi: setPadForNote / set transport mapping
  User->>TransportStore: start via mapped note
  TransportStore-->>DrumMachine: isPlaying=true
  DrumMachine->>Sequencer: start()
  Midi->>ExternalClock: send/start/stop (if master)
```

## Export mixes and stems
```mermaid
sequenceDiagram
  participant User
  participant ExportPanel
  participant DrumMachine
  participant ImportExport
  participant Sequencer

  User->>ExportPanel: click Export mixdown
  ExportPanel->>DrumMachine: export()
  DrumMachine->>ImportExport: exportAudio(duration)
  ImportExport->>Sequencer: render scene chain via RenderClock
  ImportExport-->>DrumMachine: {audioBlob, metadata, stems}
  DrumMachine-->>ExportPanel: metadata + download actions
  User->>ExportPanel: download WAV/ZIP/stems
```

## Import and normalization
```mermaid
sequenceDiagram
  participant User
  participant ImportUI
  participant DrumMachine
  participant ImportExport
  participant PatternsStore
  participant SoundbanksStore

  User->>ImportUI: select pattern JSON / MIDI / soundbank bundle
  ImportUI->>DrumMachine: import request
  DrumMachine->>ImportExport: parse/normalize payload
  ImportExport->>PatternsStore: setPatterns / updateGridSpec normalized
  ImportExport->>SoundbanksStore: upsertBank + samples
  DrumMachine-->>User: normalized patterns/soundbanks ready to play
```

## MK3 hardware-style navigation & hover hints
```mermaid
sequenceDiagram
  participant User
  participant Displays as DualDisplays+SoftButtons
  participant ScreenKnobs
  participant Encoder as 4DEncoder
  participant Transport as TransportCluster
  participant Modes as ModeColumn
  participant Pads

  User->>Displays: hover soft button (see hint + symbol)
  User->>ScreenKnobs: hover knob (opens selector overlay with values)
  ScreenKnobs->>Encoder: nudge/confirm selection
  Modes-->>Pads: change pad mode (mute/solo/select)
  Transport-->>Pads: play/stop/rec/restart toggles
  User->>Pads: tap pad (see pad label + hover legend)
  Displays-->>User: status update (no page scroll)
```

- Keep all interactions inside the hardware viewport; drawers and selector overlays scroll internally while the page remains locked.
- Hover hints should list both primary and shift-layer actions to mirror the MK3 printed labels.

## Browser diagrams

- 4D encoder wiring: `control-4d-encoder-browser.md`
- File system access: `browser-file-system-access.md`
- Import progress: `library-import-progress.md`
- Recent files: `recent-files.md`
- Favorites: `favorites-flow.md`
- Sample preview: `sample-preview.md`
- Sorting: `browser-sorting.md`
- Quick-browse: `quick-browse.md`
- Tag dialog: `tag-dialog.md`
- Hierarchy: `library-hierarchy.md`
- Performance: `browser-performance.md`



=========================================
File: dist-test/audio/fxGraph.js
=========================================

export const createFxGraph = (ctx) => ({
    fxInput: ctx.createGain(),
    driveNode: ctx.createWaveShaper(),
    filterNode: (() => {
        const node = ctx.createBiquadFilter();
        node.type = 'lowpass';
        return node;
    })(),
    dryGain: ctx.createGain(),
    wetGain: ctx.createGain(),
    reverbNode: ctx.createConvolver(),
    connected: false
});
export const connectFxGraph = (graph, masterGain) => {
    if (graph.connected)
        return;
    graph.fxInput.connect(graph.driveNode);
    graph.driveNode.connect(graph.filterNode);
    graph.filterNode.connect(graph.dryGain);
    graph.filterNode.connect(graph.reverbNode);
    graph.reverbNode.connect(graph.wetGain);
    graph.dryGain.connect(masterGain);
    graph.wetGain.connect(masterGain);
    graph.connected = true;
};
export const updateFxGraph = (ctx, graph, snapshot, rng) => {
    const now = ctx.currentTime;
    const frequencyValue = snapshot.filter.enabled ? snapshot.filter.frequency : ctx.sampleRate / 2;
    graph.filterNode.frequency.setValueAtTime(frequencyValue, now);
    graph.filterNode.Q.setValueAtTime(snapshot.filter.q, now);
    const amount = snapshot.drive.enabled ? snapshot.drive.amount : 0;
    graph.driveNode.curve = createDriveCurve(amount);
    const mix = snapshot.reverb.enabled ? snapshot.reverb.mix : 0;
    graph.dryGain.gain.setValueAtTime(Math.max(0, 1 - mix), now);
    graph.wetGain.gain.setValueAtTime(Math.max(0, Math.min(1, mix)), now);
    if (snapshot.reverb.enabled) {
        if (!graph.reverbNode.buffer) {
            graph.reverbNode.buffer = createImpulseResponse(ctx, rng);
        }
    }
    else if (graph.reverbNode.buffer) {
        graph.reverbNode.buffer = null;
    }
};
const createDriveCurve = (amount) => {
    const k = Math.max(0, amount) * 50 + 1;
    const samples = 1024;
    const curve = new Float32Array(samples);
    for (let i = 0; i < samples; i += 1) {
        const x = (i * 2) / samples - 1;
        curve[i] = ((1 + k) * x) / (1 + k * Math.abs(x));
    }
    return curve;
};
const createImpulseResponse = (ctx, rng, duration = 1.2, decay = 2.5) => {
    const length = Math.max(1, Math.floor(ctx.sampleRate * duration));
    const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let channel = 0; channel < impulse.numberOfChannels; channel += 1) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i += 1) {
            channelData[i] = (rng() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
    }
    return impulse;
};
//# sourceMappingURL=fxGraph.js.map


=========================================
File: dist-test/audio/fxGraph.js.map
=========================================

{"version":3,"file":"fxGraph.js","sourceRoot":"","sources":["../../audio/fxGraph.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/use4DEncoder.js
=========================================

import { computed, ref } from 'vue';
const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
export const use4DEncoder = () => {
    const mode = ref('field-select');
    const fields = ref([]);
    const activeFieldIndex = ref(0);
    const activeListIndex = ref(0);
    const activeField = computed(() => fields.value[activeFieldIndex.value] ?? null);
    const setFields = (nextFields) => {
        fields.value = [...nextFields];
        if (fields.value.length === 0) {
            activeFieldIndex.value = 0;
            return;
        }
        activeFieldIndex.value = clamp(activeFieldIndex.value, 0, fields.value.length - 1);
    };
    const setMode = (nextMode) => {
        mode.value = nextMode;
    };
    const tiltHorizontal = (direction) => {
        if (fields.value.length === 0)
            return;
        const delta = direction === 'left' ? -1 : 1;
        const maxIndex = fields.value.length - 1;
        activeFieldIndex.value = clamp(activeFieldIndex.value + delta, 0, maxIndex);
        mode.value = 'field-select';
    };
    const tiltVertical = (direction) => {
        const delta = direction === 'up' ? -1 : 1;
        activeListIndex.value = Math.max(0, activeListIndex.value + delta);
        mode.value = 'list-navigate';
    };
    const updateFieldValue = (delta) => {
        const index = activeFieldIndex.value;
        const field = fields.value[index];
        if (!field)
            return;
        if (field.options && field.options.length > 0) {
            const startIndex = Math.max(0, field.options.findIndex((option) => option === field.value));
            const nextIndex = clamp(startIndex + delta, 0, field.options.length - 1);
            const nextValue = field.options[nextIndex] ?? field.value;
            fields.value.splice(index, 1, { ...field, value: nextValue });
            return;
        }
        if (typeof field.value === 'number') {
            const step = field.step ?? 1;
            const min = field.min ?? Number.NEGATIVE_INFINITY;
            const max = field.max ?? Number.POSITIVE_INFINITY;
            const nextValue = clamp(field.value + delta * step, min, max);
            fields.value.splice(index, 1, { ...field, value: nextValue });
        }
    };
    const turn = (delta) => {
        if (mode.value === 'list-navigate') {
            activeListIndex.value = Math.max(0, activeListIndex.value + delta);
            return;
        }
        if (mode.value !== 'value-adjust')
            return;
        updateFieldValue(delta);
    };
    const press = () => {
        if (mode.value === 'field-select') {
            mode.value = 'value-adjust';
            return;
        }
        if (mode.value === 'value-adjust') {
            mode.value = 'list-navigate';
            return;
        }
        mode.value = 'field-select';
    };
    return {
        mode,
        fields,
        activeFieldIndex,
        activeListIndex,
        activeField,
        tiltHorizontal,
        tiltVertical,
        turn,
        press,
        setFields,
        setMode
    };
};
//# sourceMappingURL=use4DEncoder.js.map


=========================================
File: dist-test/composables/use4DEncoder.js.map
=========================================

{"version":3,"file":"use4DEncoder.js","sourceRoot":"","sources":["../../composables/use4DEncoder.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useAudioEngine.client.js
=========================================

import { onBeforeUnmount, ref } from 'vue';
import { createSeededRandom } from '@/utils/seededRandom';
import { createFxGraph, connectFxGraph, updateFxGraph } from '@/audio/fxGraph';
const cloneFxSettings = (settings) => ({
    filter: { ...settings.filter },
    drive: { ...settings.drive },
    reverb: { ...settings.reverb }
});
const createAudioEngineInstance = () => {
    const audioContext = ref(null);
    const masterGain = ref(null);
    const sampleCache = ref(new Map());
    const fxSettings = ref({
        filter: { enabled: true, frequency: 12000, q: 0.7 },
        drive: { enabled: false, amount: 0.25 },
        reverb: { enabled: false, mix: 0.15 }
    });
    const fxSnapshot = ref(cloneFxSettings(fxSettings.value));
    const fxGraph = ref(null);
    let randomSource = createSeededRandom(0);
    let wasRunningOnHide = false;
    let handlePageHide = null;
    let handlePageShow = null;
    const syncFxSnapshot = () => {
        fxSnapshot.value = cloneFxSettings(fxSettings.value);
        return fxSnapshot.value;
    };
    const ensureFxGraph = (ctx, snapshot) => {
        if (!masterGain.value) {
            return;
        }
        if (!fxGraph.value) {
            fxGraph.value = createFxGraph(ctx);
            connectFxGraph(fxGraph.value, masterGain.value);
        }
        updateFxGraph(ctx, fxGraph.value, snapshot, randomSource);
    };
    const ensureContext = () => {
        if (!audioContext.value) {
            const context = new AudioContext();
            const gain = context.createGain();
            gain.gain.value = 0.8;
            gain.connect(context.destination);
            audioContext.value = context;
            masterGain.value = gain;
        }
        ensureFxGraph(audioContext.value, fxSnapshot.value);
        return audioContext.value;
    };
    const resumeContext = async () => {
        const ctx = ensureContext();
        if (ctx.state === 'suspended') {
            await ctx.resume();
        }
        return ctx;
    };
    const getFxSnapshot = () => cloneFxSettings(fxSnapshot.value);
    const setFxRandomSource = (source) => {
        randomSource = source;
        if (fxGraph.value?.reverbNode) {
            fxGraph.value.reverbNode.buffer = null;
        }
        if (audioContext.value) {
            ensureFxGraph(audioContext.value, fxSnapshot.value);
        }
    };
    const decodeSample = async (sample) => {
        const ctx = ensureContext();
        if (sample.buffer) {
            return sample.buffer;
        }
        if (sample.blob) {
            const arrayBuffer = await sample.blob.arrayBuffer();
            return ctx.decodeAudioData(arrayBuffer.slice(0));
        }
        if (sample.url) {
            const response = await fetch(sample.url);
            const arrayBuffer = await response.arrayBuffer();
            return ctx.decodeAudioData(arrayBuffer);
        }
        return null;
    };
    const setSampleForPad = async (padId, sample) => {
        const buffer = sample.buffer ?? (await decodeSample(sample));
        if (buffer) {
            sampleCache.value.set(padId, buffer);
        }
    };
    const applySoundbank = async (bank) => {
        const entries = Object.entries(bank.pads);
        await Promise.all(entries.map(async ([padId, sample]) => {
            if (sample) {
                await setSampleForPad(padId, sample);
            }
        }));
    };
    const setFx = (partial) => {
        fxSettings.value = {
            filter: { ...fxSettings.value.filter, ...(partial.filter ?? {}) },
            drive: { ...fxSettings.value.drive, ...(partial.drive ?? {}) },
            reverb: { ...fxSettings.value.reverb, ...(partial.reverb ?? {}) }
        };
        const snapshot = syncFxSnapshot();
        const ctx = ensureContext();
        ensureFxGraph(ctx, snapshot);
    };
    const trigger = async ({ padId, when, velocity = 1 }) => {
        const ctx = ensureContext();
        const buffer = sampleCache.value.get(padId) ?? null;
        if (!buffer) {
            return;
        }
        const source = ctx.createBufferSource();
        source.buffer = buffer;
        const gain = ctx.createGain();
        gain.gain.value = velocity;
        source.connect(gain);
        if (fxGraph.value) {
            gain.connect(fxGraph.value.fxInput);
        }
        else {
            gain.connect(masterGain.value ?? ctx.destination);
        }
        source.start(when);
    };
    const triggerClick = async (when, accented = false, volume = 0.12) => {
        const ctx = ensureContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'square';
        osc.frequency.value = accented ? 2200 : 1600;
        const base = Math.max(0, Math.min(1, volume));
        gain.gain.setValueAtTime((accented ? 1.4 : 1) * base, when);
        gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.06);
        osc.connect(gain);
        gain.connect(masterGain.value ?? ctx.destination);
        osc.start(when);
        osc.stop(when + 0.08);
    };
    if (typeof window !== 'undefined') {
        handlePageHide = () => {
            if (audioContext.value) {
                wasRunningOnHide = audioContext.value.state === 'running';
                void audioContext.value.suspend().catch(() => undefined);
            }
        };
        handlePageShow = () => {
            if (wasRunningOnHide && audioContext.value) {
                void audioContext.value.resume().catch(() => undefined);
            }
            wasRunningOnHide = false;
        };
        window.addEventListener('pagehide', handlePageHide);
        window.addEventListener('pageshow', handlePageShow);
    }
    onBeforeUnmount(() => {
        if (handlePageHide) {
            window.removeEventListener('pagehide', handlePageHide);
        }
        if (handlePageShow) {
            window.removeEventListener('pageshow', handlePageShow);
        }
        audioContext.value?.close();
        sampleCache.value.clear();
    });
    return {
        audioContext,
        masterGain,
        sampleCache,
        fxSettings,
        ensureContext,
        resumeContext,
        decodeSample,
        applySoundbank,
        setFx,
        setSampleForPad,
        trigger,
        triggerClick,
        getFxSnapshot,
        setFxRandomSource
    };
};
let audioEngineInstance = null;
export function useAudioEngine() {
    if (!audioEngineInstance) {
        audioEngineInstance = createAudioEngineInstance();
    }
    return audioEngineInstance;
}
//# sourceMappingURL=useAudioEngine.client.js.map


=========================================
File: dist-test/composables/useAudioEngine.client.js.map
=========================================

{"version":3,"file":"useAudioEngine.client.js","sourceRoot":"","sources":["../../composables/useAudioEngine.client.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useAudioInput.client.js
=========================================

import { onBeforeUnmount, ref } from 'vue';
export function useAudioInput() {
    const state = ref({});
    const sourceNode = ref(null);
    const audioContext = ref(null);
    let handlePageHide = null;
    const requestMic = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const context = new AudioContext();
            sourceNode.value = context.createMediaStreamSource(stream);
            audioContext.value = context;
            state.value = { stream };
        }
        catch (error) {
            const message = error instanceof Error ? error.message : 'microphone request failed';
            state.value = { error: message };
        }
    };
    const stop = () => {
        state.value.stream?.getTracks().forEach((track) => track.stop());
        void audioContext.value?.close();
        audioContext.value = null;
        state.value = {};
    };
    if (typeof window !== 'undefined') {
        handlePageHide = () => {
            stop();
            sourceNode.value = null;
        };
        window.addEventListener('pagehide', handlePageHide);
    }
    onBeforeUnmount(() => {
        if (handlePageHide) {
            window.removeEventListener('pagehide', handlePageHide);
        }
        stop();
        sourceNode.value = null;
    });
    return {
        state,
        sourceNode,
        requestMic,
        stop
    };
}
//# sourceMappingURL=useAudioInput.client.js.map


=========================================
File: dist-test/composables/useAudioInput.client.js.map
=========================================

{"version":3,"file":"useAudioInput.client.js","sourceRoot":"","sources":["../../composables/useAudioInput.client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,GAAG,EAAE,MAAM,KAAK,CAAA;AAO1C,MAAM,UAAU,aAAa;IAC3B,MAAM,KAAK,GAAG,GAAG,CAAkB,EAAE,CAAC,CAAA;IACtC,MAAM,UAAU,GAAG,GAAG,CAAoC,IAAI,CAAC,CAAA;IAC/D,MAAM,YAAY,GAAG,GAAG,CAAsB,IAAI,CAAC,CAAA;IACnD,IAAI,cAAc,GAAwB,IAAI,CAAA;IAE9C,MAAM,UAAU,GAAG,KAAK,IAAI,EAAE;QAC5B,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC,YAAY,CAAC,YAAY,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAA;YACzE,MAAM,OAAO,GAAG,IAAI,YAAY,EAAE,CAAA;YAClC,UAAU,CAAC,KAAK,GAAG,OAAO,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAA;YAC1D,YAAY,CAAC,KAAK,GAAG,OAAO,CAAA;YAC5B,KAAK,CAAC,KAAK,GAAG,EAAE,MAAM,EAAE,CAAA;QAC1B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,OAAO,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,2BAA2B,CAAA;YACpF,KAAK,CAAC,KAAK,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,CAAA;QAClC,CAAC;IACH,CAAC,CAAA;IAED,MAAM,IAAI,GAAG,GAAG,EAAE;QAChB,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAA;QAChE,KAAK,YAAY,CAAC,KAAK,EAAE,KAAK,EAAE,CAAA;QAChC,YAAY,CAAC,KAAK,GAAG,IAAI,CAAA;QACzB,KAAK,CAAC,KAAK,GAAG,EAAE,CAAA;IAClB,CAAC,CAAA;IAED,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE,CAAC;QAClC,cAAc,GAAG,GAAG,EAAE;YACpB,IAAI,EAAE,CAAA;YACN,UAAU,CAAC,KAAK,GAAG,IAAI,CAAA;QACzB,CAAC,CAAA;QACD,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAA;IACrD,CAAC;IAED,eAAe,CAAC,GAAG,EAAE;QACnB,IAAI,cAAc,EAAE,CAAC;YACnB,MAAM,CAAC,mBAAmB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAA;QACxD,CAAC;QACD,IAAI,EAAE,CAAA;QACN,UAAU,CAAC,KAAK,GAAG,IAAI,CAAA;IACzB,CAAC,CAAC,CAAA;IAEF,OAAO;QACL,KAAK;QACL,UAAU;QACV,UAAU;QACV,IAAI;KACL,CAAA;AACH,CAAC"}


=========================================
File: dist-test/composables/useCapabilities.client.js
=========================================

import { ref } from 'vue';
export function useCapabilities() {
    const capabilities = ref({ supportsWebMIDI: false, supportsAudioInput: false });
    const evaluate = () => {
        capabilities.value = {
            supportsWebMIDI: typeof navigator !== 'undefined' && 'requestMIDIAccess' in navigator,
            supportsAudioInput: typeof navigator !== 'undefined' && Boolean(navigator.mediaDevices?.getUserMedia)
        };
    };
    evaluate();
    return {
        capabilities,
        evaluate
    };
}
//# sourceMappingURL=useCapabilities.client.js.map


=========================================
File: dist-test/composables/useCapabilities.client.js.map
=========================================

{"version":3,"file":"useCapabilities.client.js","sourceRoot":"","sources":["../../composables/useCapabilities.client.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,GAAG,EAAE,MAAM,KAAK,CAAA;AAOzB,MAAM,UAAU,eAAe;IAC7B,MAAM,YAAY,GAAG,GAAG,CAAe,EAAE,eAAe,EAAE,KAAK,EAAE,kBAAkB,EAAE,KAAK,EAAE,CAAC,CAAA;IAE7F,MAAM,QAAQ,GAAG,GAAG,EAAE;QACpB,YAAY,CAAC,KAAK,GAAG;YACnB,eAAe,EAAE,OAAO,SAAS,KAAK,WAAW,IAAI,mBAAmB,IAAI,SAAS;YACrF,kBAAkB,EAAE,OAAO,SAAS,KAAK,WAAW,IAAI,OAAO,CAAC,SAAS,CAAC,YAAY,EAAE,YAAY,CAAC;SACtG,CAAA;IACH,CAAC,CAAA;IAED,QAAQ,EAAE,CAAA;IAEV,OAAO;QACL,YAAY;QACZ,QAAQ;KACT,CAAA;AACH,CAAC"}


=========================================
File: dist-test/composables/useImportExport.client.js
=========================================

import { ref } from 'vue';
import { saveAs } from 'file-saver';
import { Midi as MidiType } from '@tonejs/midi';
import { defaultMidiMapping } from '@/domain/midiMapping';
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing';
import { clampVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity';
import { createRenderClock } from '@/domain/clock/renderClock';
import { createFxGraph, connectFxGraph, updateFxGraph } from '@/audio/fxGraph';
import { useAudioEngine } from './useAudioEngine.client';
import { usePatternsStore } from '@/stores/patterns';
import { useTransportStore } from '@/stores/transport';
import { createSeededRandom } from '@/utils/seededRandom';
import { scheduleStep } from './useSequencer';
const Midi = MidiType;
const encoderHeader = 'Drumcomputer Pattern Export';
const audioBufferToWav = (buffer) => {
    const numOfChan = buffer.numberOfChannels;
    const length = buffer.length * numOfChan * 2 + 44;
    const result = new ArrayBuffer(length);
    const view = new DataView(result);
    let offset = 0;
    const writeString = (str) => {
        for (let i = 0; i < str.length; i += 1) {
            view.setUint8(offset + i, str.charCodeAt(i));
        }
        offset += str.length;
    };
    const setUint16 = (data) => {
        view.setUint16(offset, data, true);
        offset += 2;
    };
    const setUint32 = (data) => {
        view.setUint32(offset, data, true);
        offset += 4;
    };
    writeString('RIFF');
    setUint32(length - 8);
    writeString('WAVE');
    writeString('fmt ');
    setUint32(16);
    setUint16(1);
    setUint16(numOfChan);
    setUint32(buffer.sampleRate);
    setUint32(buffer.sampleRate * numOfChan * 2);
    setUint16(numOfChan * 2);
    setUint16(16);
    writeString('data');
    setUint32(length - offset - 4);
    const channels = [];
    for (let i = 0; i < numOfChan; i += 1) {
        channels.push(buffer.getChannelData(i));
    }
    while (offset < length) {
        for (let i = 0; i < numOfChan; i += 1) {
            const channel = channels[i];
            if (!channel) {
                offset += 2;
                continue;
            }
            const sampleIndex = Math.floor((offset - 44) / (2 * numOfChan));
            const rawSample = channel[sampleIndex] ?? 0;
            const sample = Math.max(-1, Math.min(1, rawSample));
            view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
            offset += 2;
        }
    }
    return result;
};
const normalizePattern = (pattern) => {
    const gridSpec = normalizeGridSpec(pattern.gridSpec);
    const steps = {};
    Object.entries(pattern.steps ?? {}).forEach(([barKey, barValue]) => {
        const barIndex = Number(barKey);
        if (Number.isNaN(barIndex))
            return;
        const normalizedBar = {};
        Object.entries(barValue ?? {}).forEach(([stepKey, stepValue]) => {
            const stepInBar = Number(stepKey);
            if (Number.isNaN(stepInBar))
                return;
            const normalizedRow = {};
            Object.entries(stepValue ?? {}).forEach(([padId, cell]) => {
                if (!cell)
                    return;
                normalizedRow[padId] = {
                    velocity: { value: clampVelocity(cell.velocity?.value ?? DEFAULT_STEP_VELOCITY) }
                };
            });
            if (Object.keys(normalizedRow).length > 0) {
                normalizedBar[stepInBar] = normalizedRow;
            }
        });
        if (Object.keys(normalizedBar).length > 0) {
            steps[barIndex] = normalizedBar;
        }
    });
    return {
        ...pattern,
        gridSpec,
        steps
    };
};
const patternFromMidi = (midi, mapping) => {
    const gridSpec = { bars: 1, division: 16 };
    const steps = {};
    const track = midi.tracks[0];
    if (!track) {
        return normalizePattern({
            id: 'imported-pattern',
            name: 'Imported Pattern',
            gridSpec,
            steps
        });
    }
    const ticksPerBeat = midi.header.ppq;
    const stepTicks = (ticksPerBeat * 4) / gridSpec.division;
    const notes = track.notes ?? [];
    notes.forEach((note) => {
        const stepIndex = Math.round(note.ticks / stepTicks);
        const barIndex = Math.floor(stepIndex / gridSpec.division);
        const stepInBar = stepIndex % gridSpec.division;
        const pad = mapping.noteMap[note.midi];
        if (!pad)
            return;
        const bar = steps[barIndex] ?? {};
        const row = bar[stepInBar] ?? {};
        const velocity = typeof note.velocity === 'number' ? note.velocity : DEFAULT_STEP_VELOCITY;
        row[pad] = { velocity: { value: clampVelocity(velocity) } };
        bar[stepInBar] = row;
        steps[barIndex] = bar;
    });
    return normalizePattern({
        id: 'imported-pattern',
        name: track.name ?? 'Imported Pattern',
        gridSpec,
        steps
    });
};
export function useImportExport() {
    const exportPattern = (pattern) => {
        const normalized = normalizePattern(pattern);
        const blob = new Blob([JSON.stringify(normalized, null, 2)], { type: 'application/json' });
        saveAs(blob, `${normalized.name}.json`);
    };
    const importPattern = async (file) => {
        try {
            const text = await file.text();
            const parsed = JSON.parse(text);
            return normalizePattern(parsed);
        }
        catch (error) {
            console.error('Failed to import pattern', error);
            return {
                id: `imported-${Date.now()}`,
                name: file.name,
                gridSpec: { bars: 1, division: 16 },
                steps: {}
            };
        }
    };
    const exportMidi = (pattern, bpm, mapping = defaultMidiMapping()) => {
        if (typeof Midi === 'undefined') {
            console.error('MIDI export is not available: Midi is undefined.');
            return;
        }
        const midi = new Midi();
        midi.header.setTempo(bpm);
        const track = midi.addTrack();
        const ticksPerBeat = midi.header.ppq;
        const stepTicks = (ticksPerBeat * 4) / pattern.gridSpec.division;
        const totalSteps = pattern.gridSpec.bars * pattern.gridSpec.division;
        for (let i = 0; i < totalSteps; i += 1) {
            const barIndex = Math.floor(i / pattern.gridSpec.division);
            const stepInBar = i % pattern.gridSpec.division;
            const row = pattern.steps[barIndex]?.[stepInBar];
            if (!row)
                continue;
            Object.entries(row).forEach(([padId, cell]) => {
                const drumPad = padId;
                const note = mapping.noteMapInverse?.[drumPad] ?? Object.entries(mapping.noteMap).find(([, pad]) => pad === drumPad)?.[0];
                if (typeof note !== 'string' && typeof note !== 'number')
                    return;
                const midiNote = typeof note === 'string' ? Number(note) : note;
                if (typeof midiNote !== 'number')
                    return;
                track.addNote({
                    midi: midiNote,
                    time: (i * stepTicks) / ticksPerBeat,
                    duration: stepTicks / ticksPerBeat,
                    velocity: cell?.velocity?.value ?? 1
                });
            });
        }
        const midiArray = midi.toArray();
        const midiBuffer = midiArray.buffer;
        const blob = new Blob([midiBuffer], { type: 'audio/midi' });
        saveAs(blob, `${pattern.name}.mid`);
    };
    const importMidi = async (file, mapping = defaultMidiMapping()) => {
        if (typeof Midi === 'undefined') {
            console.error('MIDI import is not available: Midi is undefined.');
            return {
                id: `imported-${Date.now()}`,
                name: file.name,
                gridSpec: { bars: 1, division: 16 },
                steps: {}
            };
        }
        const buffer = await file.arrayBuffer();
        const midi = new Midi(buffer);
        return patternFromMidi(midi, mapping);
    };
    const createScenePlaybackTracker = (patternsStore) => {
        const scene = patternsStore.currentScene;
        const patternList = scene?.patternIds ?? [];
        const fallbackPattern = patternsStore.patterns[0] ?? {
            id: 'pattern-1',
            name: 'Pattern 1',
            gridSpec: { ...DEFAULT_GRID_SPEC },
            steps: {}
        };
        let currentPatternId = patternList[0] ?? patternsStore.selectedPatternId ?? fallbackPattern.id;
        let scenePosition = patternList.length > 1 ? 1 : 0;
        const resolvePattern = (id) => patternsStore.patterns.find((pattern) => pattern.id === id) ?? fallbackPattern;
        const getPattern = () => resolvePattern(currentPatternId);
        const advancePattern = () => {
            if (!scene || patternList.length === 0) {
                return getPattern();
            }
            const nextId = patternList[scenePosition % patternList.length];
            scenePosition = (scenePosition + 1) % patternList.length;
            if (nextId) {
                currentPatternId = nextId;
            }
            return getPattern();
        };
        const initialPattern = getPattern();
        const patternChain = patternList.length > 0 ? [...patternList] : [patternsStore.selectedPatternId ?? initialPattern.id];
        return {
            sceneId: scene?.id ?? null,
            patternChain,
            initialPatternId: initialPattern.id,
            getPattern,
            advancePattern
        };
    };
    const createOfflineScheduler = (limit, updateClock) => {
        const tasks = [];
        return {
            schedule(task) {
                tasks.push(task);
                tasks.sort((a, b) => a.when - b.when);
            },
            run() {
                while (tasks.length > 0) {
                    const next = tasks[0];
                    if (!next || next.when > limit)
                        break;
                    tasks.shift();
                    updateClock(next.when);
                    next.callback();
                }
            }
        };
    };
    const hashSnapshot = (payload) => {
        let hash = 0;
        for (let i = 0; i < payload.length; i += 1) {
            hash = Math.imul(31, hash) + payload.charCodeAt(i);
            hash >>>= 0;
        }
        return hash.toString(36);
    };
    const slugifyName = (value) => {
        const cleaned = value
            .trim()
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '_')
            .replace(/^_+|_+$/g, '');
        return cleaned || 'session';
    };
    const collectPadIdsFromPatternChain = (patternChain, patternList) => {
        const padSet = new Set();
        patternChain.forEach((patternId) => {
            const pattern = patternList.find((entry) => entry.id === patternId);
            if (!pattern)
                return;
            Object.values(pattern.steps ?? {}).forEach((bar) => {
                Object.values(bar ?? {}).forEach((stepRow) => {
                    Object.keys(stepRow ?? {}).forEach((padId) => {
                        padSet.add(padId);
                    });
                });
            });
        });
        return Array.from(padSet);
    };
    const exportAudio = async (renderDurationSec, sampleRate = 44100, options = {}) => {
        const transport = useTransportStore();
        const patterns = usePatternsStore();
        const audio = useAudioEngine();
        const duration = Math.max(0, renderDurationSec);
        const frameCount = Math.max(1, Math.ceil(duration * sampleRate));
        const seedValue = options.seed ?? Date.now();
        const fxSnapshot = audio.getFxSnapshot();
        const shouldDebug = import.meta.env?.DEV ?? false;
        const baseSampleCache = new Map(audio.sampleCache.value);
        const metadataTracker = createScenePlaybackTracker(patterns);
        const metadataPattern = metadataTracker.getPattern();
        const initialGridSpec = normalizeGridSpec(metadataPattern.gridSpec ?? transport.gridSpec);
        const metadata = {
            seed: String(seedValue),
            bpm: transport.bpm,
            gridSpec: initialGridSpec,
            sceneId: metadataTracker.sceneId,
            patternChain: metadataTracker.patternChain,
            initialPatternId: metadataTracker.initialPatternId,
            durationSec: duration
        };
        const songSlug = slugifyName(patterns.currentScene?.name ?? metadataPattern.name ?? 'drum-session');
        const candidatePadIds = collectPadIdsFromPatternChain(metadataTracker.patternChain, patterns.patterns);
        const stemPadIds = options.stems
            ? candidatePadIds.filter((padId) => baseSampleCache.has(padId))
            : [];
        const renderPass = async (soloPadId, collectDebug = false) => {
            const context = new OfflineAudioContext(2, frameCount, sampleRate);
            const masterGainNode = context.createGain();
            masterGainNode.gain.value = 0.8;
            masterGainNode.connect(context.destination);
            const fxGraph = createFxGraph(context);
            connectFxGraph(fxGraph, masterGainNode);
            const rng = createSeededRandom(seedValue);
            updateFxGraph(context, fxGraph, fxSnapshot, rng);
            const sampleCache = new Map(baseSampleCache);
            const shouldCollectDebugEvents = shouldDebug && collectDebug;
            const debugEvents = [];
            const offlineEngine = {
                trigger({ padId, when, velocity = 1 }) {
                    if (soloPadId && padId !== soloPadId)
                        return;
                    const buffer = sampleCache.get(padId);
                    if (!buffer)
                        return;
                    const source = context.createBufferSource();
                    source.buffer = buffer;
                    const gainNode = context.createGain();
                    gainNode.gain.value = velocity;
                    source.connect(gainNode);
                    gainNode.connect(fxGraph.fxInput);
                    source.start(when);
                    if (shouldCollectDebugEvents) {
                        debugEvents.push({ time: when, padId, velocity });
                    }
                }
            };
            let simulatedTime = 0;
            const baseClock = createRenderClock(context, true);
            const renderClock = {
                ctx: baseClock.ctx,
                isOffline: true,
                now: () => simulatedTime,
                audioTime: () => baseClock.audioTime()
            };
            const offlineScheduler = createOfflineScheduler(duration, (time) => {
                simulatedTime = time;
            });
            const tracker = createScenePlaybackTracker(patterns);
            const initialPatternForRender = tracker.getPattern();
            const renderGridSpec = normalizeGridSpec(initialPatternForRender.gridSpec ?? transport.gridSpec);
            const currentStep = ref(0);
            const pendingSteps = ref([]);
            const offlineTransportBase = {
                loop: transport.loop,
                bpm: transport.bpm,
                gridSpec: renderGridSpec,
                setCurrentStep: () => { },
                setGridSpec(gridSpec) {
                    offlineTransportBase.gridSpec = normalizeGridSpec(gridSpec);
                }
            };
            const offlineTransport = offlineTransportBase;
            const stepOptions = {
                clock: renderClock,
                scheduler: offlineScheduler,
                audio: offlineEngine,
                transport: offlineTransport,
                getPattern: () => tracker.getPattern(),
                currentStep,
                pendingSteps,
                onPatternBoundary: () => {
                    const nextPattern = tracker.advancePattern();
                    offlineTransport.setGridSpec(nextPattern.gridSpec);
                    return nextPattern;
                }
            };
            scheduleStep(stepOptions, 0);
            offlineScheduler.run();
            simulatedTime = duration;
            const rendered = await context.startRendering();
            return {
                audioBuffer: rendered,
                debugEvents: shouldCollectDebugEvents ? debugEvents : undefined
            };
        };
        const mixdownResult = await renderPass(undefined, true);
        const mixdownBlob = new Blob([audioBufferToWav(mixdownResult.audioBuffer)], { type: 'audio/wav' });
        saveAs(mixdownBlob, 'mixdown.wav');
        if (shouldDebug) {
            const events = mixdownResult.debugEvents ?? [];
            const snapshotHash = hashSnapshot(JSON.stringify(fxSnapshot));
            console.info('Offline export', `seed=${seedValue}`, `snapshot=${snapshotHash}`, `events=${events.length}`, `duration=${duration.toFixed(2)}`);
            if (events.length === 0) {
                console.warn('Offline export scheduled zero events; verify the active pattern/scene contains steps');
            }
        }
        const stemFiles = {};
        for (const padId of stemPadIds) {
            const stemResult = await renderPass(padId);
            const stemBlob = new Blob([audioBufferToWav(stemResult.audioBuffer)], { type: 'audio/wav' });
            const fileName = `${songSlug}_${padId}.wav`;
            stemFiles[padId] = { fileName, blob: stemBlob };
        }
        const result = {
            audioBlob: mixdownBlob,
            metadata
        };
        if (shouldDebug && mixdownResult.debugEvents) {
            result.debugTimeline = mixdownResult.debugEvents;
        }
        if (Object.keys(stemFiles).length > 0) {
            result.stems = stemFiles;
        }
        return result;
    };
    const exportSoundbank = (bank, samples) => {
        const padEntries = Object.entries(bank.pads).reduce((acc, [padId, sample]) => {
            if (sample) {
                acc[padId] = { id: sample.id, name: sample.name, format: sample.format };
            }
            return acc;
        }, {});
        const manifest = {
            bank: { ...bank, pads: padEntries },
            samples: samples.map((sample) => {
                const entry = {
                    id: sample.id,
                    name: sample.name
                };
                if (sample.format) {
                    entry.format = sample.format;
                }
                return entry;
            })
        };
        saveAs(new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' }), `${bank.name}-manifest.json`);
        samples.forEach((sample) => {
            if (sample.blob) {
                saveAs(sample.blob, sample.name);
            }
        });
    };
    const importSoundbank = async (manifestFile, sampleFiles) => {
        try {
            const manifestText = await manifestFile.text();
            const parsed = JSON.parse(manifestText);
            const sampleMap = new Map(sampleFiles.map((file) => [file.name, file]));
            const hydratedSamples = parsed.samples.map((sample) => {
                const blob = sampleMap.get(sample.name);
                if (blob) {
                    return { ...sample, blob };
                }
                return { ...sample };
            });
            const padAssignments = {};
            Object.entries(parsed.bank.pads ?? {}).forEach(([padId, sampleInfo]) => {
                const found = hydratedSamples.find((sample) => sample.id === sampleInfo.id);
                if (found) {
                    padAssignments[padId] = found;
                }
            });
            const hydratedBank = { ...parsed.bank, pads: padAssignments };
            return { bank: hydratedBank, samples: hydratedSamples };
        }
        catch (error) {
            console.error('Failed to import soundbank', error);
            return {
                bank: { id: 'invalid-bank', name: manifestFile.name, pads: {}, createdAt: Date.now(), updatedAt: Date.now() },
                samples: []
            };
        }
    };
    const exportMidiData = (data) => {
        const blob = new Blob([encoderHeader, JSON.stringify(data)], { type: 'application/json' });
        saveAs(blob, 'sequence.mid.json');
    };
    return {
        exportPattern,
        importPattern,
        exportMidi,
        importMidi,
        exportMidiData,
        exportAudio,
        exportSoundbank,
        importSoundbank
    };
}
//# sourceMappingURL=useImportExport.client.js.map


=========================================
File: dist-test/composables/useImportExport.client.js.map
=========================================

{"version":3,"file":"useImportExport.client.js","sourceRoot":"","sources":["../../composables/useImportExport.client.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useMidi.client.js
=========================================

import { onBeforeUnmount, ref } from 'vue';
import { defaultMidiMapping } from '@/domain/midiMapping';
export function useMidi() {
    const access = ref(null);
    const inputs = ref([]);
    const outputs = ref([]);
    const mapping = ref(defaultMidiMapping());
    const selectedInputId = ref(null);
    const selectedOutputId = ref(null);
    const listeners = ref(new Set());
    let handlePageHide = null;
    let handlePageShow = null;
    const supportsMidi = () => typeof navigator !== 'undefined' && Boolean(navigator.requestMIDIAccess);
    const refreshDevices = () => {
        if (!access.value)
            return;
        inputs.value = Array.from(access.value.inputs.values()).map((device) => ({
            id: device.id,
            name: device.name ?? 'MIDI In',
            type: 'input'
        }));
        outputs.value = Array.from(access.value.outputs.values()).map((device) => ({
            id: device.id,
            name: device.name ?? 'MIDI Out',
            type: 'output'
        }));
    };
    const requestAccess = async () => {
        if (!supportsMidi()) {
            return;
        }
        access.value = await navigator.requestMIDIAccess({ sysex: false });
        refreshDevices();
        if (access.value) {
            access.value.onstatechange = () => {
                refreshDevices();
                attachSelectedInput();
            };
        }
    };
    const handleMidiMessage = (event) => {
        if (!event.data || event.data.length < 1)
            return;
        const status = event.data[0];
        const data1 = event.data[1];
        const data2 = event.data[2];
        if (status === undefined)
            return;
        const type = status & 0xf0;
        const hasNoteData = typeof data1 === 'number' && typeof data2 === 'number';
        const message = type === 0x90 && hasNoteData && data2 > 0
            ? { type: 'noteon', note: data1, velocity: data2 / 127 }
            : type === 0x80 && hasNoteData
                ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
                : type === 0x90 && hasNoteData && data2 === 0
                    ? { type: 'noteoff', note: data1, velocity: data2 / 127 }
                    : status === 0xf8
                        ? { type: 'clock' }
                        : status === 0xfa
                            ? { type: 'start' }
                            : status === 0xfc
                                ? { type: 'stop' }
                                : null;
        if (!message)
            return;
        listeners.value.forEach((cb) => cb(message));
    };
    const detachInputs = () => {
        access.value?.inputs.forEach((input) => {
            input.onmidimessage = null;
        });
    };
    const attachSelectedInput = () => {
        detachInputs();
        if (!selectedInputId.value)
            return;
        const input = access.value?.inputs.get(selectedInputId.value);
        if (input) {
            input.onmidimessage = handleMidiMessage;
        }
    };
    const listen = (cb) => {
        listeners.value.add(cb);
        attachSelectedInput();
        return () => listeners.value.delete(cb);
    };
    const send = (deviceId, message) => {
        const output = access.value?.outputs.get(deviceId);
        if (!output)
            return;
        switch (message.type) {
            case 'noteon':
                output.send([0x90, message.note ?? 0, Math.floor((message.velocity ?? 1) * 127)]);
                break;
            case 'noteoff':
                output.send([0x80, message.note ?? 0, 0]);
                break;
            case 'start':
                output.send([0xfa]);
                break;
            case 'stop':
                output.send([0xfc]);
                break;
            case 'clock':
                output.send([0xf8]);
                break;
            default:
                break;
        }
    };
    const sendClockTick = () => {
        if (selectedOutputId.value) {
            send(selectedOutputId.value, { type: 'clock' });
        }
    };
    const sendStart = () => {
        if (selectedOutputId.value) {
            send(selectedOutputId.value, { type: 'start' });
        }
    };
    const sendStop = () => {
        if (selectedOutputId.value) {
            send(selectedOutputId.value, { type: 'stop' });
        }
    };
    const setSelectedInput = (id) => {
        selectedInputId.value = id;
        attachSelectedInput();
    };
    const setSelectedOutput = (id) => {
        selectedOutputId.value = id;
    };
    const mapNoteToPad = (note) => mapping.value.noteMap[note];
    const setPadForNote = (note, padId) => {
        if (padId) {
            mapping.value.noteMap[note] = padId;
        }
        else {
            delete mapping.value.noteMap[note];
        }
    };
    if (typeof window !== 'undefined') {
        handlePageHide = () => {
            detachInputs();
            if (access.value) {
                access.value.onstatechange = null;
            }
        };
        handlePageShow = () => {
            if (access.value) {
                refreshDevices();
                attachSelectedInput();
                access.value.onstatechange = () => {
                    refreshDevices();
                    attachSelectedInput();
                };
            }
        };
        window.addEventListener('pagehide', handlePageHide);
        window.addEventListener('pageshow', handlePageShow);
    }
    onBeforeUnmount(() => {
        if (handlePageHide) {
            window.removeEventListener('pagehide', handlePageHide);
        }
        if (handlePageShow) {
            window.removeEventListener('pageshow', handlePageShow);
        }
        detachInputs();
        if (access.value) {
            access.value.onstatechange = null;
        }
    });
    return {
        access,
        inputs,
        outputs,
        mapping,
        selectedInputId,
        selectedOutputId,
        supportsMidi,
        requestAccess,
        refreshDevices,
        listen,
        send,
        sendClockTick,
        sendStart,
        sendStop,
        mapNoteToPad,
        setPadForNote,
        setMapping: (next) => {
            mapping.value = next;
        },
        setSelectedInput,
        setSelectedOutput
    };
}
//# sourceMappingURL=useMidi.client.js.map


=========================================
File: dist-test/composables/useMidi.client.js.map
=========================================

{"version":3,"file":"useMidi.client.js","sourceRoot":"","sources":["../../composables/useMidi.client.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useMidiLearn.js
=========================================

import { computed, onBeforeUnmount, ref } from 'vue';
import { defaultMidiMapping } from '@/domain/midiMapping';
const STORAGE_KEY = 'drumcomputer:midi-mapping';
const loadMapping = () => {
    if (typeof localStorage === 'undefined')
        return defaultMidiMapping();
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw)
            return defaultMidiMapping();
        const parsed = JSON.parse(raw);
        return {
            noteMap: parsed.noteMap ?? {},
            noteMapInverse: parsed.noteMapInverse ?? {},
            transportMap: parsed.transportMap ?? {}
        };
    }
    catch {
        return defaultMidiMapping();
    }
};
const persistMapping = (mapping) => {
    if (typeof localStorage === 'undefined')
        return;
    const payload = {
        noteMap: mapping.noteMap ?? {},
        noteMapInverse: mapping.noteMapInverse ?? {},
        transportMap: mapping.transportMap ?? {}
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
};
export function useMidiLearn(midi) {
    // Manages MIDI learn flow for pads and transport actions with persistence to localStorage.
    const isLearning = ref(false);
    const target = ref(null);
    const status = ref(null);
    let unsubscribe = null;
    midi.mapping.value = loadMapping();
    const learningLabel = computed(() => {
        if (!isLearning.value || !target.value)
            return null;
        if (target.value.type === 'pad') {
            return `Learning: ${target.value.padId}`;
        }
        return `Learning: ${target.value.action}`;
    });
    const clear = () => {
        target.value = null;
        status.value = null;
    };
    const midiListen = (cb) => {
        return midi.listen ? midi.listen(cb) : () => undefined;
    };
    const disable = () => {
        isLearning.value = false;
        if (unsubscribe) {
            unsubscribe();
            unsubscribe = null;
        }
        clear();
    };
    const enable = () => {
        if (isLearning.value)
            return;
        isLearning.value = true;
        unsubscribe = midiListen(handleMessage);
    };
    const setTarget = (next) => {
        target.value = next;
        status.value = null;
    };
    const setTransportMapping = (action, note) => {
        midi.mapping.value.transportMap = midi.mapping.value.transportMap ?? {};
        midi.mapping.value.transportMap[action] = note;
        persistMapping(midi.mapping.value);
    };
    const handlePadMapping = (note, padId) => {
        if (midi.mapping.value.noteMapInverse?.[padId] !== undefined) {
            const prevNote = midi.mapping.value.noteMapInverse?.[padId];
            if (typeof prevNote === 'number') {
                delete midi.mapping.value.noteMap[prevNote];
            }
        }
        midi.mapping.value.noteMapInverse = midi.mapping.value.noteMapInverse ?? {};
        midi.mapping.value.noteMapInverse[padId] = note;
        midi.mapping.value.noteMap[note] = padId;
        midi.setPadForNote(note, padId);
        persistMapping(midi.mapping.value);
    };
    const handleMessage = (message) => {
        if (!isLearning.value || !target.value)
            return false;
        if (message.type !== 'noteon' || typeof message.note !== 'number') {
            return false;
        }
        if (target.value.type === 'pad') {
            handlePadMapping(message.note, target.value.padId);
            status.value = `Mapped ${target.value.padId} to note ${message.note}`;
        }
        else {
            setTransportMapping(target.value.action, message.note);
            status.value = `Mapped ${target.value.action} to note ${message.note}`;
        }
        clear();
        return true;
    };
    onBeforeUnmount(() => {
        disable();
    });
    return {
        isLearning,
        target,
        status,
        learningLabel,
        enable,
        disable,
        setTarget,
        handleMessage,
        loadMapping,
        persistMapping
    };
}
//# sourceMappingURL=useMidiLearn.js.map


=========================================
File: dist-test/composables/useMidiLearn.js.map
=========================================

{"version":3,"file":"useMidiLearn.js","sourceRoot":"","sources":["../../composables/useMidiLearn.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/usePatternStorage.client.js
=========================================

import { ref } from 'vue';
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing';
const STORAGE_KEY = 'drum-machine/patterns';
const STORAGE_VERSION = 'v2';
const ensurePatternShape = (pattern, index) => {
    return {
        id: pattern?.id ?? `pattern-${index + 1}`,
        name: pattern?.name ?? `Pattern ${index + 1}`,
        gridSpec: normalizeGridSpec(pattern?.gridSpec ?? DEFAULT_GRID_SPEC),
        steps: pattern?.steps ?? {}
    };
};
export function usePatternStorage() {
    const lastSavedAt = ref(null);
    const save = (payload) => {
        if (typeof window === 'undefined')
            return;
        const normalizedPatterns = payload.patterns.map((pattern, index) => ensurePatternShape(pattern, index));
        const stored = {
            version: STORAGE_VERSION,
            savedAt: Date.now(),
            patterns: normalizedPatterns,
            scenes: payload.scenes ?? [],
            selectedPatternId: payload.selectedPatternId,
            activeSceneId: payload.activeSceneId ?? null
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));
        lastSavedAt.value = stored.savedAt;
    };
    const load = () => {
        if (typeof window === 'undefined') {
            return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null };
        }
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
            return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null };
        }
        try {
            const parsed = JSON.parse(raw);
            const version = parsed.version;
            const basePatterns = Array.isArray(parsed.patterns)
                ? parsed.patterns.map((pattern, index) => ensurePatternShape(pattern, index))
                : [];
            const baseState = {
                patterns: basePatterns,
                scenes: [],
                selectedPatternId: basePatterns[0]?.id ?? 'pattern-1',
                activeSceneId: null
            };
            if (version === 'v2') {
                const parsedV2 = parsed;
                if (typeof parsedV2.savedAt === 'number') {
                    lastSavedAt.value = parsedV2.savedAt;
                }
                return {
                    patterns: basePatterns,
                    scenes: Array.isArray(parsedV2.scenes) ? parsedV2.scenes : [],
                    selectedPatternId: parsedV2.selectedPatternId ?? baseState.selectedPatternId,
                    activeSceneId: parsedV2.activeSceneId ?? null
                };
            }
            if (typeof parsed.savedAt === 'number') {
                lastSavedAt.value = parsed.savedAt ?? null;
            }
            return baseState;
        }
        catch (error) {
            console.error('Failed to parse patterns from LocalStorage', error);
            return { patterns: [], scenes: [], selectedPatternId: 'pattern-1', activeSceneId: null };
        }
    };
    const clear = () => {
        if (typeof window === 'undefined')
            return;
        localStorage.removeItem(STORAGE_KEY);
    };
    return {
        save,
        load,
        clear,
        lastSavedAt
    };
}
//# sourceMappingURL=usePatternStorage.client.js.map


=========================================
File: dist-test/composables/usePatternStorage.client.js.map
=========================================

{"version":3,"file":"usePatternStorage.client.js","sourceRoot":"","sources":["../../composables/usePatternStorage.client.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useQuickBrowse.js
=========================================

import { ref } from 'vue';
const maxHistory = 50;
const storageKey = 'drumcomputer_quick_browse_v1';
const hasClientStorage = () => {
    if (typeof window === 'undefined' || typeof localStorage === 'undefined')
        return false;
    if (typeof import.meta !== 'undefined' && 'client' in import.meta && !import.meta.client)
        return false;
    return true;
};
const readStorage = () => {
    if (!hasClientStorage())
        return [];
    try {
        const raw = localStorage.getItem(storageKey);
        if (!raw)
            return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed))
            return [];
        return parsed
            .filter((entry) => entry && typeof entry.contextId === 'string' && typeof entry.timestamp === 'number')
            .map((entry) => ({
            timestamp: Number(entry.timestamp),
            mode: entry.mode,
            query: String(entry.query ?? ''),
            filters: (entry.filters ?? {}),
            selectedId: entry.selectedId ?? null,
            contextType: entry.contextType,
            contextId: String(entry.contextId)
        }));
    }
    catch {
        return [];
    }
};
const writeStorage = (entries) => {
    if (!hasClientStorage())
        return;
    try {
        localStorage.setItem(storageKey, JSON.stringify(entries));
    }
    catch {
        // ignore storage errors
    }
};
const sortHistory = (entries) => [...entries].sort((a, b) => b.timestamp - a.timestamp);
export function useQuickBrowse() {
    const history = ref(sortHistory(readStorage()));
    function recordBrowse(entry) {
        if (!hasClientStorage())
            return;
        const timestamp = Date.now();
        const withoutContext = history.value.filter((item) => item.contextId !== entry.contextId);
        const next = sortHistory([{ ...entry, timestamp }, ...withoutContext]).slice(0, maxHistory);
        history.value = next;
        writeStorage(next);
    }
    function getLastBrowse(contextId) {
        return history.value.find((entry) => entry.contextId === contextId) ?? null;
    }
    function restoreBrowse(entry) {
        void import('../stores/browser').then(async ({ useBrowserStore }) => {
            const browser = useBrowserStore();
            await browser.setMode(entry.mode);
            browser.filters = { ...entry.filters };
            browser.library.query = entry.query;
            await browser.search();
            if (entry.selectedId) {
                await browser.selectResult(entry.selectedId);
            }
        });
    }
    function clearHistory() {
        history.value = [];
        writeStorage([]);
    }
    return { history, recordBrowse, getLastBrowse, restoreBrowse, clearHistory };
}
//# sourceMappingURL=useQuickBrowse.js.map


=========================================
File: dist-test/composables/useQuickBrowse.js.map
=========================================

{"version":3,"file":"useQuickBrowse.js","sourceRoot":"","sources":["../../composables/useQuickBrowse.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useRecentFiles.js
=========================================

const maxRecent = 50;
const storageKey = 'drumcomputer_recent_files_v1';
const hasClientStorage = () => {
    if (typeof window === 'undefined' || typeof localStorage === 'undefined')
        return false;
    if (typeof import.meta !== 'undefined' && 'client' in import.meta && !import.meta.client)
        return false;
    return true;
};
const readStorage = () => {
    if (!hasClientStorage())
        return [];
    try {
        const raw = localStorage.getItem(storageKey);
        if (!raw)
            return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed))
            return [];
        return parsed
            .filter((entry) => entry && typeof entry.id === 'string' && typeof entry.timestamp === 'number')
            .map((entry) => ({
            id: String(entry.id),
            path: String(entry.path ?? ''),
            name: String(entry.name ?? ''),
            timestamp: Number(entry.timestamp),
            type: entry.type ?? 'sample'
        }));
    }
    catch {
        return [];
    }
};
const writeStorage = (entries) => {
    if (!hasClientStorage())
        return;
    try {
        localStorage.setItem(storageKey, JSON.stringify(entries));
    }
    catch {
        // ignore storage errors (quota etc.)
    }
};
const sortByTimestamp = (entries) => [...entries].sort((a, b) => b.timestamp - a.timestamp);
export function useRecentFiles() {
    function addRecent(entry) {
        if (!hasClientStorage())
            return;
        const timestamp = Date.now();
        const existing = readStorage().filter((item) => item.id !== entry.id);
        const next = sortByTimestamp([{ ...entry, timestamp }, ...existing]).slice(0, maxRecent);
        writeStorage(next);
    }
    function getRecent(limit) {
        const entries = sortByTimestamp(readStorage());
        if (limit && limit > 0)
            return entries.slice(0, limit);
        return entries;
    }
    function clearRecent() {
        if (!hasClientStorage())
            return;
        writeStorage([]);
    }
    function removeRecent(id) {
        if (!hasClientStorage())
            return;
        const next = readStorage().filter((entry) => entry.id !== id);
        writeStorage(next);
    }
    return { addRecent, getRecent, clearRecent, removeRecent };
}
//# sourceMappingURL=useRecentFiles.js.map


=========================================
File: dist-test/composables/useRecentFiles.js.map
=========================================

{"version":3,"file":"useRecentFiles.js","sourceRoot":"","sources":["../../composables/useRecentFiles.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useSamplePreview.client.js
=========================================

import { inject, onBeforeUnmount, reactive } from 'vue';
import { getFileSystemRepository } from '../services/fileSystemRepository';
const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
export function useSamplePreview() {
    const audioContext = inject('audioContext', null);
    const state = reactive({
        isPlaying: false,
        currentFile: null,
        progress: 0,
        duration: 0
    });
    let sourceNode = null;
    let buffer = null;
    let startTime = 0;
    let pausedAt = 0;
    let rafId = 0;
    const cancelProgress = () => {
        if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = 0;
        }
    };
    const updateProgress = () => {
        if (!audioContext || !buffer || !state.isPlaying)
            return;
        const elapsed = audioContext.currentTime - startTime;
        const duration = buffer.duration || 0;
        state.progress = duration > 0 ? clamp(elapsed / duration, 0, 1) : 0;
        if (state.progress >= 1) {
            stop();
            return;
        }
        rafId = requestAnimationFrame(updateProgress);
    };
    const detachSource = () => {
        if (sourceNode) {
            sourceNode.onended = null;
            try {
                sourceNode.stop();
            }
            catch {
                // ignore
            }
            try {
                sourceNode.disconnect();
            }
            catch {
                // ignore
            }
            sourceNode = null;
        }
    };
    const createSource = () => {
        if (!audioContext || !buffer)
            return;
        const node = audioContext.createBufferSource();
        node.buffer = buffer;
        node.connect(audioContext.destination);
        node.onended = () => {
            if (state.isPlaying) {
                stop();
            }
        };
        sourceNode = node;
    };
    async function loadAndPlay(path, blob) {
        if (!audioContext)
            return;
        stop();
        const repo = getFileSystemRepository();
        const fileBlob = blob ?? (await repo.readFileBlob?.(path));
        if (!fileBlob)
            return;
        const arrayBuffer = await fileBlob.arrayBuffer();
        buffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
        state.duration = buffer?.duration ?? 0;
        state.currentFile = path;
        state.progress = 0;
        pausedAt = 0;
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        createSource();
        if (!sourceNode)
            return;
        startTime = audioContext.currentTime;
        sourceNode.start(0);
        state.isPlaying = true;
        cancelProgress();
        rafId = requestAnimationFrame(updateProgress);
    }
    function stop() {
        cancelProgress();
        detachSource();
        state.isPlaying = false;
        state.progress = 0;
        state.duration = buffer?.duration ?? 0;
        pausedAt = 0;
    }
    function pause() {
        if (!audioContext || !state.isPlaying)
            return;
        pausedAt = audioContext.currentTime - startTime;
        state.isPlaying = false;
        cancelProgress();
        detachSource();
    }
    function resume() {
        if (!audioContext || !buffer || state.isPlaying)
            return;
        const offset = clamp(pausedAt, 0, buffer.duration);
        createSource();
        if (!sourceNode)
            return;
        startTime = audioContext.currentTime - offset;
        sourceNode.start(0, offset);
        state.isPlaying = true;
        cancelProgress();
        rafId = requestAnimationFrame(updateProgress);
    }
    function seek(position) {
        if (!buffer)
            return;
        const offset = clamp(position, 0, 1) * buffer.duration;
        pausedAt = offset;
        state.progress = buffer.duration > 0 ? clamp(offset / buffer.duration, 0, 1) : 0;
        if (state.isPlaying) {
            detachSource();
            createSource();
            if (!sourceNode || !audioContext)
                return;
            startTime = audioContext.currentTime - offset;
            sourceNode.start(0, offset);
        }
    }
    onBeforeUnmount(() => {
        stop();
    });
    return { state, loadAndPlay, stop, pause, resume, seek };
}
//# sourceMappingURL=useSamplePreview.client.js.map


=========================================
File: dist-test/composables/useSamplePreview.client.js.map
=========================================

{"version":3,"file":"useSamplePreview.client.js","sourceRoot":"","sources":["../../composables/useSamplePreview.client.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useScheduler.js
=========================================

import { onBeforeUnmount, ref } from 'vue';
export function useScheduler(config) {
    const tasks = ref([]);
    const intervalId = ref(null);
    let wasRunningOnHide = false;
    const tick = () => {
        const now = config.getTime();
        const windowLimit = now + config.scheduleAheadSec;
        const ready = tasks.value.filter((task) => task.when <= windowLimit);
        tasks.value = tasks.value.filter((task) => task.when > windowLimit);
        ready.forEach((task) => task.callback());
    };
    const start = () => {
        if (intervalId.value !== null)
            return;
        intervalId.value = window.setInterval(tick, config.lookahead);
    };
    const stop = () => {
        if (intervalId.value !== null) {
            clearInterval(intervalId.value);
            intervalId.value = null;
        }
    };
    const schedule = (task) => {
        tasks.value.push(task);
    };
    const clear = () => {
        tasks.value = [];
    };
    if (typeof window !== 'undefined') {
        const handlePageHide = () => {
            if (intervalId.value !== null) {
                wasRunningOnHide = true;
                stop();
            }
            else {
                wasRunningOnHide = false;
            }
        };
        const handlePageShow = () => {
            if (wasRunningOnHide) {
                start();
                tick();
            }
        };
        window.addEventListener('pagehide', handlePageHide);
        window.addEventListener('pageshow', handlePageShow);
        onBeforeUnmount(() => {
            stop();
            window.removeEventListener('pagehide', handlePageHide);
            window.removeEventListener('pageshow', handlePageShow);
        });
    }
    else {
        onBeforeUnmount(stop);
    }
    return {
        start,
        stop,
        clear,
        tick,
        schedule
    };
}
//# sourceMappingURL=useScheduler.js.map


=========================================
File: dist-test/composables/useScheduler.js.map
=========================================

{"version":3,"file":"useScheduler.js","sourceRoot":"","sources":["../../composables/useScheduler.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,GAAG,EAAE,MAAM,KAAK,CAAA;AAa1C,MAAM,UAAU,YAAY,CAAC,MAAuB;IAClD,MAAM,KAAK,GAAG,GAAG,CAAkB,EAAE,CAAC,CAAA;IACtC,MAAM,UAAU,GAAG,GAAG,CAAgB,IAAI,CAAC,CAAA;IAC3C,IAAI,gBAAgB,GAAG,KAAK,CAAA;IAE5B,MAAM,IAAI,GAAG,GAAG,EAAE;QAChB,MAAM,GAAG,GAAG,MAAM,CAAC,OAAO,EAAE,CAAA;QAC5B,MAAM,WAAW,GAAG,GAAG,GAAG,MAAM,CAAC,gBAAgB,CAAA;QACjD,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,IAAI,WAAW,CAAC,CAAA;QACpE,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,CAAA;QACnE,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAA;IAC1C,CAAC,CAAA;IAED,MAAM,KAAK,GAAG,GAAG,EAAE;QACjB,IAAI,UAAU,CAAC,KAAK,KAAK,IAAI;YAAE,OAAM;QACrC,UAAU,CAAC,KAAK,GAAG,MAAM,CAAC,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,SAAS,CAAC,CAAA;IAC/D,CAAC,CAAA;IAED,MAAM,IAAI,GAAG,GAAG,EAAE;QAChB,IAAI,UAAU,CAAC,KAAK,KAAK,IAAI,EAAE,CAAC;YAC9B,aAAa,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA;YAC/B,UAAU,CAAC,KAAK,GAAG,IAAI,CAAA;QACzB,CAAC;IACH,CAAC,CAAA;IAED,MAAM,QAAQ,GAAG,CAAC,IAAmB,EAAE,EAAE;QACvC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IACxB,CAAC,CAAA;IAED,MAAM,KAAK,GAAG,GAAG,EAAE;QACjB,KAAK,CAAC,KAAK,GAAG,EAAE,CAAA;IAClB,CAAC,CAAA;IAED,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE,CAAC;QAClC,MAAM,cAAc,GAAG,GAAG,EAAE;YAC1B,IAAI,UAAU,CAAC,KAAK,KAAK,IAAI,EAAE,CAAC;gBAC9B,gBAAgB,GAAG,IAAI,CAAA;gBACvB,IAAI,EAAE,CAAA;YACR,CAAC;iBAAM,CAAC;gBACN,gBAAgB,GAAG,KAAK,CAAA;YAC1B,CAAC;QACH,CAAC,CAAA;QAED,MAAM,cAAc,GAAG,GAAG,EAAE;YAC1B,IAAI,gBAAgB,EAAE,CAAC;gBACrB,KAAK,EAAE,CAAA;gBACP,IAAI,EAAE,CAAA;YACR,CAAC;QACH,CAAC,CAAA;QAED,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAA;QACnD,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAA;QAEnD,eAAe,CAAC,GAAG,EAAE;YACnB,IAAI,EAAE,CAAA;YACN,MAAM,CAAC,mBAAmB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAA;YACtD,MAAM,CAAC,mBAAmB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAA;QACxD,CAAC,CAAC,CAAA;IACJ,CAAC;SAAM,CAAC;QACN,eAAe,CAAC,IAAI,CAAC,CAAA;IACvB,CAAC;IAED,OAAO;QACL,KAAK;QACL,IAAI;QACJ,KAAK;QACL,IAAI;QACJ,QAAQ;KACT,CAAA;AACH,CAAC"}


=========================================
File: dist-test/composables/useSequencer.js
=========================================

import { ref } from 'vue';
import { quantizeToStep } from '@/domain/quantize';
import { normalizeGridSpec, secondsPerStep } from '@/domain/timing';
import { useTransportStore } from '@/stores/transport';
import { useScheduler } from './useScheduler';
import { useAudioEngine } from './useAudioEngine.client';
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity';
import { createRenderClock } from '@/domain/clock/renderClock';
const totalStepsForGrid = (gridSpec) => gridSpec.bars * gridSpec.division;
export function scheduleStep(options, when) {
    const pattern = options.getPattern();
    const totalSteps = totalStepsForGrid(pattern.gridSpec);
    const loopStart = Math.min(Math.max(0, options.transport.loopStart), Math.max(0, totalSteps - 1));
    const loopEnd = Math.min(Math.max(loopStart + 1, options.transport.loopEnd), totalSteps);
    const loopLength = Math.max(1, loopEnd - loopStart);
    const stepIndex = loopStart +
        (((options.currentStep.value - loopStart) % loopLength) + loopLength) %
            loopLength;
    const barIndex = Math.floor(stepIndex / pattern.gridSpec.division);
    const stepInBar = stepIndex % pattern.gridSpec.division;
    const scheduledWhen = Math.max(when, options.clock.now());
    options.pendingSteps.value.push({ when: scheduledWhen, stepAddress: { barIndex, stepInBar } });
    options.scheduler.schedule({
        when: scheduledWhen,
        callback: () => {
            const bar = pattern.steps[barIndex];
            const stepRow = bar?.[stepInBar];
            if (stepRow) {
                Object.entries(stepRow).forEach(([padId, cell]) => {
                    options.audio.trigger({
                        padId: padId,
                        when: scheduledWhen,
                        velocity: cell?.velocity?.value ?? 1
                    });
                });
            }
            const rawNext = options.currentStep.value + 1;
            const nextStepInLoop = loopStart + (((rawNext - loopStart) % loopLength) + loopLength) % loopLength;
            const isPatternBoundary = nextStepInLoop === 0;
            if (options.transport.metronomeEnabled) {
                const isQuarter = pattern.gridSpec.division % 4 === 0
                    ? stepInBar % (pattern.gridSpec.division / 4) === 0
                    : stepInBar === 0;
                if (isQuarter) {
                    void options.audio.triggerClick(scheduledWhen, isPatternBoundary, options.transport.metronomeVolume);
                }
            }
            let nextPattern = pattern;
            if (isPatternBoundary && options.onPatternBoundary) {
                const candidate = options.onPatternBoundary();
                if (candidate) {
                    nextPattern = candidate;
                    options.transport.setGridSpec(nextPattern.gridSpec);
                }
                else {
                    nextPattern = options.getPattern();
                }
            }
            options.currentStep.value = nextStepInLoop;
            options.transport.setCurrentStep(options.currentStep.value);
            if (options.transport.loop) {
                const stepDuration = secondsPerStep(options.transport.bpm, nextPattern.gridSpec.division);
                scheduleStep(options, scheduledWhen + stepDuration);
            }
        }
    });
}
export function useSequencer(options) {
    const transport = useTransportStore();
    const audio = useAudioEngine();
    let renderClock = null;
    const scheduler = useScheduler({
        lookahead: options.lookahead ?? 25,
        scheduleAheadSec: options.scheduleAheadSec ?? 0.1,
        getTime: () => renderClock?.now() ?? 0
    });
    const currentStep = ref(0);
    const isRecording = ref(false);
    const pendingSteps = ref([]);
    let loopStartTime = 0;
    const boundaryCallback = options.onPatternBoundary ?? (() => undefined);
    const buildStepOptions = (clock) => ({
        clock,
        scheduler,
        audio,
        transport,
        getPattern: options.getPattern,
        currentStep,
        pendingSteps,
        onPatternBoundary: boundaryCallback
    });
    const start = async () => {
        if (transport.isPlaying)
            return;
        const ctx = await audio.resumeContext();
        renderClock = createRenderClock(ctx);
        const pattern = options.getPattern();
        const gridSpec = normalizeGridSpec(pattern.gridSpec);
        pattern.gridSpec = gridSpec;
        transport.setGridSpec(gridSpec);
        loopStartTime = renderClock.now();
        currentStep.value = Math.max(0, transport.loopStart);
        pendingSteps.value = [];
        transport.setCurrentStep(currentStep.value);
        transport.setPlaying(true);
        scheduler.clear();
        const stepOptions = buildStepOptions(renderClock);
        scheduleStep(stepOptions, loopStartTime);
        scheduler.start();
        scheduler.tick();
    };
    const stop = () => {
        transport.setPlaying(false);
        scheduler.stop();
        scheduler.clear();
        pendingSteps.value = [];
        currentStep.value = Math.max(0, transport.loopStart);
        transport.setCurrentStep(currentStep.value);
        loopStartTime = 0;
        renderClock = null;
    };
    const toggleStep = (barIndex, stepInBar, padId) => {
        const pattern = options.getPattern();
        const bar = pattern.steps[barIndex] ?? {};
        const stepRow = bar[stepInBar] ?? {};
        const updated = { ...stepRow };
        const nextVelocity = cycleVelocity(updated[padId]?.velocity?.value);
        if (nextVelocity === null) {
            delete updated[padId];
        }
        else {
            updated[padId] = { velocity: { value: clampVelocity(nextVelocity) } };
        }
        pattern.steps[barIndex] = { ...bar, [stepInBar]: updated };
    };
    const setStepVelocity = (barIndex, stepInBar, padId, velocity) => {
        const pattern = options.getPattern();
        const bar = pattern.steps[barIndex] ?? {};
        const stepRow = bar[stepInBar] ?? {};
        const updated = { ...stepRow, [padId]: { velocity: { value: clampVelocity(velocity || DEFAULT_STEP_VELOCITY) } } };
        pattern.steps[barIndex] = { ...bar, [stepInBar]: updated };
    };
    const recordHit = async (padId, velocity = 1, quantize = true) => {
        const pattern = options.getPattern();
        const ctx = await audio.resumeContext();
        const gridSpec = pattern.gridSpec;
        const stepDuration = secondsPerStep(transport.bpm, gridSpec.division);
        const resolvedVelocity = clampVelocity(velocity);
        const anchor = transport.isPlaying ? loopStartTime : ctx.currentTime;
        if (!transport.isPlaying) {
            loopStartTime = anchor;
        }
        const sinceStart = ctx.currentTime - anchor;
        const step = quantize
            ? quantizeToStep(sinceStart, stepDuration, gridSpec.bars, gridSpec.division)
            : {
                barIndex: Math.floor(currentStep.value / gridSpec.division),
                stepInBar: currentStep.value % gridSpec.division
            };
        setStepVelocity(step.barIndex, step.stepInBar, padId, resolvedVelocity);
        audio.trigger({ padId, when: ctx.currentTime, velocity: resolvedVelocity });
    };
    const setSampleForPad = async (padId, sample) => {
        await audio.setSampleForPad(padId, sample);
    };
    const applySoundbank = async (bank) => {
        await audio.applySoundbank(bank);
    };
    const getAudioTime = () => renderClock?.now() ?? audio.ensureContext().currentTime;
    return {
        currentStep,
        isRecording,
        pendingSteps,
        start,
        stop,
        toggleStep,
        setStepVelocity,
        recordHit,
        fxSettings: audio.fxSettings,
        setFx: audio.setFx,
        setSampleForPad,
        applySoundbank,
        getAudioTime
    };
}
//# sourceMappingURL=useSequencer.js.map


=========================================
File: dist-test/composables/useSequencer.js.map
=========================================

{"version":3,"file":"useSequencer.js","sourceRoot":"","sources":["../../composables/useSequencer.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useSoundbankStorage.client.js
=========================================

import { ref } from 'vue';
const DB_NAME = 'drum-machine-db';
const DB_VERSION = 2;
const stripNonSerializableSample = (sample) => {
    if (!sample)
        return undefined;
    const sanitized = {
        id: sample.id,
        name: sample.name
    };
    if (sample.url !== undefined) {
        sanitized.url = sample.url;
    }
    if (sample.format !== undefined) {
        sanitized.format = sample.format;
    }
    return sanitized;
};
const serializeSoundbank = (bank) => {
    const pads = {};
    Object.entries(bank.pads).forEach(([padId, sample]) => {
        const sanitized = stripNonSerializableSample(sample);
        if (sanitized) {
            pads[padId] = sanitized;
        }
    });
    return {
        id: bank.id,
        name: bank.name,
        createdAt: bank.createdAt,
        updatedAt: bank.updatedAt,
        pads
    };
};
export function useSoundbankStorage() {
    const dbRef = ref(null);
    const open = () => {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = () => {
                const db = request.result;
                if (!db.objectStoreNames.contains('soundbanks')) {
                    db.createObjectStore('soundbanks', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('samples')) {
                    db.createObjectStore('samples', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('patterns')) {
                    const store = db.createObjectStore('patterns', { keyPath: 'id' });
                    store.createIndex('bankId', 'bankId', { unique: false });
                }
            };
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                dbRef.value = request.result;
                resolve(request.result);
            };
        });
    };
    const ensureDb = async () => {
        if (dbRef.value)
            return dbRef.value;
        return open();
    };
    const saveBank = async (bank) => {
        const db = await ensureDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['soundbanks'], 'readwrite');
            tx.objectStore('soundbanks').put(serializeSoundbank(bank));
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
        });
    };
    const saveSample = async (sample) => {
        const db = await ensureDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['samples'], 'readwrite');
            const record = { id: sample.id, name: sample.name, blob: sample.blob };
            if (sample.format) {
                record.format = sample.format;
            }
            tx.objectStore('samples').put(record);
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
        });
    };
    const loadBanks = async () => {
        const db = await ensureDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['soundbanks'], 'readonly');
            const request = tx.objectStore('soundbanks').getAll();
            request.onsuccess = () => resolve(request.result ?? []);
            request.onerror = () => reject(request.error);
        });
    };
    const loadSample = async (sampleId) => {
        const db = await ensureDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['samples'], 'readonly');
            const request = tx.objectStore('samples').get(sampleId);
            request.onsuccess = () => {
                const result = request.result;
                if (!result) {
                    resolve(null);
                    return;
                }
                const restored = { id: result.id, name: result.name, blob: result.blob };
                const format = result.format;
                if (format) {
                    restored.format = format;
                }
                resolve(restored);
            };
            request.onerror = () => reject(request.error);
        });
    };
    const savePatterns = async (bankId, patterns) => {
        const db = await ensureDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['patterns'], 'readwrite');
            patterns.forEach((pattern) => {
                const record = { id: `${bankId}:${pattern.id}`, bankId, pattern };
                tx.objectStore('patterns').put(record);
            });
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
        });
    };
    const loadPatterns = async (bankId) => {
        const db = await ensureDb();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['patterns'], 'readonly');
            const index = tx.objectStore('patterns').index('bankId');
            const request = index.getAll(bankId);
            request.onsuccess = () => {
                const records = request.result ?? [];
                resolve(records.map((record) => record.pattern));
            };
            request.onerror = () => reject(request.error);
        });
    };
    return {
        saveBank,
        saveSample,
        loadBanks,
        loadSample,
        savePatterns,
        loadPatterns
    };
}
//# sourceMappingURL=useSoundbankStorage.client.js.map


=========================================
File: dist-test/composables/useSoundbankStorage.client.js.map
=========================================

{"version":3,"file":"useSoundbankStorage.client.js","sourceRoot":"","sources":["../../composables/useSoundbankStorage.client.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/composables/useSync.client.js
=========================================

import { onBeforeUnmount, ref } from 'vue';
import { useScheduler } from './useScheduler';
const MIDI_CLOCKS_PER_QUARTER = 24;
const CLOCK_AUTHORITY = 'audioContext';
export function useSync(initialMode = 'internal', deps) {
    // Coordinates transport sync between audio clock and MIDI clock roles (master/slave), handling clock ticks and start/stop events.
    const state = ref({
        bpm: 120,
        phase: 0,
        isPlaying: false,
        mode: initialMode,
        role: 'master',
        linkAvailable: false,
        clockAuthority: CLOCK_AUTHORITY,
        bpmSource: 'transport'
    });
    const scheduler = deps?.getAudioTime
        ? useScheduler({
            lookahead: 25,
            scheduleAheadSec: 0.05,
            getTime: deps.getAudioTime
        })
        : null;
    const lastStableBpm = ref(state.value.bpm);
    let nextClockAt = null;
    let midiUnsubscribe = null;
    const secondsPerClockTick = () => 60 / (state.value.bpm * MIDI_CLOCKS_PER_QUARTER);
    const resetPhase = () => {
        state.value.phase = 0;
    };
    const stopClock = () => {
        scheduler?.stop();
        scheduler?.clear();
        nextClockAt = null;
        deps?.midi?.sendStop();
    };
    const tick = () => {
        state.value.phase = (state.value.phase + 1) % MIDI_CLOCKS_PER_QUARTER;
    };
    const scheduleClockTick = () => {
        if (!scheduler || nextClockAt === null)
            return;
        scheduler.schedule({
            when: nextClockAt,
            callback: () => {
                deps?.midi?.sendClockTick();
                tick();
                if (nextClockAt !== null) {
                    nextClockAt = nextClockAt + secondsPerClockTick();
                    scheduleClockTick();
                }
            }
        });
    };
    const startClock = () => {
        stopClock();
        if (state.value.mode !== 'midiClock' || state.value.role !== 'master')
            return;
        if (!deps?.midi?.selectedOutputId.value)
            return;
        if (!deps?.getAudioTime || !scheduler)
            return;
        const now = deps.getAudioTime();
        nextClockAt = now + secondsPerClockTick();
        deps.midi.sendStart();
        scheduleClockTick();
        scheduler.start();
        scheduler.tick();
    };
    const setMode = (mode) => {
        state.value.mode = mode;
        state.value.bpm = lastStableBpm.value;
        stopClock();
        if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
            startClock();
        }
    };
    const setRole = (role) => {
        state.value.role = role;
        state.value.bpm = lastStableBpm.value;
        stopClock();
        if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
            startClock();
        }
    };
    const setPlaying = (isPlaying) => {
        state.value.isPlaying = isPlaying;
        if (isPlaying) {
            startClock();
        }
        else {
            stopClock();
        }
    };
    const setBpm = (bpm) => {
        state.value.bpm = Math.max(20, Math.min(300, bpm));
        lastStableBpm.value = state.value.bpm;
        if (state.value.isPlaying && state.value.mode === 'midiClock' && state.value.role === 'master') {
            startClock();
        }
    };
    const handleMidiMessage = (message) => {
        if (state.value.mode !== 'midiClock' || state.value.role !== 'slave')
            return;
        if (message.type === 'start') {
            state.value.isPlaying = true;
            resetPhase();
            deps?.onExternalStart?.();
        }
        else if (message.type === 'stop') {
            state.value.isPlaying = false;
            resetPhase();
            deps?.onExternalStop?.();
        }
        else if (message.type === 'clock') {
            tick();
        }
    };
    const startTransport = (bpm) => {
        setBpm(bpm);
        setPlaying(true);
    };
    const stopTransport = () => {
        setPlaying(false);
    };
    if (deps?.midi) {
        midiUnsubscribe = deps.midi.listen(handleMidiMessage);
    }
    onBeforeUnmount(() => {
        stopClock();
        midiUnsubscribe?.();
    });
    return {
        state,
        setMode,
        setRole,
        setPlaying,
        setBpm,
        startTransport,
        stopTransport
    };
}
//# sourceMappingURL=useSync.client.js.map


=========================================
File: dist-test/composables/useSync.client.js.map
=========================================

{"version":3,"file":"useSync.client.js","sourceRoot":"","sources":["../../composables/useSync.client.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/domain/clock/renderClock.js
=========================================

export function createRenderClock(ctx, isOffline = false) {
    return {
        ctx,
        isOffline,
        audioTime: () => ctx.currentTime,
        now: () => ctx.currentTime
    };
}
//# sourceMappingURL=renderClock.js.map


=========================================
File: dist-test/domain/clock/renderClock.js.map
=========================================

{"version":3,"file":"renderClock.js","sourceRoot":"","sources":["../../../domain/clock/renderClock.ts"],"names":[],"mappings":"AAqBA,MAAM,UAAU,iBAAiB,CAG/B,GAAqB,EACrB,SAAS,GAAG,KAAK;IAEjB,OAAO;QACL,GAAG;QACH,SAAS;QACT,SAAS,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,WAAW;QAChC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,WAAW;KAC3B,CAAA;AACH,CAAC"}


=========================================
File: dist-test/domain/clock/scheduler.js
=========================================

// Lookahead scheduler that batches callbacks scheduled within a horizon relative to the audio clock.
const DEFAULT_OPTIONS = {
    lookaheadSec: 0.1,
    intervalMs: 25
};
export function createScheduler(clock, options = {}) {
    const cfg = { ...DEFAULT_OPTIONS, ...options };
    let timerId = null;
    let wasRunningOnHide = false;
    let queue = [];
    const flush = () => {
        const now = clock.audioTime();
        const horizon = now + cfg.lookaheadSec;
        queue.sort((a, b) => a.at - b.at);
        const due = [];
        const pending = [];
        for (const item of queue) {
            if (item.at <= horizon) {
                due.push(item);
            }
            else {
                pending.push(item);
            }
        }
        queue = pending;
        for (const item of due) {
            item.fn(item.at);
        }
    };
    const startTimer = () => {
        if (clock.isOffline) {
            return;
        }
        if (timerId) {
            return;
        }
        timerId = setInterval(flush, cfg.intervalMs);
    };
    const stopTimer = () => {
        if (!timerId) {
            return;
        }
        clearInterval(timerId);
        timerId = null;
    };
    if (typeof window !== 'undefined') {
        const handlePageHide = () => {
            if (timerId) {
                wasRunningOnHide = true;
                stopTimer();
            }
            else {
                wasRunningOnHide = false;
            }
        };
        const handlePageShow = () => {
            if (wasRunningOnHide) {
                startTimer();
                flush();
            }
        };
        window.addEventListener('pagehide', handlePageHide);
        window.addEventListener('pageshow', handlePageShow);
    }
    return {
        start() {
            startTimer();
        },
        stop() {
            stopTimer();
        },
        schedule(atTimeSec, fn) {
            queue.push({ at: atTimeSec, fn });
        },
        clear() {
            queue = [];
        }
    };
}
//# sourceMappingURL=scheduler.js.map


=========================================
File: dist-test/domain/clock/scheduler.js.map
=========================================

{"version":3,"file":"scheduler.js","sourceRoot":"","sources":["../../../domain/clock/scheduler.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/domain/midiMapping.js
=========================================

const defaultPads = [
    'pad1',
    'pad2',
    'pad3',
    'pad4',
    'pad5',
    'pad6',
    'pad7',
    'pad8',
    'pad9',
    'pad10',
    'pad11',
    'pad12',
    'pad13',
    'pad14',
    'pad15',
    'pad16'
];
export function defaultMidiMapping() {
    const noteMap = {};
    const noteMapInverse = {};
    defaultPads.forEach((padId, index) => {
        const note = 36 + index;
        noteMap[note] = padId;
        noteMapInverse[padId] = note;
    });
    return { noteMap, noteMapInverse, transportMap: {} };
}
//# sourceMappingURL=midiMapping.js.map


=========================================
File: dist-test/domain/midiMapping.js.map
=========================================

{"version":3,"file":"midiMapping.js","sourceRoot":"","sources":["../../domain/midiMapping.ts"],"names":[],"mappings":"AAGA,MAAM,WAAW,GAAgB;IAC/B,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;CACR,CAAA;AAED,MAAM,UAAU,kBAAkB;IAChC,MAAM,OAAO,GAAuC,EAAE,CAAA;IACtD,MAAM,cAAc,GAAuC,EAAE,CAAA;IAC7D,WAAW,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;QACnC,MAAM,IAAI,GAAG,EAAE,GAAG,KAAK,CAAA;QACvB,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;QACrB,cAAc,CAAC,KAAK,CAAC,GAAG,IAAI,CAAA;IAC9B,CAAC,CAAC,CAAA;IACF,OAAO,EAAE,OAAO,EAAE,cAAc,EAAE,YAAY,EAAE,EAAE,EAAE,CAAA;AACtD,CAAC"}


=========================================
File: dist-test/domain/quantize.js
=========================================

export function quantizeToStep(time, secondsPerStep, bars, division) {
    const totalSteps = bars * division;
    const stepIndex = Math.max(0, Math.min(totalSteps - 1, Math.round(time / secondsPerStep)));
    return {
        barIndex: Math.floor(stepIndex / division),
        stepInBar: stepIndex % division
    };
}
//# sourceMappingURL=quantize.js.map


=========================================
File: dist-test/domain/quantize.js.map
=========================================

{"version":3,"file":"quantize.js","sourceRoot":"","sources":["../../domain/quantize.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,cAAc,CAAC,IAAY,EAAE,cAAsB,EAAE,IAAY,EAAE,QAAgB;IACjG,MAAM,UAAU,GAAG,IAAI,GAAG,QAAQ,CAAA;IAClC,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,CAAA;IAC1F,OAAO;QACL,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1C,SAAS,EAAE,SAAS,GAAG,QAAQ;KAChC,CAAA;AACH,CAAC"}


=========================================
File: dist-test/domain/timing.js
=========================================

export const GRID_DIVISIONS = [1, 2, 4, 8, 16, 32, 64];
export const DEFAULT_GRID_SPEC = { bars: 1, division: 16 };
export function secondsPerStep(bpm, division) {
    return (60 / bpm) * (4 / division);
}
export function stepsPerBar(gridSpec) {
    return gridSpec.division;
}
export function normalizeGridSpec(gridSpec) {
    const division = GRID_DIVISIONS.includes((gridSpec?.division ?? DEFAULT_GRID_SPEC.division))
        ? gridSpec?.division
        : DEFAULT_GRID_SPEC.division;
    const bars = gridSpec?.bars === 1 || gridSpec?.bars === 2 || gridSpec?.bars === 4 || gridSpec?.bars === 8
        ? gridSpec.bars
        : DEFAULT_GRID_SPEC.bars;
    return { bars, division };
}
//# sourceMappingURL=timing.js.map


=========================================
File: dist-test/domain/timing.js.map
=========================================

{"version":3,"file":"timing.js","sourceRoot":"","sources":["../../domain/timing.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,MAAM,cAAc,GAA4B,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAU,CAAA;AACxF,MAAM,CAAC,MAAM,iBAAiB,GAAa,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAA;AAEpE,MAAM,UAAU,cAAc,CAAC,GAAW,EAAE,QAAgB;IAC1D,OAAO,CAAC,EAAE,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAA;AACpC,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,QAAkB;IAC5C,OAAO,QAAQ,CAAC,QAAQ,CAAA;AAC1B,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,QAA4B;IAC5D,MAAM,QAAQ,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC,QAAQ,EAAE,QAAQ,IAAI,iBAAiB,CAAC,QAAQ,CAAiB,CAAC;QAC1G,CAAC,CAAE,QAAQ,EAAE,QAAyB;QACtC,CAAC,CAAC,iBAAiB,CAAC,QAAQ,CAAA;IAC9B,MAAM,IAAI,GACR,QAAQ,EAAE,IAAI,KAAK,CAAC,IAAI,QAAQ,EAAE,IAAI,KAAK,CAAC,IAAI,QAAQ,EAAE,IAAI,KAAK,CAAC,IAAI,QAAQ,EAAE,IAAI,KAAK,CAAC;QAC1F,CAAC,CAAC,QAAQ,CAAC,IAAI;QACf,CAAC,CAAC,iBAAiB,CAAC,IAAI,CAAA;IAE5B,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAA;AAC3B,CAAC"}


=========================================
File: dist-test/domain/transport/audioHooks.js
=========================================

export {};
//# sourceMappingURL=audioHooks.js.map


=========================================
File: dist-test/domain/transport/audioHooks.js.map
=========================================

{"version":3,"file":"audioHooks.js","sourceRoot":"","sources":["../../../domain/transport/audioHooks.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/domain/transport/transportEngine.js
=========================================

const clampInt = (value) => {
    if (!Number.isFinite(value)) {
        return 0;
    }
    return Math.floor(value);
};
export function createTransportEngine(clock, scheduler, initial, audioHooks) {
    let cfg = initial;
    let isPlaying = false;
    let startTimeSec = 0;
    let lastStep = -1;
    let lastAbsoluteStep = -1;
    const listeners = new Set();
    const stepDurationSec = () => {
        const stepsPerBar = Math.max(1, cfg.gridSpec.division);
        const beatsPerBar = 4;
        const beatsPerStep = beatsPerBar / stepsPerBar;
        const secPerBeat = 60 / Math.max(1, cfg.bpm);
        return beatsPerStep * secPerBeat;
    };
    const totalSteps = () => {
        const steps = cfg.gridSpec.bars * cfg.gridSpec.division;
        return Math.max(0, clampInt(steps));
    };
    const normalizeStep = (step) => {
        const steps = Math.max(totalSteps(), 1);
        return ((step % steps) + steps) % steps;
    };
    const swingOffsetSec = (stepIndex) => {
        const swing = cfg.swing ?? 0;
        if (swing <= 0) {
            return 0;
        }
        const isOffBeat = stepIndex % 2 === 1;
        if (!isOffBeat) {
            return 0;
        }
        return stepDurationSec() * swing * 0.5;
    };
    const emit = () => {
        const steps = Math.max(totalSteps(), 1);
        const normalized = ((lastStep % steps) + steps) % steps;
        const state = {
            isPlaying,
            currentStep: normalized
        };
        for (const listener of listeners) {
            listener(state);
        }
    };
    const computeAbsoluteStepAt = (timeSec) => {
        const dur = stepDurationSec();
        const raw = (timeSec - startTimeSec) / dur;
        return clampInt(raw);
    };
    let lastScheduledStep = -1;
    const scheduleStepBoundary = (stepIndexAbsolute) => {
        if (stepIndexAbsolute === lastScheduledStep) {
            return;
        }
        const normalizedStep = normalizeStep(stepIndexAbsolute);
        lastScheduledStep = stepIndexAbsolute;
        const stepTimeSec = startTimeSec +
            stepIndexAbsolute * stepDurationSec() +
            swingOffsetSec(normalizedStep);
        scheduler.schedule(stepTimeSec, (audioTime) => {
            audioHooks?.onStep(normalizedStep, audioTime);
        });
    };
    const advance = () => {
        const now = clock.audioTime();
        const currentAbsolute = computeAbsoluteStepAt(now);
        const current = normalizeStep(currentAbsolute);
        if (current !== lastStep) {
            lastStep = current;
            lastAbsoluteStep = currentAbsolute;
            scheduleStepBoundary(lastAbsoluteStep + 1);
            emit();
        }
    };
    return {
        start() {
            if (isPlaying) {
                return;
            }
            isPlaying = true;
            startTimeSec = clock.audioTime();
            lastStep = -1;
            lastAbsoluteStep = -1;
            lastScheduledStep = -1;
            scheduler.clear();
            scheduler.start();
            lastAbsoluteStep = computeAbsoluteStepAt(startTimeSec);
            lastStep = normalizeStep(lastAbsoluteStep);
            emit();
            scheduleStepBoundary(lastAbsoluteStep + 1);
        },
        stop() {
            if (!isPlaying) {
                return;
            }
            isPlaying = false;
            scheduler.stop();
            scheduler.clear();
            lastStep = -1;
            lastScheduledStep = -1;
            emit();
        },
        setConfig(next) {
            cfg = next;
            if (isPlaying) {
                const now = clock.audioTime();
                const dur = stepDurationSec();
                const steps = Math.max(totalSteps(), 1);
                const current = ((lastAbsoluteStep % steps) + steps) % steps;
                startTimeSec = now - lastAbsoluteStep * dur - swingOffsetSec(current);
                lastAbsoluteStep = computeAbsoluteStepAt(now);
                lastStep = normalizeStep(lastAbsoluteStep);
                if (lastScheduledStep < lastAbsoluteStep) {
                    lastScheduledStep = lastAbsoluteStep;
                }
            }
            else {
                lastScheduledStep = -1;
            }
            emit();
        },
        subscribe(listener) {
            listeners.add(listener);
            listener({
                isPlaying,
                currentStep: Math.max(0, lastStep)
            });
            return () => {
                listeners.delete(listener);
            };
        },
        tick() {
            if (!isPlaying) {
                return;
            }
            advance();
        }
    };
}
//# sourceMappingURL=transportEngine.js.map


=========================================
File: dist-test/domain/transport/transportEngine.js.map
=========================================

{"version":3,"file":"transportEngine.js","sourceRoot":"","sources":["../../../domain/transport/transportEngine.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/domain/transport/types.js
=========================================

export {};
//# sourceMappingURL=types.js.map


=========================================
File: dist-test/domain/transport/types.js.map
=========================================

{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../domain/transport/types.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/domain/velocity.js
=========================================

export const STEP_VELOCITY_LEVELS = [0.7, 1, 1.25];
export const DEFAULT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[0];
export const ACCENT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[STEP_VELOCITY_LEVELS.length - 1];
const EPSILON = 0.001;
const matchesLevel = (value, level) => Math.abs(value - level) < EPSILON;
export function clampVelocity(value) {
    const resolved = typeof value === 'number' ? value : DEFAULT_STEP_VELOCITY;
    const clamped = Math.max(STEP_VELOCITY_LEVELS[0], Math.min(ACCENT_STEP_VELOCITY, resolved));
    const closest = STEP_VELOCITY_LEVELS.find((level) => matchesLevel(clamped, level));
    return closest ?? clamped;
}
export function cycleVelocity(current) {
    if (typeof current !== 'number') {
        return DEFAULT_STEP_VELOCITY;
    }
    const index = STEP_VELOCITY_LEVELS.findIndex((level) => matchesLevel(current, level));
    if (index === -1) {
        return DEFAULT_STEP_VELOCITY;
    }
    const nextIndex = index + 1;
    if (nextIndex >= STEP_VELOCITY_LEVELS.length) {
        return null;
    }
    const nextValue = STEP_VELOCITY_LEVELS[nextIndex];
    if (typeof nextValue !== 'number') {
        return null;
    }
    return nextValue;
}
export function velocityToIntensity(value) {
    if (!value)
        return 0;
    return Math.min(1, value / ACCENT_STEP_VELOCITY);
}
//# sourceMappingURL=velocity.js.map


=========================================
File: dist-test/domain/velocity.js.map
=========================================

{"version":3,"file":"velocity.js","sourceRoot":"","sources":["../../domain/velocity.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,CAAU,CAAA;AAC3D,MAAM,CAAC,MAAM,qBAAqB,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAA;AAC5D,MAAM,CAAC,MAAM,oBAAoB,GAAG,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAE,CAAA;AAE1F,MAAM,OAAO,GAAG,KAAK,CAAA;AAErB,MAAM,YAAY,GAAG,CAAC,KAAa,EAAE,KAAa,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC,GAAG,OAAO,CAAA;AAExF,MAAM,UAAU,aAAa,CAAC,KAAc;IAC1C,MAAM,QAAQ,GAAG,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,qBAAqB,CAAA;IAC1E,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,oBAAoB,EAAE,QAAQ,CAAC,CAAC,CAAA;IAC3F,MAAM,OAAO,GAAG,oBAAoB,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAA;IAClF,OAAO,OAAO,IAAI,OAAO,CAAA;AAC3B,CAAC;AAED,MAAM,UAAU,aAAa,CAAC,OAAgB;IAC5C,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QAChC,OAAO,qBAAqB,CAAA;IAC9B,CAAC;IACD,MAAM,KAAK,GAAG,oBAAoB,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAA;IACrF,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,CAAC;QACjB,OAAO,qBAAqB,CAAA;IAC9B,CAAC;IACD,MAAM,SAAS,GAAG,KAAK,GAAG,CAAC,CAAA;IAC3B,IAAI,SAAS,IAAI,oBAAoB,CAAC,MAAM,EAAE,CAAC;QAC7C,OAAO,IAAI,CAAA;IACb,CAAC;IACD,MAAM,SAAS,GAAG,oBAAoB,CAAC,SAAS,CAAC,CAAA;IACjD,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,CAAC;QAClC,OAAO,IAAI,CAAA;IACb,CAAC;IACD,OAAO,SAAS,CAAA;AAClB,CAAC;AAED,MAAM,UAAU,mBAAmB,CAAC,KAAc;IAChD,IAAI,CAAC,KAAK;QAAE,OAAO,CAAC,CAAA;IACpB,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,GAAG,oBAAoB,CAAC,CAAA;AAClD,CAAC"}


=========================================
File: dist-test/services/fileSystemRepository.js
=========================================

const defaultTree = {
    name: '/',
    children: [
        {
            name: 'Samples',
            children: [
                { name: 'kick.wav' },
                { name: 'snare.wav' },
                { name: 'hat.wav' },
                { name: 'loops', children: [{ name: 'break1.wav' }] }
            ]
        },
        {
            name: 'Imports',
            children: [
                { name: 'vox.wav' },
                { name: 'bass.aiff' }
            ]
        }
    ]
};
const buildPath = (parent, child) => {
    const normalizedParent = parent.endsWith('/') ? parent.slice(0, -1) : parent;
    return `${normalizedParent}/${child}`.replace(/\/+/g, '/');
};
const normalizePath = (path) => {
    const parts = path.split('/').filter(Boolean);
    return parts.length === 0 ? '/' : `/${parts.join('/')}`;
};
const isDirectoryHandle = (handle) => handle.kind === 'directory';
const isFileHandle = (handle) => handle.kind === 'file';
const getDirectoryPicker = () => {
    if (typeof window === 'undefined' || typeof window.showDirectoryPicker !== 'function') {
        throw new Error('File System Access API not supported');
    }
    return window.showDirectoryPicker;
};
const hasFileSystemAccess = () => {
    if (typeof window === 'undefined')
        return false;
    if (typeof import.meta !== 'undefined' && 'client' in import.meta && !import.meta.client) {
        return false;
    }
    return typeof window.showDirectoryPicker === 'function';
};
class BrowserFileSystemRepository {
    rootHandle = null;
    handleCache = new Map();
    async requestAccess() {
        try {
            const picker = getDirectoryPicker();
            this.rootHandle = await picker();
            this.handleCache.clear();
            this.handleCache.set('/', this.rootHandle);
            return true;
        }
        catch {
            return false;
        }
    }
    async resolveHandle(path) {
        const normalized = normalizePath(path);
        const cached = this.handleCache.get(normalized);
        if (cached)
            return cached;
        if (!this.rootHandle)
            return null;
        const parts = normalized.split('/').filter(Boolean);
        let current = this.rootHandle;
        let currentPath = '/';
        for (let index = 0; index < parts.length; index += 1) {
            const part = parts[index];
            if (!current)
                return null;
            const nextPath = buildPath(currentPath, part);
            let nextHandle = null;
            try {
                nextHandle = await current.getDirectoryHandle(part);
            }
            catch {
                try {
                    nextHandle = await current.getFileHandle(part);
                }
                catch {
                    nextHandle = null;
                }
            }
            if (!nextHandle)
                return null;
            this.handleCache.set(nextPath, nextHandle);
            if (isDirectoryHandle(nextHandle)) {
                current = nextHandle;
            }
            else {
                current = null;
            }
            currentPath = nextPath;
        }
        return this.handleCache.get(normalized) ?? null;
    }
    async resolveDirectoryHandle(path) {
        const handle = await this.resolveHandle(path);
        if (handle && isDirectoryHandle(handle))
            return handle;
        return null;
    }
    async resolveFileHandle(path) {
        const handle = await this.resolveHandle(path);
        if (handle && isFileHandle(handle))
            return handle;
        return null;
    }
    async listDir(path) {
        if (!this.rootHandle) {
            const granted = await this.requestAccess();
            if (!granted)
                return { dirs: [], files: [] };
        }
        const dirHandle = await this.resolveDirectoryHandle(path);
        if (!dirHandle)
            return { dirs: [], files: [] };
        const dirs = [];
        const files = [];
        for await (const [name, handle] of dirHandle.entries()) {
            const entryPath = buildPath(normalizePath(path), name);
            if (isDirectoryHandle(handle)) {
                dirs.push({ name, path: entryPath });
            }
            else if (isFileHandle(handle)) {
                files.push({ name, path: entryPath });
            }
            this.handleCache.set(entryPath, handle);
        }
        return { dirs, files };
    }
    async stat(path) {
        if (!this.rootHandle) {
            const granted = await this.requestAccess();
            if (!granted)
                return { isDir: false };
        }
        const handle = await this.resolveHandle(path);
        return { isDir: handle?.kind === 'directory' };
    }
    async readFileMeta(path) {
        const name = path.split('/').pop() ?? path;
        const parts = name.split('.');
        const extension = parts.length > 1 ? parts.pop() : undefined;
        const meta = { name };
        if (extension) {
            meta.extension = extension;
        }
        return meta;
    }
    async readFileBlob(path) {
        if (!this.rootHandle) {
            const granted = await this.requestAccess();
            if (!granted)
                return new Blob();
        }
        const handle = await this.resolveFileHandle(path);
        if (!handle)
            return new Blob();
        const file = await handle.getFile();
        return file;
    }
}
const createMemoryFs = (root = defaultTree) => {
    const findNode = (path) => {
        const parts = path.split('/').filter(Boolean);
        let cursor = root;
        if (parts.length === 0)
            return root;
        for (const part of parts) {
            cursor = cursor?.children?.find((child) => child.name === part);
            if (!cursor)
                return null;
        }
        return cursor ?? null;
    };
    return {
        async listDir(path) {
            const node = findNode(path);
            if (!node || !node.children) {
                return { dirs: [], files: [] };
            }
            const dirs = [];
            const files = [];
            node.children.forEach((child) => {
                const entryPath = buildPath(path || '/', child.name);
                if (child.children) {
                    dirs.push({ name: child.name, path: entryPath });
                }
                else {
                    files.push({ name: child.name, path: entryPath });
                }
            });
            return { dirs, files };
        },
        async stat(path) {
            const node = findNode(path);
            return { isDir: !!node?.children };
        },
        async readFileMeta(path) {
            const name = path.split('/').pop() ?? path;
            const parts = name.split('.');
            const extension = parts.length > 1 ? parts.pop() : undefined;
            const meta = { name };
            if (extension) {
                meta.extension = extension;
            }
            return meta;
        }
    };
};
let repository = null;
export const getFileSystemRepository = () => {
    if (repository)
        return repository;
    if (hasFileSystemAccess()) {
        repository = new BrowserFileSystemRepository();
        return repository;
    }
    repository = createMemoryFs();
    return repository;
};
export const __setFileSystemRepositoryForTests = (repo) => {
    repository = repo;
};
export const __resetFileSystemRepository = () => {
    repository = null;
};
//# sourceMappingURL=fileSystemRepository.js.map


=========================================
File: dist-test/services/fileSystemRepository.js.map
=========================================

{"version":3,"file":"fileSystemRepository.js","sourceRoot":"","sources":["../../services/fileSystemRepository.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/services/libraryRepository.js
=========================================

import { getFileSystemRepository } from './fileSystemRepository';
const STORAGE_KEY = 'drumcomputer_library_items_v1';
const FAVORITES_KEY = 'drumcomputer_favorites_v1';
const normalizeTag = (value) => value.trim().toLowerCase();
const supportedExtensions = new Set(['wav', 'wave', 'mp3', 'aiff', 'aif', 'flac', 'ogg']);
const getExtension = (path) => {
    const name = path.split('/').pop() ?? '';
    const parts = name.split('.');
    if (parts.length < 2)
        return '';
    return (parts.pop() ?? '').toLowerCase();
};
const extractMetadataFromPath = (path) => {
    const parts = path.split('/').filter(Boolean);
    return {
        category: parts[0],
        product: parts[1],
        bank: parts[2],
        subBank: parts[3],
        character: parts[4],
        vendor: 'user'
    };
};
const createLocalRepository = () => {
    let items = loadPersisted();
    let favorites = loadFavorites();
    function persist() {
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
            }
        }
        catch {
            // ignore persistence errors in non-browser environments
        }
    }
    function loadPersisted() {
        try {
            if (typeof localStorage === 'undefined')
                return [];
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw)
                return [];
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
                return parsed.map((entry) => ({
                    ...entry,
                    tags: Array.isArray(entry?.tags) ? entry.tags.map(String) : []
                }));
            }
        }
        catch {
            // ignore
        }
        return [];
    }
    function persistFavorites() {
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem(FAVORITES_KEY, JSON.stringify(Array.from(favorites)));
            }
        }
        catch {
            // ignore
        }
    }
    function loadFavorites() {
        try {
            if (typeof localStorage === 'undefined')
                return new Set();
            const raw = localStorage.getItem(FAVORITES_KEY);
            if (!raw)
                return new Set();
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
                return new Set(parsed.map(String));
            }
        }
        catch {
            // ignore
        }
        return new Set();
    }
    return {
        async search(query, _filters) {
            const text = query.trim().toLowerCase();
            if (!text)
                return [...items];
            return items.filter((item) => {
                const haystack = `${item.name} ${item.tags.join(' ')}`.toLowerCase();
                return haystack.includes(text);
            });
        },
        async getItem(id) {
            return items.find((item) => item.id === id);
        },
        async getTags(itemId) {
            return (await this.getItem(itemId))?.tags ?? [];
        },
        async addTag(itemId, tag) {
            const normalized = normalizeTag(tag);
            items = items.map((item) => {
                if (item.id !== itemId)
                    return item;
                const tags = new Set(item.tags.map(normalizeTag));
                tags.add(normalized);
                return { ...item, tags: Array.from(tags) };
            });
            persist();
            return (await this.getTags(itemId)) ?? [];
        },
        async removeTag(itemId, tag) {
            const normalized = normalizeTag(tag);
            items = items.map((item) => {
                if (item.id !== itemId)
                    return item;
                return { ...item, tags: item.tags.filter((value) => normalizeTag(value) !== normalized) };
            });
            persist();
            return (await this.getTags(itemId)) ?? [];
        },
        async importFile(path, meta) {
            const id = meta?.id ?? path;
            const existing = items.find((item) => item.id === id);
            const name = meta?.name ?? path.split('/').pop() ?? 'Sample';
            const next = {
                id,
                name,
                path,
                tags: existing?.tags ?? [],
                importedAt: Date.now(),
                ...meta
            };
            if (existing) {
                items = items.map((item) => (item.id === id ? next : item));
            }
            else {
                items = [...items, next];
            }
            persist();
            return next;
        },
        async addToFavorites(itemId) {
            favorites.add(itemId);
            persistFavorites();
        },
        async removeFromFavorites(itemId) {
            favorites.delete(itemId);
            persistFavorites();
        },
        async getFavorites() {
            return items.filter((item) => favorites.has(item.id));
        },
        async isFavorite(itemId) {
            return favorites.has(itemId);
        },
        async getCategories() {
            const values = items.map((item) => item.category).filter((value) => !!value);
            return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        },
        async getProducts(category) {
            const filtered = category ? items.filter((item) => item.category === category) : items;
            const values = filtered.map((item) => item.product).filter((value) => !!value);
            return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        },
        async getBanks(product) {
            const filtered = product ? items.filter((item) => item.product === product) : items;
            const values = filtered.map((item) => item.bank).filter((value) => !!value);
            return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        },
        async getSubBanks(bank) {
            const filtered = bank ? items.filter((item) => item.bank === bank) : items;
            const values = filtered.map((item) => item.subBank).filter((value) => !!value);
            return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        },
        async refreshIndex() {
            items = loadPersisted();
            favorites = loadFavorites();
        },
        async importDirectory(path, options, onProgress) {
            const repo = getFileSystemRepository();
            const recursive = options?.recursive ?? false;
            const errors = [];
            const filesToImport = [];
            const collectFiles = async (dirPath) => {
                try {
                    const listing = await repo.listDir(dirPath);
                    for (const file of listing.files) {
                        const extension = getExtension(file.path);
                        if (!supportedExtensions.has(extension)) {
                            errors.push(file.path);
                            continue;
                        }
                        filesToImport.push(file.path);
                    }
                    if (recursive) {
                        for (const dir of listing.dirs) {
                            await collectFiles(dir.path);
                        }
                    }
                }
                catch {
                    errors.push(dirPath);
                }
            };
            await collectFiles(path);
            const total = filesToImport.length;
            let completed = 0;
            for (const filePath of filesToImport) {
                try {
                    const meta = extractMetadataFromPath(filePath);
                    await this.importFile(filePath, meta);
                }
                catch {
                    errors.push(filePath);
                }
                completed += 1;
                onProgress?.({ total, completed, current: filePath, errors: [...errors] });
            }
            if (errors.length > 0) {
                console.warn('Import completed with errors', errors);
            }
        }
    };
};
let repository = createLocalRepository();
export const getLibraryRepository = () => repository;
export const __setLibraryRepositoryForTests = (repo) => {
    repository = repo;
};
export const __resetLibraryRepository = () => {
    repository = createLocalRepository();
};
//# sourceMappingURL=libraryRepository.js.map


=========================================
File: dist-test/services/libraryRepository.js.map
=========================================

{"version":3,"file":"libraryRepository.js","sourceRoot":"","sources":["../../services/libraryRepository.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/stores/browser.js
=========================================

import { defineStore } from 'pinia';
import { markRaw } from 'vue';
import { getFileSystemRepository } from '../services/fileSystemRepository';
import { getLibraryRepository } from '../services/libraryRepository';
import { useRecentFiles } from '../composables/useRecentFiles';
import { useSamplePreview } from '../composables/useSamplePreview.client';
import { useQuickBrowse } from '../composables/useQuickBrowse';
const emptyListing = { dirs: [], files: [] };
const createInitialFilters = () => ({
    fileType: 'all',
    contentType: 'all',
    tags: [],
    favorites: false
});
const normalizeTags = (tags) => (tags ?? []).map((tag) => tag.trim().toLowerCase()).filter((tag) => tag.length > 0);
const matchesFilters = (item, filters) => {
    if (filters.fileType && filters.fileType !== 'all' && item.fileType !== filters.fileType)
        return false;
    if (filters.contentType && filters.contentType !== 'all' && item.contentType !== filters.contentType) {
        return false;
    }
    if (filters.category && item.category !== filters.category)
        return false;
    if (filters.product && item.product !== filters.product)
        return false;
    if (filters.bank && item.bank !== filters.bank)
        return false;
    if (filters.subBank && item.subBank !== filters.subBank)
        return false;
    if (filters.character && item.character !== filters.character)
        return false;
    if (filters.favorites && item.favorites !== true)
        return false;
    if (filters.tags && filters.tags.length > 0) {
        const requiredTags = normalizeTags(filters.tags);
        const itemTags = normalizeTags(item.tags);
        const hasAllTags = requiredTags.every((tag) => itemTags.includes(tag));
        if (!hasAllTags)
            return false;
    }
    return true;
};
const describeFilters = (filters) => {
    const parts = [];
    if (filters.fileType && filters.fileType !== 'all')
        parts.push(`Type: ${filters.fileType}`);
    if (filters.contentType && filters.contentType !== 'all')
        parts.push(`Content: ${filters.contentType}`);
    if (filters.category)
        parts.push(`Cat: ${filters.category}`);
    if (filters.product)
        parts.push(`Prod: ${filters.product}`);
    if (filters.bank)
        parts.push(`Bank: ${filters.bank}`);
    if (filters.subBank)
        parts.push(`Sub: ${filters.subBank}`);
    if (filters.tags && filters.tags.length > 0)
        parts.push(`Tags: ${filters.tags.join(', ')}`);
    if (filters.favorites)
        parts.push('Favs');
    return parts.join(', ');
};
const mapLibraryItemToResult = (item, isFavorite) => ({
    id: item.id,
    title: item.name,
    ...(item.tags && item.tags.length > 0 ? { subtitle: item.tags.join(', '), tags: item.tags } : {}),
    ...(item.path ? { path: item.path } : {}),
    ...(item.importedAt ? { importedAt: item.importedAt } : {}),
    ...(item.fileType ? { fileType: item.fileType } : {}),
    ...(item.contentType ? { contentType: item.contentType } : {}),
    ...(item.category ? { category: item.category } : {}),
    ...(item.product ? { product: item.product } : {}),
    ...(item.bank ? { bank: item.bank } : {}),
    ...(item.subBank ? { subBank: item.subBank } : {}),
    ...(item.character ? { character: item.character } : {}),
    ...(isFavorite ? { favorites: true } : {})
});
const mapRecentType = (extension) => {
    if (!extension)
        return 'sample';
    const normalized = extension.toLowerCase();
    if (normalized === 'kit')
        return 'kit';
    if (normalized === 'pattern')
        return 'pattern';
    if (normalized === 'preset')
        return 'preset';
    return 'sample';
};
const sortStorageKey = 'drumcomputer_sort_mode_v1';
const hasClientStorage = () => {
    if (typeof window === 'undefined' || typeof localStorage === 'undefined')
        return false;
    return true;
};
const loadSortMode = () => {
    if (!hasClientStorage())
        return 'relevance';
    try {
        const raw = localStorage.getItem(sortStorageKey);
        if (!raw)
            return 'relevance';
        const value = raw;
        if (['name-asc', 'name-desc', 'date-asc', 'date-desc', 'relevance'].includes(value)) {
            return value;
        }
    }
    catch {
        // ignore
    }
    return 'relevance';
};
const persistSortMode = (mode) => {
    if (!hasClientStorage())
        return;
    try {
        localStorage.setItem(sortStorageKey, mode);
    }
    catch {
        // ignore
    }
};
const sortLabel = (mode) => {
    switch (mode) {
        case 'name-asc':
            return 'Name â†‘';
        case 'name-desc':
            return 'Name â†“';
        case 'date-asc':
            return 'Date â†‘';
        case 'date-desc':
            return 'Date â†“';
        default:
            return 'Relevance';
    }
};
const searchDebounceMs = 300;
const emptyPreviewState = {
    isPlaying: false,
    currentFile: null,
    progress: 0,
    duration: 0
};
const collectTags = (items) => {
    const tags = new Set();
    items.forEach((item) => {
        item.tags?.forEach((tag) => {
            const trimmed = tag.trim();
            if (trimmed.length > 0)
                tags.add(trimmed);
        });
    });
    return Array.from(tags).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
};
export const useBrowserStore = defineStore('browser', {
    state: () => ({
        mode: 'LIBRARY',
        library: {
            query: '',
            results: [],
            rawResults: [],
            selectedId: null
        },
        files: {
            currentPath: '/',
            entries: emptyListing,
            rawEntries: emptyListing,
            selectedPath: null
        },
        filters: createInitialFilters(),
        availableCategories: [],
        availableProducts: [],
        availableBanks: [],
        availableSubBanks: [],
        recentEntries: [],
        availableTags: [],
        tagDialogOpen: false,
        tagDialogItemId: null,
        sortMode: loadSortMode(),
        hierarchyCacheVersion: 0,
        hierarchyCache: {
            version: 0,
            categories: null,
            products: {},
            banks: {},
            subBanks: {}
        },
        searchDebounceId: null,
        preview: null
    }),
    getters: {
        recentFiles(state) {
            return state.recentEntries;
        },
        previewState(state) {
            return state.preview?.state ?? emptyPreviewState;
        }
    },
    actions: {
        ensurePreview() {
            if (!this.preview) {
                this.preview = markRaw(useSamplePreview());
            }
            return this.preview;
        },
        async setMode(mode) {
            this.mode = mode;
            if (mode === 'LIBRARY') {
                await this.loadAvailableTags();
                await this.search();
            }
            else {
                await this.listDir(this.files.currentPath || '/');
            }
        },
        async setQuery(query) {
            this.library.query = query;
            if (this.searchDebounceId) {
                clearTimeout(this.searchDebounceId);
            }
            this.searchDebounceId = setTimeout(() => {
                void this.search();
            }, searchDebounceMs);
        },
        async search() {
            const repo = getLibraryRepository();
            const favorites = await repo.getFavorites();
            const favoriteIds = new Set(favorites.map((item) => item.id));
            const results = this.filters.favorites === true ? favorites : await repo.search(this.library.query ?? '', this.filters);
            const mapped = results.map((item) => mapLibraryItemToResult(item, favoriteIds.has(item.id)));
            const filtered = mapped.filter((item) => matchesFilters(item, this.filters));
            this.library.rawResults = filtered;
            this.library.results = filtered;
            if (this.library.selectedId && !filtered.find((entry) => entry.id === this.library.selectedId)) {
                this.library.selectedId = null;
            }
            await this.refreshHierarchyOptions();
            this.sortResults();
        },
        setFilter(key, value) {
            const nextValue = Array.isArray(value) ? [...value] : value;
            const nextFilters = { ...this.filters, [key]: nextValue };
            if (key === 'category') {
                delete nextFilters.product;
                delete nextFilters.bank;
                delete nextFilters.subBank;
            }
            if (key === 'product') {
                delete nextFilters.bank;
                delete nextFilters.subBank;
            }
            if (key === 'bank') {
                delete nextFilters.subBank;
            }
            this.filters = nextFilters;
            void this.applyFilters();
        },
        async clearFilters() {
            this.filters = createInitialFilters();
            await this.applyFilters();
        },
        async applyFilters() {
            await this.search();
        },
        getAvailableOptions(filterKey) {
            switch (filterKey) {
                case 'fileType':
                    return ['all', 'sample', 'kit', 'pattern', 'preset'];
                case 'contentType':
                    return ['all', 'factory', 'user'];
                case 'category':
                    return this.availableCategories;
                case 'product':
                    return this.availableProducts;
                case 'bank':
                    return this.availableBanks;
                case 'subBank':
                    return this.availableSubBanks;
                default:
                    return [];
            }
        },
        async refreshHierarchyOptions() {
            const repo = getLibraryRepository();
            const version = this.hierarchyCacheVersion;
            if (this.hierarchyCache.version !== version) {
                this.hierarchyCache = {
                    version,
                    categories: null,
                    products: {},
                    banks: {},
                    subBanks: {}
                };
            }
            if (!this.hierarchyCache.categories) {
                this.hierarchyCache.categories = (await repo.getCategories?.()) ?? [];
            }
            const productKey = this.filters.category ?? '';
            if (!this.hierarchyCache.products[productKey]) {
                this.hierarchyCache.products[productKey] = (await repo.getProducts?.(this.filters.category)) ?? [];
            }
            const bankKey = this.filters.product ?? '';
            if (!this.hierarchyCache.banks[bankKey]) {
                this.hierarchyCache.banks[bankKey] = (await repo.getBanks?.(this.filters.product)) ?? [];
            }
            const subBankKey = this.filters.bank ?? '';
            if (!this.hierarchyCache.subBanks[subBankKey]) {
                this.hierarchyCache.subBanks[subBankKey] = (await repo.getSubBanks?.(this.filters.bank)) ?? [];
            }
            this.availableCategories = this.hierarchyCache.categories ?? [];
            this.availableProducts = this.hierarchyCache.products[productKey] ?? [];
            this.availableBanks = this.hierarchyCache.banks[bankKey] ?? [];
            this.availableSubBanks = this.hierarchyCache.subBanks[subBankKey] ?? [];
        },
        invalidateHierarchyCache() {
            this.hierarchyCacheVersion += 1;
        },
        getEncoderFields() {
            if (this.tagDialogOpen) {
                return this.availableTags.map((tag, index) => ({
                    id: `tag-${index}`,
                    label: tag,
                    value: tag
                }));
            }
            const fields = [
                {
                    id: 'fileType',
                    label: 'Type',
                    value: this.filters.fileType ?? 'all',
                    options: this.getAvailableOptions('fileType')
                },
                {
                    id: 'contentType',
                    label: 'Factory/User',
                    value: this.filters.contentType ?? 'all',
                    options: this.getAvailableOptions('contentType')
                },
                {
                    id: 'category',
                    label: 'Category',
                    value: this.filters.category ?? '',
                    options: this.getAvailableOptions('category')
                },
                {
                    id: 'product',
                    label: 'Product',
                    value: this.filters.product ?? '',
                    options: this.getAvailableOptions('product')
                },
                {
                    id: 'bank',
                    label: 'Bank',
                    value: this.filters.bank ?? '',
                    options: this.getAvailableOptions('bank')
                },
                {
                    id: 'subBank',
                    label: 'Sub Bank',
                    value: this.filters.subBank ?? '',
                    options: this.getAvailableOptions('subBank')
                },
                {
                    id: 'tags',
                    label: 'Tags',
                    value: (this.filters.tags ?? []).join(', ')
                },
                {
                    id: 'favorites',
                    label: 'Favorites',
                    value: this.filters.favorites ? 'on' : 'off',
                    options: ['off', 'on']
                }
            ];
            if (this.mode === 'FILES') {
                fields.push({
                    id: 'sort',
                    label: 'Sort',
                    value: sortLabel(this.sortMode),
                    options: ['Name â†‘', 'Name â†“', 'Date â†‘', 'Date â†“']
                });
            }
            return fields;
        },
        async selectResult(id) {
            this.library.selectedId = id;
        },
        async loadAvailableTags() {
            const repo = getLibraryRepository();
            const items = await repo.search('', undefined);
            const mapped = items.map((item) => mapLibraryItemToResult(item, false));
            this.availableTags = collectTags(mapped);
        },
        async openTagDialog(itemId) {
            this.tagDialogOpen = true;
            this.tagDialogItemId = itemId;
            await this.loadAvailableTags();
            await this.selectResult(itemId);
        },
        closeTagDialog() {
            this.tagDialogOpen = false;
            this.tagDialogItemId = null;
        },
        async addTagToSelected(tag) {
            const itemId = this.tagDialogItemId ?? this.library.selectedId;
            if (!itemId)
                return;
            const repo = getLibraryRepository();
            await repo.addTag(itemId, tag);
            await this.search();
            await this.loadAvailableTags();
            await this.selectResult(itemId);
        },
        async removeTagFromSelected(tag) {
            const itemId = this.tagDialogItemId ?? this.library.selectedId;
            if (!itemId)
                return;
            const repo = getLibraryRepository();
            await repo.removeTag(itemId, tag);
            await this.search();
            await this.loadAvailableTags();
            await this.selectResult(itemId);
        },
        getAvailableTags() {
            return this.availableTags;
        },
        loadRecentFiles() {
            const recent = useRecentFiles();
            const entries = recent.getRecent();
            this.recentEntries = entries;
            const mapped = entries.map((entry) => ({
                id: entry.id,
                title: entry.name,
                subtitle: entry.path,
                path: entry.path,
                timestamp: entry.timestamp
            }));
            this.library.rawResults = mapped;
            this.library.results = mapped;
            this.sortResults();
        },
        async addTag(tag) {
            if (!this.library.selectedId)
                return;
            const repo = getLibraryRepository();
            await repo.addTag(this.library.selectedId, tag);
            await this.search();
        },
        async toggleFavorite(itemId) {
            const repo = getLibraryRepository();
            const isFavorite = await repo.isFavorite(itemId);
            if (isFavorite) {
                await repo.removeFromFavorites(itemId);
            }
            else {
                await repo.addToFavorites(itemId);
            }
            await this.search();
        },
        setSortMode(mode) {
            this.sortMode = mode;
            persistSortMode(mode);
            this.sortResults();
        },
        sortResults() {
            const mode = this.sortMode;
            if (mode === 'relevance') {
                this.library.results = [...this.library.rawResults];
                this.files.entries = {
                    dirs: [...this.files.rawEntries.dirs],
                    files: [...this.files.rawEntries.files]
                };
                return;
            }
            const nameSort = (a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' });
            const dateValue = (value) => (typeof value === 'number' ? value : 0);
            const sortedResults = [...this.library.rawResults].sort((a, b) => {
                if (mode === 'name-asc')
                    return nameSort(a.title, b.title);
                if (mode === 'name-desc')
                    return nameSort(b.title, a.title);
                const dateA = dateValue(a.importedAt ?? a.timestamp);
                const dateB = dateValue(b.importedAt ?? b.timestamp);
                return mode === 'date-asc' ? dateA - dateB : dateB - dateA;
            });
            const sortedDirs = [...this.files.rawEntries.dirs].sort((a, b) => {
                if (mode === 'name-asc')
                    return nameSort(a.name, b.name);
                if (mode === 'name-desc')
                    return nameSort(b.name, a.name);
                return 0;
            });
            const sortedFiles = [...this.files.rawEntries.files].sort((a, b) => {
                if (mode === 'name-asc')
                    return nameSort(a.name, b.name);
                if (mode === 'name-desc')
                    return nameSort(b.name, a.name);
                return 0;
            });
            if (mode === 'date-asc' || mode === 'date-desc') {
                const fallback = mode === 'date-asc' ? 1 : -1;
                sortedDirs.sort((a, b) => nameSort(a.name, b.name) * fallback);
                sortedFiles.sort((a, b) => nameSort(a.name, b.name) * fallback);
            }
            this.library.results = sortedResults;
            this.files.entries = { dirs: sortedDirs, files: sortedFiles };
        },
        async removeTag(tag) {
            if (!this.library.selectedId)
                return;
            const repo = getLibraryRepository();
            await repo.removeTag(this.library.selectedId, tag);
            await this.search();
        },
        async listDir(path) {
            const repo = getFileSystemRepository();
            this.files.currentPath = path || '/';
            this.files.entries = await repo.listDir(this.files.currentPath);
            this.files.rawEntries = this.files.entries;
            if (this.files.selectedPath && !this.files.entries.files.find((file) => file.path === this.files.selectedPath)) {
                this.files.selectedPath = null;
            }
            this.sortResults();
        },
        selectPath(path) {
            this.files.selectedPath = path;
        },
        async importSelected(context) {
            if (!this.files.selectedPath)
                return;
            const fileRepo = getFileSystemRepository();
            const recent = useRecentFiles();
            const repo = getLibraryRepository();
            const meta = await fileRepo.readFileMeta(this.files.selectedPath);
            await repo.importFile(this.files.selectedPath, { name: meta.name });
            recent.addRecent({
                id: this.files.selectedPath,
                path: this.files.selectedPath,
                name: meta.name,
                type: mapRecentType(meta.extension)
            });
            const quickBrowse = useQuickBrowse();
            quickBrowse.recordBrowse({
                mode: this.mode,
                query: this.library.query,
                filters: this.filters,
                selectedId: this.library.selectedId,
                contextType: context?.contextType ?? 'sample',
                contextId: context?.contextId ?? 'global'
            });
            this.loadRecentFiles();
            this.invalidateHierarchyCache();
            await this.loadAvailableTags();
            await repo.refreshIndex();
            await this.search();
        },
        openQuickBrowse(contextId) {
            const quickBrowse = useQuickBrowse();
            const entry = quickBrowse.getLastBrowse(contextId);
            if (entry) {
                quickBrowse.restoreBrowse(entry);
            }
        },
        async prehearSelected() {
            const preview = this.ensurePreview();
            const fileRepo = getFileSystemRepository();
            if (this.mode === 'FILES') {
                if (!this.files.selectedPath)
                    return;
                const blob = await fileRepo.readFileBlob?.(this.files.selectedPath);
                await preview.loadAndPlay(this.files.selectedPath, blob);
                return;
            }
            if (this.library.selectedId) {
                const selected = this.library.results.find((item) => item.id === this.library.selectedId);
                if (!selected?.path)
                    return;
                const blob = await fileRepo.readFileBlob?.(selected.path);
                await preview.loadAndPlay(selected.path, blob);
            }
        },
        stopPrehear() {
            this.preview?.stop();
        },
        toDisplayModels() {
            const sortSummary = this.sortMode === 'relevance' ? '' : `Sorted by ${sortLabel(this.sortMode)}`;
            if (this.tagDialogOpen) {
                const selectedId = this.tagDialogItemId ?? this.library.selectedId;
                const selected = this.library.results.find((item) => item.id === selectedId);
                const selectedTags = selected?.tags ?? [];
                const leftItems = this.availableTags.map((tag) => ({
                    title: tag,
                    subtitle: selectedTags.includes(tag) ? '[x]' : '[ ]'
                }));
                const rightItems = selectedTags.map((tag) => ({
                    title: tag,
                    subtitle: 'Remove'
                }));
                return {
                    leftModel: {
                        view: 'BROWSER',
                        title: 'Add Tag',
                        summary: `${selectedTags.length} tags`,
                        items: leftItems
                    },
                    rightModel: {
                        view: 'BROWSER',
                        title: 'Current Tags',
                        summary: 'Press to toggle',
                        items: rightItems
                    }
                };
            }
            if (this.mode === 'FILES') {
                const leftItems = this.files.entries.dirs.map((dir) => ({
                    title: dir.name,
                    subtitle: dir.path
                }));
                const rightItems = this.files.entries.files.map((file) => ({
                    title: file.name,
                    subtitle: file.path,
                    active: file.path === this.files.selectedPath
                }));
                return {
                    leftModel: {
                        view: 'FILE',
                        title: 'Directories',
                        summary: this.files.currentPath,
                        items: leftItems
                    },
                    rightModel: {
                        view: 'FILE',
                        title: 'Files',
                        summary: [sortSummary || null, 'Select a file to import'].filter(Boolean).join(' â€¢ '),
                        items: rightItems
                    }
                };
            }
            const leftItems = [
                {
                    title: 'Search',
                    subtitle: [this.library.query || 'All', describeFilters(this.filters)].filter(Boolean).join(' â€¢ ')
                }
            ];
            const results = this.library.results;
            const selectedIndex = results.findIndex((result) => result.id === this.library.selectedId);
            const maxItems = 100;
            let start = 0;
            if (results.length > maxItems) {
                const targetIndex = selectedIndex >= 0 ? selectedIndex : 0;
                start = Math.max(0, Math.min(results.length - maxItems, targetIndex - Math.floor(maxItems / 3)));
            }
            const windowedResults = results.slice(start, start + maxItems);
            const rightItems = windowedResults.map((result) => {
                const subtitle = result.subtitle;
                const decoratedSubtitle = result.favorites ? `${subtitle ? `${subtitle} ` : ''}â˜…` : subtitle;
                const entry = {
                    title: result.title,
                    active: result.id === this.library.selectedId,
                    value: result.id
                };
                if (decoratedSubtitle) {
                    entry.subtitle = decoratedSubtitle;
                }
                return entry;
            });
            const leftSummary = [this.library.query || 'All', describeFilters(this.filters), sortSummary || null]
                .filter(Boolean)
                .join(' â€¢ ');
            return {
                leftModel: {
                    view: 'BROWSER',
                    title: 'Library',
                    summary: leftSummary,
                    items: leftItems
                },
                rightModel: {
                    view: 'BROWSER',
                    title: 'Results',
                    summary: `${rightItems.length} items`,
                    items: rightItems
                }
            };
        }
    }
});
//# sourceMappingURL=browser.js.map


=========================================
File: dist-test/stores/browser.js.map
=========================================

{"version":3,"file":"browser.js","sourceRoot":"","sources":["../../stores/browser.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/stores/control.js
=========================================

import { defineStore } from 'pinia';
import { markRaw } from 'vue';
import { use4DEncoder } from '../composables/use4DEncoder';
import { useBrowserStore } from './browser';
const MODES = [
    'CHANNEL',
    'PLUGIN',
    'ARRANGER',
    'MIXER',
    'BROWSER',
    'SAMPLING',
    'FILE',
    'SETTINGS',
    'AUTO',
    'MACRO'
];
const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
const formatRelativeTimestamp = (timestamp) => {
    const now = Date.now();
    const diffMs = Math.max(0, now - timestamp);
    const minuteMs = 60 * 1000;
    const hourMs = 60 * minuteMs;
    const dayMs = 24 * hourMs;
    if (diffMs < minuteMs)
        return 'gerade';
    if (diffMs < hourMs) {
        const minutes = Math.floor(diffMs / minuteMs);
        return `vor ${minutes} Minute${minutes === 1 ? '' : 'n'}`;
    }
    const nowDate = new Date(now);
    const entryDate = new Date(timestamp);
    const sameDay = nowDate.getFullYear() === entryDate.getFullYear() &&
        nowDate.getMonth() === entryDate.getMonth() &&
        nowDate.getDate() === entryDate.getDate();
    if (sameDay)
        return 'heute';
    const days = Math.floor(diffMs / dayMs);
    if (days === 1)
        return 'gestern';
    return `vor ${Math.max(2, days)} Tagen`;
};
const parseFieldValueForFilter = (field) => {
    if (field.id === 'favorites') {
        return String(field.value) === 'on';
    }
    if (field.id === 'tags') {
        if (typeof field.value !== 'string')
            return [];
        const tags = field.value
            .split(',')
            .map((tag) => tag.trim())
            .filter((tag) => tag.length > 0);
        return tags;
    }
    if (typeof field.value === 'number') {
        return String(field.value);
    }
    return field.value;
};
const parseSortMode = (value) => {
    const label = String(value);
    if (label.includes('Name â†‘'))
        return 'name-asc';
    if (label.includes('Name â†“'))
        return 'name-desc';
    if (label.includes('Date â†‘'))
        return 'date-asc';
    if (label.includes('Date â†“'))
        return 'date-desc';
    return 'relevance';
};
const buildSoftButtons = (buttons) => {
    const defaults = {
        label: '',
        actionId: 'noop',
        enabled: false,
        description: undefined
    };
    const filled = buttons.map((btn) => ({
        ...defaults,
        ...btn,
        enabled: btn.enabled !== false
    }));
    while (filled.length < 8) {
        filled.push({ ...defaults });
    }
    return filled.slice(0, 8);
};
const buildParams = (params) => {
    const defaults = {
        id: 'param',
        name: '',
        value: 0,
        min: 0,
        max: 127,
        step: 1,
        side: 'left'
    };
    const filled = params.map((param, index) => ({
        ...defaults,
        id: param.id ?? `param-${index + 1}`,
        name: param.name ?? `Param ${index + 1}`,
        ...param
    }));
    while (filled.length < 8) {
        const idx = filled.length + 1;
        filled.push({ ...defaults, id: `param-${idx}`, name: `Param ${idx}`, side: idx <= 4 ? 'left' : 'right' });
    }
    return filled.slice(0, 8);
};
const buildPreviewParams = () => buildParams([
    { id: 'preview-vol', name: 'Preview Vol', value: 80, min: 0, max: 100, step: 1 },
    { id: 'preview-start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
    { id: 'preview-end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
    { id: 'preview-tune', name: 'Tune', value: 0, min: -12, max: 12, step: 1 }
]);
const browserPages = [
    {
        label: 'Library',
        softButtons: buildSoftButtons([
            { label: 'Search', actionId: 'BROWSER_SEARCH', shiftLabel: 'Plug-In Menu', shiftActionId: 'BROWSER_PLUGIN_MENU' },
            { label: 'Type', actionId: 'BROWSER_TYPE' },
            { label: 'Tag', actionId: 'BROWSER_TAG' },
            { label: 'Favorites', actionId: 'BROWSER_FAVORITES' },
            { label: 'Prehear', actionId: 'BROWSER_PREHEAR', shiftLabel: 'Stop', shiftActionId: 'BROWSER_STOP' },
            { label: 'Load', actionId: 'BROWSER_LOAD' },
            { label: 'Replace', actionId: 'BROWSER_REPLACE' },
            { label: 'Clear', actionId: 'BROWSER_CLEAR' }
        ]),
        params: buildParams([
            { id: 'filter1', name: 'Filter', value: 40, min: 0, max: 100, step: 2, format: '%' },
            { id: 'cutoff', name: 'Cutoff', value: 72, min: 0, max: 127, step: 3 },
            { id: 'res', name: 'Resonance', value: 32, min: 0, max: 127, step: 3 },
            { id: 'rate', name: 'Rate', value: 4, min: 1, max: 16, step: 1 },
            { id: 'depth', name: 'Depth', value: 25, min: 0, max: 100, step: 1, side: 'right' },
            { id: 'space', name: 'Space', value: 35, min: 0, max: 100, step: 1, side: 'right' },
            { id: 'tone', name: 'Tone', value: 64, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'volume', name: 'Volume', value: 90, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'BROWSER',
            title: 'Browser',
            summary: 'Navigate library',
            items: [
                { title: 'Drums', subtitle: 'Kits, Percussion', active: true },
                { title: 'Instruments', subtitle: 'Bass, Keys' },
                { title: 'Loops', subtitle: 'Textures' },
                { title: 'User', subtitle: 'Local content' }
            ],
            hint: 'SHIFT: Plug-in menu'
        },
        rightModel: {
            view: 'BROWSER',
            title: 'Results',
            items: [
                { title: 'Neon Kit', subtitle: 'Kit â€¢ 16 samples', active: true },
                { title: 'Marble Kit', subtitle: 'Kit â€¢ 16 samples' },
                { title: 'Dusty Breaks', subtitle: 'Loop â€¢ 92 BPM' },
                { title: 'Glass Pluck', subtitle: 'Instrument' }
            ],
            summary: 'Use Load or Replace'
        }
    },
    {
        label: 'Recent',
        softButtons: buildSoftButtons([
            { label: 'Recent', actionId: 'BROWSER_RECENT' },
            { label: 'Clear', actionId: 'BROWSER_CLEAR_RECENT' },
            { label: 'Fav', actionId: 'BROWSER_FAVORITE' },
            { label: 'Tag', actionId: 'BROWSER_TAG_RECENT' },
            { label: 'Load', actionId: 'BROWSER_LOAD_RECENT' },
            { label: 'Prehear', actionId: 'BROWSER_PREHEAR' },
            { label: 'Replace', actionId: 'BROWSER_REPLACE' },
            { label: 'Stop', actionId: 'BROWSER_STOP' }
        ]),
        params: buildParams([
            { id: 'recent-volume', name: 'Preview Vol', value: 68, min: 0, max: 127, step: 2 },
            { id: 'recent-start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
            { id: 'recent-end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
            { id: 'recent-tune', name: 'Tune', value: 64, min: 0, max: 127, step: 1 },
            { id: 'recent-form', name: 'Formant', value: 64, min: 0, max: 127, step: 1, side: 'right' },
            { id: 'recent-pan', name: 'Pan', value: 64, min: 0, max: 127, step: 1, side: 'right' },
            { id: 'recent-dry', name: 'Dry/Wet', value: 80, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'recent-level', name: 'Level', value: 90, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'BROWSER',
            title: 'Recent Files',
            items: [
                { title: 'Deep Snare', subtitle: 'Sample', active: true },
                { title: 'Air Hat', subtitle: 'Sample' },
                { title: 'Chop Vox', subtitle: 'Sample' },
                { title: 'Lo-fi Loop', subtitle: 'Loop â€¢ 87 BPM' }
            ]
        },
        rightModel: {
            view: 'BROWSER',
            title: 'Preview',
            summary: 'Use Prehear',
            items: [
                { title: 'Waveform', subtitle: '00:12', value: 'Fade-in' },
                { title: 'Slice Points', subtitle: 'Auto â€¢ 8' }
            ]
        }
    }
];
const channelPages = [
    {
        label: 'Levels',
        softButtons: buildSoftButtons([
            { label: 'Sound', actionId: 'CHANNEL_SOUND' },
            { label: 'Group', actionId: 'CHANNEL_GROUP' },
            { label: 'Master', actionId: 'CHANNEL_MASTER' },
            { label: 'Input', actionId: 'CHANNEL_INPUT' },
            { label: 'Route', actionId: 'CHANNEL_ROUTE' },
            { label: 'Solo', actionId: 'CHANNEL_SOLO' },
            { label: 'Mute', actionId: 'CHANNEL_MUTE' },
            { label: 'Monitor', actionId: 'CHANNEL_MONITOR' }
        ]),
        params: buildParams([
            { id: 'snd-level', name: 'Sound Vol', value: 96, min: 0, max: 127, step: 2 },
            { id: 'snd-pan', name: 'Sound Pan', value: 64, min: 0, max: 127, step: 2 },
            { id: 'snd-send-a', name: 'Send A', value: 40, min: 0, max: 127, step: 2 },
            { id: 'snd-send-b', name: 'Send B', value: 55, min: 0, max: 127, step: 2 },
            { id: 'grp-level', name: 'Group Vol', value: 88, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'grp-pan', name: 'Group Pan', value: 64, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'mst-comp', name: 'Master Comp', value: 48, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'mst-lim', name: 'Limiter', value: 38, min: 0, max: 127, step: 1, side: 'right' }
        ]),
        leftModel: {
            view: 'MIXER',
            title: 'Channel Levels',
            items: [
                { title: 'Kick', value: '-1.2 dB', meter: 0.84 },
                { title: 'Snare', value: '-3.1 dB', meter: 0.68 },
                { title: 'Hat', value: '-5.0 dB', meter: 0.54 },
                { title: 'Bass', value: '-0.4 dB', meter: 0.9 }
            ],
            summary: 'SHIFT: MIDI'
        },
        rightModel: {
            view: 'MIXER',
            title: 'Group & Master',
            items: [
                { title: 'Group A', value: '-1.0 dB', meter: 0.82 },
                { title: 'Group B', value: '-2.4 dB', meter: 0.72 },
                { title: 'Master', value: '-0.3 dB', meter: 0.96 }
            ]
        }
    }
];
const pluginPages = [
    {
        label: 'Plug-in',
        softButtons: buildSoftButtons([
            { label: 'Instance', actionId: 'PLUGIN_INSTANCE', shiftLabel: 'Swap', shiftActionId: 'PLUGIN_SWAP' },
            { label: 'Preset', actionId: 'PLUGIN_PRESET' },
            { label: 'Bypass', actionId: 'PLUGIN_BYPASS' },
            { label: 'Enable', actionId: 'PLUGIN_ENABLE' },
            { label: 'Param', actionId: 'PLUGIN_PARAM' },
            { label: 'Macro', actionId: 'PLUGIN_MACRO' },
            { label: 'Browse', actionId: 'PLUGIN_BROWSE' },
            { label: 'Remove', actionId: 'PLUGIN_REMOVE' }
        ]),
        params: buildParams([
            { id: 'cutoff', name: 'Cutoff', value: 82, min: 0, max: 127, step: 2 },
            { id: 'resonance', name: 'Resonance', value: 52, min: 0, max: 127, step: 2 },
            { id: 'attack', name: 'Attack', value: 12, min: 0, max: 127, step: 1 },
            { id: 'release', name: 'Release', value: 88, min: 0, max: 127, step: 2 },
            { id: 'drive', name: 'Drive', value: 40, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'mix', name: 'Mix', value: 90, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'width', name: 'Stereo', value: 70, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'out', name: 'Output', value: 96, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'INFO',
            title: 'Plug-In Chain',
            items: [
                { title: 'Slot 1', subtitle: 'Drum Synth', active: true },
                { title: 'Slot 2', subtitle: 'Transient Master' },
                { title: 'Slot 3', subtitle: 'Reverb' }
            ]
        },
        rightModel: {
            view: 'INFO',
            title: 'Instance',
            summary: 'SHIFT: Swap instance',
            items: [
                { title: 'Preset', subtitle: 'Neon Dust' },
                { title: 'Category', subtitle: 'Drums' },
                { title: 'Author', subtitle: 'Native Instruments' }
            ]
        }
    }
];
const arrangerPages = [
    {
        label: 'Scenes',
        softButtons: buildSoftButtons([
            { label: 'Scenes', actionId: 'ARRANGER_SCENES' },
            { label: 'Sections', actionId: 'ARRANGER_SECTIONS' },
            { label: 'Duplicate', actionId: 'ARRANGER_DUPLICATE' },
            { label: 'Length', actionId: 'ARRANGER_LENGTH' },
            { label: 'Follow', actionId: 'ARRANGER_FOLLOW' },
            { label: 'Loop', actionId: 'ARRANGER_LOOP' },
            { label: 'Grid', actionId: 'ARRANGER_GRID' },
            { label: 'Clear', actionId: 'ARRANGER_CLEAR' }
        ]),
        params: buildParams([
            { id: 'scene-length', name: 'Scene Bars', value: 4, min: 1, max: 16, step: 1 },
            { id: 'scene-repeat', name: 'Repeat', value: 2, min: 1, max: 8, step: 1 },
            { id: 'section', name: 'Section', value: 1, min: 1, max: 16, step: 1 },
            { id: 'swing', name: 'Swing', value: 8, min: 0, max: 100, step: 1 },
            { id: 'velocity', name: 'Vel Mod', value: 50, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'humanize', name: 'Humanize', value: 24, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'shift', name: 'Shift', value: 0, min: -32, max: 32, step: 1, side: 'right' },
            { id: 'accent', name: 'Accent', value: 72, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'ARRANGER',
            title: 'Scenes',
            items: [
                { title: 'Intro', subtitle: '4 bars', active: true },
                { title: 'Hook', subtitle: '8 bars' },
                { title: 'Bridge', subtitle: '4 bars' },
                { title: 'Outro', subtitle: '4 bars' }
            ],
            summary: 'Page â—€/â–¶ for parameters'
        },
        rightModel: {
            view: 'ARRANGER',
            title: 'Layout',
            items: [
                { title: 'Pattern A1', subtitle: 'Scene: Intro' },
                { title: 'Pattern B1', subtitle: 'Scene: Hook' },
                { title: 'Pattern C1', subtitle: 'Scene: Bridge' }
            ]
        }
    }
];
const mixerPages = [
    {
        label: 'Mix',
        softButtons: buildSoftButtons([
            { label: 'Levels', actionId: 'MIXER_LEVELS' },
            { label: 'Pan', actionId: 'MIXER_PAN' },
            { label: 'Sends', actionId: 'MIXER_SENDS' },
            { label: 'FX', actionId: 'MIXER_FX' },
            { label: 'Group', actionId: 'MIXER_GROUP' },
            { label: 'Master', actionId: 'MIXER_MASTER' },
            { label: 'Cue', actionId: 'MIXER_CUE' },
            { label: 'Meters', actionId: 'MIXER_METERS' }
        ]),
        params: buildParams([
            { id: 'kick-level', name: 'Kick', value: 96, min: 0, max: 127, step: 2 },
            { id: 'snare-level', name: 'Snare', value: 92, min: 0, max: 127, step: 2 },
            { id: 'hat-level', name: 'Hat', value: 88, min: 0, max: 127, step: 2 },
            { id: 'perc-level', name: 'Perc', value: 80, min: 0, max: 127, step: 2 },
            { id: 'bus-comp', name: 'Bus Comp', value: 50, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'bus-sat', name: 'Saturate', value: 36, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'send-a', name: 'Send A', value: 45, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'send-b', name: 'Send B', value: 56, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'MIXER',
            title: 'Channels',
            items: [
                { title: 'Kick', value: '-1.2 dB', meter: 0.84 },
                { title: 'Snare', value: '-3.0 dB', meter: 0.72 },
                { title: 'Hat', value: '-4.4 dB', meter: 0.62 }
            ]
        },
        rightModel: {
            view: 'MIXER',
            title: 'Sends/FX',
            items: [
                { title: 'Reverb', subtitle: 'Aux A', value: '22%' },
                { title: 'Delay', subtitle: 'Aux B', value: '18%' },
                { title: 'Sidechain', subtitle: 'Bus', value: '-14 dB' }
            ]
        }
    }
];
const samplingPages = [
    {
        label: 'Sampling',
        softButtons: buildSoftButtons([
            { label: 'Record', actionId: 'SAMPLING_RECORD' },
            { label: 'Edit', actionId: 'SAMPLING_EDIT' },
            { label: 'Slice', actionId: 'SAMPLING_SLICE' },
            { label: 'Detect', actionId: 'SAMPLING_DETECT' },
            { label: 'Normalize', actionId: 'SAMPLING_NORMALIZE' },
            { label: 'Fade', actionId: 'SAMPLING_FADE' },
            { label: 'Apply', actionId: 'SAMPLING_APPLY' },
            { label: 'Discard', actionId: 'SAMPLING_DISCARD' }
        ]),
        params: buildParams([
            { id: 'start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
            { id: 'end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
            { id: 'snap', name: 'Snap', value: 1, min: 0, max: 8, step: 1 },
            { id: 'silence', name: 'Silence', value: 6, min: 0, max: 20, step: 1 },
            { id: 'attack', name: 'Attack', value: 4, min: 0, max: 127, step: 1, side: 'right' },
            { id: 'hold', name: 'Hold', value: 32, min: 0, max: 127, step: 1, side: 'right' },
            { id: 'release', name: 'Release', value: 60, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'gain', name: 'Gain', value: 80, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'SAMPLING',
            title: 'Waveform',
            summary: 'Set start/end or slice',
            items: [
                { title: 'Length', value: '0:12.4' },
                { title: 'Slices', value: '8 auto' }
            ]
        },
        rightModel: {
            view: 'SAMPLING',
            title: 'Actions',
            items: [
                { title: 'Record Input', subtitle: 'Line' },
                { title: 'Monitor', subtitle: 'On' },
                { title: 'Normalize', subtitle: '-1 dB' }
            ]
        }
    }
];
const filePages = [
    {
        label: 'Files',
        softButtons: buildSoftButtons([
            { label: 'New', actionId: 'FILE_NEW' },
            { label: 'Open', actionId: 'FILE_OPEN' },
            { label: 'Save', actionId: 'FILE_SAVE', shiftLabel: 'Save As', shiftActionId: 'FILE_SAVE_AS' },
            { label: 'Export', actionId: 'FILE_EXPORT' },
            { label: 'Audio', actionId: 'FILE_EXPORT_AUDIO' },
            { label: 'MIDI', actionId: 'FILE_EXPORT_MIDI' },
            { label: 'Bounce', actionId: 'FILE_BOUNCE' },
            { label: 'Close', actionId: 'FILE_CLOSE' }
        ]),
        params: buildParams([
            { id: 'mixdown', name: 'Mixdown', value: 0, min: 0, max: 1, step: 1 },
            { id: 'stems', name: 'Stems', value: 1, min: 0, max: 1, step: 1 },
            { id: 'normalize', name: 'Normalize', value: 1, min: 0, max: 1, step: 1 },
            { id: 'dither', name: 'Dither', value: 0, min: 0, max: 1, step: 1 },
            { id: 'sample-rate', name: 'Rate', value: 48000, min: 22050, max: 96000, step: 11025, side: 'right' },
            { id: 'bit-depth', name: 'Bit', value: 24, min: 8, max: 32, step: 8, side: 'right' },
            { id: 'loop-export', name: 'Loop', value: 1, min: 0, max: 1, step: 1, side: 'right' },
            { id: 'prepend', name: 'Count-in', value: 1, min: 0, max: 1, step: 1, side: 'right' }
        ]),
        leftModel: {
            view: 'FILE',
            title: 'File Ops',
            items: [
                { title: 'New Project', subtitle: 'Empty template' },
                { title: 'Open Recent', subtitle: 'DrumComputer_01' },
                { title: 'Save', subtitle: 'CTRL+S', active: true }
            ],
            summary: 'SHIFT: Save As'
        },
        rightModel: {
            view: 'FILE',
            title: 'Export',
            items: [
                { title: 'Audio', subtitle: 'Mixdown, Stems' },
                { title: 'MIDI', subtitle: 'All tracks' },
                { title: 'Bounce', subtitle: 'Selected pattern' }
            ],
            summary: 'Count-in & loop options'
        }
    }
];
const settingsPages = [
    {
        label: 'Settings',
        softButtons: buildSoftButtons([
            { label: 'Metronome', actionId: 'SETTINGS_METRO' },
            { label: 'Count-In', actionId: 'SETTINGS_COUNTIN' },
            { label: 'Quantize', actionId: 'SETTINGS_QUANTIZE' },
            { label: 'MIDI', actionId: 'SETTINGS_MIDI' },
            { label: 'Audio', actionId: 'SETTINGS_AUDIO' },
            { label: 'Theme', actionId: 'SETTINGS_THEME' },
            { label: 'Safe', actionId: 'SETTINGS_SAFE' },
            { label: 'Reset', actionId: 'SETTINGS_RESET' }
        ]),
        params: buildParams([
            { id: 'metro-lvl', name: 'Metro Vol', value: 72, min: 0, max: 127, step: 2 },
            { id: 'count-in', name: 'Count-In', value: 1, min: 0, max: 8, step: 1 },
            { id: 'swing', name: 'Swing', value: 8, min: 0, max: 100, step: 1 },
            { id: 'quantize', name: 'Quantize', value: 1, min: 0, max: 1, step: 1 },
            { id: 'theme', name: 'Theme', value: 0, min: 0, max: 2, step: 1, side: 'right' },
            { id: 'audio-lat', name: 'Latency', value: 5, min: 1, max: 20, step: 1, side: 'right' },
            { id: 'buffer', name: 'Buffer', value: 256, min: 64, max: 1024, step: 64, side: 'right' },
            { id: 'safety', name: 'Safe Mode', value: 1, min: 0, max: 1, step: 1, side: 'right' }
        ]),
        leftModel: {
            view: 'SETTINGS',
            title: 'System',
            items: [
                { title: 'Metronome', value: 'On' },
                { title: 'Count-In', value: '1 bar' },
                { title: 'Quantize', value: '1/16' }
            ]
        },
        rightModel: {
            view: 'SETTINGS',
            title: 'Audio/MIDI',
            items: [
                { title: 'Device', subtitle: 'Built-in Output' },
                { title: 'Buffer', subtitle: '256 samples' },
                { title: 'MIDI Input', subtitle: 'MK3 Virtual' }
            ]
        }
    }
];
const autoPages = [
    {
        label: 'Automation',
        softButtons: buildSoftButtons([
            { label: 'Write', actionId: 'AUTO_WRITE' },
            { label: 'Read', actionId: 'AUTO_READ' },
            { label: 'Latch', actionId: 'AUTO_LATCH' },
            { label: 'Touch', actionId: 'AUTO_TOUCH' },
            { label: 'Erase', actionId: 'AUTO_ERASE' },
            { label: 'Arm', actionId: 'AUTO_ARM' },
            { label: 'Hold', actionId: 'AUTO_HOLD' },
            { label: 'Clear', actionId: 'AUTO_CLEAR' }
        ]),
        params: buildParams([
            { id: 'auto-lane', name: 'Lane', value: 1, min: 1, max: 8, step: 1 },
            { id: 'auto-smooth', name: 'Smooth', value: 42, min: 0, max: 127, step: 2 },
            { id: 'auto-scale', name: 'Scale', value: 100, min: 0, max: 150, step: 5 },
            { id: 'auto-quant', name: 'Quantize', value: 1, min: 0, max: 1, step: 1 },
            { id: 'auto-protect', name: 'Protect', value: 0, min: 0, max: 1, step: 1, side: 'right' },
            { id: 'auto-loop', name: 'Loop', value: 1, min: 0, max: 1, step: 1, side: 'right' },
            { id: 'auto-snap', name: 'Snap', value: 1, min: 0, max: 1, step: 1, side: 'right' },
            { id: 'auto-depth', name: 'Depth', value: 60, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'INFO',
            title: 'Automation',
            summary: 'Hold to write with encoders',
            items: [
                { title: 'Mode', value: 'Write' },
                { title: 'Lane', value: '1/8 Grid' }
            ]
        },
        rightModel: {
            view: 'INFO',
            title: 'Status',
            items: [
                { title: 'Armed', value: 'Yes' },
                { title: 'Protect', value: 'Off' },
                { title: 'Overwrite', value: 'No' }
            ]
        }
    }
];
const macroPages = [
    {
        label: 'Macro',
        softButtons: buildSoftButtons([
            { label: 'Assign', actionId: 'MACRO_ASSIGN' },
            { label: 'Clear', actionId: 'MACRO_CLEAR' },
            { label: 'Hold', actionId: 'MACRO_HOLD' },
            { label: 'Latch', actionId: 'MACRO_LATCH' },
            { label: 'Morph', actionId: 'MACRO_MORPH' },
            { label: 'Set', actionId: 'MACRO_SET', shiftLabel: 'Shift Set', shiftActionId: 'MACRO_SHIFT_SET' },
            { label: 'Store', actionId: 'MACRO_STORE' },
            { label: 'Recall', actionId: 'MACRO_RECALL' }
        ]),
        params: buildParams([
            { id: 'macro1', name: 'Macro 1', value: 40, min: 0, max: 127, step: 2 },
            { id: 'macro2', name: 'Macro 2', value: 80, min: 0, max: 127, step: 2 },
            { id: 'macro3', name: 'Macro 3', value: 64, min: 0, max: 127, step: 2 },
            { id: 'macro4', name: 'Macro 4', value: 32, min: 0, max: 127, step: 2 },
            { id: 'macro5', name: 'Macro 5', value: 20, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'macro6', name: 'Macro 6', value: 55, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'macro7', name: 'Macro 7', value: 76, min: 0, max: 127, step: 2, side: 'right' },
            { id: 'macro8', name: 'Macro 8', value: 90, min: 0, max: 127, step: 2, side: 'right' }
        ]),
        leftModel: {
            view: 'INFO',
            title: 'Macro Sets',
            items: [
                { title: 'Set A', subtitle: 'Live' },
                { title: 'Set B', subtitle: 'Studio', active: true },
                { title: 'Set C', subtitle: 'User' }
            ],
            summary: 'SHIFT: Macro Set'
        },
        rightModel: {
            view: 'INFO',
            title: 'Morph',
            items: [
                { title: 'Target', subtitle: 'Set B' },
                { title: 'Morph', value: '38%' }
            ]
        }
    }
];
const pagesByMode = {
    CHANNEL: channelPages,
    PLUGIN: pluginPages,
    ARRANGER: arrangerPages,
    MIXER: mixerPages,
    BROWSER: browserPages,
    SAMPLING: samplingPages,
    FILE: filePages,
    SETTINGS: settingsPages,
    AUTO: autoPages,
    MACRO: macroPages
};
const createInitialPageIndex = () => {
    return MODES.reduce((acc, mode) => {
        acc[mode] = 0;
        return acc;
    }, {});
};
export const useControlStore = defineStore('control', {
    state: () => ({
        activeMode: 'BROWSER',
        shiftHeld: false,
        pageIndexByMode: createInitialPageIndex(),
        pagesByMode,
        lastAction: 'Ready',
        statusFlags: {
            metronome: true,
            countIn: true,
            automationArmed: false
        },
        encoder4D: null,
        browserDisplay: null
    }),
    getters: {
        activePage(state) {
            const pages = state.pagesByMode[state.activeMode] ?? [];
            const index = state.pageIndexByMode[state.activeMode] ?? 0;
            return pages[index] ?? pages[0];
        },
        pageLabel() {
            return this.activePage?.label ?? '';
        },
        modeTitle(state) {
            return state.activeMode;
        },
        activeSoftButtons() {
            return this.activePage?.softButtons ?? buildSoftButtons([]);
        },
        softLabels() {
            return this.activeSoftButtons.map((btn) => btn.label || '');
        },
        activeParams() {
            if (this.activeMode === 'BROWSER') {
                const browser = useBrowserStore();
                if (browser.previewState.isPlaying) {
                    return buildPreviewParams();
                }
            }
            return this.activePage?.params ?? buildParams([]);
        },
        paramSlotsLeft() {
            return this.activeParams.filter((param) => (param.side ?? 'left') === 'left').slice(0, 4);
        },
        paramSlotsRight() {
            return this.activeParams.filter((param) => (param.side ?? 'left') === 'right').slice(0, 4);
        },
        leftModel() {
            if ((this.activeMode === 'BROWSER' || this.activeMode === 'FILE') && this.browserDisplay?.leftModel) {
                return this.browserDisplay.leftModel;
            }
            return this.activePage?.leftModel ?? { view: 'EMPTY', title: 'Empty' };
        },
        rightModel() {
            if ((this.activeMode === 'BROWSER' || this.activeMode === 'FILE') && this.browserDisplay?.rightModel) {
                return this.browserDisplay.rightModel;
            }
            return this.activePage?.rightModel ?? { view: 'EMPTY', title: 'Empty' };
        }
    },
    actions: {
        initEncoderForBrowser() {
            const browser = useBrowserStore();
            const encoder = this.encoder4D ?? markRaw(use4DEncoder());
            this.encoder4D = encoder;
            const fields = browser.getEncoderFields();
            encoder.setFields(fields);
            encoder.setMode('field-select');
            encoder.activeListIndex.value = 0;
        },
        refreshEncoderFields() {
            if (!this.encoder4D)
                return;
            const browser = useBrowserStore();
            this.encoder4D.setFields(browser.getEncoderFields());
        },
        syncBrowserDisplay() {
            const browser = useBrowserStore();
            if (browser.tagDialogOpen) {
                if (this.encoder4D) {
                    const fields = browser.getEncoderFields();
                    this.encoder4D.setFields(fields);
                    this.encoder4D.setMode('list-navigate');
                    if (fields.length === 0) {
                        this.encoder4D.activeListIndex.value = 0;
                    }
                    else {
                        const index = clamp(this.encoder4D.activeListIndex.value, 0, fields.length - 1);
                        this.encoder4D.activeListIndex.value = index;
                    }
                }
                this.setBrowserDisplay(browser.toDisplayModels());
                return;
            }
            if (this.activeMode === 'BROWSER' && this.activePage?.label === 'Recent') {
                browser.loadRecentFiles();
                const recentItems = browser.recentFiles.map((entry) => ({
                    title: entry.name,
                    subtitle: formatRelativeTimestamp(entry.timestamp),
                    value: entry.id
                }));
                this.setBrowserDisplay({
                    leftModel: {
                        view: 'BROWSER',
                        title: 'Recent Files',
                        summary: `${recentItems.length} items`,
                        items: recentItems
                    },
                    rightModel: this.activePage?.rightModel ?? { view: 'BROWSER', title: 'Preview' }
                });
                return;
            }
            const models = browser.toDisplayModels();
            if (this.encoder4D) {
                const activeField = this.encoder4D.activeField.value;
                if (activeField) {
                    const summary = models.leftModel.summary ?? '';
                    const highlight = `(${activeField.label})`;
                    models.leftModel = {
                        ...models.leftModel,
                        summary: [summary, highlight].filter((value) => value && value.length > 0).join(' ')
                    };
                }
            }
            this.setBrowserDisplay(models);
        },
        syncListSelection() {
            if (!this.encoder4D)
                return;
            const browser = useBrowserStore();
            if (this.activeMode === 'FILE') {
                const files = browser.files.entries.files;
                if (files.length === 0) {
                    browser.selectPath(null);
                    this.encoder4D.activeListIndex.value = 0;
                }
                else {
                    const index = clamp(this.encoder4D.activeListIndex.value, 0, files.length - 1);
                    this.encoder4D.activeListIndex.value = index;
                    browser.selectPath(files[index]?.path ?? null);
                }
            }
            else {
                const results = browser.library.results;
                if (results.length === 0) {
                    browser.selectResult(null);
                    this.encoder4D.activeListIndex.value = 0;
                }
                else {
                    const index = clamp(this.encoder4D.activeListIndex.value, 0, results.length - 1);
                    this.encoder4D.activeListIndex.value = index;
                    browser.selectResult(results[index]?.id ?? null);
                }
            }
            this.syncBrowserDisplay();
        },
        applyEncoderFieldFilter() {
            if (!this.encoder4D)
                return;
            const browser = useBrowserStore();
            const field = this.encoder4D.activeField.value;
            if (!field)
                return;
            if (field.id === 'sort') {
                browser.setSortMode(parseSortMode(field.value));
                this.refreshEncoderFields();
                return;
            }
            const value = parseFieldValueForFilter(field);
            browser.setFilter(field.id, value);
            this.refreshEncoderFields();
        },
        setMode(mode) {
            this.activeMode = mode;
            if (this.pageIndexByMode[mode] == null) {
                this.pageIndexByMode[mode] = 0;
            }
            this.lastAction = `${mode} selected`;
            if (mode === 'BROWSER' || mode === 'FILE') {
                this.initEncoderForBrowser();
                this.syncBrowserDisplay();
            }
        },
        setShiftHeld(value) {
            this.shiftHeld = value;
        },
        setBrowserDisplay(models) {
            this.browserDisplay = models;
        },
        nextPage() {
            const pages = this.pagesByMode[this.activeMode] ?? [];
            if (pages.length === 0)
                return;
            const nextIndex = Math.min(pages.length - 1, (this.pageIndexByMode[this.activeMode] ?? 0) + 1);
            this.pageIndexByMode[this.activeMode] = nextIndex;
            this.lastAction = `${this.activeMode} page: ${pages[nextIndex]?.label ?? ''}`;
            if (this.activeMode === 'BROWSER') {
                this.syncBrowserDisplay();
            }
        },
        prevPage() {
            const pages = this.pagesByMode[this.activeMode] ?? [];
            if (pages.length === 0)
                return;
            const nextIndex = Math.max(0, (this.pageIndexByMode[this.activeMode] ?? 0) - 1);
            this.pageIndexByMode[this.activeMode] = nextIndex;
            this.lastAction = `${this.activeMode} page: ${pages[nextIndex]?.label ?? ''}`;
            if (this.activeMode === 'BROWSER') {
                this.syncBrowserDisplay();
            }
        },
        pressSoftButton(index) {
            const btn = this.activeSoftButtons[index];
            if (!btn || btn.enabled === false)
                return;
            const actionId = this.shiftHeld && btn.shiftActionId ? btn.shiftActionId : btn.actionId;
            this.applyAction(actionId, btn.label);
        },
        applyAction(actionId, label) {
            const browser = useBrowserStore();
            switch (actionId) {
                case 'BROWSER_SEARCH':
                    void browser.search();
                    this.lastAction = 'Browser search';
                    break;
                case 'BROWSER_TAG':
                case 'BROWSER_TAG_RECENT':
                    if (browser.library.selectedId) {
                        browser.openTagDialog(browser.library.selectedId);
                        this.lastAction = 'Tag dialog opened';
                    }
                    break;
                case 'BROWSER_PREHEAR':
                    void browser.prehearSelected();
                    this.lastAction = 'Prehear triggered';
                    break;
                case 'BROWSER_STOP':
                    browser.stopPrehear();
                    this.lastAction = 'Prehear stopped';
                    break;
                case 'BROWSER_LOAD':
                case 'BROWSER_REPLACE':
                    void browser.importSelected();
                    this.lastAction = 'Import triggered';
                    break;
                case 'BROWSER_FAVORITES':
                    if (browser.library.selectedId) {
                        void browser.toggleFavorite(browser.library.selectedId);
                        this.lastAction = 'Favorite toggled';
                    }
                    else {
                        browser.setFilter('favorites', !browser.filters.favorites);
                        this.lastAction = browser.filters.favorites ? 'Favorites filter on' : 'Favorites filter off';
                    }
                    break;
                case 'BROWSER_CLEAR':
                    browser.selectResult(null);
                    browser.selectPath(null);
                    this.lastAction = 'Browser cleared';
                    break;
                case 'BROWSER_PLUGIN_MENU':
                case 'PLUGIN_INSTANCE':
                case 'PLUGIN_SWAP':
                case 'CHANNEL_SOUND':
                case 'CHANNEL_GROUP':
                case 'CHANNEL_MASTER':
                    this.lastAction = label ? `${label} triggered` : actionId;
                    break;
                case 'FILE_SAVE':
                case 'FILE_SAVE_AS':
                    this.lastAction = 'Project saved (demo)';
                    break;
                case 'SETTINGS_METRO':
                    this.statusFlags.metronome = !this.statusFlags.metronome;
                    this.lastAction = `Metronome ${this.statusFlags.metronome ? 'On' : 'Off'}`;
                    break;
                case 'SETTINGS_COUNTIN':
                    this.statusFlags.countIn = !this.statusFlags.countIn;
                    this.lastAction = `Count-in ${this.statusFlags.countIn ? 'On' : 'Off'}`;
                    break;
                case 'AUTO_ARM':
                    this.statusFlags.automationArmed = !this.statusFlags.automationArmed;
                    this.lastAction = `Automation ${this.statusFlags.automationArmed ? 'Armed' : 'Disarmed'}`;
                    break;
                default:
                    this.lastAction = label ? `${label} triggered` : actionId;
            }
        },
        tiltEncoder4D(direction) {
            if (!this.encoder4D)
                return;
            const browser = useBrowserStore();
            if (browser.tagDialogOpen) {
                if (direction === 'right') {
                    browser.closeTagDialog();
                    this.syncBrowserDisplay();
                    return;
                }
                if (direction === 'up' || direction === 'down') {
                    this.encoder4D.tiltVertical(direction);
                    this.syncBrowserDisplay();
                }
                return;
            }
            if (direction === 'left' || direction === 'right') {
                this.encoder4D.tiltHorizontal(direction);
                this.syncBrowserDisplay();
                return;
            }
            this.encoder4D.tiltVertical(direction);
            this.syncListSelection();
        },
        turnEncoder4D(delta) {
            if (!this.encoder4D)
                return;
            const browser = useBrowserStore();
            if (browser.tagDialogOpen) {
                this.encoder4D.setMode('list-navigate');
                this.encoder4D.turn(delta);
                this.syncBrowserDisplay();
                return;
            }
            const mode = this.encoder4D.mode.value;
            this.encoder4D.turn(delta);
            if (mode === 'value-adjust') {
                this.applyEncoderFieldFilter();
            }
            else if (mode === 'list-navigate') {
                this.syncListSelection();
            }
        },
        async pressEncoder4D() {
            if (!this.encoder4D)
                return;
            const browser = useBrowserStore();
            if (browser.tagDialogOpen) {
                const index = clamp(this.encoder4D.activeListIndex.value, 0, browser.availableTags.length - 1);
                const tag = browser.availableTags[index];
                if (tag) {
                    const selectedId = browser.tagDialogItemId ?? browser.library.selectedId;
                    const selected = browser.library.results.find((item) => item.id === selectedId);
                    const assigned = selected?.tags?.includes(tag) ?? false;
                    if (assigned) {
                        await browser.removeTagFromSelected(tag);
                    }
                    else {
                        await browser.addTagToSelected(tag);
                    }
                    this.syncBrowserDisplay();
                }
                return;
            }
            const previousMode = this.encoder4D.mode.value;
            if (previousMode === 'value-adjust') {
                this.applyEncoderFieldFilter();
            }
            this.encoder4D.press();
            if (previousMode === 'list-navigate') {
                if (this.activeMode === 'FILE') {
                    await browser.importSelected();
                }
                else {
                    this.syncListSelection();
                }
            }
            if (this.encoder4D.mode.value === 'list-navigate') {
                this.syncListSelection();
            }
            else {
                this.syncBrowserDisplay();
            }
        },
        turnEncoder(index, delta, options) {
            const page = this.activePage;
            if (!page)
                return;
            const params = page.params;
            const param = params[index];
            if (!param)
                return;
            const step = options?.fine ? param.fineStep ?? Math.max(0.25, param.step / 4) : param.step;
            const nextValue = clamp(param.value + delta * step, param.min, param.max);
            param.value = nextValue;
            this.lastAction = `${param.name}: ${Math.round(nextValue * 100) / 100}${param.format ? ` ${param.format}` : ''}`;
        },
        turnEncoderById(id, delta, options) {
            const params = this.activeParams;
            const index = params.findIndex((param) => param.id === id);
            if (index >= 0) {
                this.turnEncoder(index, delta, options);
            }
        }
    }
});
//# sourceMappingURL=control.js.map


=========================================
File: dist-test/stores/control.js.map
=========================================

{"version":3,"file":"control.js","sourceRoot":"","sources":["../../stores/control.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,OAAO,CAAA;AACnC,OAAO,EAAE,OAAO,EAAY,MAAM,KAAK,CAAA;AACvC,OAAO,EAAE,YAAY,EAA8C,MAAM,6BAA6B,CAAA;AACtG,OAAO,EAAE,eAAe,EAAuB,MAAM,WAAW,CAAA;AAqEhE,MAAM,KAAK,GAAkB;IAC3B,SAAS;IACT,QAAQ;IACR,UAAU;IACV,OAAO;IACP,SAAS;IACT,UAAU;IACV,MAAM;IACN,UAAU;IACV,MAAM;IACN,OAAO;CACR,CAAA;AAED,MAAM,KAAK,GAAG,CAAC,KAAa,EAAE,GAAW,EAAE,GAAW,EAAU,EAAE,CAChE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAA;AAErC,MAAM,uBAAuB,GAAG,CAAC,SAAiB,EAAU,EAAE;IAC5D,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;IACtB,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,SAAS,CAAC,CAAA;IAC3C,MAAM,QAAQ,GAAG,EAAE,GAAG,IAAI,CAAA;IAC1B,MAAM,MAAM,GAAG,EAAE,GAAG,QAAQ,CAAA;IAC5B,MAAM,KAAK,GAAG,EAAE,GAAG,MAAM,CAAA;IACzB,IAAI,MAAM,GAAG,QAAQ;QAAE,OAAO,QAAQ,CAAA;IACtC,IAAI,MAAM,GAAG,MAAM,EAAE,CAAC;QACpB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAA;QAC7C,OAAO,OAAO,OAAO,UAAU,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAA;IAC3D,CAAC;IACD,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,CAAA;IAC7B,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,CAAA;IACrC,MAAM,OAAO,GACX,OAAO,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC,WAAW,EAAE;QACjD,OAAO,CAAC,QAAQ,EAAE,KAAK,SAAS,CAAC,QAAQ,EAAE;QAC3C,OAAO,CAAC,OAAO,EAAE,KAAK,SAAS,CAAC,OAAO,EAAE,CAAA;IAC3C,IAAI,OAAO;QAAE,OAAO,OAAO,CAAA;IAC3B,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,CAAA;IACvC,IAAI,IAAI,KAAK,CAAC;QAAE,OAAO,SAAS,CAAA;IAChC,OAAO,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAA;AACzC,CAAC,CAAA;AAED,MAAM,wBAAwB,GAAG,CAAC,KAAmB,EAAwC,EAAE;IAC7F,IAAI,KAAK,CAAC,EAAE,KAAK,WAAW,EAAE,CAAC;QAC7B,OAAO,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,CAAA;IACrC,CAAC;IACD,IAAI,KAAK,CAAC,EAAE,KAAK,MAAM,EAAE,CAAC;QACxB,IAAI,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ;YAAE,OAAO,EAAE,CAAA;QAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK;aACrB,KAAK,CAAC,GAAG,CAAC;aACV,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;aACxB,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;QAClC,OAAO,IAAI,CAAA;IACb,CAAC;IACD,IAAI,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;QACpC,OAAO,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;IAC5B,CAAC;IACD,OAAO,KAAK,CAAC,KAA6C,CAAA;AAC5D,CAAC,CAAA;AAED,MAAM,aAAa,GAAG,CAAC,KAA4B,EAAqE,EAAE;IACxH,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA;IAC3B,IAAI,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAAE,OAAO,UAAU,CAAA;IAC/C,IAAI,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAAE,OAAO,WAAW,CAAA;IAChD,IAAI,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAAE,OAAO,UAAU,CAAA;IAC/C,IAAI,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;QAAE,OAAO,WAAW,CAAA;IAChD,OAAO,WAAW,CAAA;AACpB,CAAC,CAAA;AAED,MAAM,gBAAgB,GAAG,CAAC,OAA8B,EAAgB,EAAE;IACxE,MAAM,QAAQ,GAAe;QAC3B,KAAK,EAAE,EAAE;QACT,QAAQ,EAAE,MAAM;QAChB,OAAO,EAAE,KAAK;QACd,WAAW,EAAE,SAAS;KACvB,CAAA;IACD,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;QACnC,GAAG,QAAQ;QACX,GAAG,GAAG;QACN,OAAO,EAAE,GAAG,CAAC,OAAO,KAAK,KAAK;KAC/B,CAAC,CAAC,CAAA;IACH,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACzB,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,QAAQ,EAAE,CAAC,CAAA;IAC9B,CAAC;IACD,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;AAC3B,CAAC,CAAA;AAED,MAAM,WAAW,GAAG,CAAC,MAA+B,EAAkB,EAAE;IACtE,MAAM,QAAQ,GAAiB;QAC7B,EAAE,EAAE,OAAO;QACX,IAAI,EAAE,EAAE;QACR,KAAK,EAAE,CAAC;QACR,GAAG,EAAE,CAAC;QACN,GAAG,EAAE,GAAG;QACR,IAAI,EAAE,CAAC;QACP,IAAI,EAAE,MAAM;KACb,CAAA;IACD,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;QAC3C,GAAG,QAAQ;QACX,EAAE,EAAE,KAAK,CAAC,EAAE,IAAI,SAAS,KAAK,GAAG,CAAC,EAAE;QACpC,IAAI,EAAE,KAAK,CAAC,IAAI,IAAI,SAAS,KAAK,GAAG,CAAC,EAAE;QACxC,GAAG,KAAK;KACT,CAAC,CAAC,CAAA;IACH,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACzB,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,CAAA;QAC7B,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,QAAQ,EAAE,EAAE,EAAE,SAAS,GAAG,EAAE,EAAE,IAAI,EAAE,SAAS,GAAG,EAAE,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAA;IAC3G,CAAC;IACD,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;AAC3B,CAAC,CAAA;AAED,MAAM,kBAAkB,GAAG,GAAmB,EAAE,CAC9C,WAAW,CAAC;IACV,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;IAChF,EAAE,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;IAC3E,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;IACzE,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE;CAC3E,CAAC,CAAA;AAEJ,MAAM,YAAY,GAAkB;IAClC;QACE,KAAK,EAAE,SAAS;QAChB,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,gBAAgB,EAAE,UAAU,EAAE,cAAc,EAAE,aAAa,EAAE,qBAAqB,EAAE;YACjH,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC3C,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa,EAAE;YACzC,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,mBAAmB,EAAE;YACrD,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,iBAAiB,EAAE,UAAU,EAAE,MAAM,EAAE,aAAa,EAAE,cAAc,EAAE;YACpG,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC3C,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YACjD,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE;SAC9C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE;YACpF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACtE,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACtE,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE;YAChE,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACnF,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACnF,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACjF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACtF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,SAAS;YAChB,OAAO,EAAE,kBAAkB;YAC3B,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,kBAAkB,EAAE,MAAM,EAAE,IAAI,EAAE;gBAC9D,EAAE,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,YAAY,EAAE;gBAChD,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE;gBACxC,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE;aAC7C;YACD,IAAI,EAAE,qBAAqB;SAC5B;QACD,UAAU,EAAE;YACV,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,SAAS;YAChB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,kBAAkB,EAAE,MAAM,EAAE,IAAI,EAAE;gBACjE,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,kBAAkB,EAAE;gBACrD,EAAE,KAAK,EAAE,cAAc,EAAE,QAAQ,EAAE,eAAe,EAAE;gBACpD,EAAE,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,YAAY,EAAE;aACjD;YACD,OAAO,EAAE,qBAAqB;SAC/B;KACF;IACD;QACE,KAAK,EAAE,QAAQ;QACf,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,gBAAgB,EAAE;YAC/C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,sBAAsB,EAAE;YACpD,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,kBAAkB,EAAE;YAC9C,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,oBAAoB,EAAE;YAChD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,qBAAqB,EAAE;YAClD,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YACjD,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YACjD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE;SAC5C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,eAAe,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAClF,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC1E,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACxE,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACzE,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YAC3F,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACtF,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YAC1F,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SAC3F,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,cAAc;YACrB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE;gBACzD,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE;gBACxC,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE;gBACzC,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,eAAe,EAAE;aACnD;SACF;QACD,UAAU,EAAE;YACV,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,SAAS;YAChB,OAAO,EAAE,aAAa;YACtB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE;gBAC1D,EAAE,KAAK,EAAE,cAAc,EAAE,QAAQ,EAAE,UAAU,EAAE;aAChD;SACF;KACF;CACF,CAAA;AAED,MAAM,YAAY,GAAkB;IAClC;QACE,KAAK,EAAE,QAAQ;QACf,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC7C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC7C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,gBAAgB,EAAE;YAC/C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC7C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC7C,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC3C,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC3C,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,iBAAiB,EAAE;SAClD,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC5E,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC1E,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC1E,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC1E,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YAC3F,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACzF,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YAC5F,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACxF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,OAAO;YACb,KAAK,EAAE,gBAAgB;YACvB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;gBAChD,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;gBACjD,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;gBAC/C,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE;aAChD;YACD,OAAO,EAAE,aAAa;SACvB;QACD,UAAU,EAAE;YACV,IAAI,EAAE,OAAO;YACb,KAAK,EAAE,gBAAgB;YACvB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;gBACnD,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;gBACnD,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;aACnD;SACF;KACF;CACF,CAAA;AAED,MAAM,WAAW,GAAkB;IACjC;QACE,KAAK,EAAE,SAAS;QAChB,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,iBAAiB,EAAE,UAAU,EAAE,MAAM,EAAE,aAAa,EAAE,aAAa,EAAE;YACpG,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC9C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC9C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC9C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC5C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC9C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,eAAe,EAAE;SAC/C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACtE,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC5E,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACtE,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACxE,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACnF,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YAC/E,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACpF,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACnF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,eAAe;YACtB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE;gBACzD,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,kBAAkB,EAAE;gBACjD,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE;aACxC;SACF;QACD,UAAU,EAAE;YACV,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,UAAU;YACjB,OAAO,EAAE,sBAAsB;YAC/B,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,WAAW,EAAE;gBAC1C,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,OAAO,EAAE;gBACxC,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,oBAAoB,EAAE;aACpD;SACF;KACF;CACF,CAAA;AAED,MAAM,aAAa,GAAkB;IACnC;QACE,KAAK,EAAE,QAAQ;QACf,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YAChD,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,mBAAmB,EAAE;YACpD,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,oBAAoB,EAAE;YACtD,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YAChD,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YAChD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC5C,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;SAC/C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE;YAC9E,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACzE,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE;YACtE,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACnE,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACxF,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACzF,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACnF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACtF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,QAAQ;YACf,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE;gBACpD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE;gBACrC,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE;gBACvC,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE;aACvC;YACD,OAAO,EAAE,yBAAyB;SACnC;QACD,UAAU,EAAE;YACV,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,QAAQ;YACf,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,cAAc,EAAE;gBACjD,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,aAAa,EAAE;gBAChD,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,eAAe,EAAE;aACnD;SACF;KACF;CACF,CAAA;AAED,MAAM,UAAU,GAAkB;IAChC;QACE,KAAK,EAAE,KAAK;QACZ,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC7C,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE;YACvC,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC3C,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,UAAU,EAAE;YACrC,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC3C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC7C,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE;YACvC,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,EAAE;SAC9C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACxE,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC1E,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACtE,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACxE,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACzF,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACxF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACrF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACtF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,OAAO;YACb,KAAK,EAAE,UAAU;YACjB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;gBAChD,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;gBACjD,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,IAAI,EAAE;aAChD;SACF;QACD,UAAU,EAAE;YACV,IAAI,EAAE,OAAO;YACb,KAAK,EAAE,UAAU;YACjB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE;gBACpD,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE;gBACnD,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE;aACzD;SACF;KACF;CACF,CAAA;AAED,MAAM,aAAa,GAAkB;IACnC;QACE,KAAK,EAAE,UAAU;QACjB,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YAChD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;YAC9C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,EAAE;YAChD,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,oBAAoB,EAAE;YACtD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;YAC9C,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,kBAAkB,EAAE;SACnD,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACnE,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACjE,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YAC/D,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE;YACtE,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACpF,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACjF,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACvF,EAAE,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SAClF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,UAAU;YACjB,OAAO,EAAE,wBAAwB;YACjC,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE;gBACpC,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE;aACrC;SACF;QACD,UAAU,EAAE;YACV,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,SAAS;YAChB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM,EAAE;gBAC3C,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,EAAE;gBACpC,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO,EAAE;aAC1C;SACF;KACF;CACF,CAAA;AAED,MAAM,SAAS,GAAkB;IAC/B;QACE,KAAK,EAAE,OAAO;QACd,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE;YACtC,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE;YACxC,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE,aAAa,EAAE,cAAc,EAAE;YAC9F,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,mBAAmB,EAAE;YACjD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,kBAAkB,EAAE;YAC/C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;SAC3C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACrE,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACjE,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACzE,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACnE,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE;YACrG,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACpF,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACrF,EAAE,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACtF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,UAAU;YACjB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,gBAAgB,EAAE;gBACpD,EAAE,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,iBAAiB,EAAE;gBACrD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE;aACpD;YACD,OAAO,EAAE,gBAAgB;SAC1B;QACD,UAAU,EAAE;YACV,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,QAAQ;YACf,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;gBAC9C,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE;gBACzC,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,kBAAkB,EAAE;aAClD;YACD,OAAO,EAAE,yBAAyB;SACnC;KACF;CACF,CAAA;AAED,MAAM,aAAa,GAAkB;IACnC;QACE,KAAK,EAAE,UAAU;QACjB,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,gBAAgB,EAAE;YAClD,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,kBAAkB,EAAE;YACnD,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,mBAAmB,EAAE;YACpD,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;YAC9C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;YAC9C,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE;YAC5C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE;SAC/C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC5E,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACvE,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACnE,EAAE,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACvE,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YAChF,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACvF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE;YACzF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACtF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,QAAQ;YACf,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE;gBACnC,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO,EAAE;gBACrC,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,MAAM,EAAE;aACrC;SACF;QACD,UAAU,EAAE;YACV,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,YAAY;YACnB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,EAAE;gBAChD,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,aAAa,EAAE;gBAC5C,EAAE,KAAK,EAAE,YAAY,EAAE,QAAQ,EAAE,aAAa,EAAE;aACjD;SACF;KACF;CACF,CAAA;AAED,MAAM,SAAS,GAAkB;IAC/B;QACE,KAAK,EAAE,YAAY;QACnB,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;YAC1C,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE;YACxC,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;YAC1C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;YAC1C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;YAC1C,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE;YACtC,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE;YACxC,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE;SAC3C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACpE,EAAE,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC3E,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YAC1E,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE;YACzE,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACzF,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACnF,EAAE,EAAE,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACnF,EAAE,EAAE,EAAE,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACzF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,YAAY;YACnB,OAAO,EAAE,6BAA6B;YACtC,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE;gBACjC,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE;aACrC;SACF;QACD,UAAU,EAAE;YACV,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,QAAQ;YACf,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE;gBAChC,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAE;gBAClC,EAAE,KAAK,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE;aACpC;SACF;KACF;CACF,CAAA;AAED,MAAM,UAAU,GAAkB;IAChC;QACE,KAAK,EAAE,OAAO;QACd,WAAW,EAAE,gBAAgB,CAAC;YAC5B,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,EAAE;YAC7C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC3C,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE;YACzC,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC3C,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC3C,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAE,WAAW,EAAE,aAAa,EAAE,iBAAiB,EAAE;YAClG,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE;YAC3C,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,cAAc,EAAE;SAC9C,CAAC;QACF,MAAM,EAAE,WAAW,CAAC;YAClB,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACvE,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACvE,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACvE,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE;YACvE,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACtF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACtF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;YACtF,EAAE,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE;SACvF,CAAC;QACF,SAAS,EAAE;YACT,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,YAAY;YACnB,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE;gBACpC,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE;gBACpD,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE;aACrC;YACD,OAAO,EAAE,kBAAkB;SAC5B;QACD,UAAU,EAAE;YACV,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,OAAO;YACd,KAAK,EAAE;gBACL,EAAE,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE;gBACtC,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE;aACjC;SACF;KACF;CACF,CAAA;AAED,MAAM,WAAW,GAAuC;IACtD,OAAO,EAAE,YAAY;IACrB,MAAM,EAAE,WAAW;IACnB,QAAQ,EAAE,aAAa;IACvB,KAAK,EAAE,UAAU;IACjB,OAAO,EAAE,YAAY;IACrB,QAAQ,EAAE,aAAa;IACvB,IAAI,EAAE,SAAS;IACf,QAAQ,EAAE,aAAa;IACvB,IAAI,EAAE,SAAS;IACf,KAAK,EAAE,UAAU;CAClB,CAAA;AAED,MAAM,sBAAsB,GAAG,GAAoB,EAAE;IACnD,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;QAChC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QACb,OAAO,GAAG,CAAA;IACZ,CAAC,EAAE,EAAqB,CAAC,CAAA;AAC3B,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,eAAe,GAAG,WAAW,CAAC,SAAS,EAAE;IACpD,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;QACZ,UAAU,EAAE,SAAwB;QACpC,SAAS,EAAE,KAAK;QAChB,eAAe,EAAE,sBAAsB,EAAE;QACzC,WAAW;QACX,UAAU,EAAE,OAAO;QACnB,WAAW,EAAE;YACX,SAAS,EAAE,IAAI;YACf,OAAO,EAAE,IAAI;YACb,eAAe,EAAE,KAAK;SACvB;QACD,SAAS,EAAE,IAAsC;QACjD,cAAc,EAAE,IAA8E;KAC/F,CAAC;IACF,OAAO,EAAE;QACP,UAAU,CAAC,KAAK;YACd,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,EAAE,CAAA;YACvD,MAAM,KAAK,GAAG,KAAK,CAAC,eAAe,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;YAC1D,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAA;QACjC,CAAC;QACD,SAAS;YACP,OAAO,IAAI,CAAC,UAAU,EAAE,KAAK,IAAI,EAAE,CAAA;QACrC,CAAC;QACD,SAAS,CAAC,KAAK;YACb,OAAO,KAAK,CAAC,UAAU,CAAA;QACzB,CAAC;QACD,iBAAiB;YACf,OAAO,IAAI,CAAC,UAAU,EAAE,WAAW,IAAI,gBAAgB,CAAC,EAAE,CAAC,CAAA;QAC7D,CAAC;QACD,UAAU;YACR,OAAO,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,KAAK,IAAI,EAAE,CAAC,CAAA;QAC7D,CAAC;QACD,YAAY;YACV,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;gBAClC,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;gBACjC,IAAI,OAAO,CAAC,YAAY,CAAC,SAAS,EAAE,CAAC;oBACnC,OAAO,kBAAkB,EAAE,CAAA;gBAC7B,CAAC;YACH,CAAC;YACD,OAAO,IAAI,CAAC,UAAU,EAAE,MAAM,IAAI,WAAW,CAAC,EAAE,CAAC,CAAA;QACnD,CAAC;QACD,cAAc;YACZ,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,MAAM,CAAC,KAAK,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;QAC3F,CAAC;QACD,eAAe;YACb,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,MAAM,CAAC,KAAK,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;QAC5F,CAAC;QACD,SAAS;YACP,IAAI,CAAC,IAAI,CAAC,UAAU,KAAK,SAAS,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,cAAc,EAAE,SAAS,EAAE,CAAC;gBACpG,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS,CAAA;YACtC,CAAC;YACD,OAAO,IAAI,CAAC,UAAU,EAAE,SAAS,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,CAAA;QACxE,CAAC;QACD,UAAU;YACR,IAAI,CAAC,IAAI,CAAC,UAAU,KAAK,SAAS,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,cAAc,EAAE,UAAU,EAAE,CAAC;gBACrG,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU,CAAA;YACvC,CAAC;YACD,OAAO,IAAI,CAAC,UAAU,EAAE,UAAU,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,CAAA;QACzE,CAAC;KACF;IACD,OAAO,EAAE;QACP,qBAAqB;YACnB,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,YAAY,EAAE,CAAC,CAAA;YACzD,IAAI,CAAC,SAAS,GAAG,OAAO,CAAA;YACxB,MAAM,MAAM,GAAG,OAAO,CAAC,gBAAgB,EAAE,CAAA;YACzC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,CAAA;YACzB,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAA;YAC/B,OAAO,CAAC,eAAe,CAAC,KAAK,GAAG,CAAC,CAAA;QACnC,CAAC;QACD,oBAAoB;YAClB,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAM;YAC3B,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,gBAAgB,EAAE,CAAC,CAAA;QACtD,CAAC;QACD,kBAAkB;YAChB,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;gBAC1B,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;oBACnB,MAAM,MAAM,GAAG,OAAO,CAAC,gBAAgB,EAAE,CAAA;oBACzC,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,MAAM,CAAC,CAAA;oBAChC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,eAAe,CAAC,CAAA;oBACvC,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;wBACxB,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,GAAG,CAAC,CAAA;oBAC1C,CAAC;yBAAM,CAAC;wBACN,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;wBAC/E,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,GAAG,KAAK,CAAA;oBAC9C,CAAC;gBACH,CAAC;gBACD,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC,CAAA;gBACjD,OAAM;YACR,CAAC;YACD,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE,KAAK,KAAK,QAAQ,EAAE,CAAC;gBACzE,OAAO,CAAC,eAAe,EAAE,CAAA;gBACzB,MAAM,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;oBACtD,KAAK,EAAE,KAAK,CAAC,IAAI;oBACjB,QAAQ,EAAE,uBAAuB,CAAC,KAAK,CAAC,SAAS,CAAC;oBAClD,KAAK,EAAE,KAAK,CAAC,EAAE;iBAChB,CAAC,CAAC,CAAA;gBACH,IAAI,CAAC,iBAAiB,CAAC;oBACrB,SAAS,EAAE;wBACT,IAAI,EAAE,SAAS;wBACf,KAAK,EAAE,cAAc;wBACrB,OAAO,EAAE,GAAG,WAAW,CAAC,MAAM,QAAQ;wBACtC,KAAK,EAAE,WAAW;qBACnB;oBACD,UAAU,EAAE,IAAI,CAAC,UAAU,EAAE,UAAU,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE;iBACjF,CAAC,CAAA;gBACF,OAAM;YACR,CAAC;YACD,MAAM,MAAM,GAAG,OAAO,CAAC,eAAe,EAAE,CAAA;YACxC,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;gBACnB,MAAM,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,CAAA;gBACpD,IAAI,WAAW,EAAE,CAAC;oBAChB,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,OAAO,IAAI,EAAE,CAAA;oBAC9C,MAAM,SAAS,GAAG,IAAI,WAAW,CAAC,KAAK,GAAG,CAAA;oBAC1C,MAAM,CAAC,SAAS,GAAG;wBACjB,GAAG,MAAM,CAAC,SAAS;wBACnB,OAAO,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;qBACrF,CAAA;gBACH,CAAC;YACH,CAAC;YACD,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAA;QAChC,CAAC;QACD,iBAAiB;YACf,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAM;YAC3B,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,EAAE,CAAC;gBAC/B,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAA;gBACzC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACvB,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;oBACxB,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,GAAG,CAAC,CAAA;gBAC1C,CAAC;qBAAM,CAAC;oBACN,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;oBAC9E,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,GAAG,KAAK,CAAA;oBAC5C,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,IAAI,IAAI,IAAI,CAAC,CAAA;gBAChD,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,OAAO,CAAA;gBACvC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACzB,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA;oBAC1B,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,GAAG,CAAC,CAAA;gBAC1C,CAAC;qBAAM,CAAC;oBACN,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,EAAE,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;oBAChF,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,GAAG,KAAK,CAAA;oBAC5C,OAAO,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,IAAI,CAAC,CAAA;gBAClD,CAAC;YACH,CAAC;YACD,IAAI,CAAC,kBAAkB,EAAE,CAAA;QAC3B,CAAC;QACD,uBAAuB;YACrB,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAM;YAC3B,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,CAAA;YAC9C,IAAI,CAAC,KAAK;gBAAE,OAAM;YAClB,IAAI,KAAK,CAAC,EAAE,KAAK,MAAM,EAAE,CAAC;gBACxB,OAAO,CAAC,WAAW,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAA;gBAC/C,IAAI,CAAC,oBAAoB,EAAE,CAAA;gBAC3B,OAAM;YACR,CAAC;YACD,MAAM,KAAK,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAA;YAC7C,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,EAA0B,EAAE,KAA6C,CAAC,CAAA;YAClG,IAAI,CAAC,oBAAoB,EAAE,CAAA;QAC7B,CAAC;QACD,OAAO,CAAC,IAAiB;YACvB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAA;YACtB,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC;gBACvC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;YAChC,CAAC;YACD,IAAI,CAAC,UAAU,GAAG,GAAG,IAAI,WAAW,CAAA;YACpC,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,MAAM,EAAE,CAAC;gBAC1C,IAAI,CAAC,qBAAqB,EAAE,CAAA;gBAC5B,IAAI,CAAC,kBAAkB,EAAE,CAAA;YAC3B,CAAC;QACH,CAAC;QACD,YAAY,CAAC,KAAc;YACzB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAA;QACxB,CAAC;QACD,iBAAiB,CAAC,MAA8E;YAC9F,IAAI,CAAC,cAAc,GAAG,MAAM,CAAA;QAC9B,CAAC;QACD,QAAQ;YACN,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAA;YACrD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;gBAAE,OAAM;YAC9B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;YAC9F,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,SAAS,CAAA;YACjD,IAAI,CAAC,UAAU,GAAG,GAAG,IAAI,CAAC,UAAU,UAAU,KAAK,CAAC,SAAS,CAAC,EAAE,KAAK,IAAI,EAAE,EAAE,CAAA;YAC7E,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;gBAClC,IAAI,CAAC,kBAAkB,EAAE,CAAA;YAC3B,CAAC;QACH,CAAC;QACD,QAAQ;YACN,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAA;YACrD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;gBAAE,OAAM;YAC9B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;YAC/E,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,SAAS,CAAA;YACjD,IAAI,CAAC,UAAU,GAAG,GAAG,IAAI,CAAC,UAAU,UAAU,KAAK,CAAC,SAAS,CAAC,EAAE,KAAK,IAAI,EAAE,EAAE,CAAA;YAC7E,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE,CAAC;gBAClC,IAAI,CAAC,kBAAkB,EAAE,CAAA;YAC3B,CAAC;QACH,CAAC;QACD,eAAe,CAAC,KAAa;YAC3B,MAAM,GAAG,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAA;YACzC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,OAAO,KAAK,KAAK;gBAAE,OAAM;YACzC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAA;YACvF,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAA;QACvC,CAAC;QACD,WAAW,CAAC,QAAgB,EAAE,KAAc;YAC1C,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,QAAQ,QAAQ,EAAE,CAAC;gBACjB,KAAK,gBAAgB;oBACnB,KAAK,OAAO,CAAC,MAAM,EAAE,CAAA;oBACrB,IAAI,CAAC,UAAU,GAAG,gBAAgB,CAAA;oBAClC,MAAK;gBACP,KAAK,aAAa,CAAC;gBACnB,KAAK,oBAAoB;oBACvB,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;wBAC/B,OAAO,CAAC,aAAa,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;wBACjD,IAAI,CAAC,UAAU,GAAG,mBAAmB,CAAA;oBACvC,CAAC;oBACD,MAAK;gBACP,KAAK,iBAAiB;oBACpB,KAAK,OAAO,CAAC,eAAe,EAAE,CAAA;oBAC9B,IAAI,CAAC,UAAU,GAAG,mBAAmB,CAAA;oBACrC,MAAK;gBACP,KAAK,cAAc;oBACjB,OAAO,CAAC,WAAW,EAAE,CAAA;oBACrB,IAAI,CAAC,UAAU,GAAG,iBAAiB,CAAA;oBACnC,MAAK;gBACP,KAAK,cAAc,CAAC;gBACpB,KAAK,iBAAiB;oBACpB,KAAK,OAAO,CAAC,cAAc,EAAE,CAAA;oBAC7B,IAAI,CAAC,UAAU,GAAG,kBAAkB,CAAA;oBACpC,MAAK;gBACP,KAAK,mBAAmB;oBACtB,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;wBAC/B,KAAK,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;wBACvD,IAAI,CAAC,UAAU,GAAG,kBAAkB,CAAA;oBACtC,CAAC;yBAAM,CAAC;wBACN,OAAO,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAA;wBAC1D,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC,sBAAsB,CAAA;oBAC9F,CAAC;oBACD,MAAK;gBACP,KAAK,eAAe;oBAClB,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA;oBAC1B,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;oBACxB,IAAI,CAAC,UAAU,GAAG,iBAAiB,CAAA;oBACnC,MAAK;gBACP,KAAK,qBAAqB,CAAC;gBAC3B,KAAK,iBAAiB,CAAC;gBACvB,KAAK,aAAa,CAAC;gBACnB,KAAK,eAAe,CAAC;gBACrB,KAAK,eAAe,CAAC;gBACrB,KAAK,gBAAgB;oBACnB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,YAAY,CAAC,CAAC,CAAC,QAAQ,CAAA;oBACzD,MAAK;gBACP,KAAK,WAAW,CAAC;gBACjB,KAAK,cAAc;oBACjB,IAAI,CAAC,UAAU,GAAG,sBAAsB,CAAA;oBACxC,MAAK;gBACP,KAAK,gBAAgB;oBACnB,IAAI,CAAC,WAAW,CAAC,SAAS,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAA;oBACxD,IAAI,CAAC,UAAU,GAAG,aAAa,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,CAAA;oBAC1E,MAAK;gBACP,KAAK,kBAAkB;oBACrB,IAAI,CAAC,WAAW,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAA;oBACpD,IAAI,CAAC,UAAU,GAAG,YAAY,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,EAAE,CAAA;oBACvE,MAAK;gBACP,KAAK,UAAU;oBACb,IAAI,CAAC,WAAW,CAAC,eAAe,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,eAAe,CAAA;oBACpE,IAAI,CAAC,UAAU,GAAG,cAAc,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,UAAU,EAAE,CAAA;oBACzF,MAAK;gBACP;oBACE,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,YAAY,CAAC,CAAC,CAAC,QAAQ,CAAA;YAC7D,CAAC;QACH,CAAC;QACD,aAAa,CAAC,SAA2C;YACvD,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAM;YAC3B,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;gBAC1B,IAAI,SAAS,KAAK,OAAO,EAAE,CAAC;oBAC1B,OAAO,CAAC,cAAc,EAAE,CAAA;oBACxB,IAAI,CAAC,kBAAkB,EAAE,CAAA;oBACzB,OAAM;gBACR,CAAC;gBACD,IAAI,SAAS,KAAK,IAAI,IAAI,SAAS,KAAK,MAAM,EAAE,CAAC;oBAC/C,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,SAAS,CAAC,CAAA;oBACtC,IAAI,CAAC,kBAAkB,EAAE,CAAA;gBAC3B,CAAC;gBACD,OAAM;YACR,CAAC;YACD,IAAI,SAAS,KAAK,MAAM,IAAI,SAAS,KAAK,OAAO,EAAE,CAAC;gBAClD,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,SAAS,CAAC,CAAA;gBACxC,IAAI,CAAC,kBAAkB,EAAE,CAAA;gBACzB,OAAM;YACR,CAAC;YACD,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,SAAS,CAAC,CAAA;YACtC,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC1B,CAAC;QACD,aAAa,CAAC,KAAa;YACzB,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAM;YAC3B,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;gBAC1B,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,eAAe,CAAC,CAAA;gBACvC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;gBAC1B,IAAI,CAAC,kBAAkB,EAAE,CAAA;gBACzB,OAAM;YACR,CAAC;YACD,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAA;YACtC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAC1B,IAAI,IAAI,KAAK,cAAc,EAAE,CAAC;gBAC5B,IAAI,CAAC,uBAAuB,EAAE,CAAA;YAChC,CAAC;iBAAM,IAAI,IAAI,KAAK,eAAe,EAAE,CAAC;gBACpC,IAAI,CAAC,iBAAiB,EAAE,CAAA;YAC1B,CAAC;QACH,CAAC;QACD,KAAK,CAAC,cAAc;YAClB,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAM;YAC3B,MAAM,OAAO,GAAG,eAAe,EAAE,CAAA;YACjC,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;gBAC1B,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC,EAAE,OAAO,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;gBAC9F,MAAM,GAAG,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;gBACxC,IAAI,GAAG,EAAE,CAAC;oBACR,MAAM,UAAU,GAAG,OAAO,CAAC,eAAe,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAA;oBACxE,MAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE,KAAK,UAAU,CAAC,CAAA;oBAC/E,MAAM,QAAQ,GAAG,QAAQ,EAAE,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI,KAAK,CAAA;oBACvD,IAAI,QAAQ,EAAE,CAAC;wBACb,MAAM,OAAO,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAA;oBAC1C,CAAC;yBAAM,CAAC;wBACN,MAAM,OAAO,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAA;oBACrC,CAAC;oBACD,IAAI,CAAC,kBAAkB,EAAE,CAAA;gBAC3B,CAAC;gBACD,OAAM;YACR,CAAC;YACD,MAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAA;YAC9C,IAAI,YAAY,KAAK,cAAc,EAAE,CAAC;gBACpC,IAAI,CAAC,uBAAuB,EAAE,CAAA;YAChC,CAAC;YACD,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAA;YACtB,IAAI,YAAY,KAAK,eAAe,EAAE,CAAC;gBACrC,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,EAAE,CAAC;oBAC/B,MAAM,OAAO,CAAC,cAAc,EAAE,CAAA;gBAChC,CAAC;qBAAM,CAAC;oBACN,IAAI,CAAC,iBAAiB,EAAE,CAAA;gBAC1B,CAAC;YACH,CAAC;YACD,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,KAAK,eAAe,EAAE,CAAC;gBAClD,IAAI,CAAC,iBAAiB,EAAE,CAAA;YAC1B,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,kBAAkB,EAAE,CAAA;YAC3B,CAAC;QACH,CAAC;QACD,WAAW,CAAC,KAAa,EAAE,KAAa,EAAE,OAA4B;YACpE,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAA;YAC5B,IAAI,CAAC,IAAI;gBAAE,OAAM;YACjB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAA;YAC1B,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA;YAC3B,IAAI,CAAC,KAAK;gBAAE,OAAM;YAClB,MAAM,IAAI,GAAG,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAA;YAC1F,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,GAAG,IAAI,EAAE,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,CAAC,CAAA;YACzE,KAAK,CAAC,KAAK,GAAG,SAAS,CAAA;YACvB,IAAI,CAAC,UAAU,GAAG,GAAG,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAA;QAClH,CAAC;QACD,eAAe,CAAC,EAAU,EAAE,KAAa,EAAE,OAA4B;YACrE,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAA;YAChC,MAAM,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,CAAC,CAAA;YAC1D,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;gBACf,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,CAAA;YACzC,CAAC;QACH,CAAC;KACF;CACF,CAAC,CAAA"}


=========================================
File: dist-test/stores/patterns.js
=========================================

import { defineStore } from 'pinia';
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing';
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity';
// Manages patterns and scenes with undo/redo history, grid spec updates, and step velocity editing.
const createDefaultGrid = () => ({ ...DEFAULT_GRID_SPEC });
const createEmptyPattern = (id, name) => ({
    id,
    name,
    gridSpec: createDefaultGrid(),
    steps: {}
});
const createScene = (id, name, patternIds = []) => ({
    id,
    name,
    patternIds
});
const HISTORY_LIMIT = 50;
export const usePatternsStore = defineStore('patterns', {
    state: () => ({
        patterns: [createEmptyPattern('pattern-1', 'Pattern 1')],
        scenes: [],
        selectedPatternId: 'pattern-1',
        activeSceneId: null,
        scenePosition: 0,
        history: [],
        historyIndex: -1,
        isRestoring: false
    }),
    getters: {
        currentPattern(state) {
            return state.patterns.find((p) => p.id === state.selectedPatternId) ?? createEmptyPattern('pattern-1', 'Pattern 1');
        },
        currentScene(state) {
            return state.scenes.find((scene) => scene.id === state.activeSceneId) ?? null;
        }
    },
    actions: {
        snapshotState() {
            return {
                patterns: JSON.parse(JSON.stringify(this.patterns)),
                scenes: JSON.parse(JSON.stringify(this.scenes)),
                selectedPatternId: this.selectedPatternId,
                activeSceneId: this.activeSceneId
            };
        },
        recordHistory() {
            if (this.isRestoring)
                return;
            const snapshot = this.snapshotState();
            this.history = this.history.slice(0, this.historyIndex + 1);
            this.history.push(snapshot);
            if (this.history.length > HISTORY_LIMIT) {
                this.history.shift();
                this.historyIndex -= 1;
            }
            this.historyIndex = this.history.length - 1;
        },
        restoreSnapshot(snapshot) {
            this.isRestoring = true;
            this.patterns = snapshot.patterns.map((pattern) => ({
                ...pattern,
                gridSpec: normalizeGridSpec(pattern.gridSpec)
            }));
            this.setScenes(snapshot.scenes);
            this.selectedPatternId = snapshot.selectedPatternId;
            if (!this.patterns.find((pattern) => pattern.id === this.selectedPatternId)) {
                this.selectedPatternId = this.patterns[0]?.id ?? 'pattern-1';
            }
            this.activeSceneId = snapshot.activeSceneId;
            this.scenePosition = 0;
            this.isRestoring = false;
        },
        undo() {
            if (this.historyIndex <= 0)
                return;
            this.historyIndex -= 1;
            const snapshot = this.history[this.historyIndex];
            if (snapshot) {
                this.restoreSnapshot(snapshot);
            }
        },
        redo() {
            if (this.historyIndex >= this.history.length - 1)
                return;
            this.historyIndex += 1;
            const snapshot = this.history[this.historyIndex];
            if (snapshot) {
                this.restoreSnapshot(snapshot);
            }
        },
        selectPattern(id) {
            this.selectedPatternId = id;
        },
        addPattern(name) {
            this.recordHistory();
            const nextIndex = this.patterns.length + 1;
            const id = `pattern-${Date.now()}-${nextIndex}`;
            const pattern = createEmptyPattern(id, name ?? `Pattern ${nextIndex}`);
            this.patterns.push(pattern);
            this.selectedPatternId = pattern.id;
        },
        renamePattern(id, name) {
            this.recordHistory();
            const pattern = this.patterns.find((entry) => entry.id === id);
            if (pattern) {
                pattern.name = name;
            }
        },
        setScenes(scenes) {
            const allowedIds = this.patterns.map((pattern) => pattern.id);
            this.scenes = scenes.map((scene) => ({
                ...scene,
                patternIds: scene.patternIds.filter((id) => allowedIds.includes(id))
            }));
            if (this.activeSceneId && !this.scenes.find((scene) => scene.id === this.activeSceneId)) {
                this.activeSceneId = null;
                this.scenePosition = 0;
            }
        },
        setPatterns(patterns) {
            this.patterns = patterns.length ? patterns : [createEmptyPattern('pattern-1', 'Pattern 1')];
            if (!this.patterns.find((pattern) => pattern.id === this.selectedPatternId)) {
                this.selectedPatternId = this.patterns[0]?.id ?? 'pattern-1';
            }
            const allowedIds = this.patterns.map((pattern) => pattern.id);
            this.scenes = this.scenes.map((scene) => ({
                ...scene,
                patternIds: scene.patternIds.filter((id) => allowedIds.includes(id))
            }));
            if (this.activeSceneId && !this.scenes.find((scene) => scene.id === this.activeSceneId)) {
                this.activeSceneId = null;
                this.scenePosition = 0;
            }
        },
        toggleStep(barIndex, stepInBar, padId) {
            this.recordHistory();
            const pattern = this.currentPattern;
            const grid = pattern.steps;
            const bar = grid[barIndex] ?? {};
            const stepRow = bar[stepInBar] ?? {};
            const updated = { ...stepRow };
            const nextVelocity = cycleVelocity(updated[padId]?.velocity?.value);
            if (nextVelocity === null) {
                delete updated[padId];
            }
            else {
                updated[padId] = { velocity: { value: clampVelocity(nextVelocity) } };
            }
            grid[barIndex] = { ...bar, [stepInBar]: updated };
        },
        setStepVelocity(barIndex, stepInBar, padId, velocity) {
            this.recordHistory();
            const pattern = this.currentPattern;
            const grid = pattern.steps;
            const bar = grid[barIndex] ?? {};
            const stepRow = bar[stepInBar] ?? {};
            const updated = { ...stepRow };
            updated[padId] = { velocity: { value: clampVelocity(velocity || DEFAULT_STEP_VELOCITY) } };
            grid[barIndex] = { ...bar, [stepInBar]: updated };
        },
        eraseStepForPad(barIndex, stepInBar, padId) {
            this.recordHistory();
            const pattern = this.currentPattern;
            const grid = pattern.steps;
            const bar = grid[barIndex] ?? {};
            const stepRow = bar[stepInBar] ?? {};
            if (stepRow && stepRow[padId]) {
                const updated = { ...stepRow };
                delete updated[padId];
                grid[barIndex] = { ...bar, [stepInBar]: updated };
            }
        },
        erasePadEvents(padId) {
            this.recordHistory();
            const pattern = this.currentPattern;
            const grid = pattern.steps;
            Object.entries(grid).forEach(([barIndex, bar]) => {
                const barIdx = Number(barIndex);
                Object.entries(bar ?? {}).forEach(([stepIndex, row]) => {
                    if (row && row[padId]) {
                        const updated = { ...row };
                        delete updated[padId];
                        grid[barIdx] = { ...(grid[barIdx] ?? {}), [Number(stepIndex)]: updated };
                    }
                });
            });
        },
        eraseAutomationForPad(padId) {
            // Placeholder: no automation envelope stored yet; reuse pad erase.
            this.erasePadEvents(padId);
        },
        updateGridSpec(gridSpec) {
            this.recordHistory();
            const pattern = this.currentPattern;
            pattern.gridSpec = normalizeGridSpec(gridSpec);
        },
        addScene(name, patternIds = []) {
            this.recordHistory();
            const id = `scene-${Date.now()}-${this.scenes.length + 1}`;
            this.scenes.push(createScene(id, name, patternIds));
            this.activeSceneId = id;
            this.scenePosition = 0;
        },
        updateScene(sceneId, updates) {
            this.recordHistory();
            const scene = this.scenes.find((entry) => entry.id === sceneId);
            if (!scene)
                return;
            if (updates.name) {
                scene.name = updates.name;
            }
            if (updates.patternIds) {
                const allowed = this.patterns.map((pattern) => pattern.id);
                scene.patternIds = updates.patternIds.filter((id) => allowed.includes(id));
            }
        },
        selectScene(sceneId) {
            this.activeSceneId = sceneId;
            this.scenePosition = 0;
        },
        prepareScenePlayback() {
            this.scenePosition = 0;
            const scene = this.currentScene;
            if (scene && scene.patternIds.length > 0) {
                const nextId = scene.patternIds[0];
                if (nextId) {
                    this.selectedPatternId = nextId;
                }
                this.scenePosition = scene.patternIds.length > 1 ? 1 : 0;
            }
        },
        advanceScenePlayback() {
            const scene = this.currentScene;
            if (!scene || scene.patternIds.length === 0) {
                return this.currentPattern;
            }
            const nextId = scene.patternIds[this.scenePosition % scene.patternIds.length];
            this.scenePosition = (this.scenePosition + 1) % scene.patternIds.length;
            if (nextId) {
                this.selectedPatternId = nextId;
            }
            return this.currentPattern;
        }
    }
});
//# sourceMappingURL=patterns.js.map


=========================================
File: dist-test/stores/patterns.js.map
=========================================

{"version":3,"file":"patterns.js","sourceRoot":"","sources":["../../stores/patterns.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/stores/session.js
=========================================

import { defineStore } from 'pinia';
export const useSessionStore = defineStore('session', {
    state: () => ({
        midiInput: undefined,
        midiOutput: undefined,
        audioReady: false,
        capabilities: {
            supportsWebMIDI: false,
            supportsAudioInput: false
        }
    }),
    actions: {
        setMidiInput(device) {
            this.midiInput = device;
        },
        setMidiOutput(device) {
            this.midiOutput = device;
        },
        setAudioReady(isReady) {
            this.audioReady = isReady;
        },
        setCapabilities(capabilities) {
            this.capabilities = capabilities;
        }
    }
});
//# sourceMappingURL=session.js.map


=========================================
File: dist-test/stores/session.js.map
=========================================

{"version":3,"file":"session.js","sourceRoot":"","sources":["../../stores/session.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,OAAO,CAAA;AAGnC,MAAM,CAAC,MAAM,eAAe,GAAG,WAAW,CAAC,SAAS,EAAE;IACpD,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;QACZ,SAAS,EAAE,SAAuC;QAClD,UAAU,EAAE,SAAuC;QACnD,UAAU,EAAE,KAAK;QACjB,YAAY,EAAE;YACZ,eAAe,EAAE,KAAK;YACtB,kBAAkB,EAAE,KAAK;SAC1B;KACF,CAAC;IACF,OAAO,EAAE;QACP,YAAY,CAAC,MAAuB;YAClC,IAAI,CAAC,SAAS,GAAG,MAAM,CAAA;QACzB,CAAC;QACD,aAAa,CAAC,MAAuB;YACnC,IAAI,CAAC,UAAU,GAAG,MAAM,CAAA;QAC1B,CAAC;QACD,aAAa,CAAC,OAAgB;YAC5B,IAAI,CAAC,UAAU,GAAG,OAAO,CAAA;QAC3B,CAAC;QACD,eAAe,CAAC,YAAuE;YACrF,IAAI,CAAC,YAAY,GAAG,YAAY,CAAA;QAClC,CAAC;KACF;CACF,CAAC,CAAA"}


=========================================
File: dist-test/stores/soundbanks.js
=========================================

import { defineStore } from 'pinia';
export const useSoundbanksStore = defineStore('soundbanks', {
    state: () => ({
        banks: [],
        selectedBankId: ''
    }),
    getters: {
        currentBank(state) {
            return state.banks.find((bank) => bank.id === state.selectedBankId);
        }
    },
    actions: {
        setBanks(banks) {
            this.banks = banks;
            if (!this.selectedBankId && banks.length > 0) {
                const first = banks[0];
                if (first) {
                    this.selectedBankId = first.id;
                }
            }
        },
        selectBank(id) {
            this.selectedBankId = id;
        },
        upsertBank(bank) {
            const index = this.banks.findIndex((b) => b.id === bank.id);
            if (index >= 0) {
                this.banks.splice(index, 1, bank);
            }
            else {
                this.banks.push(bank);
            }
        }
    }
});
//# sourceMappingURL=soundbanks.js.map


=========================================
File: dist-test/stores/soundbanks.js.map
=========================================

{"version":3,"file":"soundbanks.js","sourceRoot":"","sources":["../../stores/soundbanks.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,OAAO,CAAA;AAGnC,MAAM,CAAC,MAAM,kBAAkB,GAAG,WAAW,CAAC,YAAY,EAAE;IAC1D,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;QACZ,KAAK,EAAE,EAAiB;QACxB,cAAc,EAAE,EAAE;KACnB,CAAC;IACF,OAAO,EAAE;QACP,WAAW,CAAC,KAAK;YACf,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE,KAAK,KAAK,CAAC,cAAc,CAAC,CAAA;QACrE,CAAC;KACF;IACD,OAAO,EAAE;QACP,QAAQ,CAAC,KAAkB;YACzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;YAClB,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC7C,MAAM,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAA;gBACtB,IAAI,KAAK,EAAE,CAAC;oBACV,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,EAAE,CAAA;gBAChC,CAAC;YACH,CAAC;QACH,CAAC;QACD,UAAU,CAAC,EAAU;YACnB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAA;QAC1B,CAAC;QACD,UAAU,CAAC,IAAe;YACxB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,CAAC,CAAA;YAC3D,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;gBACf,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC,CAAA;YACnC,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YACvB,CAAC;QACH,CAAC;KACF;CACF,CAAC,CAAA"}


=========================================
File: dist-test/stores/transport.js
=========================================

import { defineStore } from 'pinia';
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing';
export const useTransportStore = defineStore('transport', {
    state: () => ({
        bpm: 120,
        isPlaying: false,
        loop: true,
        gridSpec: { ...DEFAULT_GRID_SPEC },
        currentStep: 0,
        isRecording: false,
        countInEnabled: false,
        countInBars: 1,
        metronomeEnabled: false,
        metronomeVolume: 0.12,
        followEnabled: true,
        loopStart: 0,
        loopEnd: DEFAULT_GRID_SPEC.bars * DEFAULT_GRID_SPEC.division
    }),
    actions: {
        setBpm(bpm) {
            this.bpm = bpm;
        },
        setPlaying(isPlaying) {
            this.isPlaying = isPlaying;
        },
        setGridSpec(gridSpec) {
            const prevTotal = this.gridSpec.bars * this.gridSpec.division;
            this.gridSpec = normalizeGridSpec(gridSpec);
            const nextTotal = this.gridSpec.bars * this.gridSpec.division;
            if (prevTotal > 0 && nextTotal > 0) {
                const startRatio = this.loopStart / prevTotal;
                const endRatio = this.loopEnd / prevTotal;
                const nextStart = Math.floor(startRatio * nextTotal);
                const nextEnd = Math.max(nextStart + 1, Math.round(endRatio * nextTotal));
                this.setLoopRange(nextStart, nextEnd);
            }
            else {
                this.setLoopRange(0, nextTotal);
            }
        },
        setLoop(loop) {
            this.loop = loop;
        },
        setCurrentStep(step) {
            this.currentStep = step;
        },
        setRecording(isRecording) {
            this.isRecording = isRecording;
        },
        setCountInEnabled(enabled) {
            this.countInEnabled = enabled;
        },
        setCountInBars(bars) {
            const normalized = Math.max(1, Math.floor(bars));
            this.countInBars = normalized;
        },
        setMetronomeEnabled(enabled) {
            this.metronomeEnabled = enabled;
        },
        setMetronomeVolume(volume) {
            const clamped = Math.max(0, Math.min(1, volume));
            this.metronomeVolume = clamped;
        },
        setFollowEnabled(enabled) {
            this.followEnabled = enabled;
        },
        setLoopRange(start, end) {
            const total = this.gridSpec.bars * this.gridSpec.division;
            const clampedStart = Math.max(0, Math.min(start, total - 1));
            const clampedEnd = Math.max(clampedStart + 1, Math.min(end, total));
            this.loopStart = clampedStart;
            this.loopEnd = clampedEnd;
        },
        nudgeLoopRange(delta) {
            const length = this.loopEnd - this.loopStart;
            this.setLoopRange(this.loopStart + delta, this.loopStart + delta + length);
        }
    }
});
//# sourceMappingURL=transport.js.map


=========================================
File: dist-test/stores/transport.js.map
=========================================

{"version":3,"file":"transport.js","sourceRoot":"","sources":["../../stores/transport.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/componentTests/PadCell.component.spec.js
=========================================

import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import PadCell from '../../components/PadCell.vue';
describe('PadCell', () => {
    it('renders label', () => {
        const wrapper = mount(PadCell, {
            props: {
                padId: 'pad1',
                label: 'Kick'
            }
        });
        expect(wrapper.text()).to.equal('Kick');
    });
    it('emits pad:down on pointerdown', async () => {
        const wrapper = mount(PadCell, {
            props: {
                padId: 'pad1',
                label: 'Kick'
            }
        });
        await wrapper.trigger('pointerdown');
        const emitted = wrapper.emitted('pad:down');
        expect(emitted).to.be.an('array');
        expect(emitted).to.have.lengthOf(1);
        if (emitted && emitted[0]) {
            expect(emitted[0][0]).to.equal('pad1');
        }
    });
    it('applies is-playing class', () => {
        const wrapper = mount(PadCell, {
            props: {
                padId: 'pad1',
                label: 'Kick',
                isPlaying: true
            }
        });
        expect(wrapper.classes()).to.include('is-playing');
    });
});
//# sourceMappingURL=PadCell.component.spec.js.map


=========================================
File: dist-test/tests/componentTests/PadCell.component.spec.js.map
=========================================

{"version":3,"file":"PadCell.component.spec.js","sourceRoot":"","sources":["../../../tests/componentTests/PadCell.component.spec.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAA;AAC7C,OAAO,EAAE,KAAK,EAAE,MAAM,iBAAiB,CAAA;AACvC,OAAO,OAAO,MAAM,8BAA8B,CAAA;AAElD,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE;IACvB,EAAE,CAAC,eAAe,EAAE,GAAG,EAAE;QACvB,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,EAAE;YAC7B,KAAK,EAAE;gBACL,KAAK,EAAE,MAAM;gBACb,KAAK,EAAE,MAAM;aACd;SACF,CAAC,CAAA;QAEF,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;IACzC,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,+BAA+B,EAAE,KAAK,IAAI,EAAE;QAC7C,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,EAAE;YAC7B,KAAK,EAAE;gBACL,KAAK,EAAE,MAAM;gBACb,KAAK,EAAE,MAAM;aACd;SACF,CAAC,CAAA;QAEF,MAAM,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAA;QAEpC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;QAE3C,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,CAAC,CAAA;QACjC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;QACnC,IAAI,OAAO,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;YAC1B,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;QACxC,CAAC;IACH,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,0BAA0B,EAAE,GAAG,EAAE;QAClC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,EAAE;YAC7B,KAAK,EAAE;gBACL,KAAK,EAAE,MAAM;gBACb,KAAK,EAAE,MAAM;gBACb,SAAS,EAAE,IAAI;aAChB;SACF,CAAC,CAAA;QAEF,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,CAAA;IACpD,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA"}


=========================================
File: dist-test/tests/componentTests/PadGrid.component.spec.js
=========================================

import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import PadGrid from '@/components/PadGrid.vue';
describe('PadGrid', () => {
    const pads = ['pad1', 'pad2'];
    it('renders PadCell components', () => {
        const wrapper = mount(PadGrid, {
            props: { pads, selectedPad: null, padStates: {} }
        });
        expect(wrapper.findAllComponents({ name: 'PadCell' }))
            .to.have.lengthOf(2);
    });
    it('emits pad:select when PadCell emits', async () => {
        const wrapper = mount(PadGrid, {
            props: { pads, selectedPad: null, padStates: {} }
        });
        await wrapper.findComponent({ name: 'PadCell' })
            .vm.$emit('pad:select', 'pad1');
        const emitted = wrapper.emitted('pad:select');
        const payload = emitted?.[0]?.[0];
        expect(emitted).to.be.an('array');
        expect(emitted.length).to.equal(1);
        expect(payload).to.equal('pad1');
    });
    it('passes is-selected correctly', () => {
        const wrapper = mount(PadGrid, {
            props: { pads, selectedPad: 'pad1', padStates: {} }
        });
        const cells = wrapper.findAllComponents({ name: 'PadCell' });
        expect(cells).to.have.lengthOf(2);
        expect(cells[0].props('isSelected')).to.equal(true);
        expect(cells[1].props('isSelected')).to.equal(false);
    });
});
//# sourceMappingURL=PadGrid.component.spec.js.map


=========================================
File: dist-test/tests/componentTests/PadGrid.component.spec.js.map
=========================================

{"version":3,"file":"PadGrid.component.spec.js","sourceRoot":"","sources":["../../../tests/componentTests/PadGrid.component.spec.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAA;AAC7C,OAAO,EAAE,KAAK,EAAE,MAAM,iBAAiB,CAAA;AACvC,OAAO,OAAO,MAAM,0BAA0B,CAAA;AAG9C,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE;IACvB,MAAM,IAAI,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IAE7B,EAAE,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACpC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,EAAE;YAC7B,KAAK,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,EAAE;SAClD,CAAC,CAAA;QAEF,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC;aACnD,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;IACxB,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,qCAAqC,EAAE,KAAK,IAAI,EAAE;QACnD,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,EAAE;YAC7B,KAAK,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,EAAE;SAClD,CAAC,CAAA;QAEF,MAAM,OAAO,CAAC,aAAa,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC;aAC7C,EAAE,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,CAAC,CAAA;QAEjC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,YAAY,CAAgB,CAAA;QAC5D,MAAM,OAAO,GAAG,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;QACjC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,OAAO,CAAC,CAAA;QACjC,MAAM,CAAC,OAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACnC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;IAElC,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,8BAA8B,EAAE,GAAG,EAAE;QACtC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,EAAE;YAC7B,KAAK,EAAE,EAAE,IAAI,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,EAAE,EAAE;SACpD,CAAC,CAAA;QAEF,MAAM,KAAK,GAAG,OAAO,CAAC,iBAAiB,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,CAAA;QAC5D,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;QAEjC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAE,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;QACpD,MAAM,CAAC,KAAK,CAAC,CAAC,CAAE,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;IACvD,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA"}


=========================================
File: dist-test/tests/unitTests/browserPerformance.spec.js
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useBrowserStore } from '../../stores/browser';
import { __setLibraryRepositoryForTests } from '../../services/libraryRepository';
class MemoryLibraryRepo {
    items;
    constructor(items = []) {
        this.items = items;
    }
    favorites = new Set();
    async search(query, _filters) {
        const text = query.trim().toLowerCase();
        if (!text)
            return this.items;
        return this.items.filter((item) => item.name.toLowerCase().includes(text));
    }
    async getItem(id) {
        return this.items.find((item) => item.id === id);
    }
    async getTags(itemId) {
        return (await this.getItem(itemId))?.tags ?? [];
    }
    async addTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item);
        return this.getTags(itemId);
    }
    async removeTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item);
        return this.getTags(itemId);
    }
    async importFile(path, meta) {
        const item = {
            id: meta?.id ?? path,
            name: meta?.name ?? path,
            tags: meta?.tags ?? [],
            path,
            ...meta
        };
        this.items.push(item);
        return item;
    }
    async addToFavorites(itemId) {
        this.favorites.add(itemId);
    }
    async removeFromFavorites(itemId) {
        this.favorites.delete(itemId);
    }
    async getFavorites() {
        return this.items.filter((item) => this.favorites.has(item.id));
    }
    async isFavorite(itemId) {
        return this.favorites.has(itemId);
    }
    async getCategories() {
        return [];
    }
    async getProducts() {
        return [];
    }
    async getBanks() {
        return [];
    }
    async getSubBanks() {
        return [];
    }
    async refreshIndex() {
        return;
    }
    async importDirectory() {
        return;
    }
}
describe('browser performance helpers', () => {
    beforeEach(() => {
        setActivePinia(createPinia());
        if (typeof localStorage !== 'undefined') {
            localStorage.clear();
        }
        vi.useFakeTimers();
    });
    afterEach(() => {
        vi.runOnlyPendingTimers();
        vi.useRealTimers();
    });
    it('debounces search calls on query changes', async () => {
        const repo = new MemoryLibraryRepo([{ id: '1', name: 'Kick', tags: [] }]);
        __setLibraryRepositoryForTests(repo);
        const store = useBrowserStore();
        await store.setQuery('Kick');
        expect(store.library.results.length).toBe(0);
        vi.advanceTimersByTime(310);
        await Promise.resolve();
        expect(store.library.results.length).toBeGreaterThan(0);
    });
    it('limits display items to 100 when results are large', async () => {
        const items = Array.from({ length: 150 }, (_, index) => ({
            id: String(index),
            name: `Item ${index}`,
            tags: []
        }));
        __setLibraryRepositoryForTests(new MemoryLibraryRepo(items));
        const store = useBrowserStore();
        await store.search();
        const models = store.toDisplayModels();
        expect(models.rightModel.items?.length).toBe(100);
    });
});
//# sourceMappingURL=browserPerformance.spec.js.map


=========================================
File: dist-test/tests/unitTests/browserPerformance.spec.js.map
=========================================

{"version":3,"file":"browserPerformance.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/browserPerformance.spec.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,EAAE,EAAE,MAAM,QAAQ,CAAA;AACxE,OAAO,EAAE,cAAc,EAAE,WAAW,EAAE,MAAM,OAAO,CAAA;AACnD,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;AACtD,OAAO,EACL,8BAA8B,EAG/B,MAAM,kCAAkC,CAAA;AAEzC,MAAM,iBAAiB;IACF;IAAnB,YAAmB,QAAuB,EAAE;QAAzB,UAAK,GAAL,KAAK,CAAoB;IAAG,CAAC;IAChD,SAAS,GAAG,IAAI,GAAG,EAAU,CAAA;IAE7B,KAAK,CAAC,MAAM,CAAC,KAAa,EAAE,QAAkB;QAC5C,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,CAAA;QACvC,IAAI,CAAC,IAAI;YAAE,OAAO,IAAI,CAAC,KAAK,CAAA;QAC5B,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAA;IAC5E,CAAC;IACD,KAAK,CAAC,OAAO,CAAC,EAAU;QACtB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAA;IAClD,CAAC;IACD,KAAK,CAAC,OAAO,CAAC,MAAc;QAC1B,OAAO,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,IAAI,EAAE,CAAA;IACjD,CAAC;IACD,KAAK,CAAC,MAAM,CAAC,MAAc,EAAE,GAAW;QACtC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CACnC,IAAI,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CACnE,CAAA;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA;IAC7B,CAAC;IACD,KAAK,CAAC,SAAS,CAAC,MAAc,EAAE,GAAW;QACzC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CACnC,IAAI,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAC1F,CAAA;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA;IAC7B,CAAC;IACD,KAAK,CAAC,UAAU,CAAC,IAAY,EAAE,IAA2B;QACxD,MAAM,IAAI,GAAgB;YACxB,EAAE,EAAE,IAAI,EAAE,EAAE,IAAI,IAAI;YACpB,IAAI,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI;YACxB,IAAI,EAAE,IAAI,EAAE,IAAI,IAAI,EAAE;YACtB,IAAI;YACJ,GAAG,IAAI;SACR,CAAA;QACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QACrB,OAAO,IAAI,CAAA;IACb,CAAC;IACD,KAAK,CAAC,cAAc,CAAC,MAAc;QACjC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;IAC5B,CAAC;IACD,KAAK,CAAC,mBAAmB,CAAC,MAAc;QACtC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;IAC/B,CAAC;IACD,KAAK,CAAC,YAAY;QAChB,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAA;IACjE,CAAC;IACD,KAAK,CAAC,UAAU,CAAC,MAAc;QAC7B,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;IACnC,CAAC;IACD,KAAK,CAAC,aAAa;QACjB,OAAO,EAAE,CAAA;IACX,CAAC;IACD,KAAK,CAAC,WAAW;QACf,OAAO,EAAE,CAAA;IACX,CAAC;IACD,KAAK,CAAC,QAAQ;QACZ,OAAO,EAAE,CAAA;IACX,CAAC;IACD,KAAK,CAAC,WAAW;QACf,OAAO,EAAE,CAAA;IACX,CAAC;IACD,KAAK,CAAC,YAAY;QAChB,OAAM;IACR,CAAC;IACD,KAAK,CAAC,eAAe;QACnB,OAAM;IACR,CAAC;CACF;AAED,QAAQ,CAAC,6BAA6B,EAAE,GAAG,EAAE;IAC3C,UAAU,CAAC,GAAG,EAAE;QACd,cAAc,CAAC,WAAW,EAAE,CAAC,CAAA;QAC7B,IAAI,OAAO,YAAY,KAAK,WAAW,EAAE,CAAC;YACxC,YAAY,CAAC,KAAK,EAAE,CAAA;QACtB,CAAC;QACD,EAAE,CAAC,aAAa,EAAE,CAAA;IACpB,CAAC,CAAC,CAAA;IAEF,SAAS,CAAC,GAAG,EAAE;QACb,EAAE,CAAC,oBAAoB,EAAE,CAAA;QACzB,EAAE,CAAC,aAAa,EAAE,CAAA;IACpB,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,yCAAyC,EAAE,KAAK,IAAI,EAAE;QACvD,MAAM,IAAI,GAAG,IAAI,iBAAiB,CAAC,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC,CAAA;QACzE,8BAA8B,CAAC,IAAI,CAAC,CAAA;QACpC,MAAM,KAAK,GAAG,eAAe,EAAE,CAAA;QAC/B,MAAM,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAA;QAC5B,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;QAC5C,EAAE,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAA;QAC3B,MAAM,OAAO,CAAC,OAAO,EAAE,CAAA;QACvB,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA;IACzD,CAAC,CAAC,CAAA;IAEF,EAAE,CAAC,oDAAoD,EAAE,KAAK,IAAI,EAAE;QAClE,MAAM,KAAK,GAAkB,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;YACtE,EAAE,EAAE,MAAM,CAAC,KAAK,CAAC;YACjB,IAAI,EAAE,QAAQ,KAAK,EAAE;YACrB,IAAI,EAAE,EAAE;SACT,CAAC,CAAC,CAAA;QACH,8BAA8B,CAAC,IAAI,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAA;QAC5D,MAAM,KAAK,GAAG,eAAe,EAAE,CAAA;QAC/B,MAAM,KAAK,CAAC,MAAM,EAAE,CAAA;QACpB,MAAM,MAAM,GAAG,KAAK,CAAC,eAAe,EAAE,CAAA;QACtC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;IACnD,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA"}


=========================================
File: dist-test/tests/unitTests/browserSort.spec.js
=========================================

import { describe, it, expect, beforeEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { __setLibraryRepositoryForTests } from '../../services/libraryRepository';
import { __setFileSystemRepositoryForTests } from '../../services/fileSystemRepository';
import { useBrowserStore } from '../../stores/browser';
class MemoryLibraryRepo {
    items;
    constructor(items = []) {
        this.items = items;
    }
    favorites = new Set();
    async search(query, _filters) {
        const text = query.trim().toLowerCase();
        if (!text)
            return this.items;
        return this.items.filter((item) => item.name.toLowerCase().includes(text));
    }
    async getItem(id) {
        return this.items.find((item) => item.id === id);
    }
    async getTags(itemId) {
        return (await this.getItem(itemId))?.tags ?? [];
    }
    async addTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item);
        return this.getTags(itemId);
    }
    async removeTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item);
        return this.getTags(itemId);
    }
    async importFile(path, meta) {
        const item = {
            id: meta?.id ?? path,
            name: meta?.name ?? path,
            tags: meta?.tags ?? [],
            path,
            ...meta
        };
        this.items.push(item);
        return item;
    }
    async addToFavorites(itemId) {
        this.favorites.add(itemId);
    }
    async removeFromFavorites(itemId) {
        this.favorites.delete(itemId);
    }
    async getFavorites() {
        return this.items.filter((item) => this.favorites.has(item.id));
    }
    async isFavorite(itemId) {
        return this.favorites.has(itemId);
    }
    async refreshIndex() {
        return;
    }
    async importDirectory() {
        return;
    }
}
class MemoryFileRepo {
    listing;
    constructor(listing) {
        this.listing = listing;
    }
    async listDir(_path) {
        return this.listing;
    }
    async stat(_path) {
        return { isDir: false };
    }
    async readFileMeta(path) {
        const name = path.split('/').pop() ?? path;
        const ext = name.includes('.') ? name.split('.').pop() : undefined;
        const meta = { name };
        if (ext)
            meta.extension = ext;
        return meta;
    }
}
const createStoreWithSortMode = async (mode) => {
    const store = useBrowserStore();
    await store.search();
    store.setSortMode(mode);
    return store;
};
describe('browser sorting', () => {
    beforeEach(() => {
        setActivePinia(createPinia());
        if (typeof localStorage !== 'undefined') {
            localStorage.clear();
        }
        const repo = new MemoryLibraryRepo([
            { id: '1', name: 'Alpha', tags: [], importedAt: 2000 },
            { id: '2', name: 'beta', tags: [], importedAt: 1000 },
            { id: '3', name: 'Gamma', tags: [], importedAt: 3000 }
        ]);
        __setLibraryRepositoryForTests(repo);
        __setFileSystemRepositoryForTests(new MemoryFileRepo({
            dirs: [
                { name: 'b-dir', path: '/b-dir' },
                { name: 'a-dir', path: '/a-dir' }
            ],
            files: [
                { name: 'z.wav', path: '/z.wav' },
                { name: 'a.wav', path: '/a.wav' }
            ]
        }));
    });
    it('sorts library results by name asc/desc', async () => {
        const store = await createStoreWithSortMode('name-asc');
        expect(store.library.results.map((item) => item.title)).toEqual(['Alpha', 'beta', 'Gamma']);
        store.setSortMode('name-desc');
        expect(store.library.results.map((item) => item.title)).toEqual(['Gamma', 'beta', 'Alpha']);
    });
    it('sorts library results by date asc/desc', async () => {
        const store = await createStoreWithSortMode('date-asc');
        expect(store.library.results.map((item) => item.id)).toEqual(['2', '1', '3']);
        store.setSortMode('date-desc');
        expect(store.library.results.map((item) => item.id)).toEqual(['3', '1', '2']);
    });
    it('restores relevance order when switching back', async () => {
        const store = await createStoreWithSortMode('name-desc');
        store.setSortMode('relevance');
        expect(store.library.results.map((item) => item.id)).toEqual(['1', '2', '3']);
    });
    it('sorts files when mode changes', async () => {
        const store = useBrowserStore();
        await store.setMode('FILES');
        store.setSortMode('name-asc');
        expect(store.files.entries.dirs.map((dir) => dir.name)).toEqual(['a-dir', 'b-dir']);
        expect(store.files.entries.files.map((file) => file.name)).toEqual(['a.wav', 'z.wav']);
    });
    it('persists sort mode in localStorage', async () => {
        const store = useBrowserStore();
        store.setSortMode('name-desc');
        setActivePinia(createPinia());
        const nextStore = useBrowserStore();
        expect(nextStore.sortMode).toBe('name-desc');
    });
});
//# sourceMappingURL=browserSort.spec.js.map


=========================================
File: dist-test/tests/unitTests/browserSort.spec.js.map
=========================================

{"version":3,"file":"browserSort.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/browserSort.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/browserStore.spec.js
=========================================

import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useBrowserStore } from '../../stores/browser';
import { __setLibraryRepositoryForTests } from '../../services/libraryRepository';
import { __setFileSystemRepositoryForTests } from '../../services/fileSystemRepository';
class MemoryLibraryRepo {
    items;
    constructor(items = []) {
        this.items = items;
    }
    favorites = new Set();
    async search(query, filters) {
        const term = query.trim().toLowerCase();
        const matchesQuery = (item) => {
            if (!term)
                return true;
            return item.name.toLowerCase().includes(term);
        };
        const matchesFilters = (item) => {
            if (!filters)
                return true;
            if (filters.fileType && filters.fileType !== 'all' && item.fileType !== filters.fileType)
                return false;
            if (filters.contentType && filters.contentType !== 'all' && item.contentType !== filters.contentType)
                return false;
            if (filters.category && item.category !== filters.category)
                return false;
            if (filters.product && item.product !== filters.product)
                return false;
            if (filters.bank && item.bank !== filters.bank)
                return false;
            if (filters.tags && filters.tags.length > 0) {
                const normalizedTags = filters.tags.map((tag) => tag.trim().toLowerCase()).filter((tag) => tag.length > 0);
                const itemTags = (item.tags ?? []).map((tag) => tag.trim().toLowerCase());
                if (!normalizedTags.every((tag) => itemTags.includes(tag)))
                    return false;
            }
            if (filters.favorites && item.favorites !== true)
                return false;
            return true;
        };
        return this.items.filter((item) => matchesQuery(item) && matchesFilters(item));
    }
    async getItem(id) {
        return this.items.find((item) => item.id === id);
    }
    async getTags(itemId) {
        return (await this.getItem(itemId))?.tags ?? [];
    }
    async addTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item);
        return this.getTags(itemId);
    }
    async removeTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item);
        return this.getTags(itemId);
    }
    importCalls = [];
    async importFile(path, meta) {
        this.importCalls.push(path);
        const item = {
            id: meta?.id ?? path,
            name: meta?.name ?? path,
            tags: meta?.tags ?? [],
            path
        };
        this.items.push(item);
        return item;
    }
    async refreshIndex() {
        // no-op for in-memory
    }
    async addToFavorites(itemId) {
        this.favorites.add(itemId);
    }
    async removeFromFavorites(itemId) {
        this.favorites.delete(itemId);
    }
    async getFavorites() {
        return this.items.filter((item) => this.favorites.has(item.id));
    }
    async isFavorite(itemId) {
        return this.favorites.has(itemId);
    }
    async importDirectory() {
        return;
    }
}
class MemoryFileRepo {
    listing;
    constructor(listing) {
        this.listing = listing;
    }
    async listDir(_path) {
        return this.listing;
    }
    async stat(_path) {
        return { isDir: false };
    }
    async readFileMeta(path) {
        const name = path.split('/').pop() ?? path;
        const ext = name.includes('.') ? name.split('.').pop() : undefined;
        const meta = { name };
        if (ext) {
            meta.extension = ext;
        }
        return meta;
    }
}
describe('browser store', () => {
    let libraryRepo;
    let fileRepo;
    beforeEach(() => {
        setActivePinia(createPinia());
        vi.useFakeTimers();
        libraryRepo = new MemoryLibraryRepo([
            {
                id: '1',
                name: 'Kick One',
                tags: ['drum'],
                fileType: 'sample',
                contentType: 'factory',
                category: 'drums',
                product: 'Kit A',
                bank: 'A',
                favorites: false
            },
            {
                id: '2',
                name: 'Snare Tight',
                tags: ['snare', 'tight'],
                fileType: 'sample',
                contentType: 'factory',
                category: 'drums',
                product: 'Kit A',
                bank: 'B',
                favorites: true
            },
            {
                id: '3',
                name: 'Pad Warm',
                tags: ['pad'],
                fileType: 'preset',
                contentType: 'user',
                category: 'synth',
                product: 'Pads',
                bank: 'Main',
                favorites: false
            }
        ]);
        fileRepo = new MemoryFileRepo({
            dirs: [{ name: 'kits', path: '/kits' }],
            files: [{ name: 'new.wav', path: '/kits/new.wav' }]
        });
        __setLibraryRepositoryForTests(libraryRepo);
        __setFileSystemRepositoryForTests(fileRepo);
    });
    afterEach(() => {
        vi.runOnlyPendingTimers();
        vi.useRealTimers();
    });
    it('keeps library and files state separated on mode switch', async () => {
        const store = useBrowserStore();
        await store.setQuery('Kick');
        vi.advanceTimersByTime(350);
        await Promise.resolve();
        expect(store.library.results).toHaveLength(1);
        await store.setMode('FILES');
        expect(store.files.entries.files).toHaveLength(1);
        expect(store.library.query).toBe('Kick');
        await store.setMode('LIBRARY');
        expect(store.library.results).toHaveLength(1);
    });
    it('updates search results when query changes', async () => {
        const store = useBrowserStore();
        await store.setQuery('snare');
        vi.advanceTimersByTime(350);
        await Promise.resolve();
        expect(store.library.results[0]?.title).toContain('Snare');
    });
    it('persists tag changes through repository', async () => {
        const store = useBrowserStore();
        await store.search();
        await store.selectResult('1');
        await store.addTag('punch');
        expect(await libraryRepo.getTags('1')).toContain('punch');
        await store.removeTag('punch');
        expect(await libraryRepo.getTags('1')).not.toContain('punch');
    });
    it('lists directories and files for the current path', async () => {
        const store = useBrowserStore();
        await store.setMode('FILES');
        expect(store.files.entries.dirs[0]?.name).toBe('kits');
        expect(store.files.entries.files[0]?.name).toBe('new.wav');
    });
    it('imports selected file into library and refreshes search results', async () => {
        const store = useBrowserStore();
        await store.setMode('FILES');
        store.selectPath('/kits/new.wav');
        await store.importSelected();
        await store.setMode('LIBRARY');
        await store.search();
        expect(libraryRepo.importCalls).toContain('/kits/new.wav');
        expect(store.library.results.find((item) => item.title.includes('new.wav'))).toBeDefined();
    });
    it('applies filters to search results', async () => {
        const store = useBrowserStore();
        await store.search();
        store.setFilter('fileType', 'preset');
        await store.applyFilters();
        expect(store.library.results).toHaveLength(1);
        expect(store.library.results[0]?.title).toBe('Pad Warm');
    });
    it('combines multiple filters when searching', async () => {
        const store = useBrowserStore();
        await store.search();
        store.setFilter('fileType', 'sample');
        store.setFilter('favorites', true);
        store.setFilter('category', 'drums');
        await store.applyFilters();
        expect(store.library.results).toHaveLength(1);
        expect(store.library.results[0]?.title).toBe('Snare Tight');
    });
    it('builds encoder fields in the expected order', () => {
        const store = useBrowserStore();
        const fields = store.getEncoderFields();
        expect(fields.map((field) => field.id)).toEqual([
            'fileType',
            'contentType',
            'category',
            'product',
            'bank',
            'tags',
            'favorites'
        ]);
        expect(fields[0]?.options).toContain('sample');
        expect(fields[6]?.value).toBe('off');
    });
});
//# sourceMappingURL=browserStore.spec.js.map


=========================================
File: dist-test/tests/unitTests/browserStore.spec.js.map
=========================================

{"version":3,"file":"browserStore.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/browserStore.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/controlBrowserIntegration.spec.js
=========================================

import { describe, it, beforeEach, expect } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useControlStore } from '../../stores/control';
import { useBrowserStore } from '../../stores/browser';
import { __setLibraryRepositoryForTests } from '../../services/libraryRepository';
import { __setFileSystemRepositoryForTests } from '../../services/fileSystemRepository';
class ImportTrackingRepo {
    imports = [];
    items = [];
    favorites = new Set();
    async search(_query, _filters) {
        return this.items;
    }
    async getItem() {
        return undefined;
    }
    async getTags() {
        return [];
    }
    async addTag() {
        return [];
    }
    async removeTag() {
        return [];
    }
    async importFile(path) {
        this.imports.push(path);
        const item = { id: path, name: path, tags: [] };
        this.items.push(item);
        return item;
    }
    async refreshIndex() {
        return;
    }
    async addToFavorites(itemId) {
        this.favorites.add(itemId);
    }
    async removeFromFavorites(itemId) {
        this.favorites.delete(itemId);
    }
    async getFavorites() {
        return this.items.filter((item) => this.favorites.has(item.id));
    }
    async isFavorite(itemId) {
        return this.favorites.has(itemId);
    }
    async getCategories() {
        return [];
    }
    async getProducts() {
        return [];
    }
    async getBanks() {
        return [];
    }
    async getSubBanks() {
        return [];
    }
    async importDirectory() {
        return;
    }
}
describe('control to browser wiring', () => {
    beforeEach(() => {
        setActivePinia(createPinia());
        __setLibraryRepositoryForTests(new ImportTrackingRepo());
    });
    it('initializes 4D encoder when entering browser modes', () => {
        const control = useControlStore();
        control.setMode('BROWSER');
        expect(control.encoder4D).not.toBeNull();
        expect(control.encoder4D?.fields.value[0]?.id).toBe('fileType');
    });
    it('navigates encoder fields horizontally', () => {
        const control = useControlStore();
        control.setMode('BROWSER');
        control.tiltEncoder4D('right');
        expect(control.encoder4D?.activeFieldIndex.value).toBe(1);
    });
    it('syncs filter changes when turning encoder in value mode', async () => {
        const browser = useBrowserStore();
        const control = useControlStore();
        control.setMode('BROWSER');
        control.encoder4D?.setMode('value-adjust');
        control.turnEncoder4D(1);
        expect(browser.filters.fileType).toBe('sample');
    });
    it('invokes browser import when triggering load action', async () => {
        const browser = useBrowserStore();
        const control = useControlStore();
        const repo = new ImportTrackingRepo();
        __setLibraryRepositoryForTests(repo);
        await browser.setMode('FILES');
        browser.selectPath('/imports/sample.wav');
        control.setMode('FILE');
        control.applyAction('BROWSER_LOAD');
        expect(repo.imports).toContain('/imports/sample.wav');
    });
    it('loads file via encoder press in list navigate mode', async () => {
        const browser = useBrowserStore();
        const control = useControlStore();
        const repo = new ImportTrackingRepo();
        __setLibraryRepositoryForTests(repo);
        __setFileSystemRepositoryForTests({
            async listDir() {
                return { dirs: [], files: [{ name: 'clip.wav', path: '/clip.wav' }] };
            },
            async stat() {
                return { isDir: false };
            },
            async readFileMeta(path) {
                const name = path.split('/').pop() ?? path;
                const ext = name.includes('.') ? name.split('.').pop() : undefined;
                const meta = { name };
                if (ext)
                    meta.extension = ext;
                return meta;
            }
        });
        await browser.setMode('FILES');
        control.setMode('FILE');
        control.encoder4D?.setMode('list-navigate');
        control.syncListSelection();
        await control.pressEncoder4D();
        expect(repo.imports.length).toBeGreaterThan(0);
        expect(repo.imports[0]).toBe(browser.files.selectedPath);
    });
    it('runs a browser workflow: filter, search, load', async () => {
        const control = useControlStore();
        const browser = useBrowserStore();
        const repo = new ImportTrackingRepo();
        repo.items = [{ id: '1', name: 'Kick', tags: [], fileType: 'sample' }];
        __setLibraryRepositoryForTests(repo);
        __setFileSystemRepositoryForTests({
            async listDir() {
                return { dirs: [], files: [{ name: 'kick.wav', path: '/kick.wav' }] };
            },
            async stat() {
                return { isDir: false };
            },
            async readFileMeta(path) {
                const name = path.split('/').pop() ?? path;
                const ext = name.includes('.') ? name.split('.').pop() : undefined;
                const meta = { name };
                if (ext)
                    meta.extension = ext;
                return meta;
            }
        });
        control.setMode('BROWSER');
        browser.setFilter('fileType', 'sample');
        await browser.search();
        await browser.setMode('FILES');
        browser.selectPath('/kick.wav');
        control.setMode('FILE');
        control.applyAction('BROWSER_LOAD');
        expect(repo.imports).toContain('/kick.wav');
    });
    it('runs recent â†’ quick browse restore â†’ load workflow', async () => {
        const control = useControlStore();
        const browser = useBrowserStore();
        const repo = new ImportTrackingRepo();
        __setLibraryRepositoryForTests(repo);
        __setFileSystemRepositoryForTests({
            async listDir() {
                return { dirs: [], files: [{ name: 'hat.wav', path: '/hat.wav' }] };
            },
            async stat() {
                return { isDir: false };
            },
            async readFileMeta(path) {
                const name = path.split('/').pop() ?? path;
                const ext = name.includes('.') ? name.split('.').pop() : undefined;
                const meta = { name };
                if (ext)
                    meta.extension = ext;
                return meta;
            }
        });
        await browser.setMode('FILES');
        browser.selectPath('/hat.wav');
        await browser.importSelected({ contextId: 'pad-0', contextType: 'sample' });
        browser.openQuickBrowse('pad-0');
        await new Promise((resolve) => setTimeout(resolve, 0));
        browser.selectPath('/hat.wav');
        control.setMode('FILE');
        control.applyAction('BROWSER_LOAD');
        expect(repo.imports).toContain('/hat.wav');
    });
    it('runs favorites â†’ filter â†’ load workflow', async () => {
        const control = useControlStore();
        const browser = useBrowserStore();
        const repo = new ImportTrackingRepo();
        repo.items = [
            { id: '1', name: 'Kick', tags: [], fileType: 'sample' },
            { id: '2', name: 'Snare', tags: [], fileType: 'sample' }
        ];
        __setLibraryRepositoryForTests(repo);
        __setFileSystemRepositoryForTests({
            async listDir() {
                return { dirs: [], files: [{ name: 'snare.wav', path: '/snare.wav' }] };
            },
            async stat() {
                return { isDir: false };
            },
            async readFileMeta(path) {
                const name = path.split('/').pop() ?? path;
                const ext = name.includes('.') ? name.split('.').pop() : undefined;
                const meta = { name };
                if (ext)
                    meta.extension = ext;
                return meta;
            }
        });
        control.setMode('BROWSER');
        await browser.search();
        await browser.toggleFavorite('2');
        browser.setFilter('favorites', true);
        await browser.applyFilters();
        expect(browser.library.results.map((item) => item.id)).toEqual(['2']);
        await browser.setMode('FILES');
        browser.selectPath('/snare.wav');
        control.setMode('FILE');
        control.applyAction('BROWSER_LOAD');
        expect(repo.imports).toContain('/snare.wav');
    });
    it('runs preview â†’ stop â†’ load workflow', async () => {
        const control = useControlStore();
        const browser = useBrowserStore();
        const repo = new ImportTrackingRepo();
        __setLibraryRepositoryForTests(repo);
        __setFileSystemRepositoryForTests({
            async listDir() {
                return { dirs: [], files: [{ name: 'tone.wav', path: '/tone.wav' }] };
            },
            async stat() {
                return { isDir: false };
            },
            async readFileMeta(path) {
                const name = path.split('/').pop() ?? path;
                const ext = name.includes('.') ? name.split('.').pop() : undefined;
                const meta = { name };
                if (ext)
                    meta.extension = ext;
                return meta;
            },
            async readFileBlob() {
                return new Blob(['tone'], { type: 'audio/wav' });
            }
        });
        await browser.setMode('FILES');
        browser.selectPath('/tone.wav');
        control.setMode('BROWSER');
        control.applyAction('BROWSER_PREHEAR');
        control.applyAction('BROWSER_STOP');
        control.setMode('FILE');
        control.applyAction('BROWSER_LOAD');
        expect(repo.imports).toContain('/tone.wav');
    });
    it('handles empty results without selection', async () => {
        const browser = useBrowserStore();
        await browser.search();
        expect(browser.library.results).toHaveLength(0);
        expect(browser.library.selectedId).toBeNull();
    });
    it('surfaces permission denial on file system list', async () => {
        const browser = useBrowserStore();
        __setFileSystemRepositoryForTests({
            async listDir() {
                throw new Error('Permission denied');
            },
            async stat() {
                return { isDir: false };
            },
            async readFileMeta(path) {
                return { name: path };
            }
        });
        await expect(browser.setMode('FILES')).rejects.toThrow('Permission denied');
    });
    it('surfaces import errors', async () => {
        const browser = useBrowserStore();
        const repo = new ImportTrackingRepo();
        repo.importFile = async () => {
            throw new Error('Import failed');
        };
        __setLibraryRepositoryForTests(repo);
        __setFileSystemRepositoryForTests({
            async listDir() {
                return { dirs: [], files: [{ name: 'broken.wav', path: '/broken.wav' }] };
            },
            async stat() {
                return { isDir: false };
            },
            async readFileMeta(path) {
                return { name: path };
            }
        });
        await browser.setMode('FILES');
        browser.selectPath('/broken.wav');
        await expect(browser.importSelected()).rejects.toThrow('Import failed');
    });
});
//# sourceMappingURL=controlBrowserIntegration.spec.js.map


=========================================
File: dist-test/tests/unitTests/controlBrowserIntegration.spec.js.map
=========================================

{"version":3,"file":"controlBrowserIntegration.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/controlBrowserIntegration.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/favorites.spec.js
=========================================

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { __resetLibraryRepository, __setLibraryRepositoryForTests, getLibraryRepository } from '../../services/libraryRepository';
import { useBrowserStore } from '../../stores/browser';
class MemoryLibraryRepo {
    items;
    constructor(items = []) {
        this.items = items;
    }
    favorites = new Set();
    async search(query, _filters) {
        const text = query.trim().toLowerCase();
        if (!text)
            return this.items;
        return this.items.filter((item) => item.name.toLowerCase().includes(text));
    }
    async getItem(id) {
        return this.items.find((item) => item.id === id);
    }
    async getTags(itemId) {
        return (await this.getItem(itemId))?.tags ?? [];
    }
    async addTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item);
        return this.getTags(itemId);
    }
    async removeTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item);
        return this.getTags(itemId);
    }
    async importFile(path, meta) {
        const item = {
            id: meta?.id ?? path,
            name: meta?.name ?? path,
            tags: meta?.tags ?? [],
            path,
            ...meta
        };
        this.items.push(item);
        return item;
    }
    async addToFavorites(itemId) {
        this.favorites.add(itemId);
    }
    async removeFromFavorites(itemId) {
        this.favorites.delete(itemId);
    }
    async getFavorites() {
        return this.items.filter((item) => this.favorites.has(item.id));
    }
    async isFavorite(itemId) {
        return this.favorites.has(itemId);
    }
    async refreshIndex() {
        return;
    }
    async importDirectory() {
        return;
    }
}
describe('favorites', () => {
    beforeEach(() => {
        setActivePinia(createPinia());
        __resetLibraryRepository();
        if (typeof localStorage !== 'undefined') {
            localStorage.clear();
        }
    });
    afterEach(() => {
        __resetLibraryRepository();
    });
    it('adds/removes favorites and persists them', async () => {
        const repo = getLibraryRepository();
        await repo.importFile('/kick.wav', { id: 'kick', name: 'Kick', tags: [] });
        await repo.addToFavorites('kick');
        expect(await repo.isFavorite('kick')).toBe(true);
        const favorites = await repo.getFavorites();
        expect(favorites.map((item) => item.id)).toContain('kick');
        __resetLibraryRepository();
        const reloaded = getLibraryRepository();
        expect(await reloaded.isFavorite('kick')).toBe(true);
        await reloaded.removeFromFavorites('kick');
        expect(await reloaded.isFavorite('kick')).toBe(false);
    });
    it('toggles favorites through the browser store action', async () => {
        const repo = new MemoryLibraryRepo([
            { id: '1', name: 'Kick', tags: [] },
            { id: '2', name: 'Snare', tags: [] }
        ]);
        __setLibraryRepositoryForTests(repo);
        const store = useBrowserStore();
        await store.search();
        await store.toggleFavorite('1');
        expect(await repo.isFavorite('1')).toBe(true);
        expect(store.library.results.find((item) => item.id === '1')?.favorites).toBe(true);
    });
    it('filters results to favorites and marks display subtitles', async () => {
        const repo = new MemoryLibraryRepo([
            { id: '1', name: 'Kick', tags: ['drum'] },
            { id: '2', name: 'Snare', tags: ['drum'] }
        ]);
        await repo.addToFavorites('2');
        __setLibraryRepositoryForTests(repo);
        const store = useBrowserStore();
        store.setFilter('favorites', true);
        await store.search();
        expect(store.library.results).toHaveLength(1);
        expect(store.library.results[0]?.id).toBe('2');
        const display = store.toDisplayModels();
        const subtitle = display.rightModel.items?.[0]?.subtitle ?? '';
        expect(subtitle.includes('â˜…')).toBe(true);
    });
});
//# sourceMappingURL=favorites.spec.js.map


=========================================
File: dist-test/tests/unitTests/favorites.spec.js.map
=========================================

{"version":3,"file":"favorites.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/favorites.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/fileSystemRepository.spec.js
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { getFileSystemRepository, __resetFileSystemRepository } from '../../services/fileSystemRepository';
const createFileHandle = (node) => {
    return {
        kind: 'file',
        name: node.name,
        async getFile() {
            return new File([node.content], node.name, { type: 'text/plain' });
        }
    };
};
const createDirHandle = (node) => {
    const entries = async function* () {
        for (const child of node.children) {
            if (child.kind === 'directory') {
                yield [child.name, createDirHandle(child)];
            }
            else {
                yield [child.name, createFileHandle(child)];
            }
        }
    };
    const getDirectoryHandle = async (name) => {
        const match = node.children.find((child) => child.kind === 'directory' && child.name === name);
        if (!match || match.kind !== 'directory') {
            throw new Error('Directory not found');
        }
        return createDirHandle(match);
    };
    const getFileHandle = async (name) => {
        const match = node.children.find((child) => child.kind === 'file' && child.name === name);
        if (!match || match.kind !== 'file') {
            throw new Error('File not found');
        }
        return createFileHandle(match);
    };
    return {
        kind: 'directory',
        name: node.name,
        entries,
        getDirectoryHandle,
        getFileHandle
    };
};
describe('file system repository', () => {
    const originalWindow = globalThis.window;
    const originalPicker = globalThis.window?.showDirectoryPicker;
    beforeEach(() => {
        __resetFileSystemRepository();
    });
    afterEach(() => {
        if (originalWindow) {
            if (originalPicker) {
                originalWindow.showDirectoryPicker = originalPicker;
            }
            else if ('showDirectoryPicker' in originalWindow) {
                delete originalWindow.showDirectoryPicker;
            }
            globalThis.window = originalWindow;
        }
        else {
            // @ts-expect-error: cleanup for test-only window injection
            delete globalThis.window;
        }
        __resetFileSystemRepository();
    });
    it('lists directories and files via browser file system access', async () => {
        const root = {
            name: 'root',
            kind: 'directory',
            children: [
                {
                    name: 'Samples',
                    kind: 'directory',
                    children: [{ name: 'kick.wav', kind: 'file', content: 'kick' }]
                },
                { name: 'root.wav', kind: 'file', content: 'root' }
            ]
        };
        const picker = vi.fn(async () => createDirHandle(root));
        globalThis.window = { showDirectoryPicker: picker };
        const repo = getFileSystemRepository();
        const listing = await repo.listDir('/');
        expect(picker).toHaveBeenCalledTimes(1);
        expect(listing.dirs.map((dir) => dir.name)).toContain('Samples');
        expect(listing.files.map((file) => file.name)).toContain('root.wav');
    });
    it('reads a blob from the browser file system access handle', async () => {
        const root = {
            name: 'root',
            kind: 'directory',
            children: [{ name: 'clip.txt', kind: 'file', content: 'clip' }]
        };
        const picker = vi.fn(async () => createDirHandle(root));
        globalThis.window = { showDirectoryPicker: picker };
        const repo = getFileSystemRepository();
        const blob = await repo.readFileBlob?.('/clip.txt');
        expect(blob).toBeInstanceOf(Blob);
        expect(blob?.size).toBe(4);
    });
    it('falls back to the in-memory file system when the API is unavailable', async () => {
        if (globalThis.window) {
            delete globalThis.window.showDirectoryPicker;
        }
        const repo = getFileSystemRepository();
        const listing = await repo.listDir('/');
        expect(listing.dirs.length).toBeGreaterThan(0);
        expect(listing.files.length).toBeGreaterThanOrEqual(0);
    });
});
//# sourceMappingURL=fileSystemRepository.spec.js.map


=========================================
File: dist-test/tests/unitTests/fileSystemRepository.spec.js.map
=========================================

{"version":3,"file":"fileSystemRepository.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/fileSystemRepository.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/libraryHierarchy.spec.js
=========================================

import { describe, it, expect, beforeEach } from 'vitest';
import { __resetLibraryRepository, getLibraryRepository } from '../../services/libraryRepository';
import { __setFileSystemRepositoryForTests } from '../../services/fileSystemRepository';
import { setActivePinia, createPinia } from 'pinia';
import { useBrowserStore } from '../../stores/browser';
class MemoryFileRepo {
    listing;
    constructor(listing) {
        this.listing = listing;
    }
    async listDir(_path) {
        return this.listing;
    }
    async stat(_path) {
        return { isDir: false };
    }
    async readFileMeta(path) {
        const name = path.split('/').pop() ?? path;
        const ext = name.includes('.') ? name.split('.').pop() : undefined;
        const meta = { name };
        if (ext)
            meta.extension = ext;
        return meta;
    }
}
describe('library hierarchy', () => {
    beforeEach(() => {
        __resetLibraryRepository();
        if (typeof localStorage !== 'undefined') {
            localStorage.clear();
        }
        setActivePinia(createPinia());
    });
    it('returns hierarchical values based on parent filters', async () => {
        const repo = getLibraryRepository();
        await repo.importFile('/Drums/808/Kicks/Deep/kick_01.wav', {
            name: 'kick_01',
            category: 'Drums',
            product: '808',
            bank: 'Kicks',
            subBank: 'Deep',
            vendor: 'user'
        });
        await repo.importFile('/Drums/909/Snares/Loose/snare_01.wav', {
            name: 'snare_01',
            category: 'Drums',
            product: '909',
            bank: 'Snares',
            subBank: 'Loose',
            vendor: 'user'
        });
        const categories = await repo.getCategories?.();
        const products = await repo.getProducts?.('Drums');
        const banks = await repo.getBanks?.('808');
        const subBanks = await repo.getSubBanks?.('Kicks');
        expect(categories).toEqual(['Drums']);
        expect(products).toEqual(['808', '909']);
        expect(banks).toEqual(['Kicks']);
        expect(subBanks).toEqual(['Deep']);
    });
    it('updates filter cascade options in browser store', async () => {
        const repo = getLibraryRepository();
        await repo.importFile('/Drums/808/Kicks/Deep/kick_01.wav', {
            name: 'kick_01',
            category: 'Drums',
            product: '808',
            bank: 'Kicks',
            subBank: 'Deep',
            vendor: 'user'
        });
        await repo.importFile('/Drums/909/Snares/Loose/snare_01.wav', {
            name: 'snare_01',
            category: 'Drums',
            product: '909',
            bank: 'Snares',
            subBank: 'Loose',
            vendor: 'user'
        });
        const store = useBrowserStore();
        await store.search();
        store.setFilter('category', 'Drums');
        await store.applyFilters();
        expect(store.availableProducts).toEqual(['808', '909']);
        store.setFilter('product', '808');
        await store.applyFilters();
        expect(store.availableBanks).toEqual(['Kicks']);
    });
    it('extracts metadata from paths during directory import', async () => {
        __setFileSystemRepositoryForTests(new MemoryFileRepo({
            dirs: [],
            files: [{ name: 'kick_01.wav', path: '/Drums/808/Kicks/Deep/kick_01.wav' }]
        }));
        const repo = getLibraryRepository();
        await repo.importDirectory?.('/', undefined, undefined);
        const items = await repo.search('');
        const entry = items.find((item) => item.path?.includes('kick_01.wav'));
        expect(entry?.category).toBe('Drums');
        expect(entry?.product).toBe('808');
        expect(entry?.bank).toBe('Kicks');
        expect(entry?.subBank).toBe('Deep');
    });
});
//# sourceMappingURL=libraryHierarchy.spec.js.map


=========================================
File: dist-test/tests/unitTests/libraryHierarchy.spec.js.map
=========================================

{"version":3,"file":"libraryHierarchy.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/libraryHierarchy.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/libraryImport.spec.js
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { __resetLibraryRepository, getLibraryRepository } from '../../services/libraryRepository';
import { __resetFileSystemRepository, __setFileSystemRepositoryForTests } from '../../services/fileSystemRepository';
class MockFileSystemRepository {
    listings;
    throwOn;
    constructor(listings, throwOn) {
        this.listings = listings;
        this.throwOn = throwOn;
    }
    async listDir(path) {
        if (this.throwOn?.has(path)) {
            throw new Error('Read error');
        }
        return this.listings[path] ?? { dirs: [], files: [] };
    }
    async stat(_path) {
        return { isDir: false };
    }
    async readFileMeta(path) {
        const name = path.split('/').pop() ?? path;
        const parts = name.split('.');
        const extension = parts.length > 1 ? parts.pop() : undefined;
        const meta = { name };
        if (extension)
            meta.extension = extension;
        return meta;
    }
}
describe('library import directory', () => {
    beforeEach(() => {
        __resetLibraryRepository();
        __resetFileSystemRepository();
        if (typeof localStorage !== 'undefined') {
            localStorage.clear();
        }
    });
    afterEach(() => {
        __resetLibraryRepository();
        __resetFileSystemRepository();
    });
    it('imports recursively and reports progress with metadata', async () => {
        const listings = {
            '/': {
                dirs: [{ name: 'Drums', path: '/Drums' }],
                files: [{ name: 'readme.txt', path: '/readme.txt' }]
            },
            '/Drums': {
                dirs: [{ name: 'KitA', path: '/Drums/KitA' }],
                files: [{ name: 'kick.wav', path: '/Drums/kick.wav' }]
            },
            '/Drums/KitA': {
                dirs: [{ name: 'Bank1', path: '/Drums/KitA/Bank1' }],
                files: []
            },
            '/Drums/KitA/Bank1': {
                dirs: [{ name: 'Sub', path: '/Drums/KitA/Bank1/Sub' }],
                files: [{ name: 'snare.aiff', path: '/Drums/KitA/Bank1/snare.aiff' }]
            },
            '/Drums/KitA/Bank1/Sub': {
                dirs: [],
                files: [{ name: 'loop.wav', path: '/Drums/KitA/Bank1/Sub/loop.wav' }]
            }
        };
        __setFileSystemRepositoryForTests(new MockFileSystemRepository(listings));
        const repo = getLibraryRepository();
        const progressCalls = [];
        await repo.importDirectory?.('/', { recursive: true }, (progress) => progressCalls.push(progress));
        expect(progressCalls).toHaveLength(3);
        expect(progressCalls[2]?.completed).toBe(3);
        expect(progressCalls[2]?.total).toBe(3);
        expect(progressCalls[2]?.errors).toContain('/readme.txt');
        const items = await repo.search('');
        const loopItem = items.find((item) => item.path === '/Drums/KitA/Bank1/Sub/loop.wav');
        expect(loopItem?.category).toBe('Drums');
        expect(loopItem?.product).toBe('KitA');
        expect(loopItem?.bank).toBe('Bank1');
        expect(loopItem?.subBank).toBe('Sub');
        expect(loopItem?.vendor).toBe('user');
    });
    it('records errors for unsupported formats and import failures', async () => {
        const listings = {
            '/': {
                dirs: [],
                files: [
                    { name: 'bad.wav', path: '/bad.wav' },
                    { name: 'note.txt', path: '/note.txt' }
                ]
            }
        };
        __setFileSystemRepositoryForTests(new MockFileSystemRepository(listings));
        const repo = getLibraryRepository();
        const warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => undefined);
        const originalImport = repo.importFile.bind(repo);
        repo.importFile = async (path, meta) => {
            if (path === '/bad.wav') {
                throw new Error('Import failed');
            }
            return originalImport(path, meta);
        };
        const progressCalls = [];
        await repo.importDirectory?.('/', undefined, (progress) => progressCalls.push(progress));
        expect(progressCalls).toHaveLength(1);
        expect(progressCalls[0]?.errors).toContain('/bad.wav');
        expect(progressCalls[0]?.errors).toContain('/note.txt');
        expect(warnSpy).toHaveBeenCalled();
        warnSpy.mockRestore();
    });
});
//# sourceMappingURL=libraryImport.spec.js.map


=========================================
File: dist-test/tests/unitTests/libraryImport.spec.js.map
=========================================

{"version":3,"file":"libraryImport.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/libraryImport.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/quickBrowse.spec.js
=========================================

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useQuickBrowse } from '../../composables/useQuickBrowse';
import { __setLibraryRepositoryForTests } from '../../services/libraryRepository';
import { useBrowserStore } from '../../stores/browser';
class MemoryLibraryRepo {
    items;
    constructor(items = []) {
        this.items = items;
    }
    favorites = new Set();
    async search(query, _filters) {
        const text = query.trim().toLowerCase();
        if (!text)
            return this.items;
        return this.items.filter((item) => item.name.toLowerCase().includes(text));
    }
    async getItem(id) {
        return this.items.find((item) => item.id === id);
    }
    async getTags(itemId) {
        return (await this.getItem(itemId))?.tags ?? [];
    }
    async addTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item);
        return this.getTags(itemId);
    }
    async removeTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item);
        return this.getTags(itemId);
    }
    async importFile(path, meta) {
        const item = {
            id: meta?.id ?? path,
            name: meta?.name ?? path,
            tags: meta?.tags ?? [],
            path,
            ...meta
        };
        this.items.push(item);
        return item;
    }
    async addToFavorites(itemId) {
        this.favorites.add(itemId);
    }
    async removeFromFavorites(itemId) {
        this.favorites.delete(itemId);
    }
    async getFavorites() {
        return this.items.filter((item) => this.favorites.has(item.id));
    }
    async isFavorite(itemId) {
        return this.favorites.has(itemId);
    }
    async refreshIndex() {
        return;
    }
    async importDirectory() {
        return;
    }
}
describe('useQuickBrowse', () => {
    beforeEach(() => {
        setActivePinia(createPinia());
        if (typeof localStorage !== 'undefined') {
            localStorage.clear();
        }
    });
    it('records history entries grouped by context', () => {
        const quickBrowse = useQuickBrowse();
        vi.spyOn(Date, 'now').mockReturnValueOnce(1000).mockReturnValueOnce(2000);
        quickBrowse.recordBrowse({
            mode: 'LIBRARY',
            query: 'Kick',
            filters: { fileType: 'sample' },
            selectedId: '1',
            contextType: 'sample',
            contextId: 'pad-0'
        });
        quickBrowse.recordBrowse({
            mode: 'LIBRARY',
            query: 'Snare',
            filters: { fileType: 'sample' },
            selectedId: '2',
            contextType: 'sample',
            contextId: 'pad-0'
        });
        expect(quickBrowse.history.value).toHaveLength(1);
        expect(quickBrowse.history.value[0]?.query).toBe('Snare');
    });
    it('returns the last browse entry for a context', () => {
        const quickBrowse = useQuickBrowse();
        quickBrowse.recordBrowse({
            mode: 'LIBRARY',
            query: 'Pad',
            filters: { fileType: 'preset' },
            selectedId: '3',
            contextType: 'preset',
            contextId: 'sound-1'
        });
        const entry = quickBrowse.getLastBrowse('sound-1');
        expect(entry?.query).toBe('Pad');
    });
    it('restores browse state from history', async () => {
        const repo = new MemoryLibraryRepo([{ id: '1', name: 'Kick', tags: [] }]);
        __setLibraryRepositoryForTests(repo);
        const store = useBrowserStore();
        const quickBrowse = useQuickBrowse();
        quickBrowse.restoreBrowse({
            timestamp: Date.now(),
            mode: 'LIBRARY',
            query: 'Kick',
            filters: { fileType: 'sample' },
            selectedId: '1',
            contextType: 'sample',
            contextId: 'pad-0'
        });
        await new Promise((resolve) => setTimeout(resolve, 0));
        expect(store.mode).toBe('LIBRARY');
        expect(store.library.query).toBe('Kick');
        expect(store.filters.fileType).toBe('sample');
        expect(store.library.selectedId).toBe('1');
    });
});
//# sourceMappingURL=quickBrowse.spec.js.map


=========================================
File: dist-test/tests/unitTests/quickBrowse.spec.js.map
=========================================

{"version":3,"file":"quickBrowse.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/quickBrowse.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/recentFiles.spec.js
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { useRecentFiles } from '../../composables/useRecentFiles';
describe('useRecentFiles', () => {
    beforeEach(() => {
        if (typeof localStorage !== 'undefined') {
            localStorage.clear();
        }
    });
    afterEach(() => {
        vi.restoreAllMocks();
    });
    it('deduplicates entries and moves them to the front', () => {
        const recent = useRecentFiles();
        vi.spyOn(Date, 'now').mockReturnValueOnce(1000).mockReturnValueOnce(2000);
        recent.addRecent({ id: 'a', path: '/a.wav', name: 'A', type: 'sample' });
        recent.addRecent({ id: 'a', path: '/a.wav', name: 'A', type: 'sample' });
        const entries = recent.getRecent();
        expect(entries).toHaveLength(1);
        expect(entries[0]?.timestamp).toBe(2000);
    });
    it('caps the recent list to the max limit', () => {
        const recent = useRecentFiles();
        const nowSpy = vi.spyOn(Date, 'now');
        for (let i = 0; i < 55; i += 1) {
            nowSpy.mockReturnValueOnce(1000 + i);
            recent.addRecent({ id: String(i), path: `/file-${i}.wav`, name: `File ${i}`, type: 'sample' });
        }
        const entries = recent.getRecent();
        expect(entries).toHaveLength(50);
        expect(entries[0]?.id).toBe('54');
    });
    it('sorts by timestamp descending', () => {
        const recent = useRecentFiles();
        vi.spyOn(Date, 'now').mockReturnValueOnce(1000).mockReturnValueOnce(3000).mockReturnValueOnce(2000);
        recent.addRecent({ id: 'first', path: '/first.wav', name: 'First', type: 'sample' });
        recent.addRecent({ id: 'third', path: '/third.wav', name: 'Third', type: 'sample' });
        recent.addRecent({ id: 'second', path: '/second.wav', name: 'Second', type: 'sample' });
        const entries = recent.getRecent();
        expect(entries.map((entry) => entry.id)).toEqual(['third', 'second', 'first']);
    });
    it('persists entries to localStorage', () => {
        const recent = useRecentFiles();
        vi.spyOn(Date, 'now').mockReturnValueOnce(5000);
        const entry = {
            id: 'persist',
            path: '/persist.wav',
            name: 'Persist',
            type: 'sample'
        };
        recent.addRecent(entry);
        const reloaded = useRecentFiles();
        const entries = reloaded.getRecent();
        expect(entries).toHaveLength(1);
        expect(entries[0]?.id).toBe('persist');
        expect(entries[0]?.timestamp).toBe(5000);
    });
});
//# sourceMappingURL=recentFiles.spec.js.map


=========================================
File: dist-test/tests/unitTests/recentFiles.spec.js.map
=========================================

{"version":3,"file":"recentFiles.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/recentFiles.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/samplePreview.spec.js
=========================================

import { describe, it, expect, beforeEach, vi } from 'vitest';
let injectedContext = null;
vi.mock('vue', async () => {
    const actual = await vi.importActual('vue');
    return {
        ...actual,
        inject: () => injectedContext
    };
});
import { useSamplePreview } from '../../composables/useSamplePreview.client';
class MockAudioBufferSourceNode {
    buffer = null;
    onended = null;
    connect() {
        return;
    }
    disconnect() {
        return;
    }
    start() {
        return;
    }
    stop() {
        this.onended?.();
    }
}
class MockAudioContext {
    currentTime = 0;
    state = 'running';
    createBufferSource() {
        return new MockAudioBufferSourceNode();
    }
    async decodeAudioData() {
        return { duration: 4 };
    }
    async resume() {
        this.state = 'running';
    }
    destination = {};
}
describe('useSamplePreview', () => {
    let rafCallback = null;
    beforeEach(() => {
        injectedContext = new MockAudioContext();
        rafCallback = null;
        globalThis.requestAnimationFrame = (cb) => {
            rafCallback = cb;
            return 1;
        };
        globalThis.cancelAnimationFrame = () => {
            rafCallback = null;
        };
    });
    it('loads and plays a blob', async () => {
        const preview = useSamplePreview();
        const blob = new Blob(['test'], { type: 'audio/wav' });
        await preview.loadAndPlay('/audio/test.wav', blob);
        expect(preview.state.isPlaying).toBe(true);
        expect(preview.state.currentFile).toBe('/audio/test.wav');
        expect(preview.state.duration).toBe(4);
    });
    it('stops playback', async () => {
        const preview = useSamplePreview();
        const blob = new Blob(['test'], { type: 'audio/wav' });
        await preview.loadAndPlay('/audio/test.wav', blob);
        preview.stop();
        expect(preview.state.isPlaying).toBe(false);
        expect(preview.state.progress).toBe(0);
    });
    it('tracks progress while playing', async () => {
        const preview = useSamplePreview();
        const blob = new Blob(['test'], { type: 'audio/wav' });
        await preview.loadAndPlay('/audio/test.wav', blob);
        const ctx = injectedContext;
        ctx.currentTime = 2;
        rafCallback?.(0);
        expect(preview.state.progress).toBeGreaterThan(0);
    });
});
//# sourceMappingURL=samplePreview.spec.js.map


=========================================
File: dist-test/tests/unitTests/samplePreview.spec.js.map
=========================================

{"version":3,"file":"samplePreview.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/samplePreview.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/tagManagement.spec.js
=========================================

import { describe, it, expect, beforeEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useBrowserStore } from '../../stores/browser';
import { useControlStore } from '../../stores/control';
import { __setLibraryRepositoryForTests } from '../../services/libraryRepository';
class MemoryLibraryRepo {
    items;
    constructor(items = []) {
        this.items = items;
    }
    favorites = new Set();
    async search(query, _filters) {
        const text = query.trim().toLowerCase();
        if (!text)
            return this.items;
        return this.items.filter((item) => item.name.toLowerCase().includes(text));
    }
    async getItem(id) {
        return this.items.find((item) => item.id === id);
    }
    async getTags(itemId) {
        return (await this.getItem(itemId))?.tags ?? [];
    }
    async addTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item);
        return this.getTags(itemId);
    }
    async removeTag(itemId, tag) {
        this.items = this.items.map((item) => item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item);
        return this.getTags(itemId);
    }
    async importFile(path, meta) {
        const item = {
            id: meta?.id ?? path,
            name: meta?.name ?? path,
            tags: meta?.tags ?? [],
            path,
            ...meta
        };
        this.items.push(item);
        return item;
    }
    async addToFavorites(itemId) {
        this.favorites.add(itemId);
    }
    async removeFromFavorites(itemId) {
        this.favorites.delete(itemId);
    }
    async getFavorites() {
        return this.items.filter((item) => this.favorites.has(item.id));
    }
    async isFavorite(itemId) {
        return this.favorites.has(itemId);
    }
    async refreshIndex() {
        return;
    }
    async importDirectory() {
        return;
    }
}
describe('tag management', () => {
    beforeEach(() => {
        setActivePinia(createPinia());
        const repo = new MemoryLibraryRepo([
            { id: '1', name: 'Kick', tags: ['drum', 'kick'] },
            { id: '2', name: 'Snare', tags: ['drum'] }
        ]);
        __setLibraryRepositoryForTests(repo);
    });
    it('opens the tag dialog and loads available tags', async () => {
        const store = useBrowserStore();
        await store.search();
        await store.openTagDialog('1');
        expect(store.tagDialogOpen).toBe(true);
        expect(store.availableTags).toContain('drum');
        expect(store.availableTags).toContain('kick');
    });
    it('adds and removes tags for the selected item', async () => {
        const store = useBrowserStore();
        await store.search();
        await store.openTagDialog('1');
        await store.addTagToSelected('new-tag');
        expect(store.library.results.find((item) => item.id === '1')?.tags).toContain('new-tag');
        await store.removeTagFromSelected('drum');
        expect(store.library.results.find((item) => item.id === '1')?.tags).not.toContain('drum');
        expect(store.availableTags).toContain('new-tag');
    });
    it('uses the encoder to navigate and toggle tags', async () => {
        const browser = useBrowserStore();
        const control = useControlStore();
        await browser.search();
        await browser.openTagDialog('1');
        control.setMode('BROWSER');
        control.syncBrowserDisplay();
        control.turnEncoder4D(1);
        expect(control.encoder4D?.activeListIndex.value).toBe(1);
        const initialTags = browser.library.results.find((item) => item.id === '1')?.tags ?? [];
        await control.pressEncoder4D();
        const updatedTags = browser.library.results.find((item) => item.id === '1')?.tags ?? [];
        expect(updatedTags.length === initialTags.length || updatedTags.length === initialTags.length + 1).toBe(true);
        control.tiltEncoder4D('right');
        expect(browser.tagDialogOpen).toBe(false);
    });
});
//# sourceMappingURL=tagManagement.spec.js.map


=========================================
File: dist-test/tests/unitTests/tagManagement.spec.js.map
=========================================

{"version":3,"file":"tagManagement.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/tagManagement.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/transportEngine.spec.js
=========================================

import { describe, it, expect, beforeEach } from 'vitest';
import { createTransportEngine } from '@/domain/transport/transportEngine';
const createTestClock = (initialTime = 0) => {
    let now = initialTime;
    const clock = {
        ctx: {},
        isOffline: false,
        audioTime: () => now,
        now: () => now
    };
    return {
        clock,
        setTime: (next) => {
            now = next;
        }
    };
};
const createStubScheduler = () => {
    const calls = [];
    let start = 0;
    let stop = 0;
    let clear = 0;
    const scheduler = {
        start() {
            start += 1;
        },
        stop() {
            stop += 1;
        },
        schedule(atTimeSec, fn) {
            calls.push({ at: atTimeSec, fn });
        },
        clear() {
            clear += 1;
            calls.length = 0;
        }
    };
    return {
        scheduler,
        calls,
        counts: () => ({ start, stop, clear })
    };
};
describe('transportEngine', () => {
    const baseConfig = {
        bpm: 120,
        gridSpec: { bars: 1, division: 4 }
    };
    let states;
    beforeEach(() => {
        states = [];
    });
    it('starts playback, emits state and schedules the first boundary', () => {
        const { clock, setTime } = createTestClock(0);
        const schedulerStub = createStubScheduler();
        const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig);
        const unsubscribe = engine.subscribe((state) => states.push(state));
        expect(states).to.deep.equal([{ isPlaying: false, currentStep: 0 }]);
        engine.start();
        setTime(0.1);
        const lastState = states[states.length - 1];
        expect(lastState).to.deep.equal({ isPlaying: true, currentStep: 0 });
        const counts = schedulerStub.counts();
        expect(counts.start).to.equal(1);
        expect(counts.clear).to.equal(1);
        expect(schedulerStub.calls).to.have.lengthOf(1);
        expect(schedulerStub.calls[0].at).to.be.closeTo(0.5, 0.0001);
        unsubscribe();
    });
    it('advances steps on tick and schedules subsequent boundaries', () => {
        const { clock, setTime } = createTestClock(0);
        const schedulerStub = createStubScheduler();
        const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig);
        engine.subscribe((state) => states.push(state));
        engine.start();
        setTime(0.51);
        engine.tick();
        const lastState = states[states.length - 1];
        expect(lastState).to.deep.equal({ isPlaying: true, currentStep: 1 });
        expect(schedulerStub.calls).to.have.lengthOf(2);
        expect(schedulerStub.calls[1].at).to.be.closeTo(1, 0.0001);
    });
    it('stops playback, clears scheduler, and ignores further ticks', () => {
        const { clock } = createTestClock(0);
        const schedulerStub = createStubScheduler();
        const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig);
        engine.subscribe((state) => states.push(state));
        engine.start();
        schedulerStub.calls.length = 0;
        engine.stop();
        const counts = schedulerStub.counts();
        expect(counts.stop).to.equal(1);
        expect(counts.clear).to.equal(2);
        const lastState = states[states.length - 1];
        expect(lastState).to.deep.equal({ isPlaying: false, currentStep: 3 });
        engine.tick();
        expect(schedulerStub.calls).to.have.lengthOf(0);
    });
    it('keeps phase stable when the config changes during playback', () => {
        const { clock, setTime } = createTestClock(0);
        const schedulerStub = createStubScheduler();
        const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig);
        engine.subscribe((state) => states.push(state));
        engine.start();
        setTime(0.51);
        engine.tick();
        expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 1 });
        engine.setConfig({
            bpm: 120,
            gridSpec: { bars: 1, division: 8 }
        });
        expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 1 });
        setTime(0.76);
        engine.tick();
        expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 2 });
        expect(schedulerStub.calls).to.have.lengthOf(3);
        expect(schedulerStub.calls[2].at).to.be.closeTo(1.01, 0.0001);
    });
    it('applies swing offset to off-beat scheduling and forwards onStep callbacks', () => {
        const { clock } = createTestClock(0);
        const schedulerStub = createStubScheduler();
        const hookCalls = [];
        const audioHooks = {
            onStep(stepIndex, audioTime) {
                hookCalls.push({ stepIndex, audioTime });
            }
        };
        const engine = createTransportEngine(clock, schedulerStub.scheduler, {
            bpm: 120,
            gridSpec: { bars: 1, division: 4 },
            swing: 0.5
        }, audioHooks);
        engine.subscribe((state) => states.push(state));
        engine.start();
        expect(schedulerStub.calls[0].at).to.be.closeTo(0.625, 0.0001);
        schedulerStub.calls[0].fn(schedulerStub.calls[0].at);
        expect(hookCalls).to.deep.equal([
            { stepIndex: 1, audioTime: schedulerStub.calls[0].at }
        ]);
    });
});
//# sourceMappingURL=transportEngine.spec.js.map


=========================================
File: dist-test/tests/unitTests/transportEngine.spec.js.map
=========================================

{"version":3,"file":"transportEngine.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/transportEngine.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/tests/unitTests/use4DEncoder.spec.js
=========================================

import { describe, it, expect } from 'vitest';
import { use4DEncoder } from '@/composables/use4DEncoder';
describe('use4DEncoder', () => {
    it('navigates fields horizontally and clamps at bounds', () => {
        const encoder = use4DEncoder();
        encoder.setFields([
            { id: 'fileType', label: 'Type', value: 'all' },
            { id: 'category', label: 'Category', value: '' },
            { id: 'product', label: 'Product', value: '' }
        ]);
        encoder.tiltHorizontal('right');
        expect(encoder.activeFieldIndex.value).toBe(1);
        encoder.tiltHorizontal('left');
        expect(encoder.activeFieldIndex.value).toBe(0);
        encoder.tiltHorizontal('left');
        expect(encoder.activeFieldIndex.value).toBe(0);
    });
    it('adjusts numeric values when turning in value-adjust mode', () => {
        const encoder = use4DEncoder();
        encoder.setFields([{ id: 'bank', label: 'Bank', value: 5, min: 0, max: 10, step: 2 }]);
        encoder.setMode('value-adjust');
        encoder.turn(1);
        expect(encoder.fields.value[0]?.value).toBe(7);
        encoder.turn(10);
        expect(encoder.fields.value[0]?.value).toBe(10);
        encoder.turn(-20);
        expect(encoder.fields.value[0]?.value).toBe(0);
    });
    it('cycles modes with press', () => {
        const encoder = use4DEncoder();
        expect(encoder.mode.value).toBe('field-select');
        encoder.press();
        expect(encoder.mode.value).toBe('value-adjust');
        encoder.press();
        expect(encoder.mode.value).toBe('list-navigate');
        encoder.press();
        expect(encoder.mode.value).toBe('field-select');
    });
    it('navigates list vertically and with turn when in list mode', () => {
        const encoder = use4DEncoder();
        encoder.setMode('list-navigate');
        encoder.tiltVertical('down');
        expect(encoder.activeListIndex.value).toBe(1);
        encoder.turn(2);
        expect(encoder.activeListIndex.value).toBe(3);
        encoder.tiltVertical('up');
        expect(encoder.activeListIndex.value).toBe(2);
    });
    it('cycles through option values for the active field', () => {
        const encoder = use4DEncoder();
        encoder.setFields([{ id: 'fileType', label: 'Type', value: 'all', options: ['all', 'sample', 'kit'] }]);
        encoder.setMode('value-adjust');
        encoder.turn(1);
        expect(encoder.fields.value[0]?.value).toBe('sample');
        encoder.turn(10);
        expect(encoder.fields.value[0]?.value).toBe('kit');
    });
});
//# sourceMappingURL=use4DEncoder.spec.js.map


=========================================
File: dist-test/tests/unitTests/use4DEncoder.spec.js.map
=========================================

{"version":3,"file":"use4DEncoder.spec.js","sourceRoot":"","sources":["../../../tests/unitTests/use4DEncoder.spec.ts"],"names":[],"mappings":"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"}


=========================================
File: dist-test/types/audio.js
=========================================

export {};
//# sourceMappingURL=audio.js.map


=========================================
File: dist-test/types/audio.js.map
=========================================

{"version":3,"file":"audio.js","sourceRoot":"","sources":["../../types/audio.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/types/drums.js
=========================================

export {};
//# sourceMappingURL=drums.js.map


=========================================
File: dist-test/types/drums.js.map
=========================================

{"version":3,"file":"drums.js","sourceRoot":"","sources":["../../types/drums.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/types/library.js
=========================================

export {};
//# sourceMappingURL=library.js.map


=========================================
File: dist-test/types/library.js.map
=========================================

{"version":3,"file":"library.js","sourceRoot":"","sources":["../../types/library.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/types/midi.js
=========================================

export {};
//# sourceMappingURL=midi.js.map


=========================================
File: dist-test/types/midi.js.map
=========================================

{"version":3,"file":"midi.js","sourceRoot":"","sources":["../../types/midi.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/types/persistence.js
=========================================

export {};
//# sourceMappingURL=persistence.js.map


=========================================
File: dist-test/types/persistence.js.map
=========================================

{"version":3,"file":"persistence.js","sourceRoot":"","sources":["../../types/persistence.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/types/render.js
=========================================

export {};
//# sourceMappingURL=render.js.map


=========================================
File: dist-test/types/render.js.map
=========================================

{"version":3,"file":"render.js","sourceRoot":"","sources":["../../types/render.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/types/sync.js
=========================================

export {};
//# sourceMappingURL=sync.js.map


=========================================
File: dist-test/types/sync.js.map
=========================================

{"version":3,"file":"sync.js","sourceRoot":"","sources":["../../types/sync.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/types/time.js
=========================================

export {};
//# sourceMappingURL=time.js.map


=========================================
File: dist-test/types/time.js.map
=========================================

{"version":3,"file":"time.js","sourceRoot":"","sources":["../../types/time.ts"],"names":[],"mappings":""}


=========================================
File: dist-test/utils/seededRandom.js
=========================================

export function createSeededRandom(seed) {
    let value = seed >>> 0;
    return () => {
        value += 0x6d2b79f5;
        let t = value;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}
//# sourceMappingURL=seededRandom.js.map


=========================================
File: dist-test/utils/seededRandom.js.map
=========================================

{"version":3,"file":"seededRandom.js","sourceRoot":"","sources":["../../utils/seededRandom.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,kBAAkB,CAAC,IAAY;IAC7C,IAAI,KAAK,GAAG,IAAI,KAAK,CAAC,CAAA;IACtB,OAAO,GAAG,EAAE;QACV,KAAK,IAAI,UAAU,CAAA;QACnB,IAAI,CAAC,GAAG,KAAK,CAAA;QACb,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAA;QACpC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAA;QACzC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,UAAU,CAAA;IAC9C,CAAC,CAAA;AACH,CAAC"}


=========================================
File: dist-test/utils/zip.js
=========================================

// Minimal ZIP creator that writes stored entries with CRC32 checksums.
const textEncoder = new TextEncoder();
const CRC_TABLE = (() => {
    const table = new Uint32Array(256);
    for (let i = 0; i < 256; i += 1) {
        let crc = i;
        for (let j = 0; j < 8; j += 1) {
            crc = crc & 1 ? 0xedb88320 ^ (crc >>> 1) : crc >>> 1;
        }
        table[i] = crc >>> 0;
    }
    return table;
})();
const crc32 = (data) => {
    let crc = 0xffffffff;
    for (let i = 0; i < data.length; i += 1) {
        const byte = data[i] ?? 0;
        const tableValue = CRC_TABLE[(crc ^ byte) & 0xff] ?? 0;
        crc = tableValue ^ (crc >>> 8);
    }
    return (crc ^ 0xffffffff) >>> 0;
};
export const createZip = (entries) => {
    const localChunks = [];
    const centralChunks = [];
    let offset = 0;
    let centralSize = 0;
    for (const entry of entries) {
        const { name, data } = entry;
        const crc = crc32(data);
        const nameBytes = textEncoder.encode(name);
        // Build local file header and append raw data.
        const localHeaderBuffer = new ArrayBuffer(30 + nameBytes.length);
        const localView = new DataView(localHeaderBuffer);
        localView.setUint32(0, 0x04034b50, true);
        localView.setUint16(4, 20, true);
        localView.setUint16(6, 0, true);
        localView.setUint16(8, 0, true);
        localView.setUint16(10, 0, true);
        localView.setUint16(12, 0, true);
        localView.setUint32(14, crc, true);
        localView.setUint32(18, data.length, true);
        localView.setUint32(22, data.length, true);
        localView.setUint16(26, nameBytes.length, true);
        localView.setUint16(28, 0, true);
        const localHeaderBytes = new Uint8Array(localHeaderBuffer);
        localHeaderBytes.set(nameBytes, 30);
        localChunks.push(localHeaderBuffer);
        let ab;
        if (data.buffer instanceof ArrayBuffer && !(data.buffer instanceof SharedArrayBuffer)) {
            ab = data.buffer.slice(0, data.byteLength);
        }
        else {
            ab = new Uint8Array(data).buffer.slice(0);
        }
        localChunks.push(ab);
        // Build central directory header for the entry.
        const centralHeaderBuffer = new ArrayBuffer(46 + nameBytes.length);
        const centralView = new DataView(centralHeaderBuffer);
        centralView.setUint32(0, 0x02014b50, true);
        centralView.setUint16(4, 20, true);
        centralView.setUint16(6, 20, true);
        centralView.setUint16(8, 0, true);
        centralView.setUint16(10, 0, true);
        centralView.setUint16(12, 0, true);
        centralView.setUint16(14, 0, true);
        centralView.setUint32(16, crc, true);
        centralView.setUint32(20, data.length, true);
        centralView.setUint32(24, data.length, true);
        centralView.setUint16(28, nameBytes.length, true);
        centralView.setUint16(30, 0, true);
        centralView.setUint16(32, 0, true);
        centralView.setUint16(34, 0, true);
        centralView.setUint16(36, 0, true);
        centralView.setUint32(38, 0, true);
        centralView.setUint32(42, offset, true);
        const centralHeaderBytes = new Uint8Array(centralHeaderBuffer);
        centralHeaderBytes.set(nameBytes, 46);
        centralChunks.push(centralHeaderBuffer);
        offset += localHeaderBytes.length + data.length;
        centralSize += centralHeaderBytes.length;
    }
    // Write end of central directory record.
    const endBuffer = new ArrayBuffer(22);
    const endView = new DataView(endBuffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, 0, true);
    endView.setUint16(6, 0, true);
    endView.setUint16(8, entries.length, true);
    endView.setUint16(10, entries.length, true);
    endView.setUint32(12, centralSize, true);
    endView.setUint32(16, offset, true);
    endView.setUint16(20, 0, true);
    const parts = [
        ...localChunks,
        ...centralChunks,
        endBuffer
    ];
    return new Blob(parts, { type: 'application/zip' });
};
//# sourceMappingURL=zip.js.map


=========================================
File: dist-test/utils/zip.js.map
=========================================

{"version":3,"file":"zip.js","sourceRoot":"","sources":["../../utils/zip.ts"],"names":[],"mappings":"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"}


=========================================
File: domain/clock/renderClock.ts
=========================================

export interface RenderClock {
  readonly ctx: BaseAudioContext

  /**
   * Indicates whether the clock is used for offline rendering.
   * Offline clocks must not rely on real-time scheduling.
   */
  readonly isOffline: boolean

  /**
   * Current audio time in seconds.
   * This is always based on the underlying AudioContext.
   */
  audioTime(): number

  /**
   * Alias for audioTime(), for compatibility.
   */
  now(): number
}

export function createRenderClock(


  ctx: BaseAudioContext,
  isOffline = false
): RenderClock {
  return {
    ctx,
    isOffline,
    audioTime: () => ctx.currentTime,
    now: () => ctx.currentTime
  }
}



=========================================
File: domain/clock/scheduler.ts
=========================================

import type { RenderClock } from './renderClock'

export type ScheduledFn = (audioTime: number) => void

export interface SchedulerOptions {
  readonly lookaheadSec: number
  readonly intervalMs: number
}

export interface Scheduler {
  start(): void
  stop(): void
  schedule(atTimeSec: number, fn: ScheduledFn): void
  clear(): void
}

interface ScheduledItem {
  at: number
  fn: ScheduledFn
}

// Lookahead scheduler that batches callbacks scheduled within a horizon relative to the audio clock.
const DEFAULT_OPTIONS: SchedulerOptions = {
  lookaheadSec: 0.1,
  intervalMs: 25
}

export function createScheduler(clock: RenderClock, options: Partial<SchedulerOptions> = {}): Scheduler {
  const cfg: SchedulerOptions = { ...DEFAULT_OPTIONS, ...options }

  let timerId: ReturnType<typeof setInterval> | null = null
  let wasRunningOnHide = false
  let queue: ScheduledItem[] = []

  const flush = (): void => {
    const now = clock.audioTime()
    const horizon = now + cfg.lookaheadSec

    queue.sort((a, b) => a.at - b.at)

    const due: ScheduledItem[] = []
    const pending: ScheduledItem[] = []

    for (const item of queue) {
      if (item.at <= horizon) {
        due.push(item)
      } else {
        pending.push(item)
      }
    }

    queue = pending

    for (const item of due) {
      item.fn(item.at)
    }
  }

  const startTimer = (): void => {
    if (clock.isOffline) {
      return
    }
    if (timerId) {
      return
    }
    timerId = setInterval(flush, cfg.intervalMs)
  }

  const stopTimer = (): void => {
    if (!timerId) {
      return
    }
    clearInterval(timerId)
    timerId = null
  }

  if (typeof window !== 'undefined') {
    const handlePageHide = () => {
      if (timerId) {
        wasRunningOnHide = true
        stopTimer()
      } else {
        wasRunningOnHide = false
      }
    }

    const handlePageShow = () => {
      if (wasRunningOnHide) {
        startTimer()
        flush()
      }
    }

    window.addEventListener('pagehide', handlePageHide)
    window.addEventListener('pageshow', handlePageShow)
  }

  return {
    start(): void {
      startTimer()
    },

    stop(): void {
      stopTimer()
    },

    schedule(atTimeSec: number, fn: ScheduledFn): void {
      queue.push({ at: atTimeSec, fn })
    },

    clear(): void {
      queue = []
    }
  }
}



=========================================
File: domain/midiMapping.ts
=========================================

import type { MidiMapping } from '@/types/midi'
import type { DrumPadId } from '@/types/drums'

const defaultPads: DrumPadId[] = [
  'pad1',
  'pad2',
  'pad3',
  'pad4',
  'pad5',
  'pad6',
  'pad7',
  'pad8',
  'pad9',
  'pad10',
  'pad11',
  'pad12',
  'pad13',
  'pad14',
  'pad15',
  'pad16'
]

export function defaultMidiMapping(): MidiMapping {
  const noteMap: Partial<Record<number, DrumPadId>> = {}
  const noteMapInverse: Partial<Record<DrumPadId, number>> = {}
  defaultPads.forEach((padId, index) => {
    const note = 36 + index
    noteMap[note] = padId
    noteMapInverse[padId] = note
  })
  return { noteMap, noteMapInverse, transportMap: {} }
}



=========================================
File: domain/quantize.ts
=========================================

import type { StepAddress } from '@/types/time'

export function quantizeToStep(time: number, secondsPerStep: number, bars: number, division: number): StepAddress {
  const totalSteps = bars * division
  const stepIndex = Math.max(0, Math.min(totalSteps - 1, Math.round(time / secondsPerStep)))
  return {
    barIndex: Math.floor(stepIndex / division),
    stepInBar: stepIndex % division
  }
}



=========================================
File: domain/timing.ts
=========================================

import type { GridSpec, TimeDivision } from '@/types/time'

export const GRID_DIVISIONS: readonly TimeDivision[] = [1, 2, 4, 8, 16, 32, 64] as const
export const DEFAULT_GRID_SPEC: GridSpec = { bars: 1, division: 16 }

export function secondsPerStep(bpm: number, division: number): number {
  return (60 / bpm) * (4 / division)
}

export function stepsPerBar(gridSpec: GridSpec): number {
  return gridSpec.division
}

export function normalizeGridSpec(gridSpec?: Partial<GridSpec>): GridSpec {
  const division = GRID_DIVISIONS.includes((gridSpec?.division ?? DEFAULT_GRID_SPEC.division) as TimeDivision)
    ? (gridSpec?.division as TimeDivision)
    : DEFAULT_GRID_SPEC.division
  const bars: GridSpec['bars'] =
    gridSpec?.bars === 1 || gridSpec?.bars === 2 || gridSpec?.bars === 4 || gridSpec?.bars === 8
      ? gridSpec.bars
      : DEFAULT_GRID_SPEC.bars

  return { bars, division }
}



=========================================
File: domain/transport/audioHooks.ts
=========================================

export interface TransportAudioHooks {
  onStep(stepIndex: number, audioTime: number): void
}



=========================================
File: domain/transport/transportEngine.ts
=========================================

import type { RenderClock } from '../clock/renderClock'
import type { Scheduler } from '../clock/scheduler'
import type { TransportConfig, TransportState } from './types'
import type { TransportAudioHooks } from './audioHooks'
export type TransportListener = (state: TransportState) => void

// Transport engine that schedules step boundaries against the audio clock, emitting normalized transport state.
export interface TransportEngine {
  start(): void
  stop(): void
  setConfig(next: TransportConfig): void
  subscribe(listener: TransportListener): () => void
  tick(): void
}

const clampInt = (value: number): number => {
  if (!Number.isFinite(value)) {
    return 0
  }
  return Math.floor(value)
}



export function createTransportEngine(
  clock: RenderClock,
  scheduler: Scheduler,
  initial: TransportConfig,
  audioHooks?: TransportAudioHooks
  ): TransportEngine {
    let cfg: TransportConfig = initial

    let isPlaying = false
    let startTimeSec = 0
    let lastStep = -1
    let lastAbsoluteStep = -1

    const listeners = new Set<TransportListener>()
    const stepDurationSec = (): number => {
    const stepsPerBar = Math.max(1, cfg.gridSpec.division)
    const beatsPerBar = 4
    const beatsPerStep = beatsPerBar / stepsPerBar
    const secPerBeat = 60 / Math.max(1, cfg.bpm)
    return beatsPerStep * secPerBeat
    }
  
    const totalSteps = (): number => {
      const steps = cfg.gridSpec.bars * cfg.gridSpec.division
      return Math.max(0, clampInt(steps))
    }

    const normalizeStep = (step: number): number => {
      const steps = Math.max(totalSteps(), 1)
      return ((step % steps) + steps) % steps
    }

    const swingOffsetSec = (stepIndex: number): number => {
    const swing = cfg.swing ?? 0
    if (swing <= 0) {
      return 0
    }

    const isOffBeat = stepIndex % 2 === 1
    if (!isOffBeat) {
      return 0
    }

    return stepDurationSec() * swing * 0.5
  }

  const emit = (): void => {
    const steps = Math.max(totalSteps(), 1)
    const normalized = ((lastStep % steps) + steps) % steps

    const state: TransportState = {
      isPlaying,
      currentStep: normalized
    }

    for (const listener of listeners) {
      listener(state)
      }
    }
    
    const computeAbsoluteStepAt = (timeSec: number): number => {
      const dur = stepDurationSec()
      const raw = (timeSec - startTimeSec) / dur
      return clampInt(raw)
    }

    let lastScheduledStep = -1

    const scheduleStepBoundary = (stepIndexAbsolute: number): void => {
      if (stepIndexAbsolute === lastScheduledStep) {
        return
      }

      const normalizedStep = normalizeStep(stepIndexAbsolute)
      lastScheduledStep = stepIndexAbsolute

      const stepTimeSec =
        startTimeSec +
        stepIndexAbsolute * stepDurationSec() +
        swingOffsetSec(normalizedStep)

      scheduler.schedule(stepTimeSec, (audioTime) => {
        audioHooks?.onStep(normalizedStep, audioTime)
      })
    }


    const advance = (): void => {
      const now = clock.audioTime()
      const currentAbsolute = computeAbsoluteStepAt(now)
      const current = normalizeStep(currentAbsolute)

      if (current !== lastStep) {
        lastStep = current
        lastAbsoluteStep = currentAbsolute
        scheduleStepBoundary(lastAbsoluteStep + 1)
        emit()
      }
    }

  return {
    start(): void {
      if (isPlaying) {
        return
      }
      isPlaying = true
      startTimeSec = clock.audioTime()
      lastStep = -1
      lastAbsoluteStep = -1
      lastScheduledStep = -1
      scheduler.clear()
      scheduler.start()
      lastAbsoluteStep = computeAbsoluteStepAt(startTimeSec)
      lastStep = normalizeStep(lastAbsoluteStep)
      emit()
      scheduleStepBoundary(lastAbsoluteStep + 1)
    },

    stop(): void {
      if (!isPlaying) {
        return
      }
      isPlaying = false
      scheduler.stop()
      scheduler.clear()
      lastStep = -1
      lastScheduledStep = -1
      emit()
    },

  setConfig(next: TransportConfig): void {
      cfg = next
      if (isPlaying) {
        const now = clock.audioTime()
        const dur = stepDurationSec()
        const steps = Math.max(totalSteps(), 1)
        const current = ((lastAbsoluteStep % steps) + steps) % steps
        startTimeSec = now - lastAbsoluteStep * dur - swingOffsetSec(current)
        lastAbsoluteStep = computeAbsoluteStepAt(now)
        lastStep = normalizeStep(lastAbsoluteStep)
        if (lastScheduledStep < lastAbsoluteStep) {
          lastScheduledStep = lastAbsoluteStep
        }
      } else {
        lastScheduledStep = -1
      }
      emit()
    },

    subscribe(listener: TransportListener): () => void {
      listeners.add(listener)
      listener({
        isPlaying,
        currentStep: Math.max(0, lastStep)
      })
      return (): void => {
        listeners.delete(listener)
      }
    },

    tick(): void {
      if (!isPlaying) {
        return
      }
      advance()
    }
  }
}



=========================================
File: domain/transport/types.ts
=========================================

import type { DrumPadId } from '@/types/drums'
import type { GridSpec } from '@/types/time'

// Shared transport domain types for playback and grid configuration.

export interface TransportState {
  readonly isPlaying: boolean
  readonly currentStep: number
}

export type StepTogglePayload = {
  barIndex: number
  stepInBar: number
  padId: DrumPadId
}

export interface TransportConfig {
  readonly bpm: number
  readonly gridSpec: GridSpec
  swing?: number
}



=========================================
File: domain/validators.ts
=========================================

import { GRID_DIVISIONS } from './timing'
import type { GridSpec } from '../types/time'

export function isValidGridSpec(gridSpec: GridSpec): boolean {
  return gridSpec.bars >= 1 && gridSpec.bars <= 8 && GRID_DIVISIONS.includes(gridSpec.division)
}



=========================================
File: domain/velocity/velocityToGain.ts
=========================================

// Converts a normalized velocity value to a gain multiplier using a simple curve.
export function velocityToGain(
  velocity: number,
  minGain = 0.15
): number {
  const v = Math.max(0, Math.min(1, velocity))

  const curved = v * v

  return minGain + (1 - minGain) * curved
}



=========================================
File: domain/velocity.ts
=========================================

export const STEP_VELOCITY_LEVELS = [0.7, 1, 1.25] as const
export const DEFAULT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[0]
export const ACCENT_STEP_VELOCITY = STEP_VELOCITY_LEVELS[STEP_VELOCITY_LEVELS.length - 1]!

const EPSILON = 0.001

const matchesLevel = (value: number, level: number) => Math.abs(value - level) < EPSILON

export function clampVelocity(value?: number): number {
  const resolved = typeof value === 'number' ? value : DEFAULT_STEP_VELOCITY
  const clamped = Math.max(STEP_VELOCITY_LEVELS[0], Math.min(ACCENT_STEP_VELOCITY, resolved))
  const closest = STEP_VELOCITY_LEVELS.find((level) => matchesLevel(clamped, level))
  return closest ?? clamped
}

export function cycleVelocity(current?: number): number | null {
  if (typeof current !== 'number') {
    return DEFAULT_STEP_VELOCITY
  }
  const index = STEP_VELOCITY_LEVELS.findIndex((level) => matchesLevel(current, level))
  if (index === -1) {
    return DEFAULT_STEP_VELOCITY
  }
  const nextIndex = index + 1
  if (nextIndex >= STEP_VELOCITY_LEVELS.length) {
    return null
  }
  const nextValue = STEP_VELOCITY_LEVELS[nextIndex]
  if (typeof nextValue !== 'number') {
    return null
  }
  return nextValue
}

export function velocityToIntensity(value?: number): number {
  if (!value) return 0
  return Math.min(1, value / ACCENT_STEP_VELOCITY)
}



=========================================
File: eslint.config.cjs
=========================================

const { FlatCompat } = require('@eslint/eslintrc')
const js = require('@eslint/js')

const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all
})

module.exports = [
  ...compat.config(require('./.eslintrc.cjs')),
  {
    ignores: ['eslint.config.cjs', '.eslintrc.cjs']
  }
]



=========================================
File: eslint.config.js
=========================================

import js from '@eslint/js'
import tseslint from '@typescript-eslint/eslint-plugin'
import tsParser from '@typescript-eslint/parser'
import vue from 'eslint-plugin-vue'
import vueParser from 'vue-eslint-parser'
import globals from 'globals'

export default [{
    ignores: ['node_modules', '.nuxt', '.output', 'dist', 'coverage'],
  },

  // Main config for JS/TS/Vue
  {
    files: ['**/*.{ts,tsx,js,jsx,vue}'],
    languageOptions: {
      parser: vueParser,
      parserOptions: {
        parser: tsParser, // use TS parser for <script> blocks and TS files
        ecmaVersion: 'latest',
        sourceType: 'module',
        extraFileExtensions: ['.vue'],
      },
      globals: {
        ...globals.browser,
        ...globals.es2021,
        ...globals.node,
        defineNuxtPlugin: 'readonly',
      },
    },
    plugins: {
      '@typescript-eslint': tseslint,
      vue,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...tseslint.configs.recommended.rules,
      ...vue.configs['vue3-recommended'].rules,

      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-empty-object-type': 'off',

      // âœ… Fix: TS types are not runtime globals â†’ disable core no-undef
      'no-undef': 'off',

      // âœ… Fix: avoid duplicate unused-vars; use TS rule and allow leading underscores
      'no-unused-vars': 'off',
      '@typescript-eslint/no-unused-vars': [
        'error',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
          caughtErrorsIgnorePattern: '^_',
        },
      ],
    },
  },

  // Tests (Mocha)
  {
    files: ['**/*.spec.{ts,tsx,js,jsx}'],
    languageOptions: {
      globals: {
        ...globals.mocha,
      },
    },
  },
]


=========================================
File: implementationPlan.json
=========================================

{
  "phases": [
    {
      "id": 1,
      "title": "Analyse & Planung",
      "description": "Analyse aller json-Dateien (uiList, functionsList, nimamk3) und Abgleich mit der aktuellen Codebasis. Identifikation aller fehlenden UI-Elemente, Funktionen und Hardware-Workflows. Erstellung einer vollstÃ¤ndigen Feature- und Task-Liste.",
      "criteria": [
        "Alle Anforderungen und LÃ¼cken sind dokumentiert",
        "Abgleich mit Hardware-Workflows und Interaktionsmodellen"
      ]
    },
    {
      "id": 2,
      "title": "Architektur & Clean Code Setup",
      "description": "Definition und Dokumentation der Architektur, Clean Code-Prinzipien, Performance-Standards und Nuxt 4-spezifischen Patterns (Options API, Pug, Less). ErgÃ¤nzung/Anpassung der Diagramme im diagrams-Ordner.",
      "criteria": [
        "README.md enthÃ¤lt Architektur- und Clean Code-Richtlinien",
        "Diagramme sind aktuell und vollstÃ¤ndig"
      ]
    },
    {
      "id": 3,
      "title": "UI/UX & Interaktions-Implementierung",
      "description": "Schrittweise Implementierung aller fehlenden UI-Elemente und Interaktionsmodelle gemÃ¤ÃŸ uiList.json und Hardware-Workflows. Fokus auf Performance, Accessibility und Options API. Jede Komponente erhÃ¤lt Pug/Less-Templates und ist in Nuxt 4 eingebunden.",
      "criteria": [
        "Alle UI-Elemente und Panels sind funktionsfÃ¤hig",
        "Accessibility und Fokussteuerung umgesetzt"
      ]
    },
    {
      "id": 4,
      "title": "Funktionale Logik & Audio/MIDI",
      "description": "Implementierung aller fehlenden Funktionen aus functionsList.json und nimamk3.json (Transport, Pattern, Erase, Undo/Redo, MIDI, LED-Feedback etc.). Performance-Optimierung und deterministische Exporte. Erweiterung/Anpassung der Stores und Composables.",
      "criteria": [
        "Alle Funktionen sind testbar und performant",
        "Audio/MIDI-Engine vollstÃ¤ndig integriert"
      ]
    },
    {
      "id": 5,
      "title": "Testing, QA & Use Cases",
      "description": "Komponententests, Unittests und End-to-End-Tests fÃ¼r alle neuen Features. ErgÃ¤nzung der README.md um alle relevanten Use Cases. Testabdeckung und Performance werden dokumentiert.",
      "criteria": [
        "Tests fÃ¼r alle neuen Features vorhanden",
        "README.md enthÃ¤lt alle Use Cases"
      ]
    },
    {
      "id": 6,
      "title": "Finalisierung & Review",
      "description": "Abschluss aller Tasks im Feature-Branch. Review mit Repository-Inhaber vor Merge. Kein Merge ohne explizite Freigabe. Abschlussdokumentation und Ãœbergabe.",
      "criteria": [
        "Alle Phasen abgeschlossen und dokumentiert",
        "Review und Freigabe durch Inhaber"
      ]
    }
  ],
  "branching": {
    "feature_branch_only": true,
    "merge_policy": "Kein Merge ohne RÃ¼cksprache mit dem Inhaber des Repositories."
  },
  "documentation": {
    "readme": "Jede Phase und alle neuen Use Cases werden in der README.md dokumentiert.",
    "diagrams": "Alle relevanten Diagramme im diagrams-Ordner werden ergÃ¤nzt/aktualisiert."
  },
  "tech_stack": {
    "framework": "Nuxt 4",
    "ui": "Vue 3 Options API, Pug, Less, Vuetify 3",
    "audio": "Web Audio API, Web MIDI API",
    "persistence": "IndexedDB, LocalStorage",
    "testing": "Vitest, Vue Test Utils"
  },
  "quality": {
    "performance": "Alle Komponenten und Funktionen werden auf Performance optimiert.",
    "clean_code": "Strikte Einhaltung von Clean Code und Architekturprinzipien."
  }
}


=========================================
File: layouts/default.vue
=========================================

<template>
  <v-app>
    <NuxtPage />
  </v-app>
</template>

<script lang="ts">
export default {
  // Provides the root Vuetify app shell for all pages.
}
</script>



=========================================
File: nuxt.config.ts
=========================================

import { defineNuxtConfig } from 'nuxt/config'

const DEFAULT_HMR_PORT = 24678
const hmrPort = Number.isInteger(Number(process.env.HMR_PORT)) && process.env.HMR_PORT
  ? Number(process.env.HMR_PORT)
  : DEFAULT_HMR_PORT

export default defineNuxtConfig({
  // Nuxt configuration for the client-only drum machine, wiring modules, styles, and Vite options.
  ssr: false,
  debug: true,
  compatibilityDate: '2024-04-03',
  devtools: {
    enabled: true,

    timeline: {
      enabled: true
    }
  },
  modules: [
    '@pinia/nuxt',
  ],


  css: ['vuetify/styles', '@/styles/globals.less'],
  typescript: {
    strict: true,
    typeCheck: false
  },
  devServer: {
    host: '0.0.0.0',
    port: 3100
  },
  nitro: {
    prerender: {
      routes: []
    }
  },
  vite: {
    server: {
      hmr: {
        port: hmrPort,
        host: '127.0.0.1'
      }
    },

    define: {
      'process.env.DEBUG': true
    },
    css: {
      preprocessorOptions: {
        less: {
          javascriptEnabled: true,
          additionalData: `@import '@/styles/variables.less';`
        }
      }
    }
  },

  pages: true,
  app: {
    head: {
      title: 'Drumcomputer',
      meta: [
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { name: 'description', content: 'Nuxt 4 Drumcomputer with WebAudio and MIDI' }
      ]
    }
  }
})



=========================================
File: package.json
=========================================

{
  "name": "drumcomputer",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "node scripts/dev.mjs",
    "build": "nuxt build",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "lint": "eslint .",
    "typecheck": "vue-tsc --noEmit",
    "build:test": "tsc -p tsconfig.test.json",
    "test:unit": "vitest run tests/unitTests/*.spec.ts",
    "test:components": "vitest",
    "test:watch": "mocha --watch --loader ts-node/esm --require jsdom-global/register tests/**/*.spec.ts"
  },
  "dependencies": {
    "@pinia/nuxt": "^0.5.4",
    "@tonejs/midi": "^2.0.27",
    "@vite-pwa/nuxt": "^0.10.1",
    "file-saver": "^2.0.5",
    "nuxt": "^4.2.2",
    "pinia": "^2.2.6",
    "pug": "^3.0.3",
    "vuetify": "^3.11.4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.3",
    "@types/chai": "^5.2.3",
    "@types/mocha": "^10.0.10",
    "@types/node": "^25.0.3",
    "@types/vue": "^1.0.31",
    "@types/webmidi": "^2.0.12",
    "@types/wicg-file-system-access": "^2023.10.7",
    "@typescript-eslint/eslint-plugin": "^8.18.1",
    "@typescript-eslint/parser": "^8.18.1",
    "@vue/test-utils": "^2.4.6",
    "chai": "^4.5.0",
    "eslint": "^9.13.0",
    "eslint-plugin-vue": "^9.29.0",
    "fake-indexeddb": "^6.2.5",
    "jsdom": "^27.3.0",
    "jsdom-global": "^3.0.2",
    "less": "^4.2.0",
    "mocha": "^11.7.5",
    "ts-node": "^10.9.2",
    "tsx": "^4.21.0",
    "typescript": "^5.6.3",
    "vitest": "^4.0.16",
    "vue-tsc": "^2.1.10"
  },
  "volta": {
    "node": "20.19.6"
  }
}



=========================================
File: pages/index.vue
=========================================

<template>
<ClientOnly>
  <DrumMachine>
    <template #main>
      <div class="main-placeholder" />
    </template>

    <template #pads="{ props }">
      <PadGrid v-bind="props.padGridProps" />
    </template>

    <template #transport="{ props }">
      <TransportBar v-bind="props.transportProps" />
    </template>

  </DrumMachine>
</ClientOnly>
</template>

<script>
import DrumMachine from '@/components/DrumMachine.vue'
import TransportBar from '@/components/TransportBar.vue'
import PadGrid from '@/components/PadGrid.vue'
import FxPanel from '@/components/panels/FxPanel.vue'

export default {
  // Composes the DrumMachine with transport, pads, and FX panels for the main page.
  components: {
    DrumMachine,
    TransportBar,
    PadGrid,
    FxPanel
  }
}
</script>

<style scoped>
.main-placeholder {
  width: 100%;
  height: 100%;
}
</style>



=========================================
File: plugins/vuetify.client.ts
=========================================

import { defineNuxtPlugin } from '#app'
import { createVuetify } from 'vuetify'
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'

export default defineNuxtPlugin((nuxtApp) => {
  const vuetify = createVuetify({
    components,
    directives,
    theme: {
      defaultTheme: 'dark',
      themes: {
        dark: {
          dark: true,
          colors: {
            background: '#0E1013',
            surface: '#12151B',
            primary: '#2EC5FF',
            secondary: '#5EE1FF',
            error: '#FF4D4D',
            info: '#2EC5FF',
            success: '#4CAF50',
            warning: '#FFC107'
          }
        }
      }
    }
  })

  nuxtApp.vueApp.use(vuetify)
})



=========================================
File: plugins/vuetify.ts
=========================================

import { createVuetify, DateInstance, DefaultsInstance, DisplayInstance, GoToInstance, IconAliases, IconSet, LocaleInstance, LocaleMessages, LocaleOptions, ThemeInstance } from 'vuetify'
import { aliases, mdi } from 'vuetify/iconsets/mdi'
import * as components from 'vuetify/components'
import * as directives from 'vuetify/directives'
import { defineNuxtPlugin } from 'nuxt/app'
import { App, Ref, ShallowRef } from 'vue'

export default defineNuxtPlugin((nuxtApp: { vueApp: { use: (arg0: { install: (app: App<unknown>) => void; unmount: () => void; defaults: Ref<DefaultsInstance, DefaultsInstance>; display: DisplayInstance; theme: ThemeInstance & { install: (app: App<unknown>) => void }; icons: { defaultSet: string; aliases: Partial<IconAliases>; sets: Record<string, IconSet> }; locale: { name: string; decimalSeparator: ShallowRef<string>; messages: Ref<LocaleMessages, LocaleMessages>; current: Ref<string, string>; fallback: Ref<string, string>; t: (key: string, ...params: unknown[]) => string; n: (value: number) => string; provide: (props: LocaleOptions) => LocaleInstance; isRtl: Ref<boolean, boolean>; rtl: Ref<Record<string, boolean>, Record<string, boolean>>; rtlClasses: Ref<string, string> }; date: { options: { adapter: (new (options: { locale: unknown; formats?: unknown }) => DateInstance) | DateInstance; formats?: Record<string, unknown>; locale: Record<string, unknown> }; instance: { date: (value?: unknown) => unknown; format: (date: unknown, formatString: string) => string; toJsDate: (value: unknown) => Date; parseISO: (date: string) => unknown; toISO: (date: unknown) => string; startOfDay: (date: unknown) => unknown; endOfDay: (date: unknown) => unknown; startOfWeek: (date: unknown, firstDayOfWeek?: string | number | undefined) => unknown; endOfWeek: (date: unknown) => unknown; startOfMonth: (date: unknown) => unknown; endOfMonth: (date: unknown) => unknown; startOfYear: (date: unknown) => unknown; endOfYear: (date: unknown) => unknown; isAfter: (date: unknown, comparing: unknown) => boolean; isAfterDay: (date: unknown, comparing: unknown) => boolean; isSameDay: (date: unknown, comparing: unknown) => boolean; isSameMonth: (date: unknown, comparing: unknown) => boolean; isSameYear: (date: unknown, comparing: unknown) => boolean; isBefore: (date: unknown, comparing: unknown) => boolean; isEqual: (date: unknown, comparing: unknown) => boolean; isValid: (date: unknown) => boolean; isWithinRange: (date: unknown, range: [unknown, unknown]) => boolean; addMinutes: (date: unknown, amount: number) => unknown; addHours: (date: unknown, amount: number) => unknown; addDays: (date: unknown, amount: number) => unknown; addWeeks: (date: unknown, amount: number) => unknown; addMonths: (date: unknown, amount: number) => unknown; getYear: (date: unknown) => number; setYear: (date: unknown, year: number) => unknown; getDiff: (date: unknown, comparing: unknown, unit?: string | undefined) => number; getWeekArray: (date: unknown, firstDayOfWeek?: string | number | undefined) => unknown[][]; getWeekdays: (firstDayOfWeek?: string | number | undefined, weekdayFormat?: "long" | "narrow" | "short" | undefined) => string[]; getWeek: (date: unknown, firstDayOfWeek?: string | number | undefined, firstDayOfYear?: string | number | undefined) => number; getMonth: (date: unknown) => number; setMonth: (date: unknown, month: number) => unknown; getDate: (date: unknown) => number; setDate: (date: unknown, day: number) => unknown; getNextMonth: (date: unknown) => unknown; getPreviousMonth: (date: unknown) => unknown; getHours: (date: unknown) => number; setHours: (date: unknown, hours: number) => unknown; getMinutes: (date: unknown) => number; setMinutes: (date: unknown, minutes: number) => unknown; locale?: unknown } }; goTo: GoToInstance }) => void } }) => {
  const vuetify = createVuetify({
    components,
    directives,
    icons: {
      defaultSet: 'mdi',
      aliases,
      sets: { mdi }
    },
    theme: {
      defaultTheme: 'dark'
    }
  })

  nuxtApp.vueApp.use(vuetify)
})




=========================================
File: promptingAgentInstructions.json
=========================================

{
  "branch": "featureImplementation",
  "merge_policy": "Merge in master nur nach expliziter Freigabe durch den Inhaber.",
  "phasen": [
    {
      "missing_functions": [
        "Play/Stop Toggle (Transport)",
        "Stop + Reset Playhead (Transport)",
        "Record Toggle und Count-In (Transport)",
        "Pattern Preset Mode (Pattern-LÃ¤nge vor Aufnahme)",
        "Restart Loop Range (Transport)",
        "Loop On/Off und Loop-Range-Verschiebung/Endpunkt-Anpassung",
        "Tap Tempo (Transport)",
        "Metronom Toggle",
        "Follow Toggle (Display folgt Playhead)",
        "Grid Mode (Perform/Arrange/Step/Nudge Grid)",
        "Live-Erase (Events wÃ¤hrend Playback lÃ¶schen)",
        "Erase All Events for Pad (Shortcut)",
        "Erase Automation for Parameter",
        "Remove Sound/Group Slot (Reset)",
        "Channel Properties (Control Mode)",
        "MIDI Mode Umschaltung (SHIFT + CHANNEL)",
        "Pad/Group-LED-Feedback (Farben, Choke, Create)",
        "Soft Button/Knob Kontextsteuerung (Overlays, Selector-Listen)",
        "Mode-Pinning und Shift-Layer-Handling (UI/Logik)",
        "Undo/Redo-Logik fÃ¼r Pattern/Scene-Edits (History)"
      ],
      "hardware_functions": [
        "Pad Input: Note On/Off, Velocity, Aftertouch, RGB-Feedback je nach Modus (Mute/Solo/Pattern/Slot)",
        "Pad Mode: Umschalten zwischen SCENE, PATTERN, PAD MODE, KEYBOARD, CHORD, STEP, ARRANGE, DUPLICATE",
        "Group Select: 2x4 Buttons, Farbkodiert, Create-Button (dim white)",
        "Transport: RESTART, ERASE, TAP, FOLLOW, PLAY, REC, STOP, SHIFT, mit Status-Feedback",
        "Performance: Note Repeat, Lock, Strip Mode, Smart Strip (Touch/Slide, LED-Bar, Strip Mode)",
        "Edit Zone: 4D-Encoder (tilt, push, turn), Quick Edit (VOLUME, SWING, TEMPO)",
        "Screen Buttons: Soft Buttons 1â€“8, kontextabhÃ¤ngige Funktion",
        "Screen Knobs: 8 Touch-Knobs, Touch blendet Werteliste ein, Push fÃ¼r Reset",
        "Displays: 2x, dynamische Overlays, Kontext-Feedback, Selector-Listen",
        "Control Zone: CHANNEL, PLUG-IN, ARRANGER, MIXER, BROWSER, SAMPLING, PATTERN, SCENE, PAD MODE, EVENTS, VARIATION, DUPLICATE",
        "Pad Input Mode: FIXED VEL, PAD MODE, KEYBOARD, CHORD, STEP",
        "Global: Shift-Layer, Mode-Pinning, Undo/Redo, Kontext-Feedback, LED-Feedback, Overlay-Icons"
      ],
      "interaction_models": [
        "press: Kurzer Tastendruck (z.B. Pad, Button)",
        "press_twice: Doppelklick (z.B. Stop)",
        "hold: GedrÃ¼ckt halten (Momentary)",
        "hold_combo: GedrÃ¼ckt halten + weiteres Element",
        "shift_combo: SHIFT + Element",
        "turn: Drehen (Knob, Encoder)",
        "touch: BerÃ¼hren (Touch-Knob, Strip)",
        "slide: Fingerbewegung Ã¼ber Touch-Strip",
        "push_turn: Encoder drÃ¼cken + drehen",
        "tilt: 4D-Encoder Richtung",
        "confirm: Auswahl bestÃ¤tigen (Encoder drÃ¼cken)"
      ],
      "feedback_mechanisms": [
        "Pad RGB: Status je nach Modus (Mute/Solo/Pattern/Slot)",
        "Button LED: off/dim/bright/pinned",
        "Group Button: Farbkodiert, dim white fÃ¼r Create",
        "Soft Button/Knob: Overlay/Label im Display",
        "Selector-Listen: Overlay bei Touch auf Knob",
        "Touch Strip: LED-Bar, haptisches Feedback",
        "4D-Encoder: LED-Ring fÃ¼r Richtungen, Push-Feedback"
      ],
      "roadmap": [
        "1. Transport- und Playback-Funktionen vollstÃ¤ndig implementieren",
        "2. Pattern/Scene-Chain- und Preset-Mode-Logik entwickeln",
        "3. Loop- und Grid-Handling (inkl. Endpunkt/Range) umsetzen",
        "4. Erase- und Automation-Funktionen ergÃ¤nzen",
        "5. Channel-Properties- und MIDI-Mode-Logik bereitstellen",
        "6. Pad/Group-LED-Feedback und Soft-Button/Knob-Kontextsteuerung integrieren",
        "7. Mode-Pinning, Shift-Layer-Handling und Undo/Redo-Logik finalisieren"
      ]
    }
  ],
  "dokumentation": {
    "readme": "Jede Phase und alle neuen Use Cases werden in der README.md dokumentiert.",
    "diagrams": "Alle relevanten Diagramme im diagrams-Ordner werden ergÃ¤nzt/aktualisiert."
  },
  "qualitaet": {
    "performance": "Alle Komponenten und Funktionen werden auf Performance optimiert.",
    "clean_code": "Strikte Einhaltung von Clean Code und Architekturprinzipien."
  },
  "hinweise": [
    "Es darf ausschlieÃŸlich im Branch 'featureImplementation' gearbeitet werden.",
    "Der Merge in den master-Branch erfolgt nur nach expliziter Freigabe durch den Inhaber.",
    "Alle Aufgaben sind so zu dokumentieren, dass ein Eingreifen des Inhabers erst zum Merge erforderlich ist."
  ]
}


=========================================
File: scripts/dev.mjs
=========================================

import {
  spawn
} from 'node:child_process'
import path from 'node:path'
import {
  fileURLToPath
} from 'node:url'

/**
 * __dirname for ESM
 */
const __dirname = path.dirname(fileURLToPath(
  import.meta.url))

/**
 * Project root (one level above /scripts)
 */
const rootDir = path.resolve(__dirname, '..')

/**
 * Direct entry point for Nuxt CLI (nuxi)
 * â†’ no .bin symlinks, no shebang, no shell:true
 */
const nuxtEntry = path.join(
  rootDir,
  'node_modules',
  '@nuxt',
  'cli',
  'bin',
  'nuxi.mjs'
)

/**
 * Dev parameters
 */
const host = '127.0.0.1'
const port = process.env.PORT ?? '3000'
const passThroughArgs = process.argv.slice(2)

const nuxtArgs = [
  nuxtEntry,
  'dev',
  '--host',
  host,
  '--port',
  port,
  ...passThroughArgs
]

/**
 * Spawn via explicit Node binary
 */
const runner = spawn(
  process.execPath, // garantiert der richtige Node
  nuxtArgs, {
    stdio: 'inherit',
    cwd: rootDir,
    env: {
      ...process.env
    }
  }
)

/**
 * Forward exit code cleanly
 */
runner.on('exit', (code, signal) => {
  if (typeof code === 'number') {
    process.exitCode = code
  } else if (signal) {
    process.exitCode = 1
  }
})



=========================================
File: services/fileSystemRepository.ts
=========================================

export type FileEntry = {
  name: string
  path: string
}

export type DirEntry = FileEntry

export type DirectoryListing = {
  dirs: DirEntry[]
  files: FileEntry[]
}

export interface FileSystemRepository {
  listDir(path: string): Promise<DirectoryListing>
  stat(path: string): Promise<{ isDir: boolean }>
  readFileMeta(path: string): Promise<{ name: string; extension?: string }>
  requestAccess?: () => Promise<boolean>
  readFileBlob?: (path: string) => Promise<Blob>
}

declare global {
  interface Window {
    showDirectoryPicker?: () => Promise<FileSystemDirectoryHandle>
  }
}

type FsNode = {
  name: string
  children?: FsNode[]
}

const defaultTree: FsNode = {
  name: '/',
  children: [
    {
      name: 'Samples',
      children: [
        { name: 'kick.wav' },
        { name: 'snare.wav' },
        { name: 'hat.wav' },
        { name: 'loops', children: [{ name: 'break1.wav' }] }
      ]
    },
    {
      name: 'Imports',
      children: [
        { name: 'vox.wav' },
        { name: 'bass.aiff' }
      ]
    }
  ]
}

const buildPath = (parent: string, child: string): string => {
  const normalizedParent = parent.endsWith('/') ? parent.slice(0, -1) : parent
  return `${normalizedParent}/${child}`.replace(/\/+/g, '/')
}

const normalizePath = (path: string): string => {
  const parts = path.split('/').filter(Boolean)
  return parts.length === 0 ? '/' : `/${parts.join('/')}`
}

const isDirectoryHandle = (handle: FileSystemHandle): handle is FileSystemDirectoryHandle =>
  handle.kind === 'directory'

const isFileHandle = (handle: FileSystemHandle): handle is FileSystemFileHandle => handle.kind === 'file'

const getDirectoryPicker = (): (() => Promise<FileSystemDirectoryHandle>) => {
  if (typeof window === 'undefined' || typeof window.showDirectoryPicker !== 'function') {
    throw new Error('File System Access API not supported')
  }
  return window.showDirectoryPicker
}

const hasFileSystemAccess = (): boolean => {
  if (typeof window === 'undefined') return false
  if (typeof import.meta !== 'undefined' && 'client' in import.meta && !import.meta.client) {
    return false
  }
  return typeof window.showDirectoryPicker === 'function'
}

class BrowserFileSystemRepository implements FileSystemRepository {
  private rootHandle: FileSystemDirectoryHandle | null = null
  private handleCache = new Map<string, FileSystemHandle>()

  async requestAccess(): Promise<boolean> {
    try {
      const picker = getDirectoryPicker()
      this.rootHandle = await picker()
      this.handleCache.clear()
      this.handleCache.set('/', this.rootHandle)
      return true
    } catch {
      return false
    }
  }

  private async resolveHandle(path: string): Promise<FileSystemHandle | null> {
    const normalized = normalizePath(path)
    const cached = this.handleCache.get(normalized)
    if (cached) return cached
    if (!this.rootHandle) return null
    const parts = normalized.split('/').filter(Boolean)
    let current: FileSystemDirectoryHandle | null = this.rootHandle
    let currentPath = '/'
    for (let index = 0; index < parts.length; index += 1) {
      const part = parts[index]
      if (!current) return null
      const nextPath = buildPath(currentPath, part)
      let nextHandle: FileSystemHandle | null = null
      try {
        nextHandle = await current.getDirectoryHandle(part)
      } catch {
        try {
          nextHandle = await current.getFileHandle(part)
        } catch {
          nextHandle = null
        }
      }
      if (!nextHandle) return null
      this.handleCache.set(nextPath, nextHandle)
      if (isDirectoryHandle(nextHandle)) {
        current = nextHandle
      } else {
        current = null
      }
      currentPath = nextPath
    }
    return this.handleCache.get(normalized) ?? null
  }

  private async resolveDirectoryHandle(path: string): Promise<FileSystemDirectoryHandle | null> {
    const handle = await this.resolveHandle(path)
    if (handle && isDirectoryHandle(handle)) return handle
    return null
  }

  private async resolveFileHandle(path: string): Promise<FileSystemFileHandle | null> {
    const handle = await this.resolveHandle(path)
    if (handle && isFileHandle(handle)) return handle
    return null
  }

  async listDir(path: string): Promise<DirectoryListing> {
    if (!this.rootHandle) {
      const granted = await this.requestAccess()
      if (!granted) return { dirs: [], files: [] }
    }
    const dirHandle = await this.resolveDirectoryHandle(path)
    if (!dirHandle) return { dirs: [], files: [] }
    const dirs: DirEntry[] = []
    const files: FileEntry[] = []
    for await (const [name, handle] of dirHandle.entries()) {
      const entryPath = buildPath(normalizePath(path), name)
      if (isDirectoryHandle(handle)) {
        dirs.push({ name, path: entryPath })
      } else if (isFileHandle(handle)) {
        files.push({ name, path: entryPath })
      }
      this.handleCache.set(entryPath, handle)
    }
    return { dirs, files }
  }

  async stat(path: string): Promise<{ isDir: boolean }> {
    if (!this.rootHandle) {
      const granted = await this.requestAccess()
      if (!granted) return { isDir: false }
    }
    const handle = await this.resolveHandle(path)
    return { isDir: handle?.kind === 'directory' }
  }

  async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
    const name = path.split('/').pop() ?? path
    const parts = name.split('.')
    const extension = parts.length > 1 ? parts.pop() : undefined
    const meta: { name: string; extension?: string } = { name }
    if (extension) {
      meta.extension = extension
    }
    return meta
  }

  async readFileBlob(path: string): Promise<Blob> {
    if (!this.rootHandle) {
      const granted = await this.requestAccess()
      if (!granted) return new Blob()
    }
    const handle = await this.resolveFileHandle(path)
    if (!handle) return new Blob()
    const file = await handle.getFile()
    return file
  }
}

const createMemoryFs = (root: FsNode = defaultTree): FileSystemRepository => {
  const findNode = (path: string): FsNode | null => {
    const parts = path.split('/').filter(Boolean)
    let cursor: FsNode | undefined = root
    if (parts.length === 0) return root
    for (const part of parts) {
      cursor = cursor?.children?.find((child) => child.name === part)
      if (!cursor) return null
    }
    return cursor ?? null
  }

  return {
    async listDir(path: string): Promise<DirectoryListing> {
      const node = findNode(path)
      if (!node || !node.children) {
        return { dirs: [], files: [] }
      }
      const dirs: DirEntry[] = []
      const files: FileEntry[] = []
      node.children.forEach((child) => {
        const entryPath = buildPath(path || '/', child.name)
        if (child.children) {
          dirs.push({ name: child.name, path: entryPath })
        } else {
          files.push({ name: child.name, path: entryPath })
        }
      })
      return { dirs, files }
    },
    async stat(path: string): Promise<{ isDir: boolean }> {
      const node = findNode(path)
      return { isDir: !!node?.children }
    },
    async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
      const name = path.split('/').pop() ?? path
      const parts = name.split('.')
      const extension = parts.length > 1 ? parts.pop() : undefined
      const meta: { name: string; extension?: string } = { name }
      if (extension) {
        meta.extension = extension
      }
      return meta
    }
  }
}

let repository: FileSystemRepository | null = null

export const getFileSystemRepository = (): FileSystemRepository => {
  if (repository) return repository
  if (hasFileSystemAccess()) {
    repository = new BrowserFileSystemRepository()
    return repository
  }
  repository = createMemoryFs()
  return repository
}

export const __setFileSystemRepositoryForTests = (repo: FileSystemRepository) => {
  repository = repo
}

export const __resetFileSystemRepository = () => {
  repository = null
}



=========================================
File: services/libraryRepository.ts
=========================================

import { getFileSystemRepository } from './fileSystemRepository'
import * as sampleDb from './sampleDb'

export type LibraryItem = {
  id: string
  name: string
  path?: string
  tags: string[]
  importedAt?: number
  lastUsedAtMs?: number
  fileType?: string
  contentType?: string
  category?: string
  product?: string
  bank?: string
  subBank?: string
  character?: string
  vendor?: 'factory' | 'user'
  favorites?: boolean
}

export type LibrarySearchFilters = Record<string, string | string[] | boolean | undefined>

export interface ImportProgress {
  total: number
  completed: number
  current: string
  errors: string[]
}

export interface LibraryRepository {
  search(query: string, filters?: LibrarySearchFilters): Promise<LibraryItem[]>
  getItem(id: string): Promise<LibraryItem | undefined>
  getTags(itemId: string): Promise<string[]>
  addTag(itemId: string, tag: string): Promise<string[]>
  removeTag(itemId: string, tag: string): Promise<string[]>
  importFile(path: string, meta?: Partial<LibraryItem>): Promise<LibraryItem>
  addToFavorites(itemId: string): Promise<void>
  removeFromFavorites(itemId: string): Promise<void>
  getFavorites(): Promise<LibraryItem[]>
  isFavorite(itemId: string): Promise<boolean>
  getCategories?: () => Promise<string[]>
  getProducts?: (category?: string) => Promise<string[]>
  getBanks?: (product?: string) => Promise<string[]>
  getSubBanks?: (bank?: string) => Promise<string[]>
  refreshIndex(): Promise<void>
  importDirectory?(
    path: string,
    options?: { recursive?: boolean },
    onProgress?: (progress: ImportProgress) => void
  ): Promise<void>
}

const STORAGE_KEY = 'drumcomputer_library_items_v1'
const FAVORITES_KEY = 'drumcomputer_favorites_v1'

const normalizeTag = (value: string): string => value.trim().toLowerCase()
const supportedExtensions = new Set(['wav', 'wave', 'mp3', 'aiff', 'aif', 'flac', 'ogg'])

const getExtension = (path: string): string => {
  const name = path.split('/').pop() ?? ''
  const parts = name.split('.')
  if (parts.length < 2) return ''
  return (parts.pop() ?? '').toLowerCase()
}

const extractMetadataFromPath = (path: string): Partial<LibraryItem> => {
  const parts = path.split('/').filter(Boolean)
  return {
    category: parts[0],
    product: parts[1],
    bank: parts[2],
    subBank: parts[3],
    character: parts[4],
    vendor: 'user'
  }
}

const createLocalRepository = (): LibraryRepository => {
  let items: LibraryItem[] = loadPersisted()
  let favorites = loadFavorites()
  let migrationTriggered = false
  const DB_SEARCH_THRESHOLD = 50

  // Trigger migration on first access
  async function ensureMigration() {
    if (migrationTriggered) return
    migrationTriggered = true
    try {
      await sampleDb.migrateFromLocalStorage()
    } catch (error) {
      console.error('IndexedDB migration failed:', error)
    }
  }

  function persist() {
    try {
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(items))
      }
    } catch {
      // ignore persistence errors in non-browser environments
    }
  }

  function loadPersisted(): LibraryItem[] {
    try {
      if (typeof localStorage === 'undefined') return []
      const raw = localStorage.getItem(STORAGE_KEY)
      if (!raw) return []
      const parsed = JSON.parse(raw)
      if (Array.isArray(parsed)) {
        return parsed.map((entry) => ({
          ...entry,
          tags: Array.isArray(entry?.tags) ? entry.tags.map(String) : []
        }))
      }
    } catch {
      // ignore
    }
    return []
  }

  function persistFavorites() {
    try {
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem(FAVORITES_KEY, JSON.stringify(Array.from(favorites)))
      }
    } catch {
      // ignore
    }
  }

  function loadFavorites(): Set<string> {
    try {
      if (typeof localStorage === 'undefined') return new Set()
      const raw = localStorage.getItem(FAVORITES_KEY)
      if (!raw) return new Set()
      const parsed = JSON.parse(raw)
      if (Array.isArray(parsed)) {
        return new Set(parsed.map(String))
      }
    } catch {
      // ignore
    }
    return new Set()
  }

  return {
    async search(query: string, _filters?: LibrarySearchFilters): Promise<LibraryItem[]> {
      await ensureMigration()

      const text = query.trim().toLowerCase()

      // Use IndexedDB search if item count exceeds threshold
      if (items.length > DB_SEARCH_THRESHOLD) {
        try {
          const dbResults = await sampleDb.search(text)
          return dbResults.map((entry): LibraryItem => {
            const item: LibraryItem = {
              id: entry.path,
              name: entry.name,
              path: entry.path,
              tags: entry.tags
            }
            if (entry.importedAt !== undefined) item.importedAt = entry.importedAt
            if (entry.lastUsedAtMs !== undefined) item.lastUsedAtMs = entry.lastUsedAtMs
            if (entry.fileType !== undefined) item.fileType = entry.fileType
            if (entry.contentType !== undefined) item.contentType = entry.contentType
            if (entry.category !== undefined) item.category = entry.category
            if (entry.product !== undefined) item.product = entry.product
            if (entry.bank !== undefined) item.bank = entry.bank
            if (entry.subBank !== undefined) item.subBank = entry.subBank
            if (entry.character !== undefined) item.character = entry.character
            if (entry.vendor !== undefined) item.vendor = entry.vendor
            if (entry.favorites !== undefined) item.favorites = entry.favorites
            return item
          })
        } catch (error) {
          console.error('IndexedDB search failed, fallback to localStorage:', error)
          // Fallback to in-memory search
        }
      }

      // Fallback: in-memory search (for small collections or DB errors)
      if (!text) return [...items]
      return items.filter((item) => {
        const haystack = `${item.name} ${item.tags.join(' ')}`.toLowerCase()
        return haystack.includes(text)
      })
    },
    async getItem(id: string) {
      return items.find((item) => item.id === id)
    },
    async getTags(itemId: string) {
      return (await this.getItem(itemId))?.tags ?? []
    },
    async addTag(itemId: string, tag: string) {
      const normalized = normalizeTag(tag)
      items = items.map((item) => {
        if (item.id !== itemId) return item
        const tags = new Set(item.tags.map(normalizeTag))
        tags.add(normalized)
        return { ...item, tags: Array.from(tags) }
      })
      persist()
      return (await this.getTags(itemId)) ?? []
    },
    async removeTag(itemId: string, tag: string) {
      const normalized = normalizeTag(tag)
      items = items.map((item) => {
        if (item.id !== itemId) return item
        return { ...item, tags: item.tags.filter((value) => normalizeTag(value) !== normalized) }
      })
      persist()
      return (await this.getTags(itemId)) ?? []
    },
    async importFile(path: string, meta?: Partial<LibraryItem>) {
      await ensureMigration()

      const id = meta?.id ?? path
      const existing = items.find((item) => item.id === id)
      const name = meta?.name ?? path.split('/').pop() ?? 'Sample'
      const now = Date.now()
      const next: LibraryItem = {
        id,
        name,
        path,
        tags: existing?.tags ?? [],
        importedAt: existing?.importedAt ?? now,
        lastUsedAtMs: now,
        ...meta
      }
      if (existing) {
        items = items.map((item) => (item.id === id ? next : item))
      } else {
        items = [...items, next]
      }
      persist()

      // Write to IndexedDB (only if we have guaranteed path)
      if (path && next.lastUsedAtMs !== undefined) {
        try {
          const dbEntry: sampleDb.SampleDbEntry = {
            path,
            name,
            tags: next.tags,
            lastUsedAtMs: next.lastUsedAtMs
          }
          if (next.importedAt !== undefined) dbEntry.importedAt = next.importedAt
          if (next.fileType !== undefined) dbEntry.fileType = next.fileType
          if (next.contentType !== undefined) dbEntry.contentType = next.contentType
          if (next.category !== undefined) dbEntry.category = next.category
          if (next.product !== undefined) dbEntry.product = next.product
          if (next.bank !== undefined) dbEntry.bank = next.bank
          if (next.subBank !== undefined) dbEntry.subBank = next.subBank
          if (next.character !== undefined) dbEntry.character = next.character
          if (next.vendor !== undefined) dbEntry.vendor = next.vendor
          if (next.favorites !== undefined) dbEntry.favorites = next.favorites

          await sampleDb.upsertFromPath(dbEntry)
        } catch (error) {
          console.error('Failed to write to IndexedDB:', error)
        }
      }

      return next
    },
    async addToFavorites(itemId: string) {
      favorites.add(itemId)
      persistFavorites()
    },
    async removeFromFavorites(itemId: string) {
      favorites.delete(itemId)
      persistFavorites()
    },
    async getFavorites() {
      return items.filter((item) => favorites.has(item.id))
    },
    async isFavorite(itemId: string) {
      return favorites.has(itemId)
    },
    async getCategories() {
      const values = items.map((item) => item.category).filter((value): value is string => !!value)
      return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }))
    },
    async getProducts(category?: string) {
      const filtered = category ? items.filter((item) => item.category === category) : items
      const values = filtered.map((item) => item.product).filter((value): value is string => !!value)
      return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }))
    },
    async getBanks(product?: string) {
      const filtered = product ? items.filter((item) => item.product === product) : items
      const values = filtered.map((item) => item.bank).filter((value): value is string => !!value)
      return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }))
    },
    async getSubBanks(bank?: string) {
      const filtered = bank ? items.filter((item) => item.bank === bank) : items
      const values = filtered.map((item) => item.subBank).filter((value): value is string => !!value)
      return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }))
    },
    async refreshIndex() {
      items = loadPersisted()
      favorites = loadFavorites()
    },
    async importDirectory(path: string, options, onProgress) {
      const repo = getFileSystemRepository()
      const recursive = options?.recursive ?? false
      const errors: string[] = []
      const filesToImport: string[] = []

      const collectFiles = async (dirPath: string) => {
        try {
          const listing = await repo.listDir(dirPath)
          for (const file of listing.files) {
            const extension = getExtension(file.path)
            if (!supportedExtensions.has(extension)) {
              errors.push(file.path)
              continue
            }
            filesToImport.push(file.path)
          }
          if (recursive) {
            for (const dir of listing.dirs) {
              await collectFiles(dir.path)
            }
          }
        } catch {
          errors.push(dirPath)
        }
      }

      await collectFiles(path)

      const total = filesToImport.length
      let completed = 0
      for (const filePath of filesToImport) {
        try {
          const meta = extractMetadataFromPath(filePath)
          await this.importFile(filePath, meta)
        } catch {
          errors.push(filePath)
        }
        completed += 1
        onProgress?.({ total, completed, current: filePath, errors: [...errors] })
      }

      if (errors.length > 0) {
        console.warn('Import completed with errors', errors)
      }
    }
  }
}

let repository: LibraryRepository = createLocalRepository()

export const getLibraryRepository = (): LibraryRepository => repository

export const __setLibraryRepositoryForTests = (repo: LibraryRepository) => {
  repository = repo
}

export const __resetLibraryRepository = () => {
  repository = createLocalRepository()
}



=========================================
File: services/sampleDb.ts
=========================================

/**
 * IndexedDB-based sample database for performant search and metadata storage.
 * Schema:
 * - samples: { path (key), name, tags[], lastUsedAtMs, importedAt, ...metadata }
 * - tokens: { token, path } for full-text search via tokenization
 */

export interface SampleDbEntry {
  path: string // Primary key
  name: string
  tags: string[]
  lastUsedAtMs?: number
  importedAt?: number
  fileType?: string
  contentType?: string
  category?: string
  product?: string
  bank?: string
  subBank?: string
  character?: string
  vendor?: 'factory' | 'user'
  favorites?: boolean
}

interface TokenEntry {
  token: string
  path: string
}

const DB_NAME = 'drumcomputer-samples'
const DB_VERSION = 1
const SAMPLES_STORE = 'samples'
const TOKENS_STORE = 'tokens'

let dbInstance: IDBDatabase | null = null
let dbPromise: Promise<IDBDatabase> | null = null

/**
 * Open IndexedDB connection with schema initialization.
 * Creates 'samples' and 'tokens' object stores with appropriate indices.
 */
export async function openDb(): Promise<IDBDatabase> {
  if (dbInstance) return dbInstance
  if (dbPromise) return dbPromise

  dbPromise = new Promise<IDBDatabase>((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION)

    request.onerror = () => reject(request.error)
    request.onsuccess = () => {
      dbInstance = request.result
      resolve(dbInstance)
    }

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result

      // Samples store: path is primary key
      if (!db.objectStoreNames.contains(SAMPLES_STORE)) {
        const samplesStore = db.createObjectStore(SAMPLES_STORE, { keyPath: 'path' })
        samplesStore.createIndex('lastUsedAtMs', 'lastUsedAtMs', { unique: false })
        samplesStore.createIndex('importedAt', 'importedAt', { unique: false })
        samplesStore.createIndex('tags', 'tags', { unique: false, multiEntry: true })
      }

      // Tokens store: compound index for token-based search
      if (!db.objectStoreNames.contains(TOKENS_STORE)) {
        const tokensStore = db.createObjectStore(TOKENS_STORE, { autoIncrement: true })
        tokensStore.createIndex('token', 'token', { unique: false })
        tokensStore.createIndex('path', 'path', { unique: false })
        tokensStore.createIndex('token_path', ['token', 'path'], { unique: true })
      }
    }
  })

  return dbPromise
}

/**
 * Tokenize string into searchable tokens (lowercase, split by non-alphanumeric).
 */
function tokenize(text: string): string[] {
  return text
    .toLowerCase()
    .split(/[^a-z0-9]+/)
    .filter((token) => token.length > 0)
}

/**
 * Upsert sample entry and update token index atomically.
 */
export async function upsertFromPath(entry: SampleDbEntry): Promise<void> {
  const db = await openDb()
  const tx = db.transaction([SAMPLES_STORE, TOKENS_STORE], 'readwrite')
  const samplesStore = tx.objectStore(SAMPLES_STORE)
  const tokensStore = tx.objectStore(TOKENS_STORE)

  // Write sample entry
  samplesStore.put(entry)

  // Delete old tokens for this path using cursor
  const pathIndex = tokensStore.index('path')
  const cursorRequest = pathIndex.openCursor(IDBKeyRange.only(entry.path))

  await new Promise<void>((resolve, reject) => {
    const keysToDelete: IDBValidKey[] = []

    cursorRequest.onsuccess = () => {
      const cursor = cursorRequest.result
      if (cursor) {
        keysToDelete.push(cursor.primaryKey)
        cursor.continue()
      } else {
        // Delete collected keys
        keysToDelete.forEach((key) => tokensStore.delete(key))

        // Write new tokens
        const tokens = new Set<string>()
        tokenize(entry.name).forEach((t) => tokens.add(t))
        tokenize(entry.path).forEach((t) => tokens.add(t))
        entry.tags.forEach((tag) => tokenize(tag).forEach((t) => tokens.add(t)))

        tokens.forEach((token) => {
          tokensStore.put({ token, path: entry.path } as TokenEntry)
        })

        resolve()
      }
    }
    cursorRequest.onerror = () => reject(cursorRequest.error)
  })

  return new Promise<void>((resolve, reject) => {
    tx.oncomplete = () => resolve()
    tx.onerror = () => reject(tx.error)
  })
}

/**
 * Get sample entry by path.
 */
export async function getByPath(path: string): Promise<SampleDbEntry | null> {
  const db = await openDb()
  const tx = db.transaction(SAMPLES_STORE, 'readonly')
  const store = tx.objectStore(SAMPLES_STORE)
  const request = store.get(path)

  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result ?? null)
    request.onerror = () => reject(request.error)
  })
}

/**
 * Search samples by query string using token index.
 * Returns samples where any token matches query tokens.
 */
export async function search(query: string): Promise<SampleDbEntry[]> {
  const db = await openDb()
  const queryTokens = tokenize(query)

  if (queryTokens.length === 0) {
    // Empty query: return all samples sorted by lastUsedAtMs
    return getRecent()
  }

  const tx = db.transaction([TOKENS_STORE, SAMPLES_STORE], 'readonly')
  const tokensStore = tx.objectStore(TOKENS_STORE)
  const samplesStore = tx.objectStore(SAMPLES_STORE)
  const tokenIndex = tokensStore.index('token')

  const matchingPaths = new Set<string>()

  // Find all paths matching any query token
  for (const token of queryTokens) {
    const range = IDBKeyRange.bound(token, token + '\uffff', false, true)
    const request = tokenIndex.getAll(range)

    await new Promise<void>((resolve, reject) => {
      request.onsuccess = () => {
        const results = request.result as TokenEntry[]
        results.forEach((entry) => matchingPaths.add(entry.path))
        resolve()
      }
      request.onerror = () => reject(request.error)
    })
  }

  // Fetch all matching samples
  const results: SampleDbEntry[] = []
  for (const path of matchingPaths) {
    const request = samplesStore.get(path)
    const entry = await new Promise<SampleDbEntry | null>((resolve, reject) => {
      request.onsuccess = () => resolve(request.result ?? null)
      request.onerror = () => reject(request.error)
    })
    if (entry) results.push(entry)
  }

  return results
}

/**
 * Update tags for an existing sample.
 */
export async function setTags(path: string, tags: string[]): Promise<void> {
  const existing = await getByPath(path)
  if (!existing) throw new Error(`Sample not found: ${path}`)

  existing.tags = tags
  await upsertFromPath(existing)
}

/**
 * Get recent samples sorted by lastUsedAtMs descending.
 */
export async function getRecent(limit?: number): Promise<SampleDbEntry[]> {
  const db = await openDb()
  const tx = db.transaction(SAMPLES_STORE, 'readonly')
  const store = tx.objectStore(SAMPLES_STORE)
  const index = store.index('lastUsedAtMs')
  const request = index.openCursor(null, 'prev')

  const results: SampleDbEntry[] = []

  return new Promise((resolve, reject) => {
    request.onsuccess = () => {
      const cursor = request.result
      if (cursor && (!limit || results.length < limit)) {
        results.push(cursor.value as SampleDbEntry)
        cursor.continue()
      } else {
        resolve(results)
      }
    }
    request.onerror = () => reject(request.error)
  })
}

/**
 * Get all samples (for migration or full export).
 */
export async function getAllSamples(): Promise<SampleDbEntry[]> {
  const db = await openDb()
  const tx = db.transaction(SAMPLES_STORE, 'readonly')
  const store = tx.objectStore(SAMPLES_STORE)
  const request = store.getAll()

  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result as SampleDbEntry[])
    request.onerror = () => reject(request.error)
  })
}

/**
 * Clear all data (for testing).
 */
export async function clearAll(): Promise<void> {
  const db = await openDb()
  const tx = db.transaction([SAMPLES_STORE, TOKENS_STORE], 'readwrite')
  tx.objectStore(SAMPLES_STORE).clear()
  tx.objectStore(TOKENS_STORE).clear()

  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve()
    tx.onerror = () => reject(tx.error)
  })
}

/**
 * Close DB connection (for cleanup).
 */
export function closeDb(): void {
  if (dbInstance) {
    dbInstance.close()
    dbInstance = null
    dbPromise = null
  }
}

/**
 * Migrate samples from localStorage libraryRepository to IndexedDB.
 * Called once on first init; sets flag 'sampleDb:migrated' to prevent re-migration.
 */
export async function migrateFromLocalStorage(): Promise<void> {
  if (typeof localStorage === 'undefined') return

  const migrated = localStorage.getItem('sampleDb:migrated')
  if (migrated === 'true') return // Already migrated

  try {
    const raw = localStorage.getItem('library:v2')
    if (!raw) {
      localStorage.setItem('sampleDb:migrated', 'true')
      return
    }

    const parsed = JSON.parse(raw)
    if (!Array.isArray(parsed)) {
      localStorage.setItem('sampleDb:migrated', 'true')
      return
    }

    // Migrate each item to IndexedDB
    for (const item of parsed) {
      if (item.path) {
        const entry: SampleDbEntry = {
          path: item.path,
          name: item.name ?? item.path.split('/').pop() ?? item.path,
          tags: Array.isArray(item.tags) ? item.tags : [],
          lastUsedAtMs: item.lastUsedAtMs,
          importedAt: item.importedAt,
          fileType: item.fileType,
          contentType: item.contentType,
          category: item.category,
          product: item.product,
          bank: item.bank,
          subBank: item.subBank,
          character: item.character,
          vendor: item.vendor,
          favorites: item.favorites
        }
        await upsertFromPath(entry)
      }
    }

    localStorage.setItem('sampleDb:migrated', 'true')
  } catch (error) {
    console.error('Migration from localStorage failed:', error)
    // Don't set migrated flag on error to retry next time
  }
}

// Test utilities
export function __resetSampleDb(): void {
  closeDb()
}



=========================================
File: stores/browser.ts
=========================================

import { defineStore } from 'pinia'
import { markRaw } from 'vue'
import { getFileSystemRepository, type DirectoryListing } from '../services/fileSystemRepository'
import { getLibraryRepository, type LibraryItem } from '../services/libraryRepository'
import { useRecentFiles, type RecentFileEntry } from '../composables/useRecentFiles'
import { useSamplePreview, type PreviewState } from '../composables/useSamplePreview.client'
import { useQuickBrowse, type BrowseHistoryEntry } from '../composables/useQuickBrowse'
import type { EncoderField } from '../composables/use4DEncoder'
import type { BrowserMode, BrowserResultItem, BrowserFileEntry as _BrowserFileEntry } from '../types/library'

type DisplayListItem = {
  title: string
  subtitle?: string
  active?: boolean
  value?: string
}

type DisplayPanelModel = {
  view: 'BROWSER' | 'FILE'
  title?: string
  summary?: string
  items?: DisplayListItem[]
}

type LibraryState = {
  query: string
  results: BrowserResultItem[]
  rawResults: BrowserResultItem[]
  selectedId: string | null
}

type FilesState = {
  currentPath: string
  entries: DirectoryListing
  rawEntries: DirectoryListing
  selectedPath: string | null
}

type HierarchyCache = {
  version: number
  categories: string[] | null
  products: Record<string, string[]>
  banks: Record<string, string[]>
  subBanks: Record<string, string[]>
}

const emptyListing: DirectoryListing = { dirs: [], files: [] }

export type SortMode = 'name-asc' | 'name-desc' | 'date-asc' | 'date-desc' | 'relevance'

export type BrowserFilters = {
  fileType?: 'sample' | 'kit' | 'pattern' | 'preset' | 'all'
  contentType?: 'factory' | 'user' | 'all'
  category?: string
  product?: string
  bank?: string
  subBank?: string
  character?: string
  tags?: string[]
  favorites?: boolean
}

const createInitialFilters = (): BrowserFilters => ({
  fileType: 'all',
  contentType: 'all',
  tags: [],
  favorites: false
})

const normalizeTags = (tags?: string[]) =>
  (tags ?? []).map((tag) => tag.trim().toLowerCase()).filter((tag) => tag.length > 0)

const matchesFilters = (item: BrowserResultItem, filters: BrowserFilters): boolean => {
  if (filters.fileType && filters.fileType !== 'all' && item.fileType !== filters.fileType) return false
  if (filters.contentType && filters.contentType !== 'all' && item.contentType !== filters.contentType) {
    return false
  }
  if (filters.category && item.category !== filters.category) return false
  if (filters.product && item.product !== filters.product) return false
  if (filters.bank && item.bank !== filters.bank) return false
  if (filters.subBank && item.subBank !== filters.subBank) return false
  if (filters.character && item.character !== filters.character) return false
  if (filters.favorites && item.favorites !== true) return false
  if (filters.tags && filters.tags.length > 0) {
    const requiredTags = normalizeTags(filters.tags)
    const itemTags = normalizeTags(item.tags)
    const hasAllTags = requiredTags.every((tag) => itemTags.includes(tag))
    if (!hasAllTags) return false
  }
  return true
}

const describeFilters = (filters: BrowserFilters): string => {
  const parts: string[] = []
  if (filters.fileType && filters.fileType !== 'all') parts.push(`Type: ${filters.fileType}`)
  if (filters.contentType && filters.contentType !== 'all') parts.push(`Content: ${filters.contentType}`)
  if (filters.category) parts.push(`Cat: ${filters.category}`)
  if (filters.product) parts.push(`Prod: ${filters.product}`)
  if (filters.bank) parts.push(`Bank: ${filters.bank}`)
  if (filters.subBank) parts.push(`Sub: ${filters.subBank}`)
  if (filters.tags && filters.tags.length > 0) parts.push(`Tags: ${filters.tags.join(', ')}`)
  if (filters.favorites) parts.push('Favs')
  return parts.join(', ')
}

const mapLibraryItemToResult = (item: LibraryItem, isFavorite: boolean): BrowserResultItem => ({
  id: item.id,
  title: item.name,
  ...(item.tags && item.tags.length > 0 ? { subtitle: item.tags.join(', '), tags: item.tags } : {}),
  ...(item.path ? { path: item.path } : {}),
  ...(item.importedAt ? { importedAt: item.importedAt } : {}),
  ...(item.fileType ? { fileType: item.fileType } : {}),
  ...(item.contentType ? { contentType: item.contentType } : {}),
  ...(item.category ? { category: item.category } : {}),
  ...(item.product ? { product: item.product } : {}),
  ...(item.bank ? { bank: item.bank } : {}),
  ...(item.subBank ? { subBank: item.subBank } : {}),
  ...(item.character ? { character: item.character } : {}),
  ...(isFavorite ? { favorites: true } : {})
})

const mapRecentType = (extension?: string): RecentFileEntry['type'] => {
  if (!extension) return 'sample'
  const normalized = extension.toLowerCase()
  if (normalized === 'kit') return 'kit'
  if (normalized === 'pattern') return 'pattern'
  if (normalized === 'preset') return 'preset'
  return 'sample'
}

const parsePathMeta = (path: string): { name: string; extension?: string } => {
  const name = path.split('/').pop() ?? path
  const extension = name.includes('.') ? name.split('.').pop() : undefined
  return extension !== undefined ? { name, extension } : { name }
}

const sortStorageKey = 'drumcomputer_sort_mode_v1'

const hasClientStorage = (): boolean => {
  if (typeof window === 'undefined' || typeof localStorage === 'undefined') return false
  return true
}

const loadSortMode = (): SortMode => {
  if (!hasClientStorage()) return 'relevance'
  try {
    const raw = localStorage.getItem(sortStorageKey)
    if (!raw) return 'relevance'
    const value = raw as SortMode
    if (['name-asc', 'name-desc', 'date-asc', 'date-desc', 'relevance'].includes(value)) {
      return value
    }
  } catch {
    // ignore
  }
  return 'relevance'
}

const persistSortMode = (mode: SortMode) => {
  if (!hasClientStorage()) return
  try {
    localStorage.setItem(sortStorageKey, mode)
  } catch {
    // ignore
  }
}

const sortLabel = (mode: SortMode): string => {
  switch (mode) {
    case 'name-asc':
      return 'Name â†‘'
    case 'name-desc':
      return 'Name â†“'
    case 'date-asc':
      return 'Date â†‘'
    case 'date-desc':
      return 'Date â†“'
    default:
      return 'Relevance'
  }
}

const searchDebounceMs = 300

const emptyPreviewState: PreviewState = {
  isPlaying: false,
  currentFile: null,
  progress: 0,
  duration: 0
}

const collectTags = (items: BrowserResultItem[]): string[] => {
  const tags = new Set<string>()
  items.forEach((item) => {
    item.tags?.forEach((tag) => {
      const trimmed = tag.trim()
      if (trimmed.length > 0) tags.add(trimmed)
    })
  })
  return Array.from(tags).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }))
}

export const useBrowserStore = defineStore('browser', {
  state: () => ({
    mode: 'LIBRARY' as BrowserMode,
    library: {
      query: '',
      results: [],
      rawResults: [],
      selectedId: null
    } as LibraryState,
    files: {
      currentPath: '/',
      entries: emptyListing,
      rawEntries: emptyListing,
      selectedPath: null
    } as FilesState,
    filters: createInitialFilters() as BrowserFilters,
    availableCategories: [] as string[],
    availableProducts: [] as string[],
    availableBanks: [] as string[],
    availableSubBanks: [] as string[],
    recentEntries: [] as RecentFileEntry[],
    availableTags: [] as string[],
    tagDialogOpen: false,
    tagDialogItemId: null as string | null,
    sortMode: loadSortMode(),
    hierarchyCacheVersion: 0,
    hierarchyCache: {
      version: 0,
      categories: null,
      products: {},
      banks: {},
      subBanks: {}
    } as HierarchyCache,
    searchDebounceId: null as ReturnType<typeof setTimeout> | null,
    searchDebounceToken: 0,
    preview: null as ReturnType<typeof useSamplePreview> | null
  }),
  getters: {
    recentFiles(state): RecentFileEntry[] {
      return state.recentEntries
    },
    previewState(state): PreviewState {
      return state.preview?.state ?? emptyPreviewState
    }
  },
  actions: {
    ensurePreview() {
      if (!this.preview) {
        this.preview = markRaw(useSamplePreview())
      }
      return this.preview
    },
    async setMode(mode: BrowserMode) {
      this.mode = mode
      if (mode === 'LIBRARY') {
        await this.loadAvailableTags()
        await this.search()
      } else {
        await this.listDir(this.files.currentPath || '/')
      }
    },
    async setQuery(query: string) {
      this.library.query = query
      if (this.searchDebounceId) {
        clearTimeout(this.searchDebounceId)
      }
      const token = this.searchDebounceToken + 1
      this.searchDebounceToken = token
      const runSearch = () => {
        if (this.searchDebounceToken !== token) return
        void this.search()
      }
      this.searchDebounceId = setTimeout(runSearch, searchDebounceMs)
    },
    search() {
      const repo = getLibraryRepository()
      const searchPromise = Promise.all([
        repo.getFavorites(),
        this.filters.favorites === true ? Promise.resolve<LibraryItem[]>([]) : repo.search(this.library.query ?? '', this.filters)
      ]).then(([favorites, results]) => {
        const favoriteIds = new Set(favorites.map((item) => item.id))
        const items = this.filters.favorites === true ? favorites : results
        const mapped = items.map((item) => mapLibraryItemToResult(item, favoriteIds.has(item.id)))
        const filtered = mapped.filter((item) => matchesFilters(item, this.filters))
        this.library.rawResults = filtered
        this.library.results = filtered
        if (this.library.selectedId && !filtered.find((entry) => entry.id === this.library.selectedId)) {
          this.library.selectedId = null
        }
        return filtered
      })
      void searchPromise.then(() => {
        void this.refreshHierarchyOptions()
        this.sortResults()
      })
      return searchPromise
    },
    setFilter<K extends keyof BrowserFilters>(key: K, value: BrowserFilters[K]) {
      const nextValue = Array.isArray(value) ? [...value] : value
      const nextFilters = { ...this.filters, [key]: nextValue } as BrowserFilters

      if (key === 'category') {
        delete nextFilters.product
        delete nextFilters.bank
        delete nextFilters.subBank
      }
      if (key === 'product') {
        delete nextFilters.bank
        delete nextFilters.subBank
      }
      if (key === 'bank') {
        delete nextFilters.subBank
      }

      this.filters = nextFilters
      void this.applyFilters()
    },
    async clearFilters() {
      this.filters = createInitialFilters()
      await this.applyFilters()
    },
    async applyFilters() {
      await this.search()
    },
    getAvailableOptions(filterKey: string): string[] {
      switch (filterKey) {
        case 'fileType':
          return ['all', 'sample', 'kit', 'pattern', 'preset']
        case 'contentType':
          return ['all', 'factory', 'user']
        case 'category':
          return this.availableCategories
        case 'product':
          return this.availableProducts
        case 'bank':
          return this.availableBanks
        case 'subBank':
          return this.availableSubBanks
        default:
          return []
      }
    },
    async refreshHierarchyOptions() {
      const repo = getLibraryRepository()
      const version = this.hierarchyCacheVersion
      if (this.hierarchyCache.version !== version) {
        this.hierarchyCache = {
          version,
          categories: null,
          products: {},
          banks: {},
          subBanks: {}
        }
      }
      if (!this.hierarchyCache.categories) {
        this.hierarchyCache.categories = (await repo.getCategories?.()) ?? []
      }
      const productKey = this.filters.category ?? ''
      if (!this.hierarchyCache.products[productKey]) {
        this.hierarchyCache.products[productKey] = (await repo.getProducts?.(this.filters.category)) ?? []
      }
      const bankKey = this.filters.product ?? ''
      if (!this.hierarchyCache.banks[bankKey]) {
        this.hierarchyCache.banks[bankKey] = (await repo.getBanks?.(this.filters.product)) ?? []
      }
      const subBankKey = this.filters.bank ?? ''
      if (!this.hierarchyCache.subBanks[subBankKey]) {
        this.hierarchyCache.subBanks[subBankKey] = (await repo.getSubBanks?.(this.filters.bank)) ?? []
      }
      this.availableCategories = this.hierarchyCache.categories ?? []
      this.availableProducts = this.hierarchyCache.products[productKey] ?? []
      this.availableBanks = this.hierarchyCache.banks[bankKey] ?? []
      this.availableSubBanks = this.hierarchyCache.subBanks[subBankKey] ?? []
    },
    invalidateHierarchyCache() {
      this.hierarchyCacheVersion += 1
    },
    getEncoderFields(): EncoderField[] {
      if (this.tagDialogOpen) {
        return this.availableTags.map((tag, index) => ({
          id: `tag-${index}`,
          label: tag,
          value: tag
        }))
      }
      const fields: EncoderField[] = [
        {
          id: 'fileType',
          label: 'Type',
          value: this.filters.fileType ?? 'all',
          options: this.getAvailableOptions('fileType')
        },
        {
          id: 'contentType',
          label: 'Factory/User',
          value: this.filters.contentType ?? 'all',
          options: this.getAvailableOptions('contentType')
        },
        {
          id: 'category',
          label: 'Category',
          value: this.filters.category ?? '',
          options: this.getAvailableOptions('category')
        },
        {
          id: 'product',
          label: 'Product',
          value: this.filters.product ?? '',
          options: this.getAvailableOptions('product')
        },
        {
          id: 'bank',
          label: 'Bank',
          value: this.filters.bank ?? '',
          options: this.getAvailableOptions('bank')
        },
        {
          id: 'tags',
          label: 'Tags',
          value: (this.filters.tags ?? []).join(', ')
        },
        {
          id: 'favorites',
          label: 'Favorites',
          value: this.filters.favorites ? 'on' : 'off',
          options: ['off', 'on']
        }
      ]
      if (this.availableSubBanks.length > 0 || this.filters.subBank) {
        fields.splice(5, 0, {
          id: 'subBank',
          label: 'Sub Bank',
          value: this.filters.subBank ?? '',
          options: this.getAvailableOptions('subBank')
        })
      }
      if (this.mode === 'FILES') {
        fields.push({
          id: 'sort',
          label: 'Sort',
          value: sortLabel(this.sortMode),
          options: ['Name â†‘', 'Name â†“', 'Date â†‘', 'Date â†“']
        })
      }
      return fields
    },
    async selectResult(id: string | null) {
      this.library.selectedId = id
    },
    async loadAvailableTags() {
      const repo = getLibraryRepository()
      const items = await repo.search('', undefined)
      const mapped = items.map((item) => mapLibraryItemToResult(item, false))
      this.availableTags = collectTags(mapped)
    },
    async openTagDialog(itemId: string) {
      this.tagDialogOpen = true
      this.tagDialogItemId = itemId
      await this.loadAvailableTags()
      await this.selectResult(itemId)
    },
    closeTagDialog() {
      this.tagDialogOpen = false
      this.tagDialogItemId = null
    },
    async addTagToSelected(tag: string) {
      const itemId = this.tagDialogItemId ?? this.library.selectedId
      if (!itemId) return
      const repo = getLibraryRepository()
      await repo.addTag(itemId, tag)
      await this.search()
      await this.loadAvailableTags()
      await this.selectResult(itemId)
    },
    async removeTagFromSelected(tag: string) {
      const itemId = this.tagDialogItemId ?? this.library.selectedId
      if (!itemId) return
      const repo = getLibraryRepository()
      await repo.removeTag(itemId, tag)
      await this.search()
      await this.loadAvailableTags()
      await this.selectResult(itemId)
    },
    getAvailableTags(): string[] {
      return this.availableTags
    },
    loadRecentFiles() {
      const recent = useRecentFiles()
      const entries = recent.getRecent()
      this.recentEntries = entries
      const mapped = entries.map((entry) => ({
        id: entry.id,
        title: entry.name,
        subtitle: entry.path,
        path: entry.path,
        timestamp: entry.timestamp
      }))
      this.library.rawResults = mapped
      this.library.results = mapped
      this.sortResults()
    },
    async addTag(tag: string) {
      if (!this.library.selectedId) return
      const repo = getLibraryRepository()
      await repo.addTag(this.library.selectedId, tag)
      await this.search()
    },
    async toggleFavorite(itemId: string) {
      const repo = getLibraryRepository()
      const isFavorite = await repo.isFavorite(itemId)
      if (isFavorite) {
        await repo.removeFromFavorites(itemId)
      } else {
        await repo.addToFavorites(itemId)
      }
      await this.search()
    },
    setSortMode(mode: SortMode) {
      this.sortMode = mode
      persistSortMode(mode)
      this.sortResults()
    },
    sortResults() {
      const mode = this.sortMode
      if (mode === 'relevance') {
        this.library.results = [...this.library.rawResults]
        this.files.entries = {
          dirs: [...this.files.rawEntries.dirs],
          files: [...this.files.rawEntries.files]
        }
        return
      }
      const nameSort = (a: string, b: string) => a.localeCompare(b, undefined, { sensitivity: 'base' })
      const dateValue = (value?: number) => (typeof value === 'number' ? value : 0)
      const sortedResults = [...this.library.rawResults].sort((a, b) => {
        if (mode === 'name-asc') return nameSort(a.title, b.title)
        if (mode === 'name-desc') return nameSort(b.title, a.title)
        const dateA = dateValue(a.importedAt ?? a.timestamp)
        const dateB = dateValue(b.importedAt ?? b.timestamp)
        return mode === 'date-asc' ? dateA - dateB : dateB - dateA
      })
      const sortedDirs = [...this.files.rawEntries.dirs].sort((a, b) => {
        if (mode === 'name-asc') return nameSort(a.name, b.name)
        if (mode === 'name-desc') return nameSort(b.name, a.name)
        return 0
      })
      const sortedFiles = [...this.files.rawEntries.files].sort((a, b) => {
        if (mode === 'name-asc') return nameSort(a.name, b.name)
        if (mode === 'name-desc') return nameSort(b.name, a.name)
        return 0
      })
      if (mode === 'date-asc' || mode === 'date-desc') {
        const fallback = mode === 'date-asc' ? 1 : -1
        sortedDirs.sort((a, b) => nameSort(a.name, b.name) * fallback)
        sortedFiles.sort((a, b) => nameSort(a.name, b.name) * fallback)
      }
      this.library.results = sortedResults
      this.files.entries = { dirs: sortedDirs, files: sortedFiles }
    },
    async removeTag(tag: string) {
      if (!this.library.selectedId) return
      const repo = getLibraryRepository()
      await repo.removeTag(this.library.selectedId, tag)
      await this.search()
    },
    async listDir(path: string) {
      const repo = getFileSystemRepository()
      this.files.currentPath = path || '/'
      this.files.entries = await repo.listDir(this.files.currentPath)
      this.files.rawEntries = this.files.entries
      if (this.files.selectedPath && !this.files.entries.files.find((file) => file.path === this.files.selectedPath)) {
        this.files.selectedPath = null
      }
      this.sortResults()
    },
    selectPath(path: string | null) {
      this.files.selectedPath = path
    },
    async importSelected(context?: { contextId?: string; contextType?: BrowseHistoryEntry['contextType'] }) {
      if (!this.files.selectedPath) return null
      const recent = useRecentFiles()
      const repo = getLibraryRepository()
      const meta = parsePathMeta(this.files.selectedPath)
      const importedItem = await repo.importFile(this.files.selectedPath, { name: meta.name })
      recent.addRecent({
        id: this.files.selectedPath,
        path: this.files.selectedPath,
        name: meta.name,
        type: mapRecentType(meta.extension)
      })
      const quickBrowse = useQuickBrowse()
      quickBrowse.recordBrowse({
        mode: this.mode,
        query: this.library.query,
        filters: this.filters,
        selectedId: this.library.selectedId,
        contextType: context?.contextType ?? 'sample',
        contextId: context?.contextId ?? 'global'
      })
      this.loadRecentFiles()
      this.invalidateHierarchyCache()
      await this.loadAvailableTags()
      await repo.refreshIndex()
      await this.search()
      return importedItem
    },
    openQuickBrowse(contextId: string) {
      const quickBrowse = useQuickBrowse()
      const entry = quickBrowse.getLastBrowse(contextId)
      if (entry) {
        quickBrowse.restoreBrowse(entry)
      }
    },
    async prehearSelected() {
      const preview = this.ensurePreview()
      const fileRepo = getFileSystemRepository()
      if (this.mode === 'FILES') {
        if (!this.files.selectedPath) return
        const blob = await fileRepo.readFileBlob?.(this.files.selectedPath)
        await preview.loadAndPlay(this.files.selectedPath, blob)
        return
      }
      if (this.library.selectedId) {
        const selected = this.library.results.find((item) => item.id === this.library.selectedId)
        if (!selected?.path) return
        const blob = await fileRepo.readFileBlob?.(selected.path)
        await preview.loadAndPlay(selected.path, blob)
      }
    },
    stopPrehear() {
      this.preview?.stop()
    },
    toDisplayModels(): { leftModel: DisplayPanelModel; rightModel: DisplayPanelModel } {
      const sortSummary = this.sortMode === 'relevance' ? '' : `Sorted by ${sortLabel(this.sortMode)}`
      if (this.tagDialogOpen) {
        const selectedId = this.tagDialogItemId ?? this.library.selectedId
        const selected = this.library.results.find((item) => item.id === selectedId)
        const selectedTags = selected?.tags ?? []
        const leftItems: DisplayListItem[] = this.availableTags.map((tag) => ({
          title: tag,
          subtitle: selectedTags.includes(tag) ? '[x]' : '[ ]'
        }))
        const rightItems: DisplayListItem[] = selectedTags.map((tag) => ({
          title: tag,
          subtitle: 'Remove'
        }))
        return {
          leftModel: {
            view: 'BROWSER',
            title: 'Add Tag',
            summary: `${selectedTags.length} tags`,
            items: leftItems
          },
          rightModel: {
            view: 'BROWSER',
            title: 'Current Tags',
            summary: 'Press to toggle',
            items: rightItems
          }
        }
      }
      if (this.mode === 'FILES') {
        const leftItems: DisplayListItem[] = this.files.entries.dirs.map((dir) => ({
          title: dir.name,
          subtitle: dir.path
        }))
        const rightItems: DisplayListItem[] = this.files.entries.files.map((file) => ({
          title: file.name,
          subtitle: file.path,
          active: file.path === this.files.selectedPath
        }))
        return {
          leftModel: {
            view: 'FILE',
            title: 'Directories',
            summary: this.files.currentPath,
            items: leftItems
          },
          rightModel: {
            view: 'FILE',
            title: 'Files',
            summary: [sortSummary || null, 'Select a file to import'].filter(Boolean).join(' â€¢ '),
            items: rightItems
          }
        }
      }
      const leftItems: DisplayListItem[] = [
        {
          title: 'Search',
          subtitle: [this.library.query || 'All', describeFilters(this.filters)].filter(Boolean).join(' â€¢ ')
        }
      ]
      const results = this.library.results
      const selectedIndex = results.findIndex((result) => result.id === this.library.selectedId)
      const maxItems = 100
      let start = 0
      if (results.length > maxItems) {
        const targetIndex = selectedIndex >= 0 ? selectedIndex : 0
        start = Math.max(0, Math.min(results.length - maxItems, targetIndex - Math.floor(maxItems / 3)))
      }
      const windowedResults = results.slice(start, start + maxItems)
      const rightItems: DisplayListItem[] = windowedResults.map((result) => {
        const subtitle = result.subtitle
        const decoratedSubtitle = result.favorites ? `${subtitle ? `${subtitle} ` : ''}â˜…` : subtitle
        const entry: DisplayListItem = {
          title: result.title,
          active: result.id === this.library.selectedId,
          value: result.id
        }
        if (decoratedSubtitle) {
          entry.subtitle = decoratedSubtitle
        }
        return entry
      })
      const leftSummary = [this.library.query || 'All', describeFilters(this.filters), sortSummary || null]
        .filter(Boolean)
        .join(' â€¢ ')
      return {
        leftModel: {
          view: 'BROWSER',
          title: 'Library',
          summary: leftSummary,
          items: leftItems
        },
        rightModel: {
          view: 'BROWSER',
          title: 'Results',
          summary: `${rightItems.length} items`,
          items: rightItems
        }
      }
    }
  }
})



=========================================
File: stores/control.ts
=========================================

import { defineStore } from 'pinia'
import { markRaw, type Raw } from 'vue'
import { use4DEncoder, type EncoderField, type Use4DEncoderReturn } from '../composables/use4DEncoder'
import { useBrowserStore, type BrowserFilters } from './browser'

export type ControlMode =
  | 'CHANNEL'
  | 'PLUGIN'
  | 'ARRANGER'
  | 'MIXER'
  | 'BROWSER'
  | 'SAMPLING'
  | 'FILE'
  | 'SETTINGS'
  | 'AUTO'
  | 'MACRO'

type SoftButton = {
  label: string
  actionId: string
  shiftLabel?: string | undefined
  shiftActionId?: string | undefined
  enabled: boolean
  description?: string | undefined
}

type EncoderParam = {
  id: string
  name: string
  value: number
  min: number
  max: number
  step: number
  fineStep?: number
  format?: string
  side?: 'left' | 'right'
}

type ListItem = {
  title: string
  subtitle?: string
  active?: boolean
  value?: string
  meter?: number
}

type DisplayPanelModel = {
  view:
  | 'BROWSER'
  | 'FILE'
  | 'SETTINGS'
  | 'SAMPLING'
  | 'MIXER'
  | 'ARRANGER'
  | 'INFO'
  | 'EMPTY'
  title?: string
  summary?: string
  items?: ListItem[]
  hint?: string
}

type ControlPage = {
  label: string
  softButtons: SoftButton[]
  params: EncoderParam[]
  leftModel: DisplayPanelModel
  rightModel: DisplayPanelModel
}

type PageIndexByMode = Record<ControlMode, number>

const MODES: ControlMode[] = [
  'CHANNEL',
  'PLUGIN',
  'ARRANGER',
  'MIXER',
  'BROWSER',
  'SAMPLING',
  'FILE',
  'SETTINGS',
  'AUTO',
  'MACRO'
]

const clamp = (value: number, min: number, max: number): number =>
  Math.max(min, Math.min(max, value))

const formatRelativeTimestamp = (timestamp: number): string => {
  const now = Date.now()
  const diffMs = Math.max(0, now - timestamp)
  const minuteMs = 60 * 1000
  const hourMs = 60 * minuteMs
  const dayMs = 24 * hourMs
  if (diffMs < minuteMs) return 'gerade'
  if (diffMs < hourMs) {
    const minutes = Math.floor(diffMs / minuteMs)
    return `vor ${minutes} Minute${minutes === 1 ? '' : 'n'}`
  }
  const nowDate = new Date(now)
  const entryDate = new Date(timestamp)
  const sameDay =
    nowDate.getFullYear() === entryDate.getFullYear() &&
    nowDate.getMonth() === entryDate.getMonth() &&
    nowDate.getDate() === entryDate.getDate()
  if (sameDay) return 'heute'
  const days = Math.floor(diffMs / dayMs)
  if (days === 1) return 'gestern'
  return `vor ${Math.max(2, days)} Tagen`
}

const parseFieldValueForFilter = (field: EncoderField): BrowserFilters[keyof BrowserFilters] => {
  if (field.id === 'favorites') {
    return String(field.value) === 'on'
  }
  if (field.id === 'tags') {
    if (typeof field.value !== 'string') return []
    const tags = field.value
      .split(',')
      .map((tag) => tag.trim())
      .filter((tag) => tag.length > 0)
    return tags
  }
  if (typeof field.value === 'number') {
    return String(field.value)
  }
  return field.value as BrowserFilters[keyof BrowserFilters]
}

const parseSortMode = (value: EncoderField['value']): 'name-asc' | 'name-desc' | 'date-asc' | 'date-desc' | 'relevance' => {
  const label = String(value)
  if (label.includes('Name â†‘')) return 'name-asc'
  if (label.includes('Name â†“')) return 'name-desc'
  if (label.includes('Date â†‘')) return 'date-asc'
  if (label.includes('Date â†“')) return 'date-desc'
  return 'relevance'
}

const buildSoftButtons = (buttons: Partial<SoftButton>[]): SoftButton[] => {
  const defaults: SoftButton = {
    label: '',
    actionId: 'noop',
    enabled: false,
    description: undefined
  }
  const filled = buttons.map((btn) => ({
    ...defaults,
    ...btn,
    enabled: btn.enabled !== false
  }))
  while (filled.length < 8) {
    filled.push({ ...defaults })
  }
  return filled.slice(0, 8)
}

const buildParams = (params: Partial<EncoderParam>[]): EncoderParam[] => {
  const defaults: EncoderParam = {
    id: 'param',
    name: '',
    value: 0,
    min: 0,
    max: 127,
    step: 1,
    side: 'left'
  }
  const filled = params.map((param, index) => ({
    ...defaults,
    id: param.id ?? `param-${index + 1}`,
    name: param.name ?? `Param ${index + 1}`,
    ...param
  }))
  while (filled.length < 8) {
    const idx = filled.length + 1
    filled.push({ ...defaults, id: `param-${idx}`, name: `Param ${idx}`, side: idx <= 4 ? 'left' : 'right' })
  }
  return filled.slice(0, 8)
}

const buildPreviewParams = (): EncoderParam[] =>
  buildParams([
    { id: 'preview-vol', name: 'Preview Vol', value: 80, min: 0, max: 100, step: 1 },
    { id: 'preview-start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
    { id: 'preview-end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
    { id: 'preview-tune', name: 'Tune', value: 0, min: -12, max: 12, step: 1 }
  ])

const browserPages: ControlPage[] = [
  {
    label: 'Library',
    softButtons: buildSoftButtons([
      { label: 'Search', actionId: 'BROWSER_SEARCH', shiftLabel: 'Plug-In Menu', shiftActionId: 'BROWSER_PLUGIN_MENU' },
      { label: 'Type', actionId: 'BROWSER_TYPE' },
      { label: 'Tag', actionId: 'BROWSER_TAG' },
      { label: 'Favorites', actionId: 'BROWSER_FAVORITES' },
      { label: 'Prehear', actionId: 'BROWSER_PREHEAR', shiftLabel: 'Stop', shiftActionId: 'BROWSER_STOP' },
      { label: 'Load', actionId: 'BROWSER_LOAD' },
      { label: 'Import', actionId: 'BROWSER_IMPORT_TO_PAD', description: 'Import to selected pad (Ctrl+Enter)' },
      { label: 'Clear', actionId: 'BROWSER_CLEAR' }
    ]),
    params: buildParams([
      { id: 'filter1', name: 'Filter', value: 40, min: 0, max: 100, step: 2, format: '%' },
      { id: 'cutoff', name: 'Cutoff', value: 72, min: 0, max: 127, step: 3 },
      { id: 'res', name: 'Resonance', value: 32, min: 0, max: 127, step: 3 },
      { id: 'rate', name: 'Rate', value: 4, min: 1, max: 16, step: 1 },
      { id: 'depth', name: 'Depth', value: 25, min: 0, max: 100, step: 1, side: 'right' },
      { id: 'space', name: 'Space', value: 35, min: 0, max: 100, step: 1, side: 'right' },
      { id: 'tone', name: 'Tone', value: 64, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'volume', name: 'Volume', value: 90, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'BROWSER',
      title: 'Browser',
      summary: 'Navigate library',
      items: [
        { title: 'Drums', subtitle: 'Kits, Percussion', active: true },
        { title: 'Instruments', subtitle: 'Bass, Keys' },
        { title: 'Loops', subtitle: 'Textures' },
        { title: 'User', subtitle: 'Local content' }
      ],
      hint: 'SHIFT: Plug-in menu'
    },
    rightModel: {
      view: 'BROWSER',
      title: 'Results',
      items: [
        { title: 'Neon Kit', subtitle: 'Kit â€¢ 16 samples', active: true },
        { title: 'Marble Kit', subtitle: 'Kit â€¢ 16 samples' },
        { title: 'Dusty Breaks', subtitle: 'Loop â€¢ 92 BPM' },
        { title: 'Glass Pluck', subtitle: 'Instrument' }
      ],
      summary: 'Use Load or Replace'
    }
  },
  {
    label: 'Recent',
    softButtons: buildSoftButtons([
      { label: 'Recent', actionId: 'BROWSER_RECENT' },
      { label: 'Clear', actionId: 'BROWSER_CLEAR_RECENT' },
      { label: 'Fav', actionId: 'BROWSER_FAVORITE' },
      { label: 'Tag', actionId: 'BROWSER_TAG_RECENT' },
      { label: 'Load', actionId: 'BROWSER_LOAD_RECENT' },
      { label: 'Prehear', actionId: 'BROWSER_PREHEAR' },
      { label: 'Replace', actionId: 'BROWSER_REPLACE' },
      { label: 'Stop', actionId: 'BROWSER_STOP' }
    ]),
    params: buildParams([
      { id: 'recent-volume', name: 'Preview Vol', value: 68, min: 0, max: 127, step: 2 },
      { id: 'recent-start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
      { id: 'recent-end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
      { id: 'recent-tune', name: 'Tune', value: 64, min: 0, max: 127, step: 1 },
      { id: 'recent-form', name: 'Formant', value: 64, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'recent-pan', name: 'Pan', value: 64, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'recent-dry', name: 'Dry/Wet', value: 80, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'recent-level', name: 'Level', value: 90, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'BROWSER',
      title: 'Recent Files',
      items: [
        { title: 'Deep Snare', subtitle: 'Sample', active: true },
        { title: 'Air Hat', subtitle: 'Sample' },
        { title: 'Chop Vox', subtitle: 'Sample' },
        { title: 'Lo-fi Loop', subtitle: 'Loop â€¢ 87 BPM' }
      ]
    },
    rightModel: {
      view: 'BROWSER',
      title: 'Preview',
      summary: 'Use Prehear',
      items: [
        { title: 'Waveform', subtitle: '00:12', value: 'Fade-in' },
        { title: 'Slice Points', subtitle: 'Auto â€¢ 8' }
      ]
    }
  }
]

const channelPages: ControlPage[] = [
  {
    label: 'Levels',
    softButtons: buildSoftButtons([
      { label: 'Sound', actionId: 'CHANNEL_SOUND' },
      { label: 'Group', actionId: 'CHANNEL_GROUP' },
      { label: 'Master', actionId: 'CHANNEL_MASTER' },
      { label: 'Input', actionId: 'CHANNEL_INPUT' },
      { label: 'Route', actionId: 'CHANNEL_ROUTE' },
      { label: 'Solo', actionId: 'CHANNEL_SOLO' },
      { label: 'Mute', actionId: 'CHANNEL_MUTE' },
      { label: 'Monitor', actionId: 'CHANNEL_MONITOR' }
    ]),
    params: buildParams([
      { id: 'snd-level', name: 'Sound Vol', value: 96, min: 0, max: 127, step: 2 },
      { id: 'snd-pan', name: 'Sound Pan', value: 64, min: 0, max: 127, step: 2 },
      { id: 'snd-send-a', name: 'Send A', value: 40, min: 0, max: 127, step: 2 },
      { id: 'snd-send-b', name: 'Send B', value: 55, min: 0, max: 127, step: 2 },
      { id: 'grp-level', name: 'Group Vol', value: 88, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'grp-pan', name: 'Group Pan', value: 64, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'mst-comp', name: 'Master Comp', value: 48, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'mst-lim', name: 'Limiter', value: 38, min: 0, max: 127, step: 1, side: 'right' }
    ]),
    leftModel: {
      view: 'MIXER',
      title: 'Channel Levels',
      items: [
        { title: 'Kick', value: '-1.2 dB', meter: 0.84 },
        { title: 'Snare', value: '-3.1 dB', meter: 0.68 },
        { title: 'Hat', value: '-5.0 dB', meter: 0.54 },
        { title: 'Bass', value: '-0.4 dB', meter: 0.9 }
      ],
      summary: 'SHIFT: MIDI'
    },
    rightModel: {
      view: 'MIXER',
      title: 'Group & Master',
      items: [
        { title: 'Group A', value: '-1.0 dB', meter: 0.82 },
        { title: 'Group B', value: '-2.4 dB', meter: 0.72 },
        { title: 'Master', value: '-0.3 dB', meter: 0.96 }
      ]
    }
  }
]

const pluginPages: ControlPage[] = [
  {
    label: 'Plug-in',
    softButtons: buildSoftButtons([
      { label: 'Instance', actionId: 'PLUGIN_INSTANCE', shiftLabel: 'Swap', shiftActionId: 'PLUGIN_SWAP' },
      { label: 'Preset', actionId: 'PLUGIN_PRESET' },
      { label: 'Bypass', actionId: 'PLUGIN_BYPASS' },
      { label: 'Enable', actionId: 'PLUGIN_ENABLE' },
      { label: 'Param', actionId: 'PLUGIN_PARAM' },
      { label: 'Macro', actionId: 'PLUGIN_MACRO' },
      { label: 'Browse', actionId: 'PLUGIN_BROWSE' },
      { label: 'Remove', actionId: 'PLUGIN_REMOVE' }
    ]),
    params: buildParams([
      { id: 'cutoff', name: 'Cutoff', value: 82, min: 0, max: 127, step: 2 },
      { id: 'resonance', name: 'Resonance', value: 52, min: 0, max: 127, step: 2 },
      { id: 'attack', name: 'Attack', value: 12, min: 0, max: 127, step: 1 },
      { id: 'release', name: 'Release', value: 88, min: 0, max: 127, step: 2 },
      { id: 'drive', name: 'Drive', value: 40, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'mix', name: 'Mix', value: 90, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'width', name: 'Stereo', value: 70, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'out', name: 'Output', value: 96, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'INFO',
      title: 'Plug-In Chain',
      items: [
        { title: 'Slot 1', subtitle: 'Drum Synth', active: true },
        { title: 'Slot 2', subtitle: 'Transient Master' },
        { title: 'Slot 3', subtitle: 'Reverb' }
      ]
    },
    rightModel: {
      view: 'INFO',
      title: 'Instance',
      summary: 'SHIFT: Swap instance',
      items: [
        { title: 'Preset', subtitle: 'Neon Dust' },
        { title: 'Category', subtitle: 'Drums' },
        { title: 'Author', subtitle: 'Native Instruments' }
      ]
    }
  }
]

const arrangerPages: ControlPage[] = [
  {
    label: 'Scenes',
    softButtons: buildSoftButtons([
      { label: 'Scenes', actionId: 'ARRANGER_SCENES' },
      { label: 'Sections', actionId: 'ARRANGER_SECTIONS' },
      { label: 'Duplicate', actionId: 'ARRANGER_DUPLICATE' },
      { label: 'Length', actionId: 'ARRANGER_LENGTH' },
      { label: 'Follow', actionId: 'ARRANGER_FOLLOW' },
      { label: 'Loop', actionId: 'ARRANGER_LOOP' },
      { label: 'Grid', actionId: 'ARRANGER_GRID' },
      { label: 'Clear', actionId: 'ARRANGER_CLEAR' }
    ]),
    params: buildParams([
      { id: 'scene-length', name: 'Scene Bars', value: 4, min: 1, max: 16, step: 1 },
      { id: 'scene-repeat', name: 'Repeat', value: 2, min: 1, max: 8, step: 1 },
      { id: 'section', name: 'Section', value: 1, min: 1, max: 16, step: 1 },
      { id: 'swing', name: 'Swing', value: 8, min: 0, max: 100, step: 1 },
      { id: 'velocity', name: 'Vel Mod', value: 50, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'humanize', name: 'Humanize', value: 24, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'shift', name: 'Shift', value: 0, min: -32, max: 32, step: 1, side: 'right' },
      { id: 'accent', name: 'Accent', value: 72, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'ARRANGER',
      title: 'Scenes',
      items: [
        { title: 'Intro', subtitle: '4 bars', active: true },
        { title: 'Hook', subtitle: '8 bars' },
        { title: 'Bridge', subtitle: '4 bars' },
        { title: 'Outro', subtitle: '4 bars' }
      ],
      summary: 'Page â—€/â–¶ for parameters'
    },
    rightModel: {
      view: 'ARRANGER',
      title: 'Layout',
      items: [
        { title: 'Pattern A1', subtitle: 'Scene: Intro' },
        { title: 'Pattern B1', subtitle: 'Scene: Hook' },
        { title: 'Pattern C1', subtitle: 'Scene: Bridge' }
      ]
    }
  }
]

const mixerPages: ControlPage[] = [
  {
    label: 'Mix',
    softButtons: buildSoftButtons([
      { label: 'Levels', actionId: 'MIXER_LEVELS' },
      { label: 'Pan', actionId: 'MIXER_PAN' },
      { label: 'Sends', actionId: 'MIXER_SENDS' },
      { label: 'FX', actionId: 'MIXER_FX' },
      { label: 'Group', actionId: 'MIXER_GROUP' },
      { label: 'Master', actionId: 'MIXER_MASTER' },
      { label: 'Cue', actionId: 'MIXER_CUE' },
      { label: 'Meters', actionId: 'MIXER_METERS' }
    ]),
    params: buildParams([
      { id: 'kick-level', name: 'Kick', value: 96, min: 0, max: 127, step: 2 },
      { id: 'snare-level', name: 'Snare', value: 92, min: 0, max: 127, step: 2 },
      { id: 'hat-level', name: 'Hat', value: 88, min: 0, max: 127, step: 2 },
      { id: 'perc-level', name: 'Perc', value: 80, min: 0, max: 127, step: 2 },
      { id: 'bus-comp', name: 'Bus Comp', value: 50, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'bus-sat', name: 'Saturate', value: 36, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'send-a', name: 'Send A', value: 45, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'send-b', name: 'Send B', value: 56, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'MIXER',
      title: 'Channels',
      items: [
        { title: 'Kick', value: '-1.2 dB', meter: 0.84 },
        { title: 'Snare', value: '-3.0 dB', meter: 0.72 },
        { title: 'Hat', value: '-4.4 dB', meter: 0.62 }
      ]
    },
    rightModel: {
      view: 'MIXER',
      title: 'Sends/FX',
      items: [
        { title: 'Reverb', subtitle: 'Aux A', value: '22%' },
        { title: 'Delay', subtitle: 'Aux B', value: '18%' },
        { title: 'Sidechain', subtitle: 'Bus', value: '-14 dB' }
      ]
    }
  }
]

const samplingPages: ControlPage[] = [
  {
    label: 'Sampling',
    softButtons: buildSoftButtons([
      { label: 'Record', actionId: 'SAMPLING_RECORD' },
      { label: 'Edit', actionId: 'SAMPLING_EDIT' },
      { label: 'Slice', actionId: 'SAMPLING_SLICE' },
      { label: 'Detect', actionId: 'SAMPLING_DETECT' },
      { label: 'Normalize', actionId: 'SAMPLING_NORMALIZE' },
      { label: 'Fade', actionId: 'SAMPLING_FADE' },
      { label: 'Apply', actionId: 'SAMPLING_APPLY' },
      { label: 'Discard', actionId: 'SAMPLING_DISCARD' }
    ]),
    params: buildParams([
      { id: 'start', name: 'Start', value: 0, min: 0, max: 100, step: 1 },
      { id: 'end', name: 'End', value: 100, min: 0, max: 100, step: 1 },
      { id: 'snap', name: 'Snap', value: 1, min: 0, max: 8, step: 1 },
      { id: 'silence', name: 'Silence', value: 6, min: 0, max: 20, step: 1 },
      { id: 'attack', name: 'Attack', value: 4, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'hold', name: 'Hold', value: 32, min: 0, max: 127, step: 1, side: 'right' },
      { id: 'release', name: 'Release', value: 60, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'gain', name: 'Gain', value: 80, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'SAMPLING',
      title: 'Waveform',
      summary: 'Set start/end or slice',
      items: [
        { title: 'Length', value: '0:12.4' },
        { title: 'Slices', value: '8 auto' }
      ]
    },
    rightModel: {
      view: 'SAMPLING',
      title: 'Actions',
      items: [
        { title: 'Record Input', subtitle: 'Line' },
        { title: 'Monitor', subtitle: 'On' },
        { title: 'Normalize', subtitle: '-1 dB' }
      ]
    }
  }
]

const filePages: ControlPage[] = [
  {
    label: 'Files',
    softButtons: buildSoftButtons([
      { label: 'New', actionId: 'FILE_NEW' },
      { label: 'Open', actionId: 'FILE_OPEN' },
      { label: 'Save', actionId: 'FILE_SAVE', shiftLabel: 'Save As', shiftActionId: 'FILE_SAVE_AS' },
      { label: 'Export', actionId: 'FILE_EXPORT' },
      { label: 'Audio', actionId: 'FILE_EXPORT_AUDIO' },
      { label: 'MIDI', actionId: 'FILE_EXPORT_MIDI' },
      { label: 'Bounce', actionId: 'FILE_BOUNCE' },
      { label: 'Close', actionId: 'FILE_CLOSE' }
    ]),
    params: buildParams([
      { id: 'mixdown', name: 'Mixdown', value: 0, min: 0, max: 1, step: 1 },
      { id: 'stems', name: 'Stems', value: 1, min: 0, max: 1, step: 1 },
      { id: 'normalize', name: 'Normalize', value: 1, min: 0, max: 1, step: 1 },
      { id: 'dither', name: 'Dither', value: 0, min: 0, max: 1, step: 1 },
      { id: 'sample-rate', name: 'Rate', value: 48000, min: 22050, max: 96000, step: 11025, side: 'right' },
      { id: 'bit-depth', name: 'Bit', value: 24, min: 8, max: 32, step: 8, side: 'right' },
      { id: 'loop-export', name: 'Loop', value: 1, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'prepend', name: 'Count-in', value: 1, min: 0, max: 1, step: 1, side: 'right' }
    ]),
    leftModel: {
      view: 'FILE',
      title: 'File Ops',
      items: [
        { title: 'New Project', subtitle: 'Empty template' },
        { title: 'Open Recent', subtitle: 'DrumComputer_01' },
        { title: 'Save', subtitle: 'CTRL+S', active: true }
      ],
      summary: 'SHIFT: Save As'
    },
    rightModel: {
      view: 'FILE',
      title: 'Export',
      items: [
        { title: 'Audio', subtitle: 'Mixdown, Stems' },
        { title: 'MIDI', subtitle: 'All tracks' },
        { title: 'Bounce', subtitle: 'Selected pattern' }
      ],
      summary: 'Count-in & loop options'
    }
  }
]

const settingsPages: ControlPage[] = [
  {
    label: 'Settings',
    softButtons: buildSoftButtons([
      { label: 'Metronome', actionId: 'SETTINGS_METRO' },
      { label: 'Count-In', actionId: 'SETTINGS_COUNTIN' },
      { label: 'Quantize', actionId: 'SETTINGS_QUANTIZE' },
      { label: 'MIDI', actionId: 'SETTINGS_MIDI' },
      { label: 'Audio', actionId: 'SETTINGS_AUDIO' },
      { label: 'Theme', actionId: 'SETTINGS_THEME' },
      { label: 'Safe', actionId: 'SETTINGS_SAFE' },
      { label: 'Reset', actionId: 'SETTINGS_RESET' }
    ]),
    params: buildParams([
      { id: 'metro-lvl', name: 'Metro Vol', value: 72, min: 0, max: 127, step: 2 },
      { id: 'count-in', name: 'Count-In', value: 1, min: 0, max: 8, step: 1 },
      { id: 'swing', name: 'Swing', value: 8, min: 0, max: 100, step: 1 },
      { id: 'quantize', name: 'Quantize', value: 1, min: 0, max: 1, step: 1 },
      { id: 'theme', name: 'Theme', value: 0, min: 0, max: 2, step: 1, side: 'right' },
      { id: 'audio-lat', name: 'Latency', value: 5, min: 1, max: 20, step: 1, side: 'right' },
      { id: 'buffer', name: 'Buffer', value: 256, min: 64, max: 1024, step: 64, side: 'right' },
      { id: 'safety', name: 'Safe Mode', value: 1, min: 0, max: 1, step: 1, side: 'right' }
    ]),
    leftModel: {
      view: 'SETTINGS',
      title: 'System',
      items: [
        { title: 'Metronome', value: 'On' },
        { title: 'Count-In', value: '1 bar' },
        { title: 'Quantize', value: '1/16' }
      ]
    },
    rightModel: {
      view: 'SETTINGS',
      title: 'Audio/MIDI',
      items: [
        { title: 'Device', subtitle: 'Built-in Output' },
        { title: 'Buffer', subtitle: '256 samples' },
        { title: 'MIDI Input', subtitle: 'MK3 Virtual' }
      ]
    }
  }
]

const autoPages: ControlPage[] = [
  {
    label: 'Automation',
    softButtons: buildSoftButtons([
      { label: 'Write', actionId: 'AUTO_WRITE' },
      { label: 'Read', actionId: 'AUTO_READ' },
      { label: 'Latch', actionId: 'AUTO_LATCH' },
      { label: 'Touch', actionId: 'AUTO_TOUCH' },
      { label: 'Erase', actionId: 'AUTO_ERASE' },
      { label: 'Arm', actionId: 'AUTO_ARM' },
      { label: 'Hold', actionId: 'AUTO_HOLD' },
      { label: 'Clear', actionId: 'AUTO_CLEAR' }
    ]),
    params: buildParams([
      { id: 'auto-lane', name: 'Lane', value: 1, min: 1, max: 8, step: 1 },
      { id: 'auto-smooth', name: 'Smooth', value: 42, min: 0, max: 127, step: 2 },
      { id: 'auto-scale', name: 'Scale', value: 100, min: 0, max: 150, step: 5 },
      { id: 'auto-quant', name: 'Quantize', value: 1, min: 0, max: 1, step: 1 },
      { id: 'auto-protect', name: 'Protect', value: 0, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'auto-loop', name: 'Loop', value: 1, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'auto-snap', name: 'Snap', value: 1, min: 0, max: 1, step: 1, side: 'right' },
      { id: 'auto-depth', name: 'Depth', value: 60, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'INFO',
      title: 'Automation',
      summary: 'Hold to write with encoders',
      items: [
        { title: 'Mode', value: 'Write' },
        { title: 'Lane', value: '1/8 Grid' }
      ]
    },
    rightModel: {
      view: 'INFO',
      title: 'Status',
      items: [
        { title: 'Armed', value: 'Yes' },
        { title: 'Protect', value: 'Off' },
        { title: 'Overwrite', value: 'No' }
      ]
    }
  }
]

const macroPages: ControlPage[] = [
  {
    label: 'Macro',
    softButtons: buildSoftButtons([
      { label: 'Assign', actionId: 'MACRO_ASSIGN' },
      { label: 'Clear', actionId: 'MACRO_CLEAR' },
      { label: 'Hold', actionId: 'MACRO_HOLD' },
      { label: 'Latch', actionId: 'MACRO_LATCH' },
      { label: 'Morph', actionId: 'MACRO_MORPH' },
      { label: 'Set', actionId: 'MACRO_SET', shiftLabel: 'Shift Set', shiftActionId: 'MACRO_SHIFT_SET' },
      { label: 'Store', actionId: 'MACRO_STORE' },
      { label: 'Recall', actionId: 'MACRO_RECALL' }
    ]),
    params: buildParams([
      { id: 'macro1', name: 'Macro 1', value: 40, min: 0, max: 127, step: 2 },
      { id: 'macro2', name: 'Macro 2', value: 80, min: 0, max: 127, step: 2 },
      { id: 'macro3', name: 'Macro 3', value: 64, min: 0, max: 127, step: 2 },
      { id: 'macro4', name: 'Macro 4', value: 32, min: 0, max: 127, step: 2 },
      { id: 'macro5', name: 'Macro 5', value: 20, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'macro6', name: 'Macro 6', value: 55, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'macro7', name: 'Macro 7', value: 76, min: 0, max: 127, step: 2, side: 'right' },
      { id: 'macro8', name: 'Macro 8', value: 90, min: 0, max: 127, step: 2, side: 'right' }
    ]),
    leftModel: {
      view: 'INFO',
      title: 'Macro Sets',
      items: [
        { title: 'Set A', subtitle: 'Live' },
        { title: 'Set B', subtitle: 'Studio', active: true },
        { title: 'Set C', subtitle: 'User' }
      ],
      summary: 'SHIFT: Macro Set'
    },
    rightModel: {
      view: 'INFO',
      title: 'Morph',
      items: [
        { title: 'Target', subtitle: 'Set B' },
        { title: 'Morph', value: '38%' }
      ]
    }
  }
]

const pagesByMode: Record<ControlMode, ControlPage[]> = {
  CHANNEL: channelPages,
  PLUGIN: pluginPages,
  ARRANGER: arrangerPages,
  MIXER: mixerPages,
  BROWSER: browserPages,
  SAMPLING: samplingPages,
  FILE: filePages,
  SETTINGS: settingsPages,
  AUTO: autoPages,
  MACRO: macroPages
}

const createInitialPageIndex = (): PageIndexByMode => {
  return MODES.reduce((acc, mode) => {
    acc[mode] = 0
    return acc
  }, {} as PageIndexByMode)
}

export const useControlStore = defineStore('control', {
  state: () => ({
    activeMode: 'BROWSER' as ControlMode,
    shiftHeld: false,
    pageIndexByMode: createInitialPageIndex(),
    pagesByMode,
    lastAction: 'Ready',
    statusFlags: {
      metronome: true,
      countIn: true,
      automationArmed: false
    },
    encoder4D: null as Raw<Use4DEncoderReturn> | null,
    browserDisplay: null as { leftModel: DisplayPanelModel; rightModel: DisplayPanelModel } | null
  }),
  getters: {
    activePage(state): ControlPage {
      const pages = state.pagesByMode[state.activeMode] ?? []
      const index = state.pageIndexByMode[state.activeMode] ?? 0
      return pages[index] ?? pages[0]
    },
    pageLabel(): string {
      return this.activePage?.label ?? ''
    },
    modeTitle(state): string {
      return state.activeMode
    },
    activeSoftButtons(): SoftButton[] {
      return this.activePage?.softButtons ?? buildSoftButtons([])
    },
    softLabels(): string[] {
      return this.activeSoftButtons.map((btn) => btn.label || '')
    },
    activeParams(): EncoderParam[] {
      if (this.activeMode === 'BROWSER') {
        const browser = useBrowserStore()
        if (browser.previewState.isPlaying) {
          return buildPreviewParams()
        }
      }
      return this.activePage?.params ?? buildParams([])
    },
    paramSlotsLeft(): EncoderParam[] {
      return this.activeParams.filter((param) => (param.side ?? 'left') === 'left').slice(0, 4)
    },
    paramSlotsRight(): EncoderParam[] {
      return this.activeParams.filter((param) => (param.side ?? 'left') === 'right').slice(0, 4)
    },
    leftModel(): DisplayPanelModel {
      if ((this.activeMode === 'BROWSER' || this.activeMode === 'FILE') && this.browserDisplay?.leftModel) {
        return this.browserDisplay.leftModel
      }
      return this.activePage?.leftModel ?? { view: 'EMPTY', title: 'Empty' }
    },
    rightModel(): DisplayPanelModel {
      if ((this.activeMode === 'BROWSER' || this.activeMode === 'FILE') && this.browserDisplay?.rightModel) {
        return this.browserDisplay.rightModel
      }
      return this.activePage?.rightModel ?? { view: 'EMPTY', title: 'Empty' }
    }
  },
  actions: {
    initEncoderForBrowser() {
      const browser = useBrowserStore()
      const encoder = this.encoder4D ?? markRaw(use4DEncoder())
      this.encoder4D = encoder
      const fields = browser.getEncoderFields()
      encoder.setFields(fields)
      encoder.setMode('field-select')
      encoder.activeListIndex.value = 0
    },
    refreshEncoderFields() {
      if (!this.encoder4D) return
      const browser = useBrowserStore()
      this.encoder4D.setFields(browser.getEncoderFields())
    },
    syncBrowserDisplay() {
      const browser = useBrowserStore()
      if (browser.tagDialogOpen) {
        if (this.encoder4D) {
          const fields = browser.getEncoderFields()
          this.encoder4D.setFields(fields)
          this.encoder4D.setMode('list-navigate')
          if (fields.length === 0) {
            this.encoder4D.activeListIndex.value = 0
          } else {
            const index = clamp(this.encoder4D.activeListIndex.value, 0, fields.length - 1)
            this.encoder4D.activeListIndex.value = index
          }
        }
        this.setBrowserDisplay(browser.toDisplayModels())
        return
      }
      if (this.activeMode === 'BROWSER' && this.activePage?.label === 'Recent') {
        browser.loadRecentFiles()
        const recentItems = browser.recentFiles.map((entry) => ({
          title: entry.name,
          subtitle: formatRelativeTimestamp(entry.timestamp),
          value: entry.id
        }))
        this.setBrowserDisplay({
          leftModel: {
            view: 'BROWSER',
            title: 'Recent Files',
            summary: `${recentItems.length} items`,
            items: recentItems
          },
          rightModel: this.activePage?.rightModel ?? { view: 'BROWSER', title: 'Preview' }
        })
        return
      }
      const models = browser.toDisplayModels()
      if (this.encoder4D) {
        const activeField = this.encoder4D.activeField.value
        if (activeField) {
          const summary = models.leftModel.summary ?? ''
          const highlight = `(${activeField.label})`
          models.leftModel = {
            ...models.leftModel,
            summary: [summary, highlight].filter((value) => value && value.length > 0).join(' ')
          }
        }
      }
      this.setBrowserDisplay(models)
    },
    syncListSelection() {
      if (!this.encoder4D) return
      const browser = useBrowserStore()
      if (this.activeMode === 'FILE') {
        const files = browser.files.entries.files
        if (files.length === 0) {
          browser.selectPath(null)
          this.encoder4D.activeListIndex.value = 0
        } else {
          const index = clamp(this.encoder4D.activeListIndex.value, 0, files.length - 1)
          this.encoder4D.activeListIndex.value = index
          browser.selectPath(files[index]?.path ?? null)
        }
      } else {
        const results = browser.library.results
        if (results.length === 0) {
          browser.selectResult(null)
          this.encoder4D.activeListIndex.value = 0
        } else {
          const index = clamp(this.encoder4D.activeListIndex.value, 0, results.length - 1)
          this.encoder4D.activeListIndex.value = index
          browser.selectResult(results[index]?.id ?? null)
        }
      }
      this.syncBrowserDisplay()
    },
    applyEncoderFieldFilter() {
      if (!this.encoder4D) return
      const browser = useBrowserStore()
      const field = this.encoder4D.activeField.value
      if (!field) return
      if (field.id === 'sort') {
        browser.setSortMode(parseSortMode(field.value))
        this.refreshEncoderFields()
        return
      }
      const value = parseFieldValueForFilter(field)
      browser.setFilter(field.id as keyof BrowserFilters, value as BrowserFilters[keyof BrowserFilters])
      this.refreshEncoderFields()
    },
    setMode(mode: ControlMode) {
      this.activeMode = mode
      if (this.pageIndexByMode[mode] == null) {
        this.pageIndexByMode[mode] = 0
      }
      this.lastAction = `${mode} selected`
      if (mode === 'BROWSER' || mode === 'FILE') {
        this.initEncoderForBrowser()
        this.syncBrowserDisplay()
      }
    },
    setShiftHeld(value: boolean) {
      this.shiftHeld = value
    },
    setBrowserDisplay(models: { leftModel: DisplayPanelModel; rightModel: DisplayPanelModel } | null) {
      this.browserDisplay = models
    },
    nextPage() {
      const pages = this.pagesByMode[this.activeMode] ?? []
      if (pages.length === 0) return
      const nextIndex = Math.min(pages.length - 1, (this.pageIndexByMode[this.activeMode] ?? 0) + 1)
      this.pageIndexByMode[this.activeMode] = nextIndex
      this.lastAction = `${this.activeMode} page: ${pages[nextIndex]?.label ?? ''}`
      if (this.activeMode === 'BROWSER') {
        this.syncBrowserDisplay()
      }
    },
    prevPage() {
      const pages = this.pagesByMode[this.activeMode] ?? []
      if (pages.length === 0) return
      const nextIndex = Math.max(0, (this.pageIndexByMode[this.activeMode] ?? 0) - 1)
      this.pageIndexByMode[this.activeMode] = nextIndex
      this.lastAction = `${this.activeMode} page: ${pages[nextIndex]?.label ?? ''}`
      if (this.activeMode === 'BROWSER') {
        this.syncBrowserDisplay()
      }
    },
    pressSoftButton(index: number) {
      const btn = this.activeSoftButtons[index]
      if (!btn || btn.enabled === false) return
      const actionId = this.shiftHeld && btn.shiftActionId ? btn.shiftActionId : btn.actionId
      this.applyAction(actionId, btn.label)
    },
    applyAction(actionId: string, label?: string) {
      const browser = useBrowserStore()
      switch (actionId) {
        case 'BROWSER_SEARCH':
          void browser.search()
          this.lastAction = 'Browser search'
          break
        case 'BROWSER_TAG':
        case 'BROWSER_TAG_RECENT':
          if (browser.library.selectedId) {
            browser.openTagDialog(browser.library.selectedId)
            this.lastAction = 'Tag dialog opened'
          }
          break
        case 'BROWSER_PREHEAR':
          void browser.prehearSelected()
          this.lastAction = 'Prehear triggered'
          break
        case 'BROWSER_STOP':
          browser.stopPrehear()
          this.lastAction = 'Prehear stopped'
          break
        case 'BROWSER_LOAD':
        case 'BROWSER_REPLACE':
          void browser.importSelected()
          this.lastAction = 'Import triggered'
          break
        case 'BROWSER_IMPORT_TO_PAD':
          this.lastAction = 'Import to pad triggered'
          break
        case 'BROWSER_FAVORITES':
          if (browser.library.selectedId) {
            void browser.toggleFavorite(browser.library.selectedId)
            this.lastAction = 'Favorite toggled'
          } else {
            browser.setFilter('favorites', !browser.filters.favorites)
            this.lastAction = browser.filters.favorites ? 'Favorites filter on' : 'Favorites filter off'
          }
          break
        case 'BROWSER_CLEAR':
          browser.selectResult(null)
          browser.selectPath(null)
          this.lastAction = 'Browser cleared'
          break
        case 'BROWSER_PLUGIN_MENU':
        case 'PLUGIN_INSTANCE':
        case 'PLUGIN_SWAP':
        case 'CHANNEL_SOUND':
        case 'CHANNEL_GROUP':
        case 'CHANNEL_MASTER':
          this.lastAction = label ? `${label} triggered` : actionId
          break
        case 'FILE_SAVE':
        case 'FILE_SAVE_AS':
          this.lastAction = 'Project saved (demo)'
          break
        case 'SETTINGS_METRO':
          this.statusFlags.metronome = !this.statusFlags.metronome
          this.lastAction = `Metronome ${this.statusFlags.metronome ? 'On' : 'Off'}`
          break
        case 'SETTINGS_COUNTIN':
          this.statusFlags.countIn = !this.statusFlags.countIn
          this.lastAction = `Count-in ${this.statusFlags.countIn ? 'On' : 'Off'}`
          break
        case 'AUTO_ARM':
          this.statusFlags.automationArmed = !this.statusFlags.automationArmed
          this.lastAction = `Automation ${this.statusFlags.automationArmed ? 'Armed' : 'Disarmed'}`
          break
        default:
          this.lastAction = label ? `${label} triggered` : actionId
      }
    },
    tiltEncoder4D(direction: 'left' | 'right' | 'up' | 'down') {
      if (!this.encoder4D) return
      const browser = useBrowserStore()
      if (browser.tagDialogOpen) {
        if (direction === 'right') {
          browser.closeTagDialog()
          this.syncBrowserDisplay()
          return
        }
        if (direction === 'up' || direction === 'down') {
          this.encoder4D.tiltVertical(direction)
          this.syncBrowserDisplay()
        }
        return
      }
      if (direction === 'left' || direction === 'right') {
        this.encoder4D.tiltHorizontal(direction)
        this.syncBrowserDisplay()
        return
      }
      this.encoder4D.tiltVertical(direction)
      this.syncListSelection()
    },
    turnEncoder4D(delta: number) {
      if (!this.encoder4D) return
      const browser = useBrowserStore()
      if (browser.tagDialogOpen) {
        this.encoder4D.setMode('list-navigate')
        this.encoder4D.turn(delta)
        this.syncBrowserDisplay()
        return
      }
      const mode = this.encoder4D.mode.value
      this.encoder4D.turn(delta)
      if (mode === 'value-adjust') {
        this.applyEncoderFieldFilter()
      } else if (mode === 'list-navigate') {
        this.syncListSelection()
      }
    },
    async pressEncoder4D() {
      if (!this.encoder4D) return
      const browser = useBrowserStore()
      if (browser.tagDialogOpen) {
        const index = clamp(this.encoder4D.activeListIndex.value, 0, browser.availableTags.length - 1)
        const tag = browser.availableTags[index]
        if (tag) {
          const selectedId = browser.tagDialogItemId ?? browser.library.selectedId
          const selected = browser.library.results.find((item) => item.id === selectedId)
          const assigned = selected?.tags?.includes(tag) ?? false
          if (!assigned) {
            await browser.addTagToSelected(tag)
          }
          this.syncBrowserDisplay()
        }
        return
      }
      const previousMode = this.encoder4D.mode.value
      if (previousMode === 'value-adjust') {
        this.applyEncoderFieldFilter()
      }
      this.encoder4D.press()
      if (previousMode === 'list-navigate') {
        if (this.activeMode === 'FILE') {
          await browser.importSelected()
        } else {
          this.syncListSelection()
        }
      }
      if (this.encoder4D.mode.value === 'list-navigate') {
        this.syncListSelection()
      } else {
        this.syncBrowserDisplay()
      }
    },
    turnEncoder(index: number, delta: number, options?: { fine?: boolean }) {
      const page = this.activePage
      if (!page) return
      const params = page.params
      const param = params[index]
      if (!param) return
      const step = options?.fine ? param.fineStep ?? Math.max(0.25, param.step / 4) : param.step
      const nextValue = clamp(param.value + delta * step, param.min, param.max)
      param.value = nextValue
      this.lastAction = `${param.name}: ${Math.round(nextValue * 100) / 100}${param.format ? ` ${param.format}` : ''}`
    },
    turnEncoderById(id: string, delta: number, options?: { fine?: boolean }) {
      const params = this.activeParams
      const index = params.findIndex((param) => param.id === id)
      if (index >= 0) {
        this.turnEncoder(index, delta, options)
      }
    }
  }
})



=========================================
File: stores/patterns.ts
=========================================

import { defineStore } from 'pinia'
import type { DrumPadId, Pattern, Scene, StepGrid } from '@/types/drums'
import type { GridSpec } from '@/types/time'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import { clampVelocity, cycleVelocity, DEFAULT_STEP_VELOCITY } from '@/domain/velocity'

// Manages patterns and scenes with undo/redo history, grid spec updates, and step velocity editing.
const createDefaultGrid = (): GridSpec => ({ ...DEFAULT_GRID_SPEC })

const createEmptyPattern = (id: string, name: string): Pattern => ({
  id,
  name,
  gridSpec: createDefaultGrid(),
  steps: {}
})

const createScene = (id: string, name: string, patternIds: string[] = []): Scene => ({
  id,
  name,
  patternIds
})

const HISTORY_LIMIT = 50

type PatternsSnapshot = {
  patterns: Pattern[]
  scenes: Scene[]
  selectedPatternId: string
  activeSceneId: string | null
}

export const usePatternsStore = defineStore('patterns', {
  state: () => ({
    patterns: [createEmptyPattern('pattern-1', 'Pattern 1')],
    scenes: [] as Scene[],
    selectedPatternId: 'pattern-1',
    activeSceneId: null as string | null,
    scenePosition: 0,
    history: [] as PatternsSnapshot[],
    historyIndex: -1,
    isRestoring: false
  }),
  getters: {
    currentPattern(state): Pattern {
      return state.patterns.find((p) => p.id === state.selectedPatternId) ?? createEmptyPattern('pattern-1', 'Pattern 1')
    },
    currentScene(state): Scene | null {
      return state.scenes.find((scene) => scene.id === state.activeSceneId) ?? null
    }
  },
  actions: {
    snapshotState(): PatternsSnapshot {
      return {
        patterns: JSON.parse(JSON.stringify(this.patterns)) as Pattern[],
        scenes: JSON.parse(JSON.stringify(this.scenes)) as Scene[],
        selectedPatternId: this.selectedPatternId,
        activeSceneId: this.activeSceneId
      }
    },
    recordHistory() {
      if (this.isRestoring) return
      const snapshot = this.snapshotState()
      this.history = this.history.slice(0, this.historyIndex + 1)
      this.history.push(snapshot)
      if (this.history.length > HISTORY_LIMIT) {
        this.history.shift()
        this.historyIndex -= 1
      }
      this.historyIndex = this.history.length - 1
    },
    restoreSnapshot(snapshot: PatternsSnapshot) {
      this.isRestoring = true
      this.patterns = snapshot.patterns.map((pattern) => ({
        ...pattern,
        gridSpec: normalizeGridSpec(pattern.gridSpec)
      }))
      this.setScenes(snapshot.scenes)
      this.selectedPatternId = snapshot.selectedPatternId
      if (!this.patterns.find((pattern) => pattern.id === this.selectedPatternId)) {
        this.selectedPatternId = this.patterns[0]?.id ?? 'pattern-1'
      }
      this.activeSceneId = snapshot.activeSceneId
      this.scenePosition = 0
      this.isRestoring = false
    },
    undo() {
      if (this.historyIndex <= 0) return
      this.historyIndex -= 1
      const snapshot = this.history[this.historyIndex]
      if (snapshot) {
        this.restoreSnapshot(snapshot)
      }
    },
    redo() {
      if (this.historyIndex >= this.history.length - 1) return
      this.historyIndex += 1
      const snapshot = this.history[this.historyIndex]
      if (snapshot) {
        this.restoreSnapshot(snapshot)
      }
    },
    selectPattern(id: string) {
      this.selectedPatternId = id
    },
    addPattern(name?: string) {
      this.recordHistory()
      const nextIndex = this.patterns.length + 1
      const id = `pattern-${Date.now()}-${nextIndex}`
      const pattern = createEmptyPattern(id, name ?? `Pattern ${nextIndex}`)
      this.patterns.push(pattern)
      this.selectedPatternId = pattern.id
    },
    renamePattern(id: string, name: string) {
      this.recordHistory()
      const pattern = this.patterns.find((entry) => entry.id === id)
      if (pattern) {
        pattern.name = name
      }
    },
    setScenes(scenes: Scene[]) {
      const allowedIds = this.patterns.map((pattern) => pattern.id)
      this.scenes = scenes.map((scene) => ({
        ...scene,
        patternIds: scene.patternIds.filter((id) => allowedIds.includes(id))
      }))
      if (this.activeSceneId && !this.scenes.find((scene) => scene.id === this.activeSceneId)) {
        this.activeSceneId = null
        this.scenePosition = 0
      }
    },
    setPatterns(patterns: Pattern[]) {
      this.patterns = patterns.length ? patterns : [createEmptyPattern('pattern-1', 'Pattern 1')]
      if (!this.patterns.find((pattern) => pattern.id === this.selectedPatternId)) {
        this.selectedPatternId = this.patterns[0]?.id ?? 'pattern-1'
      }
      const allowedIds = this.patterns.map((pattern) => pattern.id)
      this.scenes = this.scenes.map((scene) => ({
        ...scene,
        patternIds: scene.patternIds.filter((id) => allowedIds.includes(id))
      }))
      if (this.activeSceneId && !this.scenes.find((scene) => scene.id === this.activeSceneId)) {
        this.activeSceneId = null
        this.scenePosition = 0
      }
    },
    toggleStep(barIndex: number, stepInBar: number, padId: DrumPadId) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      const bar = grid[barIndex] ?? {}
      const stepRow = bar[stepInBar] ?? {}
      const updated = { ...stepRow }
      const nextVelocity = cycleVelocity(updated[padId]?.velocity?.value)
      if (nextVelocity === null) {
        delete updated[padId]
      } else {
        updated[padId] = { velocity: { value: clampVelocity(nextVelocity) } }
      }
      grid[barIndex] = { ...bar, [stepInBar]: updated }
    },
    setStepVelocity(barIndex: number, stepInBar: number, padId: DrumPadId, velocity: number) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      const bar = grid[barIndex] ?? {}
      const stepRow = bar[stepInBar] ?? {}
      const updated = { ...stepRow }
      updated[padId] = { velocity: { value: clampVelocity(velocity || DEFAULT_STEP_VELOCITY) } }
      grid[barIndex] = { ...bar, [stepInBar]: updated }
    },
    eraseStepForPad(barIndex: number, stepInBar: number, padId: DrumPadId) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      const bar = grid[barIndex] ?? {}
      const stepRow = bar[stepInBar] ?? {}
      if (stepRow && stepRow[padId]) {
        const updated = { ...stepRow }
        delete updated[padId]
        grid[barIndex] = { ...bar, [stepInBar]: updated }
      }
    },
    erasePadEvents(padId: DrumPadId) {
      this.recordHistory()
      const pattern = this.currentPattern
      const grid = pattern.steps as StepGrid
      Object.entries(grid).forEach(([barIndex, bar]) => {
        const barIdx = Number(barIndex)
        Object.entries(bar ?? {}).forEach(([stepIndex, row]) => {
          if (row && row[padId]) {
            const updated = { ...row }
            delete updated[padId]
            grid[barIdx] = { ...(grid[barIdx] ?? {}), [Number(stepIndex)]: updated }
          }
        })
      })
    },
    eraseAutomationForPad(padId: DrumPadId) {
      // Placeholder: no automation envelope stored yet; reuse pad erase.
      this.erasePadEvents(padId)
    },
    updateGridSpec(gridSpec: GridSpec) {
      this.recordHistory()
      const pattern = this.currentPattern
      pattern.gridSpec = normalizeGridSpec(gridSpec)
    },
    addScene(name: string, patternIds: string[] = []) {
      this.recordHistory()
      const id = `scene-${Date.now()}-${this.scenes.length + 1}`
      this.scenes.push(createScene(id, name, patternIds))
      this.activeSceneId = id
      this.scenePosition = 0
    },
    updateScene(sceneId: string, updates: Partial<Scene>) {
      this.recordHistory()
      const scene = this.scenes.find((entry) => entry.id === sceneId)
      if (!scene) return
      if (updates.name) {
        scene.name = updates.name
      }
      if (updates.patternIds) {
        const allowed = this.patterns.map((pattern) => pattern.id)
        scene.patternIds = updates.patternIds.filter((id) => allowed.includes(id))
      }
    },
    selectScene(sceneId: string | null) {
      this.activeSceneId = sceneId
      this.scenePosition = 0
    },
    prepareScenePlayback() {
      this.scenePosition = 0
      const scene = this.currentScene
      if (scene && scene.patternIds.length > 0) {
        const nextId = scene.patternIds[0]
        if (nextId) {
          this.selectedPatternId = nextId
        }
        this.scenePosition = scene.patternIds.length > 1 ? 1 : 0
      }
    },
    advanceScenePlayback(): Pattern {
      const scene = this.currentScene
      if (!scene || scene.patternIds.length === 0) {
        return this.currentPattern
      }
      const nextId = scene.patternIds[this.scenePosition % scene.patternIds.length]
      this.scenePosition = (this.scenePosition + 1) % scene.patternIds.length
      if (nextId) {
        this.selectedPatternId = nextId
      }
      return this.currentPattern
    }
  }
})



=========================================
File: stores/session.ts
=========================================

import { defineStore } from 'pinia'
import type { MidiDeviceInfo } from '@/types/midi'

export const useSessionStore = defineStore('session', {
  state: () => ({
    midiInput: undefined as MidiDeviceInfo | undefined,
    midiOutput: undefined as MidiDeviceInfo | undefined,
    audioReady: false,
    capabilities: {
      supportsWebMIDI: false,
      supportsAudioInput: false
    }
  }),
  actions: {
    setMidiInput(device?: MidiDeviceInfo) {
      this.midiInput = device
    },
    setMidiOutput(device?: MidiDeviceInfo) {
      this.midiOutput = device
    },
    setAudioReady(isReady: boolean) {
      this.audioReady = isReady
    },
    setCapabilities(capabilities: { supportsWebMIDI: boolean; supportsAudioInput: boolean }) {
      this.capabilities = capabilities
    }
  }
})



=========================================
File: stores/soundbanks.ts
=========================================

import { defineStore } from 'pinia'
import type { Soundbank } from '@/types/audio'

export const useSoundbanksStore = defineStore('soundbanks', {
  state: () => ({
    banks: [] as Soundbank[],
    selectedBankId: ''
  }),
  getters: {
    currentBank(state): Soundbank | undefined {
      return state.banks.find((bank) => bank.id === state.selectedBankId)
    }
  },
  actions: {
    setBanks(banks: Soundbank[]) {
      this.banks = banks
      if (!this.selectedBankId && banks.length > 0) {
        const first = banks[0]
        if (first) {
          this.selectedBankId = first.id
        }
      }
    },
    selectBank(id: string) {
      this.selectedBankId = id
    },
    upsertBank(bank: Soundbank) {
      const index = this.banks.findIndex((b) => b.id === bank.id)
      if (index >= 0) {
        this.banks.splice(index, 1, bank)
      } else {
        this.banks.push(bank)
      }
    }
  }
})



=========================================
File: stores/transport.ts
=========================================

import { defineStore } from 'pinia'
import { DEFAULT_GRID_SPEC, normalizeGridSpec } from '@/domain/timing'
import type { GridSpec } from '@/types/time'

export const useTransportStore = defineStore('transport', {
  state: () => ({
    bpm: 120,
    isPlaying: false,
    loop: true,
    gridSpec: { ...DEFAULT_GRID_SPEC } as GridSpec,
    currentStep: 0,
    isRecording: false,
    countInEnabled: false,
    countInBars: 1,
    metronomeEnabled: false,
    metronomeVolume: 0.12,
    followEnabled: true,
    loopStart: 0,
    loopEnd: DEFAULT_GRID_SPEC.bars * DEFAULT_GRID_SPEC.division
  }),
  actions: {
    setBpm(bpm: number) {
      this.bpm = bpm
    },
    setPlaying(isPlaying: boolean) {
      this.isPlaying = isPlaying
    },
    setGridSpec(gridSpec: GridSpec) {
      const prevTotal = this.gridSpec.bars * this.gridSpec.division
      this.gridSpec = normalizeGridSpec(gridSpec)
      const nextTotal = this.gridSpec.bars * this.gridSpec.division
      if (prevTotal > 0 && nextTotal > 0) {
        const startRatio = this.loopStart / prevTotal
        const endRatio = this.loopEnd / prevTotal
        const nextStart = Math.floor(startRatio * nextTotal)
        const nextEnd = Math.max(nextStart + 1, Math.round(endRatio * nextTotal))
        this.setLoopRange(nextStart, nextEnd)
      } else {
        this.setLoopRange(0, nextTotal)
      }
    },
    setLoop(loop: boolean) {
      this.loop = loop
    },
    setCurrentStep(step: number) {
      this.currentStep = step
    },
    setRecording(isRecording: boolean) {
      this.isRecording = isRecording
    },
    setCountInEnabled(enabled: boolean) {
      this.countInEnabled = enabled
    },
    setCountInBars(bars: number) {
      const normalized = Math.max(1, Math.floor(bars))
      this.countInBars = normalized
    },
    setMetronomeEnabled(enabled: boolean) {
      this.metronomeEnabled = enabled
    },
    setMetronomeVolume(volume: number) {
      const clamped = Math.max(0, Math.min(1, volume))
      this.metronomeVolume = clamped
    },
    setFollowEnabled(enabled: boolean) {
      this.followEnabled = enabled
    },
    setLoopRange(start: number, end: number) {
      const total = this.gridSpec.bars * this.gridSpec.division
      const clampedStart = Math.max(0, Math.min(start, total - 1))
      const clampedEnd = Math.max(clampedStart + 1, Math.min(end, total))
      this.loopStart = clampedStart
      this.loopEnd = clampedEnd
    },
    nudgeLoopRange(delta: number) {
      const length = this.loopEnd - this.loopStart
      this.setLoopRange(this.loopStart + delta, this.loopStart + delta + length)
    }
  }
})



=========================================
File: styles/drum-machine.less
=========================================

@import 'variables.less';

body {
  background: @background;
  color: #fff;
  margin: 0;
}



=========================================
File: styles/globals.less
=========================================

@import '@/styles/variables.less';

html, body, #__nuxt {
  height: 100%;
  margin: 0;
  overflow: hidden;
}

body {
  background: @color-bg-root;
}

:deep(.v-application) {
  height: 100%;
}



=========================================
File: styles/variables.less
=========================================

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Root / Background */
@color-bg-root: #121212;
@bg-cell: linear-gradient(180deg, #1b1c20, #0f1013);
/* Surfaces */
@color-surface-1: #0f1115;  /* Panels, Transport */
@color-surface-2: #0a0d12;  /* Pads, deeper layers */
@color-surface-3: #080b10;  /* Drawer / FX */

/* Borders / Divider */
@color-border-1: #1d2430;
@color-border-2: #1f2838;
@color-border-3: #f2f1e8;

/* Text */
@color-text-primary: #f5f7fb;
@color-text-secondary: rgba(245, 247, 251, 0.65);
@color-text-muted: rgba(245, 247, 251, 0.4);

/* Akzent */
@color-accent-primary: #00f8ff;
@color-accent-warning: #ffc952;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Shadows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@shadow-box: inset 0 1px 0 rgba(255,255,255,0.04), 
  inset 0 -2px 4px rgba(0,0,0,0.6);

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Spacing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@space-xxs: 2px;
@space-2xs: 4px;
@space-xs: 8px;
@space-s: 12px;
@space-m: 16px;
@space-l: 24px;
@space-xl: 32px;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Pad LEDs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@pad-led-active: @color-accent-primary;
@pad-led-selected: @color-border-3;
@pad-led-idle: @bg-cell;


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Radii â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@radius-xs: 4px;
@radius-s: 6px;
@radius-xm: 8px;
@radius-m: 12px;
@radius-l: 16px;
@radius-xl: 20px;


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Typography (Base) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@font-size-xs: 0.7rem;
@font-size-s: 0.8rem;
@font-size-m: 0.9rem;
@font-size-l: 1rem;

@letter-spacing-tight: 0.1em;
@letter-spacing-wide: 0.2em;
@letter-spacing-xwide: 0.3em;


/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ UI Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

@outline-focus: 2px dashed @color-accent-primary;
@outline-focus-offset: 3px;



=========================================
File: styles/vuetify-overrides.less
=========================================

@import 'variables.less';

html,
body {
  height: 100%;
  min-height: 100%;
  margin: 0;
}

body {
  overflow: hidden;
}

#app,
#__nuxt,
.v-application,
.v-application--wrap {
  height: 100%;
  min-height: 100%;
  display: flex;
  flex-direction: column;
}

.v-main {
  flex: 1 1 auto;
  min-height: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.v-application {
  background-color: @background !important;
}



=========================================
File: tests/componentTests/DualDisplay.component.spec.ts
=========================================

import { describe, it, expect, beforeEach, vi as _vi } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import DualDisplay from '@/components/control/DualDisplay.vue'

describe('DualDisplay.vue', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('renders left and right displays', () => {
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'BROWSER', title: 'Test Left' },
        rightModel: { view: 'FILE', title: 'Test Right' },
        modeTitle: 'Test Mode',
        pageLabel: 'Page 1'
      }
    })
    expect(wrapper.find('.display.left').exists()).toBe(true)
    expect(wrapper.find('.display.right').exists()).toBe(true)
  })

  it('shows file search input in FILE view', () => {
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'FILE', title: 'Files', items: [] },
        rightModel: { view: 'BROWSER', title: 'Browser', items: [] },
        modeTitle: 'File Mode',
        pageLabel: 'Page 1'
      }
    })
    const searchInput = wrapper.find('.display.left input[type="search"]')
    expect(searchInput.exists()).toBe(true)
    expect(searchInput.attributes('placeholder')).toBe('Filter files')
  })

  it('renders scrollable file list wrapper in FILE view', () => {
    const items = Array.from({ length: 50 }, (_, i) => ({
      title: `File ${i + 1}`,
      subtitle: `path/to/file${i + 1}`
    }))
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'FILE', title: 'Files', items },
        rightModel: { view: 'BROWSER', title: 'Browser', items: [] },
        modeTitle: 'File Mode',
        pageLabel: 'Page 1'
      }
    })
    const fileListWrapper = wrapper.find('.display.left .file-list-wrapper')
    expect(fileListWrapper.exists()).toBe(true)
    expect(fileListWrapper.element).toBeInstanceOf(HTMLDivElement)
  })

  it('filters FILE view items by fileQuery', async () => {
    const items = [
      { title: 'kick.wav', subtitle: 'path/kick.wav' },
      { title: 'snare.wav', subtitle: 'path/snare.wav' },
      { title: 'hihat.wav', subtitle: 'path/hihat.wav' }
    ]
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'FILE', title: 'Files', items },
        rightModel: { view: 'BROWSER', title: 'Browser', items: [] },
        modeTitle: 'File Mode',
        pageLabel: 'Page 1'
      }
    })
    const searchInput = wrapper.find('.display.left input[type="search"]')
    await searchInput.setValue('kick')
    await wrapper.vm.$nextTick()
    const visibleItems = wrapper.findAll('.display.left .item-list li')
    expect(visibleItems).toHaveLength(1)
    expect(visibleItems[0].text()).toContain('kick.wav')
  })

  it('filters BROWSER view items by browserQuery', async () => {
    const items = [
      { title: 'Kick 808', subtitle: 'Bass drum' },
      { title: 'Snare Clap', subtitle: 'Snappy' },
      { title: 'Hi-Hat Closed', subtitle: 'Metallic' }
    ]
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'BROWSER', title: 'Browser', items },
        rightModel: { view: 'FILE', title: 'Files', items: [] },
        modeTitle: 'Browser Mode',
        pageLabel: 'Page 1'
      }
    })
    const searchInput = wrapper.find('.display.left input[type="search"]')
    await searchInput.setValue('snare')
    await wrapper.vm.$nextTick()
    const visibleItems = wrapper.findAll('.display.left .item-list li')
    expect(visibleItems).toHaveLength(1)
    expect(visibleItems[0].text()).toContain('Snare Clap')
  })

  it('shows all FILE items when fileQuery is empty', async () => {
    const items = Array.from({ length: 10 }, (_, i) => ({
      title: `File ${i + 1}`,
      subtitle: `path/file${i + 1}`
    }))
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'FILE', title: 'Files', items },
        rightModel: { view: 'BROWSER', title: 'Browser', items: [] },
        modeTitle: 'File Mode',
        pageLabel: 'Page 1'
      }
    })
    const visibleItems = wrapper.findAll('.display.left .item-list li')
    expect(visibleItems).toHaveLength(10)
  })

  it('renders FILE view in right panel with scroll wrapper', () => {
    const items = Array.from({ length: 20 }, (_, i) => ({
      title: `Dir ${i + 1}`,
      subtitle: `path/dir${i + 1}`
    }))
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'BROWSER', title: 'Browser', items: [] },
        rightModel: { view: 'FILE', title: 'Files', items },
        modeTitle: 'File Mode',
        pageLabel: 'Page 1'
      }
    })
    const fileListWrapper = wrapper.find('.display.right .file-list-wrapper')
    expect(fileListWrapper.exists()).toBe(true)
    const visibleItems = wrapper.findAll('.display.right .item-list li')
    expect(visibleItems).toHaveLength(20)
  })

  it('applies active class to selected FILE items', () => {
    const items = [
      { title: 'File 1', subtitle: 'path/file1', active: false },
      { title: 'File 2', subtitle: 'path/file2', active: true },
      { title: 'File 3', subtitle: 'path/file3', active: false }
    ]
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'BROWSER', title: 'Browser', items: [] },
        rightModel: { view: 'FILE', title: 'Files', items },
        modeTitle: 'File Mode',
        pageLabel: 'Page 1'
      }
    })
    const listItems = wrapper.findAll('.display.right .item-list li')
    expect(listItems[0].classes()).not.toContain('active')
    expect(listItems[1].classes()).toContain('active')
    expect(listItems[2].classes()).not.toContain('active')
  })

  it('formats param values correctly', () => {
    const wrapper = mount(DualDisplay, {
      props: {
        leftModel: { view: 'BROWSER', title: 'Browser', items: [] },
        rightModel: { view: 'FILE', title: 'Files', items: [] },
        modeTitle: 'Test',
        pageLabel: 'Page 1',
        paramSlotsLeft: [
          { id: 'p1', name: 'Volume', value: 75.456, format: 'dB' },
          { id: 'p2', name: 'Pan', value: 0.333 }
        ]
      }
    })
    const paramValues = wrapper.findAll('.display.left .param-value')
    expect(paramValues[0].text()).toBe('75.456dB')
    expect(paramValues[1].text()).toBe('0.33')
  })
})



=========================================
File: tests/componentTests/FourDEncoder.component.spec.ts
=========================================

import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import FourDEncoder from '@/components/control/FourDEncoder.vue'
import { createPinia, setActivePinia } from 'pinia'
import { useControlStore } from '@/stores/control'

describe('FourDEncoder', () => {
  const setup = () => {
    setActivePinia(createPinia())
    const control = useControlStore()
    vi.spyOn(control, 'turnEncoder4D')
    vi.spyOn(control, 'tiltEncoder4D')
    vi.spyOn(control, 'pressEncoder4D')
    const wrapper = mount(FourDEncoder)
    return { wrapper, control }
  }

  it('turns on wheel equivalent via key arrows', async () => {
    const { wrapper, control } = setup()
    await wrapper.trigger('keydown', { key: 'ArrowUp' })
    expect(control.turnEncoder4D).toHaveBeenCalledWith(1)
  })

  it('tilts on horizontal key arrows', async () => {
    const { wrapper, control } = setup()
    await wrapper.trigger('keydown', { key: 'ArrowLeft' })
    expect(control.tiltEncoder4D).toHaveBeenCalledWith('left')
  })

  it('presses on Enter/Space', async () => {
    const { wrapper, control } = setup()
    await wrapper.trigger('keydown', { key: 'Enter' })
    expect(control.pressEncoder4D).toHaveBeenCalled()
  })

  it('drags vertically to turn and horizontally to tilt', async () => {
    const { wrapper, control } = setup()
    const el = wrapper.element as HTMLElement

    el.dispatchEvent(new PointerEvent('pointerdown', { clientX: 100, clientY: 100, pointerId: 1, bubbles: true }))
    window.dispatchEvent(new PointerEvent('pointermove', { clientX: 100, clientY: 82, pointerId: 1 }))
    window.dispatchEvent(new PointerEvent('pointermove', { clientX: 120, clientY: 82, pointerId: 1 }))
    window.dispatchEvent(new PointerEvent('pointerup', { clientX: 120, clientY: 82, pointerId: 1 }))

    expect(control.turnEncoder4D).toHaveBeenCalled()
    expect(control.tiltEncoder4D).toHaveBeenCalled()
  })
})



=========================================
File: tests/componentTests/KnobControl.component.spec.ts
=========================================

import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import { nextTick } from 'vue'
import KnobControl from '@/components/KnobControl.vue'

const baseProps = {
  index: 0,
  label: 'Volume',
  value: 50,
  min: 0,
  max: 100,
  step: 1
}

describe('KnobControl', () => {
  it('sets rotation style based on value', () => {
    const wrapper = mount(KnobControl, { props: baseProps })

    expect(wrapper.attributes('style')).toContain('--knob-angle: 0deg')
  })

  it('emits turn on wheel', async () => {
    const wrapper = mount(KnobControl, { props: baseProps })

    await wrapper.trigger('wheel', { deltaY: -120 })

    const emitted = wrapper.emitted('turn') as Array<[{ delta: number; fine: boolean }]>
    expect(emitted?.[0]?.[0]).toMatchObject({ delta: 2, fine: false })
  })

  it('emits turn on pointer drag', async () => {
    const wrapper = mount(KnobControl, { props: baseProps })
    const el = wrapper.element as HTMLElement

    el.dispatchEvent(new PointerEvent('pointerdown', { clientY: 100, pointerId: 1, bubbles: true }))
    window.dispatchEvent(new PointerEvent('pointermove', { clientY: 88, pointerId: 1 }))
    window.dispatchEvent(new PointerEvent('pointerup', { clientY: 88, pointerId: 1 }))
    await nextTick()

    const turnEvents = wrapper.emitted('turn') as Array<[{ delta: number; fine: boolean }]>
    const payload = turnEvents?.find((entry) => (entry?.[0]?.delta ?? 0) !== 0)?.[0]

    expect(payload?.delta).to.equal(2)
  })

  it('uses fine mode when shiftHeld on keyboard', async () => {
    const wrapper = mount(KnobControl, { props: { ...baseProps, shiftHeld: true } })

    await wrapper.trigger('keydown', { key: 'ArrowUp' })

    const emitted = wrapper.emitted('turn') as Array<[{ delta: number; fine: boolean }]>
    expect(emitted?.[0]?.[0]).toMatchObject({ delta: 1, fine: true })
  })
})



=========================================
File: tests/componentTests/PadCell.component.spec.ts
=========================================

import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import PadCell from '../../components/PadCell.vue'

describe('PadCell', () => {
  it('renders label', () => {
    const wrapper = mount(PadCell, {
      props: {
        padId: 'pad1',
        label: 'Kick'
      }
    })

    expect(wrapper.text()).to.equal('Kick')
  })

  it('emits pad:down on pointerdown', async () => {
    const wrapper = mount(PadCell, {
      props: {
        padId: 'pad1',
        label: 'Kick'
      }
    })

    await wrapper.trigger('pointerdown')

    const emitted = wrapper.emitted('pad:down')

    expect(emitted).to.be.an('array')
    expect(emitted).to.have.lengthOf(1)
    if (emitted && emitted[0]) {
      expect(emitted[0][0]).to.equal('pad1')
    }
  })

  it('applies is-playing class', () => {
    const wrapper = mount(PadCell, {
      props: {
        padId: 'pad1',
        label: 'Kick',
        isPlaying: true
      }
    })

    expect(wrapper.classes()).to.include('is-playing')
  })
})



=========================================
File: tests/componentTests/PadGrid.component.spec.ts
=========================================

import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import PadGrid from '@/components/PadGrid.vue'
import type { DrumPadId } from '@/types/drums'


describe('PadGrid', () => {
  const pads: DrumPadId[] = ['pad1', 'pad2']

  it('renders PadCell components', () => {
    const wrapper = mount(PadGrid, {
      props: { pads, selectedPad: null, padStates: {} }
    })

    expect(wrapper.findAllComponents({ name: 'PadCell' }))
      .to.have.lengthOf(2)
  })

  it('emits pad:select when PadCell emits', async () => {
    const wrapper = mount(PadGrid, {
      props: { pads, selectedPad: null, padStates: {} }
    })

    await wrapper.findComponent({ name: 'PadCell' })
      .vm.$emit('pad:select', 'pad1')

    const emitted = wrapper.emitted('pad:select') as unknown[][]
    const payload = emitted?.[0]?.[0]
    expect(emitted).to.be.an('array')
    expect(emitted!.length).to.equal(1)
    expect(payload).to.equal('pad1')

  })

  it('passes is-selected correctly', () => {
    const wrapper = mount(PadGrid, {
      props: { pads, selectedPad: 'pad1', padStates: {} }
    })

    const cells = wrapper.findAllComponents({ name: 'PadCell' })
    expect(cells).to.have.lengthOf(2)

    expect(cells[0]!.props('isSelected')).to.equal(true)
    expect(cells[1]!.props('isSelected')).to.equal(false)
  })
})



=========================================
File: tests/setup/atobShim.ts
=========================================

const toBinaryString = (input: string): string => Buffer.from(input, 'base64').toString('binary')

if (typeof globalThis.atob === 'function') {
  const originalAtob = globalThis.atob.bind(globalThis)
  globalThis.atob = (input: string): string => {
    const normalized = String(input).replace(/\s+/g, '')
    try {
      return originalAtob(normalized)
    } catch {
      return toBinaryString(normalized)
    }
  }
} else {
  globalThis.atob = (input: string): string => toBinaryString(String(input).replace(/\s+/g, ''))
}



=========================================
File: tests/setup/indexedDBShim.ts
=========================================

// Shim IndexedDB for Vitest tests in Node.js environment
import 'fake-indexeddb/auto'



=========================================
File: tests/unitTests/browserPerformance.spec.ts
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useBrowserStore } from '../../stores/browser'
import {
  __setLibraryRepositoryForTests,
  type LibraryRepository,
  type LibraryItem
} from '../../services/libraryRepository'

class MemoryLibraryRepo implements LibraryRepository {
  constructor(public items: LibraryItem[] = []) { }
  favorites = new Set<string>()
  async search(query: string): Promise<LibraryItem[]>
  async search(query: string, _filters?: unknown): Promise<LibraryItem[]> {
    const text = query.trim().toLowerCase()
    if (!text) return this.items
    return this.items.filter((item) => item.name.toLowerCase().includes(text))
  }
  async getItem(id: string) {
    return this.items.find((item) => item.id === id)
  }
  async getTags(itemId: string) {
    return (await this.getItem(itemId))?.tags ?? []
  }
  async addTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item
    )
    return this.getTags(itemId)
  }
  async removeTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item
    )
    return this.getTags(itemId)
  }
  async importFile(path: string, meta?: Partial<LibraryItem>) {
    const item: LibraryItem = {
      id: meta?.id ?? path,
      name: meta?.name ?? path,
      tags: meta?.tags ?? [],
      path,
      ...meta
    }
    this.items.push(item)
    return item
  }
  async addToFavorites(itemId: string) {
    this.favorites.add(itemId)
  }
  async removeFromFavorites(itemId: string) {
    this.favorites.delete(itemId)
  }
  async getFavorites() {
    return this.items.filter((item) => this.favorites.has(item.id))
  }
  async isFavorite(itemId: string) {
    return this.favorites.has(itemId)
  }
  async getCategories() {
    return []
  }
  async getProducts() {
    return []
  }
  async getBanks() {
    return []
  }
  async getSubBanks() {
    return []
  }
  async refreshIndex() {
    return
  }
  async importDirectory() {
    return
  }
}

describe('browser performance helpers', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
    vi.useFakeTimers()
  })

  afterEach(() => {
    vi.runOnlyPendingTimers()
    vi.useRealTimers()
  })

  it('debounces search calls on query changes', async () => {
    const repo = new MemoryLibraryRepo([{ id: '1', name: 'Kick', tags: [] }])
    __setLibraryRepositoryForTests(repo)
    const store = useBrowserStore()
    await store.setQuery('Kick')
    expect(store.library.results.length).toBe(0)
    vi.advanceTimersByTime(310)
    await Promise.resolve()
    await Promise.resolve()
    expect(store.library.results.length).toBeGreaterThan(0)
  })

  it('limits display items to 100 when results are large', async () => {
    const items: LibraryItem[] = Array.from({ length: 150 }, (_, index) => ({
      id: String(index),
      name: `Item ${index}`,
      tags: []
    }))
    __setLibraryRepositoryForTests(new MemoryLibraryRepo(items))
    const store = useBrowserStore()
    await store.search()
    const models = store.toDisplayModels()
    expect(models.rightModel.items?.length).toBe(100)
  })
})



=========================================
File: tests/unitTests/browserSort.spec.ts
=========================================

import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import {
  __setLibraryRepositoryForTests,
  type LibraryRepository,
  type LibraryItem
} from '../../services/libraryRepository'
import {
  __setFileSystemRepositoryForTests,
  type FileSystemRepository,
  type DirectoryListing
} from '../../services/fileSystemRepository'
import { useBrowserStore, type SortMode } from '../../stores/browser'

class MemoryLibraryRepo implements LibraryRepository {
  constructor(public items: LibraryItem[] = []) {}
  favorites = new Set<string>()

  async search(query: string): Promise<LibraryItem[]>
  async search(query: string, _filters?: unknown): Promise<LibraryItem[]> {
    const text = query.trim().toLowerCase()
    if (!text) return this.items
    return this.items.filter((item) => item.name.toLowerCase().includes(text))
  }
  async getItem(id: string) {
    return this.items.find((item) => item.id === id)
  }
  async getTags(itemId: string) {
    return (await this.getItem(itemId))?.tags ?? []
  }
  async addTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item
    )
    return this.getTags(itemId)
  }
  async removeTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item
    )
    return this.getTags(itemId)
  }
  async importFile(path: string, meta?: Partial<LibraryItem>) {
    const item: LibraryItem = {
      id: meta?.id ?? path,
      name: meta?.name ?? path,
      tags: meta?.tags ?? [],
      path,
      ...meta
    }
    this.items.push(item)
    return item
  }
  async addToFavorites(itemId: string) {
    this.favorites.add(itemId)
  }
  async removeFromFavorites(itemId: string) {
    this.favorites.delete(itemId)
  }
  async getFavorites() {
    return this.items.filter((item) => this.favorites.has(item.id))
  }
  async isFavorite(itemId: string) {
    return this.favorites.has(itemId)
  }
  async refreshIndex() {
    return
  }
  async importDirectory() {
    return
  }
}

class MemoryFileRepo implements FileSystemRepository {
  constructor(private listing: DirectoryListing) {}
  async listDir(_path: string): Promise<DirectoryListing> {
    return this.listing
  }
  async stat(_path: string) {
    return { isDir: false }
  }
  async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
    const name = path.split('/').pop() ?? path
    const ext = name.includes('.') ? name.split('.').pop() : undefined
    const meta: { name: string; extension?: string } = { name }
    if (ext) meta.extension = ext
    return meta
  }
}

const createStoreWithSortMode = async (mode: SortMode) => {
  const store = useBrowserStore()
  await store.search()
  store.setSortMode(mode)
  return store
}

describe('browser sorting', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
    const repo = new MemoryLibraryRepo([
      { id: '1', name: 'Alpha', tags: [], importedAt: 2000 },
      { id: '2', name: 'beta', tags: [], importedAt: 1000 },
      { id: '3', name: 'Gamma', tags: [], importedAt: 3000 }
    ])
    __setLibraryRepositoryForTests(repo)
    __setFileSystemRepositoryForTests(
      new MemoryFileRepo({
        dirs: [
          { name: 'b-dir', path: '/b-dir' },
          { name: 'a-dir', path: '/a-dir' }
        ],
        files: [
          { name: 'z.wav', path: '/z.wav' },
          { name: 'a.wav', path: '/a.wav' }
        ]
      })
    )
  })

  it('sorts library results by name asc/desc', async () => {
    const store = await createStoreWithSortMode('name-asc')
    expect(store.library.results.map((item) => item.title)).toEqual(['Alpha', 'beta', 'Gamma'])

    store.setSortMode('name-desc')
    expect(store.library.results.map((item) => item.title)).toEqual(['Gamma', 'beta', 'Alpha'])
  })

  it('sorts library results by date asc/desc', async () => {
    const store = await createStoreWithSortMode('date-asc')
    expect(store.library.results.map((item) => item.id)).toEqual(['2', '1', '3'])

    store.setSortMode('date-desc')
    expect(store.library.results.map((item) => item.id)).toEqual(['3', '1', '2'])
  })

  it('restores relevance order when switching back', async () => {
    const store = await createStoreWithSortMode('name-desc')
    store.setSortMode('relevance')
    expect(store.library.results.map((item) => item.id)).toEqual(['1', '2', '3'])
  })

  it('sorts files when mode changes', async () => {
    const store = useBrowserStore()
    await store.setMode('FILES')
    store.setSortMode('name-asc')
    expect(store.files.entries.dirs.map((dir) => dir.name)).toEqual(['a-dir', 'b-dir'])
    expect(store.files.entries.files.map((file) => file.name)).toEqual(['a.wav', 'z.wav'])
  })

  it('persists sort mode in localStorage', async () => {
    const store = useBrowserStore()
    store.setSortMode('name-desc')
    setActivePinia(createPinia())
    const nextStore = useBrowserStore()
    expect(nextStore.sortMode).toBe('name-desc')
  })
})



=========================================
File: tests/unitTests/browserStore.spec.ts
=========================================

import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useBrowserStore, type BrowserFilters } from '../../stores/browser'
import {
  __setLibraryRepositoryForTests,
  type LibraryRepository,
  type LibraryItem
} from '../../services/libraryRepository'
import {
  __setFileSystemRepositoryForTests,
  type FileSystemRepository,
  type DirectoryListing
} from '../../services/fileSystemRepository'

class MemoryLibraryRepo implements LibraryRepository {
  constructor(public items: LibraryItem[] = []) { }
  favorites = new Set<string>()

  async search(query: string): Promise<LibraryItem[]>
  async search(query: string, filters?: BrowserFilters): Promise<LibraryItem[]> {
    const term = query.trim().toLowerCase()
    const matchesQuery = (item: LibraryItem) => {
      if (!term) return true
      return item.name.toLowerCase().includes(term)
    }
    const matchesFilters = (item: LibraryItem) => {
      if (!filters) return true
      if (filters.fileType && filters.fileType !== 'all' && item.fileType !== filters.fileType) return false
      if (filters.contentType && filters.contentType !== 'all' && item.contentType !== filters.contentType) return false
      if (filters.category && item.category !== filters.category) return false
      if (filters.product && item.product !== filters.product) return false
      if (filters.bank && item.bank !== filters.bank) return false
      if (filters.tags && filters.tags.length > 0) {
        const normalizedTags = filters.tags.map((tag) => tag.trim().toLowerCase()).filter((tag) => tag.length > 0)
        const itemTags = (item.tags ?? []).map((tag) => tag.trim().toLowerCase())
        if (!normalizedTags.every((tag) => itemTags.includes(tag))) return false
      }
      if (filters.favorites && item.favorites !== true) return false
      return true
    }
    return this.items.filter((item) => matchesQuery(item) && matchesFilters(item))
  }

  async getItem(id: string): Promise<LibraryItem | undefined> {
    return this.items.find((item) => item.id === id)
  }

  async getTags(itemId: string): Promise<string[]> {
    return (await this.getItem(itemId))?.tags ?? []
  }

  async addTag(itemId: string, tag: string): Promise<string[]> {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item
    )
    return this.getTags(itemId)
  }

  async removeTag(itemId: string, tag: string): Promise<string[]> {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item
    )
    return this.getTags(itemId)
  }

  importCalls: string[] = []

  async importFile(path: string, meta?: Partial<LibraryItem>): Promise<LibraryItem> {
    this.importCalls.push(path)
    const item: LibraryItem = {
      id: meta?.id ?? path,
      name: meta?.name ?? path,
      tags: meta?.tags ?? [],
      path
    }
    this.items.push(item)
    return item
  }

  async refreshIndex(): Promise<void> {
    // no-op for in-memory
  }

  async addToFavorites(itemId: string): Promise<void> {
    this.favorites.add(itemId)
  }

  async removeFromFavorites(itemId: string): Promise<void> {
    this.favorites.delete(itemId)
  }

  async getFavorites(): Promise<LibraryItem[]> {
    return this.items.filter((item) => this.favorites.has(item.id))
  }

  async isFavorite(itemId: string): Promise<boolean> {
    return this.favorites.has(itemId)
  }

  async importDirectory(): Promise<void> {
    return
  }
}

class MemoryFileRepo implements FileSystemRepository {
  constructor(private listing: DirectoryListing) { }
  async listDir(_path: string): Promise<DirectoryListing> {
    return this.listing
  }
  async stat(_path: string) {
    return { isDir: false }
  }
  async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
    const name = path.split('/').pop() ?? path
    const ext = name.includes('.') ? name.split('.').pop() : undefined
    const meta: { name: string; extension?: string } = { name }
    if (ext) {
      meta.extension = ext
    }
    return meta
  }
}

describe('browser store', () => {
  let libraryRepo: MemoryLibraryRepo
  let fileRepo: MemoryFileRepo

  beforeEach(() => {
    setActivePinia(createPinia())
    vi.useFakeTimers()
    libraryRepo = new MemoryLibraryRepo([
      {
        id: '1',
        name: 'Kick One',
        tags: ['drum'],
        fileType: 'sample',
        contentType: 'factory',
        category: 'drums',
        product: 'Kit A',
        bank: 'A',
        favorites: false
      },
      {
        id: '2',
        name: 'Snare Tight',
        tags: ['snare', 'tight'],
        fileType: 'sample',
        contentType: 'factory',
        category: 'drums',
        product: 'Kit A',
        bank: 'B',
        favorites: true
      },
      {
        id: '3',
        name: 'Pad Warm',
        tags: ['pad'],
        fileType: 'preset',
        contentType: 'user',
        category: 'synth',
        product: 'Pads',
        bank: 'Main',
        favorites: false
      }
    ])
    // Initialize favorites set based on items with favorites: true
    libraryRepo.favorites = new Set(
      libraryRepo.items.filter(item => item.favorites).map(item => item.id)
    )
    fileRepo = new MemoryFileRepo({
      dirs: [{ name: 'kits', path: '/kits' }],
      files: [{ name: 'new.wav', path: '/kits/new.wav' }]
    })
    __setLibraryRepositoryForTests(libraryRepo)
    __setFileSystemRepositoryForTests(fileRepo)
  })

  afterEach(() => {
    vi.runOnlyPendingTimers()
    vi.useRealTimers()
  })

  it('keeps library and files state separated on mode switch', async () => {
    const store = useBrowserStore()
    await store.setQuery('Kick')
    vi.advanceTimersByTime(350)
    await Promise.resolve()
    await Promise.resolve()
    expect(store.library.results).toHaveLength(1)
    await store.setMode('FILES')
    expect(store.files.entries.files).toHaveLength(1)
    expect(store.library.query).toBe('Kick')
    await store.setMode('LIBRARY')
    expect(store.library.results).toHaveLength(1)
  })

  it('updates search results when query changes', async () => {
    const store = useBrowserStore()
    await store.setQuery('snare')
    vi.advanceTimersByTime(350)
    await Promise.resolve()
    await Promise.resolve()
    expect(store.library.results[0]?.title).toContain('Snare')
  })

  it('persists tag changes through repository', async () => {
    const store = useBrowserStore()
    await store.search()
    await store.selectResult('1')
    await store.addTag('punch')
    expect(await libraryRepo.getTags('1')).toContain('punch')
    await store.removeTag('punch')
    expect(await libraryRepo.getTags('1')).not.toContain('punch')
  })

  it('lists directories and files for the current path', async () => {
    const store = useBrowserStore()
    await store.setMode('FILES')
    expect(store.files.entries.dirs[0]?.name).toBe('kits')
    expect(store.files.entries.files[0]?.name).toBe('new.wav')
  })

  it('imports selected file into library and refreshes search results', async () => {
    const store = useBrowserStore()
    await store.setMode('FILES')
    store.selectPath('/kits/new.wav')
    await store.importSelected()
    await store.setMode('LIBRARY')
    await store.search()
    expect(libraryRepo.importCalls).toContain('/kits/new.wav')
    expect(store.library.results.find((item) => item.title.includes('new.wav'))).toBeDefined()
  })

  it('applies filters to search results', async () => {
    const store = useBrowserStore()
    await store.search()
    store.setFilter('fileType', 'preset')
    await store.applyFilters()
    expect(store.library.results).toHaveLength(1)
    expect(store.library.results[0]?.title).toBe('Pad Warm')
  })

  it('combines multiple filters when searching', async () => {
    const store = useBrowserStore()
    await store.search()
    store.setFilter('fileType', 'sample')
    await Promise.resolve()
    store.setFilter('favorites', true)
    await Promise.resolve()
    store.setFilter('category', 'drums')
    await Promise.resolve()
    await store.applyFilters()
    await Promise.resolve()
    expect(store.library.results).toHaveLength(1)
    expect(store.library.results[0]?.title).toBe('Snare Tight')
  })

  it('builds encoder fields in the expected order', () => {
    const store = useBrowserStore()
    const fields = store.getEncoderFields()
    expect(fields.map((field) => field.id)).toEqual([
      'fileType',
      'contentType',
      'category',
      'product',
      'bank',
      'tags',
      'favorites'
    ])
    expect(fields[0]?.options).toContain('sample')
    expect(fields[6]?.value).toBe('off')
  })
})



=========================================
File: tests/unitTests/controlBrowserIntegration.spec.ts
=========================================

import { describe, it, beforeEach, expect } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useControlStore } from '../../stores/control'
import { useBrowserStore } from '../../stores/browser'
import { __setLibraryRepositoryForTests, type LibraryItem, type LibraryRepository } from '../../services/libraryRepository'
import { __setFileSystemRepositoryForTests } from '../../services/fileSystemRepository'

class ImportTrackingRepo implements LibraryRepository {
  imports: string[] = []
  items: LibraryItem[] = []
  favorites = new Set<string>()
  async search(_query: string, _filters?: unknown) {
    return this.items
  }
  async getItem() {
    return undefined
  }
  async getTags() {
    return []
  }
  async addTag() {
    return []
  }
  async removeTag() {
    return []
  }
  async importFile(path: string) {
    this.imports.push(path)
    const item = { id: path, name: path, tags: [] }
    this.items.push(item)
    return item
  }
  async refreshIndex() {
    return
  }
  async addToFavorites(itemId: string) {
    this.favorites.add(itemId)
  }
  async removeFromFavorites(itemId: string) {
    this.favorites.delete(itemId)
  }
  async getFavorites() {
    return this.items.filter((item) => this.favorites.has(item.id))
  }
  async isFavorite(itemId: string) {
    return this.favorites.has(itemId)
  }
  async getCategories() {
    return []
  }
  async getProducts() {
    return []
  }
  async getBanks() {
    return []
  }
  async getSubBanks() {
    return []
  }
  async importDirectory(): Promise<void> {
    return
  }
}

describe('control to browser wiring', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    __setLibraryRepositoryForTests(new ImportTrackingRepo())
  })

  it('initializes 4D encoder when entering browser modes', () => {
    const control = useControlStore()
    control.setMode('BROWSER')
    expect(control.encoder4D).not.toBeNull()
    expect(control.encoder4D?.fields.value[0]?.id).toBe('fileType')
  })

  it('navigates encoder fields horizontally', () => {
    const control = useControlStore()
    control.setMode('BROWSER')
    control.tiltEncoder4D('right')
    expect(control.encoder4D?.activeFieldIndex.value).toBe(1)
  })

  it('syncs filter changes when turning encoder in value mode', async () => {
    const browser = useBrowserStore()
    const control = useControlStore()
    control.setMode('BROWSER')
    control.encoder4D?.setMode('value-adjust')
    control.turnEncoder4D(1)
    expect(browser.filters.fileType).toBe('sample')
  })

  it('invokes browser import when triggering load action', async () => {
    const browser = useBrowserStore()
    const control = useControlStore()
    const repo = new ImportTrackingRepo()
    __setLibraryRepositoryForTests(repo)
    await browser.setMode('FILES')
    browser.selectPath('/imports/sample.wav')
    control.setMode('FILE')
    control.applyAction('BROWSER_LOAD')
    expect(repo.imports).toContain('/imports/sample.wav')
  })

  it('loads file via encoder press in list navigate mode', async () => {
    const browser = useBrowserStore()
    const control = useControlStore()
    const repo = new ImportTrackingRepo()
    __setLibraryRepositoryForTests(repo)
    __setFileSystemRepositoryForTests({
      async listDir() {
        return { dirs: [], files: [{ name: 'clip.wav', path: '/clip.wav' }] }
      },
      async stat() {
        return { isDir: false }
      },
      async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
        const name = path.split('/').pop() ?? path
        const ext = name.includes('.') ? name.split('.').pop() : undefined
        const meta: { name: string; extension?: string } = { name }
        if (ext) meta.extension = ext
        return meta
      }
    })
    await browser.setMode('FILES')
    control.setMode('FILE')
    control.encoder4D?.setMode('list-navigate')
    control.syncListSelection()
    await control.pressEncoder4D()
    expect(repo.imports.length).toBeGreaterThan(0)
    expect(repo.imports[0]).toBe(browser.files.selectedPath)
  })

  it('runs a browser workflow: filter, search, load', async () => {
    const control = useControlStore()
    const browser = useBrowserStore()
    const repo = new ImportTrackingRepo()
    repo.items = [{ id: '1', name: 'Kick', tags: [], fileType: 'sample' }]
    __setLibraryRepositoryForTests(repo)
    __setFileSystemRepositoryForTests({
      async listDir() {
        return { dirs: [], files: [{ name: 'kick.wav', path: '/kick.wav' }] }
      },
      async stat() {
        return { isDir: false }
      },
      async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
        const name = path.split('/').pop() ?? path
        const ext = name.includes('.') ? name.split('.').pop() : undefined
        const meta: { name: string; extension?: string } = { name }
        if (ext) meta.extension = ext
        return meta
      }
    })
    control.setMode('BROWSER')
    browser.setFilter('fileType', 'sample')
    await browser.search()
    await browser.setMode('FILES')
    browser.selectPath('/kick.wav')
    control.setMode('FILE')
    control.applyAction('BROWSER_LOAD')
    expect(repo.imports).toContain('/kick.wav')
  })

  it('runs recent â†’ quick browse restore â†’ load workflow', async () => {
    const control = useControlStore()
    const browser = useBrowserStore()
    const repo = new ImportTrackingRepo()
    __setLibraryRepositoryForTests(repo)
    __setFileSystemRepositoryForTests({
      async listDir() {
        return { dirs: [], files: [{ name: 'hat.wav', path: '/hat.wav' }] }
      },
      async stat() {
        return { isDir: false }
      },
      async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
        const name = path.split('/').pop() ?? path
        const ext = name.includes('.') ? name.split('.').pop() : undefined
        const meta: { name: string; extension?: string } = { name }
        if (ext) meta.extension = ext
        return meta
      }
    })
    await browser.setMode('FILES')
    browser.selectPath('/hat.wav')
    await browser.importSelected({ contextId: 'pad-0', contextType: 'sample' })
    browser.openQuickBrowse('pad-0')
    await new Promise((resolve) => setTimeout(resolve, 0))
    browser.selectPath('/hat.wav')
    control.setMode('FILE')
    control.applyAction('BROWSER_LOAD')
    expect(repo.imports).toContain('/hat.wav')
  })

  it('runs favorites â†’ filter â†’ load workflow', async () => {
    const control = useControlStore()
    const browser = useBrowserStore()
    const repo = new ImportTrackingRepo()
    repo.items = [
      { id: '1', name: 'Kick', tags: [], fileType: 'sample' },
      { id: '2', name: 'Snare', tags: [], fileType: 'sample' }
    ]
    __setLibraryRepositoryForTests(repo)
    __setFileSystemRepositoryForTests({
      async listDir() {
        return { dirs: [], files: [{ name: 'snare.wav', path: '/snare.wav' }] }
      },
      async stat() {
        return { isDir: false }
      },
      async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
        const name = path.split('/').pop() ?? path
        const ext = name.includes('.') ? name.split('.').pop() : undefined
        const meta: { name: string; extension?: string } = { name }
        if (ext) meta.extension = ext
        return meta
      }
    })
    control.setMode('BROWSER')
    await browser.search()
    await browser.toggleFavorite('2')
    browser.setFilter('favorites', true)
    await browser.applyFilters()
    expect(browser.library.results.map((item) => item.id)).toEqual(['2'])
    await browser.setMode('FILES')
    browser.selectPath('/snare.wav')
    control.setMode('FILE')
    control.applyAction('BROWSER_LOAD')
    expect(repo.imports).toContain('/snare.wav')
  })

  it('runs preview â†’ stop â†’ load workflow', async () => {
    const control = useControlStore()
    const browser = useBrowserStore()
    const repo = new ImportTrackingRepo()
    __setLibraryRepositoryForTests(repo)
    __setFileSystemRepositoryForTests({
      async listDir() {
        return { dirs: [], files: [{ name: 'tone.wav', path: '/tone.wav' }] }
      },
      async stat() {
        return { isDir: false }
      },
      async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
        const name = path.split('/').pop() ?? path
        const ext = name.includes('.') ? name.split('.').pop() : undefined
        const meta: { name: string; extension?: string } = { name }
        if (ext) meta.extension = ext
        return meta
      },
      async readFileBlob() {
        return new Blob(['tone'], { type: 'audio/wav' })
      }
    })
    await browser.setMode('FILES')
    browser.selectPath('/tone.wav')
    control.setMode('BROWSER')
    control.applyAction('BROWSER_PREHEAR')
    control.applyAction('BROWSER_STOP')
    control.setMode('FILE')
    control.applyAction('BROWSER_LOAD')
    expect(repo.imports).toContain('/tone.wav')
  })

  it('handles empty results without selection', async () => {
    const browser = useBrowserStore()
    await browser.search()
    expect(browser.library.results).toHaveLength(0)
    expect(browser.library.selectedId).toBeNull()
  })

  it('surfaces permission denial on file system list', async () => {
    const browser = useBrowserStore()
    __setFileSystemRepositoryForTests({
      async listDir() {
        throw new Error('Permission denied')
      },
      async stat() {
        return { isDir: false }
      },
      async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
        return { name: path }
      }
    })
    await expect(browser.setMode('FILES')).rejects.toThrow('Permission denied')
  })

  it('surfaces import errors', async () => {
    const browser = useBrowserStore()
    const repo = new ImportTrackingRepo()
    repo.importFile = async () => {
      throw new Error('Import failed')
    }
    __setLibraryRepositoryForTests(repo)
    __setFileSystemRepositoryForTests({
      async listDir() {
        return { dirs: [], files: [{ name: 'broken.wav', path: '/broken.wav' }] }
      },
      async stat() {
        return { isDir: false }
      },
      async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
        return { name: path }
      }
    })
    await browser.setMode('FILES')
    browser.selectPath('/broken.wav')
    await expect(browser.importSelected()).rejects.toThrow('Import failed')
  })
})



=========================================
File: tests/unitTests/favorites.spec.ts
=========================================

import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import {
  __resetLibraryRepository,
  __setLibraryRepositoryForTests,
  getLibraryRepository,
  type LibraryRepository,
  type LibraryItem
} from '../../services/libraryRepository'
import { useBrowserStore } from '../../stores/browser'

class MemoryLibraryRepo implements LibraryRepository {
  constructor(public items: LibraryItem[] = []) {}
  favorites = new Set<string>()

  async search(query: string): Promise<LibraryItem[]>
  async search(query: string, _filters?: unknown): Promise<LibraryItem[]> {
    const text = query.trim().toLowerCase()
    if (!text) return this.items
    return this.items.filter((item) => item.name.toLowerCase().includes(text))
  }
  async getItem(id: string) {
    return this.items.find((item) => item.id === id)
  }
  async getTags(itemId: string) {
    return (await this.getItem(itemId))?.tags ?? []
  }
  async addTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item
    )
    return this.getTags(itemId)
  }
  async removeTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item
    )
    return this.getTags(itemId)
  }
  async importFile(path: string, meta?: Partial<LibraryItem>) {
    const item: LibraryItem = {
      id: meta?.id ?? path,
      name: meta?.name ?? path,
      tags: meta?.tags ?? [],
      path,
      ...meta
    }
    this.items.push(item)
    return item
  }
  async addToFavorites(itemId: string) {
    this.favorites.add(itemId)
  }
  async removeFromFavorites(itemId: string) {
    this.favorites.delete(itemId)
  }
  async getFavorites() {
    return this.items.filter((item) => this.favorites.has(item.id))
  }
  async isFavorite(itemId: string) {
    return this.favorites.has(itemId)
  }
  async refreshIndex() {
    return
  }
  async importDirectory() {
    return
  }
}

describe('favorites', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    __resetLibraryRepository()
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
  })

  afterEach(() => {
    __resetLibraryRepository()
  })

  it('adds/removes favorites and persists them', async () => {
    const repo = getLibraryRepository()
    await repo.importFile('/kick.wav', { id: 'kick', name: 'Kick', tags: [] })
    await repo.addToFavorites('kick')
    expect(await repo.isFavorite('kick')).toBe(true)
    const favorites = await repo.getFavorites()
    expect(favorites.map((item) => item.id)).toContain('kick')

    __resetLibraryRepository()
    const reloaded = getLibraryRepository()
    expect(await reloaded.isFavorite('kick')).toBe(true)

    await reloaded.removeFromFavorites('kick')
    expect(await reloaded.isFavorite('kick')).toBe(false)
  })

  it('toggles favorites through the browser store action', async () => {
    const repo = new MemoryLibraryRepo([
      { id: '1', name: 'Kick', tags: [] },
      { id: '2', name: 'Snare', tags: [] }
    ])
    __setLibraryRepositoryForTests(repo)
    const store = useBrowserStore()
    await store.search()

    await store.toggleFavorite('1')
    expect(await repo.isFavorite('1')).toBe(true)
    expect(store.library.results.find((item) => item.id === '1')?.favorites).toBe(true)
  })

  it('filters results to favorites and marks display subtitles', async () => {
    const repo = new MemoryLibraryRepo([
      { id: '1', name: 'Kick', tags: ['drum'] },
      { id: '2', name: 'Snare', tags: ['drum'] }
    ])
    await repo.addToFavorites('2')
    __setLibraryRepositoryForTests(repo)

    const store = useBrowserStore()
    store.setFilter('favorites', true)
    await store.search()

    expect(store.library.results).toHaveLength(1)
    expect(store.library.results[0]?.id).toBe('2')
    const display = store.toDisplayModels()
    const subtitle = display.rightModel.items?.[0]?.subtitle ?? ''
    expect(subtitle.includes('â˜…')).toBe(true)
  })
})



=========================================
File: tests/unitTests/fileSystemRepository.spec.ts
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import {
  getFileSystemRepository,
  __resetFileSystemRepository,
  type DirectoryListing
} from '../../services/fileSystemRepository'

type MockFileNode = {
  name: string
  kind: 'file'
  content: string
}

type MockDirNode = {
  name: string
  kind: 'directory'
  children: Array<MockFileNode | MockDirNode>
}

const createFileHandle = (node: MockFileNode): FileSystemFileHandle => {
  return {
    kind: 'file',
    name: node.name,
    async getFile() {
      return new File([node.content], node.name, { type: 'text/plain' })
    }
  } as FileSystemFileHandle
}

const createDirHandle = (node: MockDirNode): FileSystemDirectoryHandle => {
  const entries = async function* () {
    for (const child of node.children) {
      if (child.kind === 'directory') {
        yield [child.name, createDirHandle(child)] as [string, FileSystemHandle]
      } else {
        yield [child.name, createFileHandle(child)] as [string, FileSystemHandle]
      }
    }
  }
  const getDirectoryHandle = async (name: string) => {
    const match = node.children.find((child) => child.kind === 'directory' && child.name === name)
    if (!match || match.kind !== 'directory') {
      throw new Error('Directory not found')
    }
    return createDirHandle(match)
  }
  const getFileHandle = async (name: string) => {
    const match = node.children.find((child) => child.kind === 'file' && child.name === name)
    if (!match || match.kind !== 'file') {
      throw new Error('File not found')
    }
    return createFileHandle(match)
  }
  return {
    kind: 'directory',
    name: node.name,
    entries,
    getDirectoryHandle,
    getFileHandle
  } as unknown as FileSystemDirectoryHandle
}

describe('file system repository', () => {
  const originalWindow = globalThis.window
  const originalPicker = (globalThis.window as Window | undefined)?.showDirectoryPicker

  beforeEach(() => {
    __resetFileSystemRepository()
  })

  afterEach(() => {
    if (originalWindow) {
      if (originalPicker) {
        originalWindow.showDirectoryPicker = originalPicker
      } else if ('showDirectoryPicker' in originalWindow) {
        delete originalWindow.showDirectoryPicker
      }
      globalThis.window = originalWindow
    } else {
      // @ts-expect-error: cleanup for test-only window injection
      delete globalThis.window
    }
    __resetFileSystemRepository()
  })

  it('lists directories and files via browser file system access', async () => {
    const root: MockDirNode = {
      name: 'root',
      kind: 'directory',
      children: [
        {
          name: 'Samples',
          kind: 'directory',
          children: [{ name: 'kick.wav', kind: 'file', content: 'kick' }]
        },
        { name: 'root.wav', kind: 'file', content: 'root' }
      ]
    }
    const picker = vi.fn(async () => createDirHandle(root))
    globalThis.window = { showDirectoryPicker: picker } as unknown as Window & typeof globalThis

    const repo = getFileSystemRepository()
    const listing: DirectoryListing = await repo.listDir('/')

    expect(picker).toHaveBeenCalledTimes(1)
    expect(listing.dirs.map((dir) => dir.name)).toContain('Samples')
    expect(listing.files.map((file) => file.name)).toContain('root.wav')
  })

  it('reads a blob from the browser file system access handle', async () => {
    const root: MockDirNode = {
      name: 'root',
      kind: 'directory',
      children: [{ name: 'clip.txt', kind: 'file', content: 'clip' }]
    }
    const picker = vi.fn(async () => createDirHandle(root))
    globalThis.window = { showDirectoryPicker: picker } as unknown as Window & typeof globalThis

    const repo = getFileSystemRepository()
    const blob = await repo.readFileBlob?.('/clip.txt')

    expect(blob).toBeInstanceOf(Blob)
    expect(blob?.size).toBe(4)
  })

  it('falls back to the in-memory file system when the API is unavailable', async () => {
    if (globalThis.window) {
      delete globalThis.window.showDirectoryPicker
    }

    const repo = getFileSystemRepository()
    const listing = await repo.listDir('/')

    expect(listing.dirs.length).toBeGreaterThan(0)
    expect(listing.files.length).toBeGreaterThanOrEqual(0)
  })
})



=========================================
File: tests/unitTests/libraryHierarchy.spec.ts
=========================================

import { describe, it, expect, beforeEach } from 'vitest'
import {
  __resetLibraryRepository,
  getLibraryRepository
} from '../../services/libraryRepository'
import {
  __setFileSystemRepositoryForTests,
  type FileSystemRepository,
  type DirectoryListing
} from '../../services/fileSystemRepository'
import { setActivePinia, createPinia } from 'pinia'
import { useBrowserStore } from '../../stores/browser'

class MemoryFileRepo implements FileSystemRepository {
  constructor(private listing: DirectoryListing) {}
  async listDir(_path: string): Promise<DirectoryListing> {
    return this.listing
  }
  async stat(_path: string) {
    return { isDir: false }
  }
  async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
    const name = path.split('/').pop() ?? path
    const ext = name.includes('.') ? name.split('.').pop() : undefined
    const meta: { name: string; extension?: string } = { name }
    if (ext) meta.extension = ext
    return meta
  }
}

describe('library hierarchy', () => {
  beforeEach(() => {
    __resetLibraryRepository()
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
    setActivePinia(createPinia())
  })

  it('returns hierarchical values based on parent filters', async () => {
    const repo = getLibraryRepository()
    await repo.importFile('/Drums/808/Kicks/Deep/kick_01.wav', {
      name: 'kick_01',
      category: 'Drums',
      product: '808',
      bank: 'Kicks',
      subBank: 'Deep',
      vendor: 'user'
    })
    await repo.importFile('/Drums/909/Snares/Loose/snare_01.wav', {
      name: 'snare_01',
      category: 'Drums',
      product: '909',
      bank: 'Snares',
      subBank: 'Loose',
      vendor: 'user'
    })
    const categories = await repo.getCategories?.()
    const products = await repo.getProducts?.('Drums')
    const banks = await repo.getBanks?.('808')
    const subBanks = await repo.getSubBanks?.('Kicks')

    expect(categories).toEqual(['Drums'])
    expect(products).toEqual(['808', '909'])
    expect(banks).toEqual(['Kicks'])
    expect(subBanks).toEqual(['Deep'])
  })

  it('updates filter cascade options in browser store', async () => {
    const repo = getLibraryRepository()
    await repo.importFile('/Drums/808/Kicks/Deep/kick_01.wav', {
      name: 'kick_01',
      category: 'Drums',
      product: '808',
      bank: 'Kicks',
      subBank: 'Deep',
      vendor: 'user'
    })
    await repo.importFile('/Drums/909/Snares/Loose/snare_01.wav', {
      name: 'snare_01',
      category: 'Drums',
      product: '909',
      bank: 'Snares',
      subBank: 'Loose',
      vendor: 'user'
    })
    const store = useBrowserStore()
    await store.search()
    store.setFilter('category', 'Drums')
    await store.applyFilters()
    expect(store.availableProducts).toEqual(['808', '909'])
    store.setFilter('product', '808')
    await store.applyFilters()
    expect(store.availableBanks).toEqual(['Kicks'])
  })

  it('extracts metadata from paths during directory import', async () => {
    __setFileSystemRepositoryForTests(
      new MemoryFileRepo({
        dirs: [],
        files: [{ name: 'kick_01.wav', path: '/Drums/808/Kicks/Deep/kick_01.wav' }]
      })
    )
    const repo = getLibraryRepository()
    await repo.importDirectory?.('/', undefined, undefined)
    const items = await repo.search('')
    const entry = items.find((item) => item.path?.includes('kick_01.wav'))
    expect(entry?.category).toBe('Drums')
    expect(entry?.product).toBe('808')
    expect(entry?.bank).toBe('Kicks')
    expect(entry?.subBank).toBe('Deep')
  })
})



=========================================
File: tests/unitTests/libraryImport.spec.ts
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import {
  __resetLibraryRepository,
  getLibraryRepository
} from '../../services/libraryRepository'
import {
  __resetFileSystemRepository,
  __setFileSystemRepositoryForTests,
  type FileSystemRepository,
  type DirectoryListing
} from '../../services/fileSystemRepository'

class MockFileSystemRepository implements FileSystemRepository {
  constructor(private listings: Record<string, DirectoryListing>, private throwOn?: Set<string>) {}

  async listDir(path: string): Promise<DirectoryListing> {
    if (this.throwOn?.has(path)) {
      throw new Error('Read error')
    }
    return this.listings[path] ?? { dirs: [], files: [] }
  }

  async stat(_path: string): Promise<{ isDir: boolean }> {
    return { isDir: false }
  }

  async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
    const name = path.split('/').pop() ?? path
    const parts = name.split('.')
    const extension = parts.length > 1 ? parts.pop() : undefined
    const meta: { name: string; extension?: string } = { name }
    if (extension) meta.extension = extension
    return meta
  }
}

describe('library import directory', () => {
  beforeEach(() => {
    __resetLibraryRepository()
    __resetFileSystemRepository()
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
  })

  afterEach(() => {
    __resetLibraryRepository()
    __resetFileSystemRepository()
  })

  it('imports recursively and reports progress with metadata', async () => {
    const listings: Record<string, DirectoryListing> = {
      '/': {
        dirs: [{ name: 'Drums', path: '/Drums' }],
        files: [{ name: 'readme.txt', path: '/readme.txt' }]
      },
      '/Drums': {
        dirs: [{ name: 'KitA', path: '/Drums/KitA' }],
        files: [{ name: 'kick.wav', path: '/Drums/kick.wav' }]
      },
      '/Drums/KitA': {
        dirs: [{ name: 'Bank1', path: '/Drums/KitA/Bank1' }],
        files: []
      },
      '/Drums/KitA/Bank1': {
        dirs: [{ name: 'Sub', path: '/Drums/KitA/Bank1/Sub' }],
        files: [{ name: 'snare.aiff', path: '/Drums/KitA/Bank1/snare.aiff' }]
      },
      '/Drums/KitA/Bank1/Sub': {
        dirs: [],
        files: [{ name: 'loop.wav', path: '/Drums/KitA/Bank1/Sub/loop.wav' }]
      }
    }
    __setFileSystemRepositoryForTests(new MockFileSystemRepository(listings))

    const repo = getLibraryRepository()
    const progressCalls: Array<{ total: number; completed: number; current: string; errors: string[] }> = []

    await repo.importDirectory?.('/', { recursive: true }, (progress) => progressCalls.push(progress))

    expect(progressCalls).toHaveLength(3)
    expect(progressCalls[2]?.completed).toBe(3)
    expect(progressCalls[2]?.total).toBe(3)
    expect(progressCalls[2]?.errors).toContain('/readme.txt')

    const items = await repo.search('')
    const loopItem = items.find((item) => item.path === '/Drums/KitA/Bank1/Sub/loop.wav')
    expect(loopItem?.category).toBe('Drums')
    expect(loopItem?.product).toBe('KitA')
    expect(loopItem?.bank).toBe('Bank1')
    expect(loopItem?.subBank).toBe('Sub')
    expect(loopItem?.vendor).toBe('user')
  })

  it('records errors for unsupported formats and import failures', async () => {
    const listings: Record<string, DirectoryListing> = {
      '/': {
        dirs: [],
        files: [
          { name: 'bad.wav', path: '/bad.wav' },
          { name: 'note.txt', path: '/note.txt' }
        ]
      }
    }
    __setFileSystemRepositoryForTests(new MockFileSystemRepository(listings))

    const repo = getLibraryRepository()
    const warnSpy = vi.spyOn(console, 'warn').mockImplementation(() => undefined)
    const originalImport = repo.importFile.bind(repo)
    repo.importFile = async (path, meta) => {
      if (path === '/bad.wav') {
        throw new Error('Import failed')
      }
      return originalImport(path, meta)
    }

    const progressCalls: Array<{ total: number; completed: number; current: string; errors: string[] }> = []
    await repo.importDirectory?.('/', undefined, (progress) => progressCalls.push(progress))

    expect(progressCalls).toHaveLength(1)
    expect(progressCalls[0]?.errors).toContain('/bad.wav')
    expect(progressCalls[0]?.errors).toContain('/note.txt')
    expect(warnSpy).toHaveBeenCalled()

    warnSpy.mockRestore()
  })
})



=========================================
File: tests/unitTests/quickBrowse.spec.ts
=========================================

import { describe, it, expect, beforeEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useQuickBrowse } from '../../composables/useQuickBrowse'
import {
  __setLibraryRepositoryForTests,
  type LibraryRepository,
  type LibraryItem
} from '../../services/libraryRepository'
import { useBrowserStore } from '../../stores/browser'

class MemoryLibraryRepo implements LibraryRepository {
  constructor(public items: LibraryItem[] = []) {}
  favorites = new Set<string>()
  async search(query: string): Promise<LibraryItem[]>
  async search(query: string, _filters?: unknown): Promise<LibraryItem[]> {
    const text = query.trim().toLowerCase()
    if (!text) return this.items
    return this.items.filter((item) => item.name.toLowerCase().includes(text))
  }
  async getItem(id: string) {
    return this.items.find((item) => item.id === id)
  }
  async getTags(itemId: string) {
    return (await this.getItem(itemId))?.tags ?? []
  }
  async addTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item
    )
    return this.getTags(itemId)
  }
  async removeTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item
    )
    return this.getTags(itemId)
  }
  async importFile(path: string, meta?: Partial<LibraryItem>) {
    const item: LibraryItem = {
      id: meta?.id ?? path,
      name: meta?.name ?? path,
      tags: meta?.tags ?? [],
      path,
      ...meta
    }
    this.items.push(item)
    return item
  }
  async addToFavorites(itemId: string) {
    this.favorites.add(itemId)
  }
  async removeFromFavorites(itemId: string) {
    this.favorites.delete(itemId)
  }
  async getFavorites() {
    return this.items.filter((item) => this.favorites.has(item.id))
  }
  async isFavorite(itemId: string) {
    return this.favorites.has(itemId)
  }
  async refreshIndex() {
    return
  }
  async importDirectory() {
    return
  }
}

describe('useQuickBrowse', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
  })

  it('records history entries grouped by context', () => {
    const quickBrowse = useQuickBrowse()
    vi.spyOn(Date, 'now').mockReturnValueOnce(1000).mockReturnValueOnce(2000)

    quickBrowse.recordBrowse({
      mode: 'LIBRARY',
      query: 'Kick',
      filters: { fileType: 'sample' },
      selectedId: '1',
      contextType: 'sample',
      contextId: 'pad-0'
    })
    quickBrowse.recordBrowse({
      mode: 'LIBRARY',
      query: 'Snare',
      filters: { fileType: 'sample' },
      selectedId: '2',
      contextType: 'sample',
      contextId: 'pad-0'
    })

    expect(quickBrowse.history.value).toHaveLength(1)
    expect(quickBrowse.history.value[0]?.query).toBe('Snare')
  })

  it('returns the last browse entry for a context', () => {
    const quickBrowse = useQuickBrowse()
    quickBrowse.recordBrowse({
      mode: 'LIBRARY',
      query: 'Pad',
      filters: { fileType: 'preset' },
      selectedId: '3',
      contextType: 'preset',
      contextId: 'sound-1'
    })
    const entry = quickBrowse.getLastBrowse('sound-1')
    expect(entry?.query).toBe('Pad')
  })

  it('restores browse state from history', async () => {
    const repo = new MemoryLibraryRepo([{ id: '1', name: 'Kick', tags: [] }])
    __setLibraryRepositoryForTests(repo)
    const store = useBrowserStore()

    const quickBrowse = useQuickBrowse()
    quickBrowse.restoreBrowse({
      timestamp: Date.now(),
      mode: 'LIBRARY',
      query: 'Kick',
      filters: { fileType: 'sample' },
      selectedId: '1',
      contextType: 'sample',
      contextId: 'pad-0'
    })

    await new Promise((resolve) => setTimeout(resolve, 0))
    expect(store.mode).toBe('LIBRARY')
    expect(store.library.query).toBe('Kick')
    expect(store.filters.fileType).toBe('sample')
    expect(store.library.selectedId).toBe('1')
  })
})



=========================================
File: tests/unitTests/recentFiles.spec.ts
=========================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { useRecentFiles, type RecentFileEntry } from '../../composables/useRecentFiles'

describe('useRecentFiles', () => {
  beforeEach(() => {
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  it('deduplicates entries and moves them to the front', () => {
    const recent = useRecentFiles()
    vi.spyOn(Date, 'now').mockReturnValueOnce(1000).mockReturnValueOnce(2000)
    recent.addRecent({ id: 'a', path: '/a.wav', name: 'A', type: 'sample' })
    recent.addRecent({ id: 'a', path: '/a.wav', name: 'A', type: 'sample' })
    const entries = recent.getRecent()
    expect(entries).toHaveLength(1)
    expect(entries[0]?.timestamp).toBe(2000)
  })

  it('caps the recent list to the max limit', () => {
    const recent = useRecentFiles()
    const nowSpy = vi.spyOn(Date, 'now')
    for (let i = 0; i < 55; i += 1) {
      nowSpy.mockReturnValueOnce(1000 + i)
      recent.addRecent({ id: String(i), path: `/file-${i}.wav`, name: `File ${i}`, type: 'sample' })
    }
    const entries = recent.getRecent()
    expect(entries).toHaveLength(50)
    expect(entries[0]?.id).toBe('54')
  })

  it('sorts by timestamp descending', () => {
    const recent = useRecentFiles()
    vi.spyOn(Date, 'now').mockReturnValueOnce(1000).mockReturnValueOnce(3000).mockReturnValueOnce(2000)
    recent.addRecent({ id: 'first', path: '/first.wav', name: 'First', type: 'sample' })
    recent.addRecent({ id: 'third', path: '/third.wav', name: 'Third', type: 'sample' })
    recent.addRecent({ id: 'second', path: '/second.wav', name: 'Second', type: 'sample' })
    const entries = recent.getRecent()
    expect(entries.map((entry) => entry.id)).toEqual(['third', 'second', 'first'])
  })

  it('persists entries to localStorage', () => {
    const recent = useRecentFiles()
    vi.spyOn(Date, 'now').mockReturnValueOnce(5000)
    const entry: Omit<RecentFileEntry, 'timestamp'> = {
      id: 'persist',
      path: '/persist.wav',
      name: 'Persist',
      type: 'sample'
    }
    recent.addRecent(entry)
    const reloaded = useRecentFiles()
    const entries = reloaded.getRecent()
    expect(entries).toHaveLength(1)
    expect(entries[0]?.id).toBe('persist')
    expect(entries[0]?.timestamp).toBe(5000)
  })
})



=========================================
File: tests/unitTests/sampleDb.spec.ts
=========================================

import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import * as sampleDb from '../../services/sampleDb'

describe('SampleDB (IndexedDB)', () => {
  beforeEach(async () => {
    await sampleDb.clearAll()
  })

  afterEach(async () => {
    await sampleDb.clearAll()
    sampleDb.closeDb()
  })

  it('upsert enforces unique path (overwrites existing)', async () => {
    const entry1 = {
      path: '/samples/kick.wav',
      name: 'Kick 1',
      tags: ['drum', 'kick'],
      lastUsedAtMs: 1000,
      importedAt: 1000
    }

    const entry2 = {
      path: '/samples/kick.wav',
      name: 'Kick Updated',
      tags: ['drum', 'kick', 'updated'],
      lastUsedAtMs: 2000,
      importedAt: 1000
    }

    await sampleDb.upsertFromPath(entry1)
    await sampleDb.upsertFromPath(entry2)

    const result = await sampleDb.getByPath('/samples/kick.wav')
    expect(result).not.toBeNull()
    expect(result?.name).toBe('Kick Updated')
    expect(result?.tags).toEqual(['drum', 'kick', 'updated'])
    expect(result?.lastUsedAtMs).toBe(2000)

    const all = await sampleDb.getAllSamples()
    expect(all.length).toBe(1)
  })

  it('token search finds partial matches', async () => {
    await sampleDb.upsertFromPath({
      path: '/samples/snare-top.wav',
      name: 'Snare Top',
      tags: ['snare', 'drum'],
      lastUsedAtMs: 1000
    })

    await sampleDb.upsertFromPath({
      path: '/samples/snare-bottom.wav',
      name: 'Snare Bottom',
      tags: ['snare', 'drum'],
      lastUsedAtMs: 2000
    })

    await sampleDb.upsertFromPath({
      path: '/samples/kick.wav',
      name: 'Kick',
      tags: ['kick', 'drum'],
      lastUsedAtMs: 3000
    })

    // Search for "snare"
    const snareResults = await sampleDb.search('snare')
    expect(snareResults.length).toBe(2)
    expect(snareResults.every((r) => r.path.includes('snare'))).toBe(true)

    // Search for "drum"
    const drumResults = await sampleDb.search('drum')
    expect(drumResults.length).toBe(3)

    // Search for partial token "sna"
    const partialResults = await sampleDb.search('sna')
    expect(partialResults.length).toBe(2)

    // Search for non-existent token
    const noResults = await sampleDb.search('cymbal')
    expect(noResults.length).toBe(0)
  })

  it('getRecent sorts by lastUsedAtMs descending', async () => {
    await sampleDb.upsertFromPath({
      path: '/samples/a.wav',
      name: 'A',
      tags: [],
      lastUsedAtMs: 1000
    })

    await sampleDb.upsertFromPath({
      path: '/samples/b.wav',
      name: 'B',
      tags: [],
      lastUsedAtMs: 3000
    })

    await sampleDb.upsertFromPath({
      path: '/samples/c.wav',
      name: 'C',
      tags: [],
      lastUsedAtMs: 2000
    })

    const recent = await sampleDb.getRecent()
    expect(recent.length).toBe(3)
    expect(recent[0].path).toBe('/samples/b.wav')
    expect(recent[1].path).toBe('/samples/c.wav')
    expect(recent[2].path).toBe('/samples/a.wav')

    const recentLimited = await sampleDb.getRecent(2)
    expect(recentLimited.length).toBe(2)
    expect(recentLimited[0].path).toBe('/samples/b.wav')
    expect(recentLimited[1].path).toBe('/samples/c.wav')
  })

  it('setTags updates existing entry and re-indexes tokens', async () => {
    await sampleDb.upsertFromPath({
      path: '/samples/hat.wav',
      name: 'Hat',
      tags: ['hihat'],
      lastUsedAtMs: 1000
    })

    // Update tags
    await sampleDb.setTags('/samples/hat.wav', ['hihat', 'closed'])

    const updated = await sampleDb.getByPath('/samples/hat.wav')
    expect(updated?.tags).toEqual(['hihat', 'closed'])

    // Search should find by new tag
    const closedResults = await sampleDb.search('closed')
    expect(closedResults.length).toBe(1)
    expect(closedResults[0].path).toBe('/samples/hat.wav')
  })

  it('search with empty query returns all samples', async () => {
    await sampleDb.upsertFromPath({
      path: '/samples/a.wav',
      name: 'A',
      tags: [],
      lastUsedAtMs: 1000
    })

    await sampleDb.upsertFromPath({
      path: '/samples/b.wav',
      name: 'B',
      tags: [],
      lastUsedAtMs: 2000
    })

    const results = await sampleDb.search('')
    expect(results.length).toBe(2)
  })

  it('upsertFromPath tokenizes path, name, and tags', async () => {
    await sampleDb.upsertFromPath({
      path: '/user/samples/808-kick-deep.wav',
      name: '808 Kick Deep',
      tags: ['electronic', 'bass-drum'],
      lastUsedAtMs: 1000
    })

    // Search by path component
    const pathResults = await sampleDb.search('808')
    expect(pathResults.length).toBe(1)

    // Search by name token
    const nameResults = await sampleDb.search('deep')
    expect(nameResults.length).toBe(1)

    // Search by tag token
    const tagResults = await sampleDb.search('electronic')
    expect(tagResults.length).toBe(1)

    // Search by hyphenated tag
    const hyphenResults = await sampleDb.search('bass')
    expect(hyphenResults.length).toBe(1)
  })
})



=========================================
File: tests/unitTests/sampleImportToPad.spec.ts
=========================================

import { describe, it, expect, beforeEach, afterEach, vi as _vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import {
  __resetLibraryRepository,
  getLibraryRepository,
  type LibraryItem as _LibraryItem
} from '../../services/libraryRepository'
import { useBrowserStore } from '../../stores/browser'
import {
  __resetFileSystemRepository,
  __setFileSystemRepositoryForTests,
  type FileSystemRepository,
  type DirectoryListing
} from '../../services/fileSystemRepository'

class MockFileSystemRepository implements FileSystemRepository {
  constructor(
    private listings: Record<string, DirectoryListing>,
    private blobs: Record<string, Blob>
  ) { }

  async listDir(path: string): Promise<DirectoryListing> {
    return this.listings[path] ?? { dirs: [], files: [] }
  }

  async stat(_path: string): Promise<{ isDir: boolean }> {
    return { isDir: false }
  }

  async readFileMeta(path: string): Promise<{ name: string; extension?: string }> {
    const name = path.split('/').pop() ?? path
    const parts = name.split('.')
    const extension = parts.length > 1 ? parts.pop() : undefined
    const meta: { name: string; extension?: string } = { name }
    if (extension) meta.extension = extension
    return meta
  }

  async readFileBlob(path: string): Promise<Blob> {
    return this.blobs[path] ?? new Blob(['mock audio data'], { type: 'audio/wav' })
  }
}

describe('Sample import to pad', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    __resetLibraryRepository()
    __resetFileSystemRepository()
    if (typeof localStorage !== 'undefined') {
      localStorage.clear()
    }
  })

  afterEach(() => {
    __resetLibraryRepository()
    __resetFileSystemRepository()
  })

  it('libraryRepository.importFile sets lastUsedAtMs on first import', async () => {
    const repo = getLibraryRepository()
    const beforeImport = Date.now()

    const imported = await repo.importFile('/samples/kick.wav', { name: 'Kick' })

    const afterImport = Date.now()
    expect(imported.lastUsedAtMs).toBeDefined()
    expect(imported.lastUsedAtMs).toBeGreaterThanOrEqual(beforeImport)
    expect(imported.lastUsedAtMs).toBeLessThanOrEqual(afterImport)
  })

  it('libraryRepository.importFile updates lastUsedAtMs on subsequent imports', async () => {
    const repo = getLibraryRepository()

    const firstImport = await repo.importFile('/samples/kick.wav', { name: 'Kick' })
    const firstTimestamp = firstImport.lastUsedAtMs!

    // Wait a bit to ensure timestamp differs
    await new Promise((resolve) => setTimeout(resolve, 10))

    const secondImport = await repo.importFile('/samples/kick.wav', { name: 'Kick' })
    const secondTimestamp = secondImport.lastUsedAtMs!

    expect(secondTimestamp).toBeGreaterThan(firstTimestamp)
  })

  it('browser.importSelected returns imported LibraryItem with lastUsedAtMs', async () => {
    const listings: Record<string, DirectoryListing> = {
      '/samples': {
        dirs: [],
        files: [{ name: 'snare.wav', path: '/samples/snare.wav' }]
      }
    }
    const blobs: Record<string, Blob> = {
      '/samples/snare.wav': new Blob(['audio'], { type: 'audio/wav' })
    }
    __setFileSystemRepositoryForTests(new MockFileSystemRepository(listings, blobs))

    const browser = useBrowserStore()
    await browser.setMode('FILES')
    await browser.listDir('/samples')
    browser.selectPath('/samples/snare.wav')
    const beforeImport = Date.now()
    const imported = await browser.importSelected({
      contextId: 'pad1',
      contextType: 'sample'
    })
    const afterImport = Date.now()

    expect(imported).not.toBeNull()
    expect(imported?.path).toBe('/samples/snare.wav')
    expect(imported?.lastUsedAtMs).toBeDefined()
    expect(imported?.lastUsedAtMs).toBeGreaterThanOrEqual(beforeImport)
    expect(imported?.lastUsedAtMs).toBeLessThanOrEqual(afterImport)
  })

  it('browser.importSelected records contextId in browse history', async () => {
    const listings: Record<string, DirectoryListing> = {
      '/samples': {
        dirs: [],
        files: [{ name: 'hat.wav', path: '/samples/hat.wav' }]
      }
    }
    const blobs: Record<string, Blob> = {
      '/samples/hat.wav': new Blob(['audio'], { type: 'audio/wav' })
    }
    __setFileSystemRepositoryForTests(new MockFileSystemRepository(listings, blobs))

    const browser = useBrowserStore()
    await browser.setMode('FILES')
    await browser.listDir('/samples')
    browser.selectPath('/samples/hat.wav')
    await browser.importSelected({
      contextId: 'pad5',
      contextType: 'sample'
    })

    // Verify import was successful (browse history is managed by useQuickBrowse composable)
    const repo = getLibraryRepository()
    const items = await repo.search('')
    const hatItem = items.find((item) => item.path === '/samples/hat.wav')
    expect(hatItem).toBeDefined()
  })

  it('browser.importSelected returns null if no file selected', async () => {
    const browser = useBrowserStore()
    await browser.setMode('FILES')

    const result = await browser.importSelected({
      contextId: 'pad1',
      contextType: 'sample'
    })

    expect(result).toBeNull()
  })

  it('importFile preserves existing tags when updating', async () => {
    const repo = getLibraryRepository()

    await repo.importFile('/samples/kick.wav', { name: 'Kick' })
    await repo.addTag('/samples/kick.wav', 'punchy')
    await repo.addTag('/samples/kick.wav', 'electronic')

    const reimported = await repo.importFile('/samples/kick.wav', { name: 'Kick Updated' })

    expect(reimported.tags).toContain('punchy')
    expect(reimported.tags).toContain('electronic')
    expect(reimported.tags).toHaveLength(2)
  })
})



=========================================
File: tests/unitTests/samplePreview.spec.ts
=========================================

import { describe, it, expect, beforeEach, vi } from 'vitest'

let injectedContext: AudioContext | null = null

vi.mock('vue', async () => {
  const actual = await vi.importActual<typeof import('vue')>('vue')
  return {
    ...actual,
    inject: () => injectedContext
  }
})

import { useSamplePreview } from '../../composables/useSamplePreview.client'

class MockAudioBufferSourceNode {
  buffer: AudioBuffer | null = null
  onended: (() => void) | null = null
  connect() {
    return
  }
  disconnect() {
    return
  }
  start() {
    return
  }
  stop() {
    this.onended?.()
  }
}

class MockAudioContext {
  currentTime = 0
  state: AudioContextState = 'running'
  createBufferSource() {
    return new MockAudioBufferSourceNode() as unknown as AudioBufferSourceNode
  }
  async decodeAudioData() {
    return { duration: 4 } as AudioBuffer
  }
  async resume() {
    this.state = 'running'
  }
  destination = {} as AudioDestinationNode
}

describe('useSamplePreview', () => {
  let rafCallback: FrameRequestCallback | null = null

  beforeEach(() => {
    injectedContext = new MockAudioContext() as unknown as AudioContext
    rafCallback = null
    globalThis.requestAnimationFrame = (cb) => {
      rafCallback = cb
      return 1
    }
    globalThis.cancelAnimationFrame = () => {
      rafCallback = null
    }
  })

  it('loads and plays a blob', async () => {
    const preview = useSamplePreview()
    const blob = new Blob(['test'], { type: 'audio/wav' })
    await preview.loadAndPlay('/audio/test.wav', blob)
    expect(preview.state.isPlaying).toBe(true)
    expect(preview.state.currentFile).toBe('/audio/test.wav')
    expect(preview.state.duration).toBe(4)
  })

  it('stops playback', async () => {
    const preview = useSamplePreview()
    const blob = new Blob(['test'], { type: 'audio/wav' })
    await preview.loadAndPlay('/audio/test.wav', blob)
    preview.stop()
    expect(preview.state.isPlaying).toBe(false)
    expect(preview.state.progress).toBe(0)
  })

  it('tracks progress while playing', async () => {
    const preview = useSamplePreview()
    const blob = new Blob(['test'], { type: 'audio/wav' })
    await preview.loadAndPlay('/audio/test.wav', blob)
    const ctx = injectedContext as unknown as MockAudioContext
    ctx.currentTime = 2
    rafCallback?.(0)
    expect(preview.state.progress).toBeGreaterThan(0)
  })
})



=========================================
File: tests/unitTests/tagManagement.spec.ts
=========================================

import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useBrowserStore } from '../../stores/browser'
import { useControlStore } from '../../stores/control'
import {
  __setLibraryRepositoryForTests,
  type LibraryRepository,
  type LibraryItem
} from '../../services/libraryRepository'

class MemoryLibraryRepo implements LibraryRepository {
  constructor(public items: LibraryItem[] = []) {}
  favorites = new Set<string>()
  async search(query: string): Promise<LibraryItem[]>
  async search(query: string, _filters?: unknown): Promise<LibraryItem[]> {
    const text = query.trim().toLowerCase()
    if (!text) return this.items
    return this.items.filter((item) => item.name.toLowerCase().includes(text))
  }
  async getItem(id: string) {
    return this.items.find((item) => item.id === id)
  }
  async getTags(itemId: string) {
    return (await this.getItem(itemId))?.tags ?? []
  }
  async addTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: [...item.tags, tag] } : item
    )
    return this.getTags(itemId)
  }
  async removeTag(itemId: string, tag: string) {
    this.items = this.items.map((item) =>
      item.id === itemId ? { ...item, tags: item.tags.filter((value) => value !== tag) } : item
    )
    return this.getTags(itemId)
  }
  async importFile(path: string, meta?: Partial<LibraryItem>) {
    const item: LibraryItem = {
      id: meta?.id ?? path,
      name: meta?.name ?? path,
      tags: meta?.tags ?? [],
      path,
      ...meta
    }
    this.items.push(item)
    return item
  }
  async addToFavorites(itemId: string) {
    this.favorites.add(itemId)
  }
  async removeFromFavorites(itemId: string) {
    this.favorites.delete(itemId)
  }
  async getFavorites() {
    return this.items.filter((item) => this.favorites.has(item.id))
  }
  async isFavorite(itemId: string) {
    return this.favorites.has(itemId)
  }
  async refreshIndex() {
    return
  }
  async importDirectory() {
    return
  }
}

describe('tag management', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    const repo = new MemoryLibraryRepo([
      { id: '1', name: 'Kick', tags: ['drum', 'kick'] },
      { id: '2', name: 'Snare', tags: ['drum'] }
    ])
    __setLibraryRepositoryForTests(repo)
  })

  it('opens the tag dialog and loads available tags', async () => {
    const store = useBrowserStore()
    await store.search()
    await store.openTagDialog('1')
    expect(store.tagDialogOpen).toBe(true)
    expect(store.availableTags).toContain('drum')
    expect(store.availableTags).toContain('kick')
  })

  it('adds and removes tags for the selected item', async () => {
    const store = useBrowserStore()
    await store.search()
    await store.openTagDialog('1')
    await store.addTagToSelected('new-tag')
    expect(store.library.results.find((item) => item.id === '1')?.tags).toContain('new-tag')
    await store.removeTagFromSelected('drum')
    expect(store.library.results.find((item) => item.id === '1')?.tags).not.toContain('drum')
    expect(store.availableTags).toContain('new-tag')
  })

  it('uses the encoder to navigate and toggle tags', async () => {
    const browser = useBrowserStore()
    const control = useControlStore()
    await browser.search()
    await browser.openTagDialog('1')
    control.setMode('BROWSER')
    control.syncBrowserDisplay()
    control.turnEncoder4D(1)
    expect(control.encoder4D?.activeListIndex.value).toBe(1)
    const initialTags = browser.library.results.find((item) => item.id === '1')?.tags ?? []
    await control.pressEncoder4D()
    const updatedTags = browser.library.results.find((item) => item.id === '1')?.tags ?? []
    expect(updatedTags.length === initialTags.length || updatedTags.length === initialTags.length + 1).toBe(true)
    control.tiltEncoder4D('right')
    expect(browser.tagDialogOpen).toBe(false)
  })
})



=========================================
File: tests/unitTests/transportEngine.spec.ts
=========================================

import { describe, it, expect, beforeEach } from 'vitest'
import { createTransportEngine } from '@/domain/transport/transportEngine'
import type { RenderClock } from '@/domain/clock/renderClock'
import type { Scheduler, ScheduledFn } from '@/domain/clock/scheduler'
import type { TransportAudioHooks } from '@/domain/transport/audioHooks'
import type { TransportConfig, TransportState } from '@/domain/transport/types'

type ScheduledCall = { at: number; fn: ScheduledFn }

const createTestClock = (
  initialTime = 0
): { clock: RenderClock; setTime: (next: number) => void } => {
  let now = initialTime

  const clock: RenderClock = {
    ctx: {} as BaseAudioContext,
    isOffline: false,
    audioTime: () => now,
    now: () => now
  }

  return {
    clock,
    setTime: (next: number) => {
      now = next
    }
  }
}

const createStubScheduler = (): {
  scheduler: Scheduler
  calls: ScheduledCall[]
  counts: () => { start: number; stop: number; clear: number }
} => {
  const calls: ScheduledCall[] = []
  let start = 0
  let stop = 0
  let clear = 0

  const scheduler: Scheduler = {
    start(): void {
      start += 1
    },
    stop(): void {
      stop += 1
    },
    schedule(atTimeSec: number, fn: ScheduledFn): void {
      calls.push({ at: atTimeSec, fn })
    },
    clear(): void {
      clear += 1
      calls.length = 0
    }
  }

  return {
    scheduler,
    calls,
    counts: () => ({ start, stop, clear })
  }
}

describe('transportEngine', () => {
  const baseConfig: TransportConfig = {
    bpm: 120,
    gridSpec: { bars: 1, division: 4 }
  }

  let states: TransportState[]

  beforeEach(() => {
    states = []
  })

  it('starts playback, emits state and schedules the first boundary', () => {
    const { clock, setTime } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)

    const unsubscribe = engine.subscribe((state) => states.push(state))
    expect(states).to.deep.equal([{ isPlaying: false, currentStep: 0 }])

    engine.start()
    setTime(0.1)

    const lastState = states[states.length - 1]
    expect(lastState).to.deep.equal({ isPlaying: true, currentStep: 0 })

    const counts = schedulerStub.counts()
    expect(counts.start).to.equal(1)
    expect(counts.clear).to.equal(1)
    expect(schedulerStub.calls).to.have.lengthOf(1)
    expect(schedulerStub.calls[0]!.at).to.be.closeTo(0.5, 0.0001)

    unsubscribe()
  })

  it('advances steps on tick and schedules subsequent boundaries', () => {
    const { clock, setTime } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)
    engine.subscribe((state) => states.push(state))

    engine.start()
    setTime(0.51)
    engine.tick()

    const lastState = states[states.length - 1]
    expect(lastState).to.deep.equal({ isPlaying: true, currentStep: 1 })
    expect(schedulerStub.calls).to.have.lengthOf(2)
    expect(schedulerStub.calls[1]!.at).to.be.closeTo(1, 0.0001)
  })

  it('stops playback, clears scheduler, and ignores further ticks', () => {
    const { clock } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)
    engine.subscribe((state) => states.push(state))

    engine.start()
    schedulerStub.calls.length = 0

    engine.stop()
    const counts = schedulerStub.counts()
    expect(counts.stop).to.equal(1)
    expect(counts.clear).to.equal(2)

    const lastState = states[states.length - 1]
    expect(lastState).to.deep.equal({ isPlaying: false, currentStep: 3 })

    engine.tick()
    expect(schedulerStub.calls).to.have.lengthOf(0)
  })

  it('keeps phase stable when the config changes during playback', () => {
    const { clock, setTime } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const engine = createTransportEngine(clock, schedulerStub.scheduler, baseConfig)
    engine.subscribe((state) => states.push(state))

    engine.start()
    setTime(0.51)
    engine.tick()

    expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 1 })

    engine.setConfig({
      bpm: 120,
      gridSpec: { bars: 1, division: 8 }
    })

    expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 1 })

    setTime(0.76)
    engine.tick()

    expect(states.at(-1)).to.deep.equal({ isPlaying: true, currentStep: 2 })
    expect(schedulerStub.calls).to.have.lengthOf(3)
    expect(schedulerStub.calls[2]!.at).to.be.closeTo(1.01, 0.0001)
  })

  it('applies swing offset to off-beat scheduling and forwards onStep callbacks', () => {
    const { clock } = createTestClock(0)
    const schedulerStub = createStubScheduler()
    const hookCalls: Array<{ stepIndex: number; audioTime: number }> = []

    const audioHooks: TransportAudioHooks = {
      onStep(stepIndex, audioTime) {
        hookCalls.push({ stepIndex, audioTime })
      }
    }

    const engine = createTransportEngine(
      clock,
      schedulerStub.scheduler,
      {
        bpm: 120,
        gridSpec: { bars: 1, division: 4 },
        swing: 0.5
      },
      audioHooks
    )

    engine.subscribe((state) => states.push(state))
    engine.start()

    expect(schedulerStub.calls[0]!.at).to.be.closeTo(0.625, 0.0001)

    schedulerStub.calls[0]!.fn(schedulerStub.calls[0]!.at)
    expect(hookCalls).to.deep.equal([
      { stepIndex: 1, audioTime: schedulerStub.calls[0]!.at }
    ])
  })
})



=========================================
File: tests/unitTests/use4DEncoder.spec.ts
=========================================

import { describe, it, expect } from 'vitest'
import { use4DEncoder } from '@/composables/use4DEncoder'

describe('use4DEncoder', () => {
  it('navigates fields horizontally and clamps at bounds', () => {
    const encoder = use4DEncoder()
    encoder.setFields([
      { id: 'fileType', label: 'Type', value: 'all' },
      { id: 'category', label: 'Category', value: '' },
      { id: 'product', label: 'Product', value: '' }
    ])

    encoder.tiltHorizontal('right')
    expect(encoder.activeFieldIndex.value).toBe(1)
    encoder.tiltHorizontal('left')
    expect(encoder.activeFieldIndex.value).toBe(0)
    encoder.tiltHorizontal('left')
    expect(encoder.activeFieldIndex.value).toBe(0)
  })

  it('adjusts numeric values when turning in value-adjust mode', () => {
    const encoder = use4DEncoder()
    encoder.setFields([{ id: 'bank', label: 'Bank', value: 5, min: 0, max: 10, step: 2 }])

    encoder.setMode('value-adjust')
    encoder.turn(1)
    expect(encoder.fields.value[0]?.value).toBe(7)
    encoder.turn(10)
    expect(encoder.fields.value[0]?.value).toBe(10)
    encoder.turn(-20)
    expect(encoder.fields.value[0]?.value).toBe(0)
  })

  it('cycles modes with press', () => {
    const encoder = use4DEncoder()
    expect(encoder.mode.value).toBe('field-select')
    encoder.press()
    expect(encoder.mode.value).toBe('value-adjust')
    encoder.press()
    expect(encoder.mode.value).toBe('list-navigate')
    encoder.press()
    expect(encoder.mode.value).toBe('field-select')
  })

  it('navigates list vertically and with turn when in list mode', () => {
    const encoder = use4DEncoder()
    encoder.setMode('list-navigate')
    encoder.tiltVertical('down')
    expect(encoder.activeListIndex.value).toBe(1)
    encoder.turn(2)
    expect(encoder.activeListIndex.value).toBe(3)
    encoder.tiltVertical('up')
    expect(encoder.activeListIndex.value).toBe(2)
  })

  it('cycles through option values for the active field', () => {
    const encoder = use4DEncoder()
    encoder.setFields([{ id: 'fileType', label: 'Type', value: 'all', options: ['all', 'sample', 'kit'] }])
    encoder.setMode('value-adjust')
    encoder.turn(1)
    expect(encoder.fields.value[0]?.value).toBe('sample')
    encoder.turn(10)
    expect(encoder.fields.value[0]?.value).toBe('kit')
  })
})



=========================================
File: tests/unitTests/useShortcuts.spec.ts
=========================================

import { describe, it, expect, beforeEach, vi } from 'vitest'
import {
  registerShortcut,
  unregisterShortcut,
  dispatchShortcut,
  getShortcutKeys,
  shortcutTitle,
  clearShortcuts,
  useShortcuts
} from '@/composables/useShortcuts'

describe('useShortcuts', () => {
  beforeEach(() => {
    clearShortcuts()
  })

  it('registers and retrieves shortcut keys', () => {
    registerShortcut('TEST_CMD', {
      keys: 'Ctrl+K',
      handler: () => { },
      description: 'Test command'
    })

    expect(getShortcutKeys('TEST_CMD')).toBe('Ctrl+K')
  })

  it('dispatches shortcut on matching key combo', () => {
    const handler = vi.fn()
    registerShortcut('TEST_CMD', {
      keys: 'Ctrl+K',
      handler,
      description: 'Test'
    })

    const event = new KeyboardEvent('keydown', {
      key: 'k',
      ctrlKey: true
    })

    const result = dispatchShortcut(event)

    expect(result).toBe(true)
    expect(handler).toHaveBeenCalledOnce()
  })

  it('does not dispatch on non-matching key combo', () => {
    const handler = vi.fn()
    registerShortcut('TEST_CMD', {
      keys: 'Ctrl+K',
      handler,
      description: 'Test'
    })

    const event = new KeyboardEvent('keydown', {
      key: 'j',
      ctrlKey: true
    })

    const result = dispatchShortcut(event)

    expect(result).toBe(false)
    expect(handler).not.toHaveBeenCalled()
  })

  it('handles Space key normalization', () => {
    const handler = vi.fn()
    registerShortcut('TEST_SPACE', {
      keys: 'Space',
      handler,
      description: 'Space test'
    })

    const event = new KeyboardEvent('keydown', {
      key: ' '
    })

    const result = dispatchShortcut(event)

    expect(result).toBe(true)
    expect(handler).toHaveBeenCalled()
  })

  it('prefers longest matching combo', () => {
    const shortHandler = vi.fn()
    const longHandler = vi.fn()

    registerShortcut('SHORT', {
      keys: 'K',
      handler: shortHandler,
      description: 'Short'
    })

    registerShortcut('LONG', {
      keys: 'Shift+K',
      handler: longHandler,
      description: 'Long'
    })

    const event = new KeyboardEvent('keydown', {
      key: 'k',
      shiftKey: true
    })

    dispatchShortcut(event)

    expect(longHandler).toHaveBeenCalled()
    expect(shortHandler).not.toHaveBeenCalled()
  })

  it('unregisters shortcuts', () => {
    const handler = vi.fn()
    registerShortcut('TEST_CMD', {
      keys: 'Ctrl+K',
      handler,
      description: 'Test'
    })

    unregisterShortcut('TEST_CMD')

    expect(getShortcutKeys('TEST_CMD')).toBeNull()

    const event = new KeyboardEvent('keydown', {
      key: 'k',
      ctrlKey: true
    })

    const result = dispatchShortcut(event)

    expect(result).toBe(false)
    expect(handler).not.toHaveBeenCalled()
  })

  it('generates tooltip with shortcut hint', () => {
    registerShortcut('TEST_CMD', {
      keys: 'Ctrl+K',
      handler: () => { },
      description: 'Test'
    })

    const tooltip = shortcutTitle('TEST_CMD', 'Quick Search')

    expect(tooltip).toBe('Quick Search (Ctrl+K)')
  })

  it('generates tooltip without shortcut if command not registered', () => {
    const tooltip = shortcutTitle('UNKNOWN_CMD', 'Some Action')

    expect(tooltip).toBe('Some Action')
  })

  it('matches case-insensitive keys', () => {
    const handler = vi.fn()
    registerShortcut('TEST_CMD', {
      keys: 'Ctrl+K',
      handler,
      description: 'Test'
    })

    const event = new KeyboardEvent('keydown', {
      key: 'K',
      ctrlKey: true
    })

    const result = dispatchShortcut(event)

    expect(result).toBe(true)
    expect(handler).toHaveBeenCalled()
  })

  it('composable returns all API methods', () => {
    const shortcuts = useShortcuts()

    expect(shortcuts.register).toBe(registerShortcut)
    expect(shortcuts.unregister).toBe(unregisterShortcut)
    expect(shortcuts.dispatch).toBe(dispatchShortcut)
    expect(shortcuts.getKeys).toBe(getShortcutKeys)
    expect(shortcuts.title).toBe(shortcutTitle)
    expect(shortcuts.clear).toBe(clearShortcuts)
  })
})



=========================================
File: tsconfig.json
=========================================

{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist-test",
    "module": "ESNext",
    "target": "ES2022",
    "moduleResolution": "Bundler",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],

    "skipLibCheck": true,

    "types": ["node", "mocha", "vite/client", "wicg-file-system-access"],
    "sourceMap": true,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "~/*": ["./*"],
      "~~/*": ["./*"]
    }
  },
  "include": [
    "tests/**/*.ts",
    "components/**/*.vue",
    "composables/**/*.ts",
    "utils/**/*.ts",
    "stores/**/*.ts",
    "./tests/*.spec.ts",
    "./components/**/*.vue",
    "./types/**/*.d.ts",
    "./types/**/*.ts"
  ]
}



=========================================
File: tsconfig.test.json
=========================================

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "dist-test",
    "module": "ESNext",
    "target": "ES2022",
    "moduleResolution": "Bundler",
    "skipLibCheck": true,
    "types": ["node", "mocha",  "vite/client", "wicg-file-system-access"],
    "sourceMap": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "~/*": ["./*"],
      "~~/*": ["./*"]
    }
  },
  "include": [
    "tests/**/*.ts",
    "components/**/*.vue",
    "composables/**/*.ts",
    "utils/**/*.ts",
    "stores/**/*.ts",
    "./tests/*.spec.ts",
    "./components/**/*.vue",
    "./types/**/*.d.ts",
    "./types/**/*.ts"

  ]
}



=========================================
File: types/audio.ts
=========================================

import type { DrumPadId } from './drums'

export type AudioFormat = 'wav' | 'mp3' | 'ogg' | 'aac' | 'flac'

export interface SampleRef {
  id: string
  name: string
  url?: string
  buffer?: AudioBuffer
  format?: AudioFormat
  blob?: Blob
}

export interface Soundbank {
  id: string
  name: string
  pads: Partial<Record<DrumPadId, SampleRef>>
  createdAt: number
  updatedAt: number
}

export interface AudioRouting {
  masterGain: number
}

export interface FxSettings {
  filter: {
    enabled: boolean
    frequency: number
    q: number
  }
  drive: {
    enabled: boolean
    amount: number
  }
  reverb: {
    enabled: boolean
    mix: number
  }
}



=========================================
File: types/drums.ts
=========================================

import type { GridSpec, StepAddress } from './time'

export type DrumPadId =
  | 'pad1'
  | 'pad2'
  | 'pad3'
  | 'pad4'
  | 'pad5'
  | 'pad6'
  | 'pad7'
  | 'pad8'
  | 'pad9'
  | 'pad10'
  | 'pad11'
  | 'pad12'
  | 'pad13'
  | 'pad14'
  | 'pad15'
  | 'pad16'

export interface Velocity {
  value: number
}

export interface StepCell {
  velocity?: Velocity
}

export type StepGrid = Record<number, Record<number, Partial<Record<DrumPadId, StepCell>>>>

export interface Pattern {
  id: string
  name: string
  gridSpec: GridSpec
  steps: StepGrid
}

export interface Scene {
  id: string
  name: string
  patternIds: string[]
}

export interface PadEvent {
  padId: DrumPadId
  time: number
  velocity: number
}

export interface QuantizedPadEvent extends PadEvent {
  step: StepAddress
}



=========================================
File: types/file-saver.d.ts
=========================================

declare module 'file-saver' {
  export function saveAs(data: Blob | File | string, filename?: string, options?: Record<string, unknown>): void
}



=========================================
File: types/import-meta.d.ts
=========================================

export { }

declare global {
  interface ImportMeta {
    readonly client: boolean
    readonly server: boolean
  }
}



=========================================
File: types/library.ts
=========================================

export type BrowserMode = 'LIBRARY' | 'FILES'

export type BrowserResultItem = {
  id: string
  title: string
  subtitle?: string
  path?: string
  tags?: string[]
  fileType?: string
  contentType?: string
  category?: string
  product?: string
  bank?: string
  subBank?: string
  character?: string
  favorites?: boolean
  importedAt?: number
  timestamp?: number
}

export type BrowserFileEntry = {
  name: string
  path: string
}



=========================================
File: types/midi.ts
=========================================

import type { DrumPadId } from './drums'

export interface MidiDeviceInfo {
  id: string
  name: string
  type: 'input' | 'output'
}

export type MidiMessageType = 'noteon' | 'noteoff' | 'clock' | 'start' | 'stop' | 'continue' | 'cc'

export interface MidiMessage {
  type: MidiMessageType
  channel?: number
  note?: number
  velocity?: number
  controller?: number
  value?: number
}

export interface MidiMapping {
  noteMap: Partial<Record<number, DrumPadId>>
  noteMapInverse?: Partial<Record<DrumPadId, number>>
  transportMap?: Partial<Record<'play' | 'stop' | 'bpmUp' | 'bpmDown', number>>
}

export interface MidiFileEvent {
  deltaTime: number
  message: MidiMessage
}

export interface MidiTrack {
  name: string
  events: MidiFileEvent[]
}

export interface MidiFileData {
  header: {
    ticksPerBeat: number
  }
  tracks: MidiTrack[]
}



=========================================
File: types/persistence.ts
=========================================

import type { Pattern, Scene } from './drums'
import type { Soundbank, SampleRef } from './audio'
import type { MidiMapping } from './midi'

export interface PersistedState {
  patterns: Pattern[]
  scenes: Scene[]
  soundbanks: Soundbank[]
  samples: SampleRef[]
  mappings: MidiMapping[]
}



=========================================
File: types/process.d.ts
=========================================

declare namespace NodeJS {
  interface Process {
    dev?: boolean
    client?: boolean
  }
}




=========================================
File: types/render.ts
=========================================

import type { DrumPadId } from './drums'
import type { GridSpec } from './time'

export interface RenderMetadata {
  seed: string
  bpm: number
  gridSpec: GridSpec
  sceneId: string | null
  patternChain: string[]
  initialPatternId: string
  durationSec: number
}

export interface RenderEvent {
  time: number
  padId: DrumPadId
  velocity: number
}



=========================================
File: types/shims-vue.d.ts
=========================================

/* eslint-disable @typescript-eslint/no-explicit-any */


declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

interface ImportMeta {
  readonly env?: Record<string, any>;
}




=========================================
File: types/sync.ts
=========================================

export type SyncMode = 'internal' | 'midiClock' | 'abletonLink'
export type SyncRole = 'master' | 'slave'
export type ClockAuthority = 'audioContext'
export type SyncBpmSource = 'transport'

export interface SyncState {
  bpm: number
  phase: number
  isPlaying: boolean
  mode: SyncMode
  role: SyncRole
  linkAvailable?: boolean
  clockAuthority: ClockAuthority
  bpmSource: SyncBpmSource
}



=========================================
File: types/time.ts
=========================================

export type TimeDivision = 1 | 2 | 4 | 8 | 16 | 32 | 64

export interface TimeSignature {
  numerator: 4
  denominator: 4
}

export interface GridSpec {
  bars: 1 | 2 | 4 | 8
  division: TimeDivision
}

export interface StepAddress {
  barIndex: number
  stepInBar: number
}



=========================================
File: types/window.d.ts
=========================================

export {}

declare global {
  interface Window {
    showDirectoryPicker?: (options?: unknown) => Promise<FileSystemDirectoryHandle>
  }
}



=========================================
File: utils/seededRandom.ts
=========================================

export type RandomSource = () => number

export function createSeededRandom(seed: number): RandomSource {
  let value = seed >>> 0
  return () => {
    value += 0x6d2b79f5
    let t = value
    t = Math.imul(t ^ (t >>> 15), t | 1)
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296
  }
}



=========================================
File: utils/zip.ts
=========================================

// Minimal ZIP creator that writes stored entries with CRC32 checksums.
const textEncoder = new TextEncoder()

const CRC_TABLE = (() => {
  const table = new Uint32Array(256)
  for (let i = 0; i < 256; i += 1) {
    let crc = i
    for (let j = 0; j < 8; j += 1) {
      crc = crc & 1 ? 0xedb88320 ^ (crc >>> 1) : crc >>> 1
    }
    table[i] = crc >>> 0
  }
  return table
})()

const crc32 = (data: Uint8Array): number => {
  let crc = 0xffffffff
  for (let i = 0; i < data.length; i += 1) {
    const byte = data[i] ?? 0
    const tableValue = CRC_TABLE[(crc ^ byte) & 0xff] ?? 0
    crc = tableValue ^ (crc >>> 8)
  }
  return (crc ^ 0xffffffff) >>> 0
}

export type ZipEntry = {
  name: string
  data: Uint8Array
}

export const createZip = (entries: ZipEntry[]): Blob => {
  const localChunks: ArrayBuffer[] = []
  const centralChunks: ArrayBuffer[] = []

  let offset = 0
  let centralSize = 0

  for (const entry of entries) {
    const { name, data } = entry
    const crc = crc32(data)
    const nameBytes = textEncoder.encode(name)

    // Build local file header and append raw data.
    const localHeaderBuffer = new ArrayBuffer(30 + nameBytes.length)
    const localView = new DataView(localHeaderBuffer)
    localView.setUint32(0, 0x04034b50, true)
    localView.setUint16(4, 20, true)
    localView.setUint16(6, 0, true)
    localView.setUint16(8, 0, true)
    localView.setUint16(10, 0, true)
    localView.setUint16(12, 0, true)
    localView.setUint32(14, crc, true)
    localView.setUint32(18, data.length, true)
    localView.setUint32(22, data.length, true)
    localView.setUint16(26, nameBytes.length, true)
    localView.setUint16(28, 0, true)

    const localHeaderBytes = new Uint8Array(localHeaderBuffer)
    localHeaderBytes.set(nameBytes, 30)
    localChunks.push(localHeaderBuffer)
    let ab: ArrayBuffer
    if (data.buffer instanceof ArrayBuffer && !(data.buffer instanceof SharedArrayBuffer)) {
      ab = data.buffer.slice(0, data.byteLength)
    } else {
      ab = new Uint8Array(data).buffer.slice(0)
    }
    localChunks.push(ab)

    // Build central directory header for the entry.
    const centralHeaderBuffer = new ArrayBuffer(46 + nameBytes.length)
    const centralView = new DataView(centralHeaderBuffer)
    centralView.setUint32(0, 0x02014b50, true)
    centralView.setUint16(4, 20, true)
    centralView.setUint16(6, 20, true)
    centralView.setUint16(8, 0, true)
    centralView.setUint16(10, 0, true)
    centralView.setUint16(12, 0, true)
    centralView.setUint16(14, 0, true)
    centralView.setUint32(16, crc, true)
    centralView.setUint32(20, data.length, true)
    centralView.setUint32(24, data.length, true)
    centralView.setUint16(28, nameBytes.length, true)
    centralView.setUint16(30, 0, true)
    centralView.setUint16(32, 0, true)
    centralView.setUint16(34, 0, true)
    centralView.setUint16(36, 0, true)
    centralView.setUint32(38, 0, true)
    centralView.setUint32(42, offset, true)

    const centralHeaderBytes = new Uint8Array(centralHeaderBuffer)
    centralHeaderBytes.set(nameBytes, 46)
    centralChunks.push(centralHeaderBuffer)

    offset += localHeaderBytes.length + data.length
    centralSize += centralHeaderBytes.length
  }

  // Write end of central directory record.
  const endBuffer = new ArrayBuffer(22)
  const endView = new DataView(endBuffer)
  endView.setUint32(0, 0x06054b50, true)
  endView.setUint16(4, 0, true)
  endView.setUint16(6, 0, true)
  endView.setUint16(8, entries.length, true)
  endView.setUint16(10, entries.length, true)
  endView.setUint32(12, centralSize, true)
  endView.setUint32(16, offset, true)
  endView.setUint16(20, 0, true)

  const parts: ArrayBuffer[] = [
    ...localChunks,
    ...centralChunks,
    endBuffer
  ]
  return new Blob(parts, { type: 'application/zip' })
}



=========================================
File: vitest.config.ts
=========================================

// vitest.config.ts
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

const root = fileURLToPath(new URL('./', import.meta.url))

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: { '@': root, '~': root },
  },
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['tests/setup/atobShim.ts', 'tests/setup/indexedDBShim.ts'],
    threads: false,

    // âœ… NUR deine Tests einsammeln
    include: [
      'tests/**/*.{test,spec}.?(c|m)[tj]s?(x)',
    ],

    // âœ… zusÃ¤tzlich absichern
    exclude: [
      '**/node_modules/**',
      '**/.nuxt/**',
      '**/.output/**',
      '**/dist/**',
      '**/coverage/**',
      '**/*.mocha.spec.*',
    ],
  },
})


